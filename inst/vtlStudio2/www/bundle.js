(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.vtl = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
/*******************************************************************************
 * Copyright 2020, Bank Of Italy
 *
 * Licensed under the EUPL, Version 1.2 (the "License");
 * You may not use this work except in compliance with the
 * License.
 * You may obtain a copy of the License at:
 *
 * https://joinup.ec.europa.eu/sites/default/files/custom-page/attachment/2020-03/EUPL-1.2%20EN.txt
 *
 * Unless required by applicable law or agreed to in
 * writing, software distributed under the License is
 * distributed on an "AS IS" basis,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied.
 *
 * See the License for the specific language governing
 * permissions and limitations under the License.
 *******************************************************************************/
require("codemirror");
//require("codemirror/addon/hint/show-hint")
require("codemirror/addon/edit/closebrackets")

var editor = require("./src").createEditor();

editor.setEditorPlaceholderText("Enter your code here...");
editor.setShowLineNumbers(true);
editor.setDisplayEditorErrors(true);
editor.setTheme("idea");

merge = require("lodash.merge");
antlr = require("antlr4");
antlr.atn = merge(antlr.atn, require("antlr4/atn/ATNState"), require("antlr4/atn/Transition"))
antlr.error = merge(antlr.error, require("antlr4/error/Errors"))

module.exports = {
	editor: editor,
	antlr: antlr,
	gen: {
		VtlParser: require("./src/VtlParser").VtlParser,
		VtlLexer: require("./src/VtlLexer").VtlLexer
	},
	CodeMirror: require("codemirror"),
//	hint: require("codemirror/addon/hint/show-hint")
};

},{"./src":322,"./src/VtlLexer":319,"./src/VtlParser":320,"antlr4":84,"antlr4/atn/ATNState":65,"antlr4/atn/Transition":73,"antlr4/error/Errors":82,"codemirror":101,"codemirror/addon/edit/closebrackets":94,"lodash.merge":110}],2:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var dom = require("../util/dom");
var _ = require("lodash");
var GenericCompletionPopup = /** @class */ (function () {
    function GenericCompletionPopup(relativeRootElement, editor) {
        this.relativeRootElement = relativeRootElement;
        this.editor = editor;
        this.currentFocus = 0;
        this.completionDomElements = [];
        this.onCancel = function () { return null; };
        this.onSelected = function (___) { return null; };
        this.afterSelection = function (___) { return null; };
    }
    GenericCompletionPopup.prototype.hasHints = function () {
        return this.completionDomElements.length > 0;
    };
    GenericCompletionPopup.prototype.removeCompletions = function () {
        this.completionDomElements.forEach(function (el) {
            el.parentNode.removeChild(el);
        });
        this.completionDomElements = [];
        if (!_.isNil(this.completionsElement)) {
            dom.removeElement(this.completionsElement);
        }
    };
    GenericCompletionPopup.prototype.choosePrevCompletion = function () {
        this.currentFocus--;
        this.renderActive();
    };
    GenericCompletionPopup.prototype.chooseNextCompletion = function () {
        this.currentFocus++;
        this.renderActive();
    };
    GenericCompletionPopup.prototype.removeCurrentFocus = function () {
        this.currentFocus = -1;
        this.removeActive();
    };
    GenericCompletionPopup.prototype.cancel = function () {
        this.removeCompletions();
        this.onCancel();
    };
    GenericCompletionPopup.prototype.select = function () {
        var hintEl = this.completionDomElements[this.currentFocus];
        if (hintEl) {
            hintEl.click();
            return true;
        }
        return false;
    };
    GenericCompletionPopup.prototype.showHints = function (inputElement, completions) {
        var _this = this;
        if (!completions) {
            return;
        }
        this.relativeInputElement = inputElement;
        this.removeCompletions();
        this.completionsElement = dom.createElement('ul', this.completionsCssClass + " antlr__search-hints");
        this.relativeRootElement.appendChild(this.completionsElement);
        completions.forEach(function (completion) {
            var el = document.createElement('li');
            el.className = _this.singleCompletionCssClass;
            el.addEventListener('click', function (evt) {
                evt.preventDefault();
                // evt.stopPropagation();
                _this.onSelected(completion);
                _this.removeCompletions();
                if (completion.range && completion.text) {
                    _this.editor.replaceRange(completion.range, completion.text);
                    _.each(completion.placeholderFactoryMethods, function (func, varName) {
                        completion.placeholders[varName] = func();
                    });
                }
                _this.afterSelection(completion);
            });
            _this.completionDomElements.push(el);
            _this.completionsElement.appendChild(el);
            if (completion.onRender) {
                completion.onRender(el);
                return;
            }
            if (completion.displayText) {
                el.innerText = completion.displayText;
                return;
            }
            el.innerText = completion.text;
        }, true);
        this.renderActive();
        this.positionHintsElement();
    };
    GenericCompletionPopup.prototype.positionHintsElement = function () {
        if (this.relativeInputElement) {
            var position = dom.getPosition(this.relativeInputElement, this.relativeRootElement);
            dom.setPosition(this.completionsElement, position);
        }
    };
    GenericCompletionPopup.prototype.renderActive = function () {
        this.removeActive();
        this.adjustCurrentFocus();
        if (this.completionDomElements.length > 0) {
            var el = this.completionDomElements[this.currentFocus];
            if (!_.isNil(el)) {
                dom.addClass(el, this.activeCompletionCssClass);
            }
        }
    };
    GenericCompletionPopup.prototype.removeActive = function () {
        var _this = this;
        this.completionDomElements.forEach(function (el) {
            dom.removeClass(el, _this.activeCompletionCssClass);
        });
    };
    GenericCompletionPopup.prototype.adjustCurrentFocus = function () {
        if (this.currentFocus >= this.completionDomElements.length) {
            this.currentFocus = 0;
        }
        if (this.currentFocus < 0) {
            this.currentFocus = this.completionDomElements.length - 1;
        }
    };
    return GenericCompletionPopup;
}());
exports.GenericCompletionPopup = GenericCompletionPopup;

},{"../util/dom":16,"lodash":111}],3:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var completion_template_handler_1 = require("../handler/completion-template-handler");
var AutoCompleteEvent = /** @class */ (function () {
    function AutoCompleteEvent(rule, editor) {
        this.rule = rule;
        this.editor = editor;
        this._allowChildrenToConsumeEvent = true;
        this.completionTemplateHandler = new completion_template_handler_1.CompletionTemplateHandler(this.editor);
    }
    AutoCompleteEvent.prototype.stopPropagation = function () {
        this._allowChildrenToConsumeEvent = false;
    };
    AutoCompleteEvent.prototype.showCompletions = function (completions) {
        var _this = this;
        completions = completions.map(function (completion) {
            if (completion.range === undefined) {
                var newCompletion = _this.editor.createRuleCompletion(completion, _this.rule);
                return _this.completionTemplateHandler.processCompletion(_this.editor.createRuleCompletion(completion, _this.rule));
            }
            else {
                return _this.completionTemplateHandler.processCompletion(completion);
            }
        });
        return this.editor.showCompletions(completions);
    };
    Object.defineProperty(AutoCompleteEvent.prototype, "allowChildrenToConsumeEvent", {
        get: function () {
            return this._allowChildrenToConsumeEvent;
        },
        enumerable: true,
        configurable: true
    });
    return AutoCompleteEvent;
}());
exports.AutoCompleteEvent = AutoCompleteEvent;

},{"../handler/completion-template-handler":6}],4:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _ = require("lodash");
var completion_template_handler_1 = require("../handler/completion-template-handler");
var PlaceHolderAutoCompleteEvent = /** @class */ (function () {
    function PlaceHolderAutoCompleteEvent(placeHolder, inputValue, editor) {
        this.placeHolder = placeHolder;
        this.inputValue = inputValue;
        this.editor = editor;
        this.completionTemplateHandler = new completion_template_handler_1.CompletionTemplateHandler(this.editor);
    }
    PlaceHolderAutoCompleteEvent.prototype.showCompletions = function (completions) {
        var _this = this;
        completions = completions.map(function (completion) {
            var newCompletion = _.clone(completion);
            if (newCompletion.range === undefined) {
                newCompletion.range = _this.placeHolder.getTextRange();
            }
            return _this.completionTemplateHandler.processCompletion(newCompletion);
        });
        return this.placeHolder.showCompletions(completions);
    };
    return PlaceHolderAutoCompleteEvent;
}());
exports.PlaceHolderAutoCompleteEvent = PlaceHolderAutoCompleteEvent;

},{"../handler/completion-template-handler":6,"lodash":111}],5:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var auto_complete_event_1 = require("../event/auto-complete-event");
var rule_1 = require("../util/rule");
var AutoCompletionHandler = /** @class */ (function () {
    function AutoCompletionHandler(editor) {
        this.editor = editor;
    }
    AutoCompletionHandler.prototype.processEvents = function () {
        var _this = this;
        this.editor.addChangeListener(function (event) {
            _this.editor.clearAllCompletions();
            if (event.hasInsertEditChange()) {
                var rule = _this.getRuleHint();
                if (rule) {
                    console.log(event);
                    console.log(rule);
                    var stack_1 = [rule];
                    while (stack_1.length > 0) {
                        var root = stack_1.pop();
                        var autoCompleteEvent = new auto_complete_event_1.AutoCompleteEvent(root, _this.editor);
                        _this.editor.triggerAutoCompletionEvent(autoCompleteEvent);
                        if (autoCompleteEvent.allowChildrenToConsumeEvent) {
                            root.getChildren()
                                .forEach(function (child) {
                                stack_1.push(child);
                            });
                        }
                    }
                }
            }
        });
    };
    AutoCompletionHandler.prototype.getErrorRuleHint = function () {
        var parser = this.editor.getParser();
        if (parser.hasErrors()) {
            var cursorPosition = this.editor.getCursorPosition();
            var colStart = Math.max(0, cursorPosition.column);
            for (var i = cursorPosition.line; i >= 0; i--) {
                for (var j = colStart; j >= 0; j--) {
                    var rule = parser.getErrorRuleAt(j, i);
                    if (rule) {
                        return rule;
                    }
                }
                colStart = Math.max(0, parser.getColumnCount(i - 1) - 1);
            }
        }
        return undefined;
    };
    AutoCompletionHandler.prototype.getRuleHint = function () {
        var errorRuleHint = this.getErrorRuleHint();
        var cursorPosition = this.editor.getCursorPosition();
        var parser = this.editor.getParser();
        var ruleLookup = null;
        var colStart = Math.max(0, cursorPosition.column - 1);
        for (var i = cursorPosition.line; i >= 0; i--) {
            for (var j = colStart; j >= 0; j--) {
                var rule = parser.getRuleAt(j, i);
                if (rule) {
                    ruleLookup = rule;
                    break;
                }
            }
            if (ruleLookup) {
                break;
            }
            colStart = Math.max(0, parser.getColumnCount(i - 1) - 1);
        }
        if (errorRuleHint && ruleLookup) {
            if (rule_1.isRuleParent(errorRuleHint.getRule(), ruleLookup.getRule())) {
                return ruleLookup;
            }
            else {
                return errorRuleHint;
            }
            // const errorPriority = this.computeRulePriority(errorRuleHint);
            // const rulePriority = this.computeRulePriority(ruleLookup);
            // if (errorPriority > rulePriority) {
            //     return errorRuleHint;
            // } else {
            //     return ruleLookup;
            // }
        }
        else if (errorRuleHint) {
            return errorRuleHint;
        }
        else if (ruleLookup) {
            return ruleLookup;
        }
        return undefined;
    };
    AutoCompletionHandler.prototype.computeRulePriority = function (ruleWrapper) {
        var rule = ruleWrapper.getRule();
        return rule.depth() * rule.invokingState;
    };
    return AutoCompletionHandler;
}());
exports.AutoCompletionHandler = AutoCompletionHandler;

},{"../event/auto-complete-event":3,"../util/rule":17}],6:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _ = require("lodash");
var expressive_template_1 = require("expressive-template");
var CompletionTemplateHandler = /** @class */ (function () {
    function CompletionTemplateHandler(editor) {
        this.editor = editor;
    }
    CompletionTemplateHandler.prototype.processCompletion = function (completion) {
        var _this = this;
        completion = _.clone(completion);
        if (_.isNil(completion.placeholderVariables)) {
            completion.placeholderVariables = {};
        }
        var text = completion.text;
        var ctx = completion.placeholderVariables;
        var templateRes = expressive_template_1.renderTemplateExpressions(text, function (varName) {
            if (ctx[varName]) {
                var placeholderVar = ctx[varName];
                if (placeholderVar.defaultValue) {
                    return placeholderVar.defaultValue;
                }
            }
            return ' ';
        });
        completion.text = templateRes.text;
        completion.placeholderFactoryMethods = {};
        completion.placeholders = {};
        templateRes.expressions
            .forEach(function (expr) {
            var range = expr.getCurrentRange();
            var newRange = [];
            newRange[0] = {
                column: range[0].column + completion.range[0].column,
                line: range[0].line + completion.range[0].line
            };
            newRange[1] = {
                column: range[1].column + completion.range[0].column,
                line: range[1].line + completion.range[0].line
            };
            var name = expr.getVariableName();
            completion.placeholderFactoryMethods[name] = function () {
                var placeholder = _this.editor.createPlaceholder(newRange);
                var placeholderVar = ctx[name];
                placeholderVar.enableDefaultKeyEventHandlers = (_.isNil(placeholderVar.enableDefaultKeyEventHandlers)) ? true : placeholderVar.enableDefaultKeyEventHandlers;
                placeholderVar.applyFocus = (_.isNil(placeholderVar.applyFocus)) ? true : placeholderVar.applyFocus;
                if (placeholderVar && placeholderVar.placeHolderText) {
                    placeholder.setPlaceHolderText(ctx[name].placeHolderText);
                }
                else {
                    placeholder.setPlaceHolderText(name);
                }
                if (placeholderVar.enableDefaultKeyEventHandlers) {
                    placeholder.enableDefaultKeyEventHandlers();
                }
                if (placeholderVar.applyFocus) {
                    placeholder.focus();
                }
                return placeholder;
            };
        });
        return completion;
    };
    return CompletionTemplateHandler;
}());
exports.CompletionTemplateHandler = CompletionTemplateHandler;

},{"expressive-template":102,"lodash":111}],7:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var CodeMirrorBookmark = /** @class */ (function () {
    function CodeMirrorBookmark(editor, position, domElement, insertLeft) {
        this.editor = editor;
        this.position = position;
        this.domElement = domElement;
        this.insertLeft = insertLeft;
        this.hidden = false;
        if (this.editor.getDisplayDecorations()) {
            this.show();
        }
        else {
            this.hidden = true;
        }
    }
    CodeMirrorBookmark.prototype.getPosition = function () {
        return this.position;
    };
    CodeMirrorBookmark.prototype.getDomElement = function () {
        return this.domElement;
    };
    CodeMirrorBookmark.prototype.isHidden = function () {
        return this.hidden;
    };
    CodeMirrorBookmark.prototype.show = function () {
        if (!this.mark) {
            this.createBookmarkWithDom();
            this.hidden = false;
        }
    };
    CodeMirrorBookmark.prototype.hide = function () {
        if (!this.hidden) {
            this.mark.clear();
            this.hidden = true;
            this.mark = null;
        }
    };
    CodeMirrorBookmark.prototype.remove = function () {
        if (this.mark) {
            this.hide();
        }
    };
    CodeMirrorBookmark.prototype.createBookmarkWithDom = function (insertLeft) {
        var opts = { widget: this.domElement, insertLeft: this.insertLeft };
        var start = { ch: this.position.column, line: this.position.line };
        this.mark = this.editor.editorImplementation.getDoc().setBookmark(start, opts);
    };
    return CodeMirrorBookmark;
}());
exports.CodeMirrorBookmark = CodeMirrorBookmark;

},{}],8:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
//
// CodeMirror addons
//
require('codemirror/addon/lint/lint');
require('codemirror/addon/selection/active-line');
require('codemirror/addon/display/placeholder');
require('codemirror/addon/runmode/runmode');
require('codemirror/keymap/vim');
require('codemirror/addon/display/autorefresh');
exports.ACTIVE_HINT_CLASS = 'CodeMirror-hint-active';
exports.HINT_CLASS = 'CodeMirror-hint';
exports.HINTS_CLASS = 'CodeMirror-hints';
var CodeMirror = require("codemirror");
var _ = require("lodash");
var index_1 = require("rxjs/index");
var codemirror_rule_decoration_1 = require("./decoration/codemirror-rule-decoration");
var codemirror_token_decoration_1 = require("./decoration/codemirror-token-decoration");
var operators_1 = require("rxjs/internal/operators");
var auto_completion_handler_1 = require("../../handler/auto-completion-handler");
var generic_completion_popup_1 = require("../../completion/generic-completion-popup");
var codemirror_change_event_1 = require("./event/codemirror-change-event");
var codemirror_placeholder_1 = require("./placeholder/codemirror-placeholder");
var codemirror_bookmark_1 = require("./bookmark/codemirror-bookmark");
var dom_1 = require("../../util/dom");
var CodeMirrorEditor = /** @class */ (function () {
    function CodeMirrorEditor(parser, domContainer) {
        var _this = this;
        this.parser = parser;
        this.domContainer = domContainer;
        var mode = _.uniqueId('antlrGrammarMode');
        this.displayDecorations = true;
        this.customErrors = new Set();
        this.changeSubject = new index_1.Subject();
        this.validators = new Set();
        this.setValueEvent = false;
        this.ruleErrorMessageHandlers = new Map();
        this.autoCompleteSubject = new index_1.Subject();
        this.defaultTokenStyles = {};
        this.defaultRuleStyles = {};
        this.ruleDecorations = new Map();
        this.tokenDecorations = new Map();
        this.autoCompletionHandler = new auto_completion_handler_1.AutoCompletionHandler(this);
        this.placeholdersRendered = new Set();
        this.bookmarkDecorations = new Set();
        this.selections = new Set();
        if (this.domContainer === undefined) {
            this.domContainer = document.createElement('div');
        }
        this.domContainer.classList.add('antlr-editor');
        this.autoCompleteContainer = this.domContainer;
        this.editorImplementation = CodeMirror(this.domContainer, {});
        this.editorImplementation.getDoc().getMode().name = mode;
        this.editorImplementation.setOption('autoRefresh', true);
        this.defaultCursorBlinkingRate = this.editorImplementation.getOption('cursorBlinkRate');
        this.attachBasicEvents();
        this.autoCompletionHandler.processEvents();
        this.updateCursorPosition();
        CodeMirror.registerHelper('lint', mode, function () {
            if (!_this.displaySingleError) {
                var parserErrors = _this.getEditorErrors();
                return parserErrors.map(function (err) { return _this.mapParseErrorToCodeMirrorError(err); });
            }
            else {
                if (_this.hasErrors()) {
                    return [_this.mapParseErrorToCodeMirrorError(_this.getRelevantEditorError())];
                }
                return [];
            }
        });
        parser.addParserStartListener(function () {
            Array.from(_this.tokenDecorations.values())
                .forEach(function (decoration) { return decoration.remove(); });
            Array.from(_this.ruleDecorations.values())
                .forEach(function (decoration) { return decoration.remove(); });
            Array.from(_this.bookmarkDecorations.values())
                .forEach(function (decoration) { return decoration.remove(); });
            _this.selections.clear();
            _this.ruleDecorations.clear();
            _this.bookmarkDecorations.clear();
            _this.tokenDecorations.clear();
            _this.placeholdersRendered.clear();
            _this.customErrors.clear();
        });
        parser.addParserCompleteListener(function () {
            _this.clearAllCompletions();
            _this.editorImplementation.operation(function () {
                _this.executeDefaultStyling();
            });
            if (_this.lastChangeEvent) {
                _this.changeSubject.next(_this.lastChangeEvent);
                _this.lastChangeEvent = undefined;
            }
        });
    }
    CodeMirrorEditor.prototype.setAutoCompleteContainer = function (el) {
        this.autoCompleteContainer = el;
    };
    CodeMirrorEditor.prototype.replaceRange = function (range, text) {
        var newRange = this.parser.replaceRange(range, text);
        this.cursorPosition = newRange[1];
        this.setValueEvent = true;
        var change = {
            from: { ch: newRange[0].column, line: newRange[0].line },
            to: { ch: newRange[0].column, line: newRange[0].line },
            text: [text],
            removed: [],
            origin: 'setValue'
        };
        this.lastChangeEvent = new codemirror_change_event_1.CodeMirrorChangeEvent(this, [change]);
        this.editorImplementation.getDoc().setCursor({ ch: this.cursorPosition.column, line: this.cursorPosition.line });
        this.editorImplementation.setValue(this.parser.getText());
        this.parser.reparse();
        this.editorImplementation.refresh();
        return newRange;
    };
    CodeMirrorEditor.prototype.setText = function (text) {
        if (!this.willValueChange(text)) {
            return;
        }
        this.updateCursorPosition();
        this.setValueEvent = true;
        this.editorImplementation.setValue(text);
        this.parser.parse(text);
    };
    CodeMirrorEditor.prototype.update = function () {
        var text = this.parser.getText();
        if (!this.willValueChange(text)) {
            return;
        }
        this.updateCursorPosition();
        this.setValueEvent = true;
        this.editorImplementation.setValue(text);
        this.parser.reparse();
    };
    CodeMirrorEditor.prototype.getText = function () {
        return this.parser.getText();
    };
    CodeMirrorEditor.prototype.getParser = function () {
        return this.parser;
    };
    CodeMirrorEditor.prototype.setParser = function (parser) {
        this.parser = parser;
    };
    CodeMirrorEditor.prototype.addKeyMapping = function (mapping) {
        this.editorImplementation.addKeyMap(mapping);
    };
    CodeMirrorEditor.prototype.removeKeyMapping = function (mapping) {
        this.editorImplementation.removeKeyMap(mapping);
    };
    CodeMirrorEditor.prototype.focus = function () {
        this.editorImplementation.focus();
    };
    CodeMirrorEditor.prototype.createRuleDecoration = function (rule, domElement) {
        var decoration = new codemirror_rule_decoration_1.CodeMirrorRuleDecoration(this, rule, domElement);
        this.ruleDecorations.set(rule.getRule(), decoration);
        return decoration;
    };
    CodeMirrorEditor.prototype.getRuleDecoration = function (rule) {
        return this.ruleDecorations.get(rule.getRule());
    };
    CodeMirrorEditor.prototype.createTokenDecoration = function (token, domElement) {
        var decoration = new codemirror_token_decoration_1.CodeMirrorTokenDecoration(this, token, domElement);
        this.tokenDecorations.set(token.getToken(), decoration);
        return decoration;
    };
    CodeMirrorEditor.prototype.getTokenDecoration = function (token) {
        return this.tokenDecorations.get(token.getToken());
    };
    CodeMirrorEditor.prototype.getDomElement = function () {
        return this.domContainer;
    };
    CodeMirrorEditor.prototype.setTheme = function (theme) {
        this.editorImplementation.setOption('theme', theme);
    };
    CodeMirrorEditor.prototype.getTheme = function () {
        return this.editorImplementation.getOption('theme');
    };
    CodeMirrorEditor.prototype.setDefaultTokenStyles = function (styles) {
        this.defaultTokenStyles = styles;
    };
    CodeMirrorEditor.prototype.setDefaultRuleStyles = function (styles) {
        this.defaultRuleStyles = styles;
    };
    CodeMirrorEditor.prototype.updateCursorPosition = function () {
        var cursor = this.editorImplementation.getDoc().getCursor();
        this.cursorPosition = { column: cursor.ch, line: cursor.line };
    };
    CodeMirrorEditor.prototype.setDisplayEditorErrors = function (display) {
        this.editorImplementation.setOption('lint', display);
    };
    CodeMirrorEditor.prototype.getDisplayEditorErrors = function () {
        return this.editorImplementation.getOption('lint');
    };
    CodeMirrorEditor.prototype.setEditorPlaceholderText = function (text) {
        this.editorImplementation.setOption('placeholder', text);
    };
    CodeMirrorEditor.prototype.setReadOnly = function (readOnly) {
        if (readOnly) {
            this.editorImplementation.setOption('cursorBlinkRate', -100);
            this.editorImplementation.setOption('readOnly', readOnly);
        }
        else {
            this.editorImplementation.setOption('cursorBlinkRate', this.defaultCursorBlinkingRate);
            this.editorImplementation.setOption('readOnly', readOnly);
        }
    };
    CodeMirrorEditor.prototype.getReadOnly = function () {
        return !!this.editorImplementation.getOption('readOnly');
    };
    CodeMirrorEditor.prototype.setStyleActiveLine = function (styleActiveLine) {
        this.editorImplementation.setOption('styleActiveLine', styleActiveLine);
    };
    CodeMirrorEditor.prototype.getStyleActiveLine = function () {
        return !!this.editorImplementation.getOption('styleActiveLine');
    };
    CodeMirrorEditor.prototype.setLineWrapping = function (lineWrapping) {
        this.editorImplementation.setOption('lineWrapping', lineWrapping);
    };
    CodeMirrorEditor.prototype.getLineWrapping = function () {
        return !!this.editorImplementation.getOption('lineWrapping');
    };
    CodeMirrorEditor.prototype.getEditorPlaceholderText = function () {
        return this.editorImplementation.getOption('placeholder');
    };
    CodeMirrorEditor.prototype.setDisplayOnlyRelevantEditorErrors = function (display) {
        this.displaySingleError = display;
    };
    CodeMirrorEditor.prototype.getDisplayOnlyRelevantEditorErrors = function () {
        return this.displaySingleError;
    };
    CodeMirrorEditor.prototype.setShowLineNumbers = function (show) {
        this.editorImplementation.setOption('lineNumbers', show);
    };
    CodeMirrorEditor.prototype.getShowLineNumbers = function () {
        return this.editorImplementation.getOption('lineNumbers');
    };
    CodeMirrorEditor.prototype.addStyleToRule = function (rule, css) {
        var ruleRange = rule.getRange();
        this.editorImplementation.getDoc().markText({ ch: ruleRange[0].column, line: ruleRange[0].line }, {
            ch: ruleRange[1].column,
            line: ruleRange[1].line
        }, { css: css });
    };
    CodeMirrorEditor.prototype.addClassToRule = function (rule, cssClass) {
        var ruleRange = rule.getRange();
        this.editorImplementation.getDoc().markText({ ch: ruleRange[0].column, line: ruleRange[0].line }, {
            ch: ruleRange[1].column,
            line: ruleRange[1].line
        }, { className: cssClass });
    };
    CodeMirrorEditor.prototype.addStyleToToken = function (token, css) {
        var tokenRange = token.getRange();
        this.editorImplementation.getDoc().markText({ ch: tokenRange[0].column, line: tokenRange[0].line }, {
            ch: tokenRange[1].column,
            line: tokenRange[1].line
        }, { css: css });
    };
    CodeMirrorEditor.prototype.addClassToToken = function (token, cssClass) {
        var tokenRange = token.getRange();
        this.editorImplementation.getDoc().markText({ ch: tokenRange[0].column, line: tokenRange[0].line }, {
            ch: tokenRange[1].column,
            line: tokenRange[1].line
        }, { className: cssClass });
    };
    CodeMirrorEditor.prototype.addAutoCompleteListener = function (rule, listener) {
        this.autoCompleteSubject
            .pipe(operators_1.filter(function (event) { return event.rule.getName() === rule; }))
            .subscribe(listener);
    };
    CodeMirrorEditor.prototype.addChangeListener = function (listener) {
        this.changeSubject.asObservable().subscribe(listener);
    };
    CodeMirrorEditor.prototype.setCursorPosition = function (position) {
        this.cursorPosition = position;
        this.editorImplementation
            .getDoc()
            .setCursor({ ch: position.column, line: position.line });
    };
    CodeMirrorEditor.prototype.getCursorPosition = function () {
        return this.cursorPosition;
    };
    CodeMirrorEditor.prototype.defineErrorMessage = function (ruleOrMessage, handler) {
        this.ruleErrorMessageHandlers.set(ruleOrMessage, handler);
    };
    CodeMirrorEditor.prototype.getEditorErrors = function () {
        var _this = this;
        var errors = _.concat(Array.from(this.customErrors), this.parser.getErrors());
        return errors.map(function (err) {
            var newErr = _.clone(err);
            if (_this.ruleErrorMessageHandlers.has(err.message)) {
                var func = _this.ruleErrorMessageHandlers.get(err.message);
                var message = func(err);
                newErr.message = message;
            }
            else if (err.ruleWrapper && err.ruleWrapper) {
                if (_this.ruleErrorMessageHandlers.has(err.ruleWrapper.getName())) {
                    var func = _this.ruleErrorMessageHandlers.get(err.ruleWrapper.getName());
                    var message = func(err);
                    newErr.message = message;
                }
            }
            return newErr;
        });
    };
    CodeMirrorEditor.prototype.getRelevantEditorError = function () {
        var errors = this.getEditorErrors();
        if (errors.length > 0) {
            return _.last(errors);
        }
        return undefined;
    };
    CodeMirrorEditor.prototype.setDisplayDecorations = function (display) {
        this.displayDecorations = display;
        if (display) {
            this.showAllDecorations();
        }
        else {
            this.hideAllDecorations();
        }
    };
    CodeMirrorEditor.prototype.getDisplayDecorations = function () {
        return this.displayDecorations;
    };
    CodeMirrorEditor.prototype.showCompletions = function (completions) {
        var _this = this;
        this.clearAllCompletions();
        this.addKeyMapping(this.defaultHintMapping);
        var popup = new generic_completion_popup_1.GenericCompletionPopup(this.autoCompleteContainer, this);
        this.currentCompletionPopup = popup;
        setTimeout(function () {
            var cursorEl = _this.domContainer.getElementsByClassName('CodeMirror-cursor').item(0);
            popup.singleCompletionCssClass = exports.HINT_CLASS;
            popup.completionsCssClass = exports.HINTS_CLASS;
            popup.activeCompletionCssClass = exports.ACTIVE_HINT_CLASS;
            popup.showHints(cursorEl, completions);
        });
        return popup;
    };
    CodeMirrorEditor.prototype.createRuleCompletion = function (baseCompletion, rule) {
        var newCompletion = _.clone(baseCompletion);
        newCompletion.range = rule.getRange();
        return newCompletion;
    };
    CodeMirrorEditor.prototype.triggerAutoCompletionEvent = function (event) {
        this.autoCompleteSubject.next(event);
    };
    CodeMirrorEditor.prototype.hasRenderedPlaceholders = function () {
        var list = Array.from(this.placeholdersRendered).filter(function (placeholder) { return placeholder.exists(); });
        return list.length > 0;
    };
    CodeMirrorEditor.prototype.createPlaceholder = function (range) {
        var el = document.createElement('span');
        var placeholder = new codemirror_placeholder_1.CodeMirrorPlaceholder(this, el, range);
        this.clearAllCompletions();
        this.placeholdersRendered.add(placeholder);
        return placeholder;
    };
    CodeMirrorEditor.prototype.createRulePlaceholder = function (rule) {
        var placeHolder = this.createPlaceholder(rule.getRange());
        placeHolder.setPlaceHolderText(rule.getName());
        this.placeholdersRendered.add(placeHolder);
        return placeHolder;
    };
    CodeMirrorEditor.prototype.createBookmarkDecoration = function (start, dom, insertLeft) {
        var bookmark = new codemirror_bookmark_1.CodeMirrorBookmark(this, start, dom, insertLeft);
        this.bookmarkDecorations.add(bookmark);
        return bookmark;
    };
    CodeMirrorEditor.prototype.hasSelections = function () {
        return this.editorImplementation.getDoc().somethingSelected();
    };
    CodeMirrorEditor.prototype.addTokenSelection = function (token) {
        this.addSelection(token.getRange());
    };
    CodeMirrorEditor.prototype.addRuleSelection = function (rule) {
        this.addSelection(rule.getRange());
    };
    CodeMirrorEditor.prototype.addSelection = function (range) {
        var anchor = { ch: range[0].column, line: range[0].line };
        var head = { ch: range[1].column, line: range[1].line };
        this.selections.add(range);
        this.editorImplementation.getDoc().addSelection(anchor, head);
    };
    CodeMirrorEditor.prototype.getSelections = function () {
        return Array.from(this.selections);
    };
    CodeMirrorEditor.prototype.setEnableVim = function (enable) {
        if (enable) {
            this.editorImplementation.setOption('keyMap', 'vim');
        }
        else {
            this.editorImplementation.setOption('keyMap', 'default');
        }
    };
    CodeMirrorEditor.prototype.getEnableVim = function () {
        return this.editorImplementation.getOption('keyMap') === 'vim';
    };
    CodeMirrorEditor.prototype.getRuleByName = function (ruleName) {
        return this.parser.findRuleByName(ruleName);
    };
    CodeMirrorEditor.prototype.getRulesByName = function (ruleName) {
        return this.parser.findRulesByName(ruleName);
    };
    CodeMirrorEditor.prototype.getAllRules = function () {
        return this.parser.getAllRules();
    };
    CodeMirrorEditor.prototype.getAllTokens = function () {
        return this.parser.getAllTokens();
    };
    CodeMirrorEditor.prototype.addEditorValidator = function (validator) {
        this.validators.add(validator);
    };
    CodeMirrorEditor.prototype.hasErrors = function () {
        return this.getEditorErrors().length > 0;
    };
    CodeMirrorEditor.prototype.createRuleError = function (rule) {
        if (rule) {
            return this.parser.createRuleError(rule.getRule());
        }
        else {
            return {
                start: { column: 0, line: 0 },
                end: { column: 0, line: 0 },
                message: '',
                exception: undefined,
                severity: 'error',
                rule: undefined,
                ruleWrapper: undefined
            };
        }
    };
    CodeMirrorEditor.prototype.validate = function () {
        var _this = this;
        Array.from(this.validators).forEach(function (validator) {
            _this.getAllRules().forEach(function (rule) {
                var res = validator(rule);
                if (!_.isNil(res)) {
                    _this.customErrors.add(res);
                }
            });
        });
        this.editorImplementation.performLint();
    };
    CodeMirrorEditor.prototype.clearAllCompletions = function () {
        if (!_.isNil(this.currentCompletionPopup)) {
            this.currentCompletionPopup.removeCompletions();
            this.removeKeyMapping(this.defaultHintMapping);
            var el_1 = document.getElementsByClassName('CodeMirror-hints');
            var n = el_1.length;
            _.range(n).forEach(function (i) {
                dom_1.removeElement(el_1.item(i));
            });
        }
    };
    CodeMirrorEditor.prototype.styleToken = function (token, styleClass) {
        var tokenRange = token.getRange();
        var tokenClass = (token.getName()) ? "antlr-token-" + token.getName() : 'antlr-token';
        this.editorImplementation.getDoc().markText({ ch: tokenRange[0].column, line: tokenRange[0].line }, {
            ch: tokenRange[1].column,
            line: tokenRange[1].line
        }, { className: tokenClass + " " + (styleClass ? styleClass : '') });
    };
    CodeMirrorEditor.prototype.styleRule = function (rule, styleClass) {
        var ruleRange = rule.getRange();
        var ruleClass = "antlr-rule-" + rule.getName();
        this.editorImplementation.getDoc().markText({ ch: ruleRange[0].column, line: ruleRange[0].line }, {
            ch: ruleRange[1].column,
            line: ruleRange[1].line
        }, { className: ruleClass + " " + (styleClass ? styleClass : '') });
    };
    CodeMirrorEditor.prototype.mapParseErrorToCodeMirrorError = function (err) {
        return {
            from: { ch: err.start.column, line: err.start.line },
            to: { ch: err.end.column, line: err.end.line },
            message: err.message,
            severity: err.severity
        };
    };
    CodeMirrorEditor.prototype.attachBasicEvents = function () {
        var _this = this;
        this.defaultHintMapping = {
            Up: function () { return _this.currentCompletionPopup.choosePrevCompletion(); },
            Enter: function () { return _this.currentCompletionPopup.select(); },
            Esc: function () { return _this.currentCompletionPopup.cancel(); },
            Down: function () { return _this.currentCompletionPopup.chooseNextCompletion(); },
        };
        window.addEventListener('blur', function () { return _this.clearAllCompletions(); });
        this.editorImplementation.on('changes', function (___, changes) {
            _this.lastChangeEvent = new codemirror_change_event_1.CodeMirrorChangeEvent(_this, changes);
            if (_this.setValueEvent) {
                //
                // Set the cursor the the last know position found.
                // If we see a direct change made to the editor.
                //
                // Typically done after the parsing  is complete.
                //
                _this.editorImplementation.getDoc()
                    .setCursor({
                    ch: _this.cursorPosition.column,
                    line: _this.cursorPosition.line
                });
                _this.setValueEvent = false;
            }
            else if (changes.length >= 1) {
                ///
                // Only need to change the parser text on a editor change.
                //
                _this.parser.parse(_this.editorImplementation.getValue());
            }
        });
        this.editorImplementation.on('cursorActivity', function () {
            if (!_this.setValueEvent) {
                console.log(_this.editorImplementation.getDoc().getCursor());
                _this.updateCursorPosition();
                return;
            }
        });
    };
    CodeMirrorEditor.prototype.hideAllDecorations = function () {
        Array.from(this.ruleDecorations.values()).forEach(function (decoration) {
            decoration.hide();
        });
        Array.from(this.tokenDecorations.values()).forEach(function (decoration) {
            decoration.hide();
        });
    };
    CodeMirrorEditor.prototype.showAllDecorations = function () {
        Array.from(this.ruleDecorations.values()).forEach(function (decoration) {
            decoration.show();
        });
        Array.from(this.tokenDecorations.values()).forEach(function (decoration) {
            decoration.show();
        });
    };
    CodeMirrorEditor.prototype.executeDefaultStyling = function () {
        if (this.defaultRuleStyles) {
            var rules = this.parser.getAllRules();
            var numberOfRules = rules.length;
            for (var i = 0; i < numberOfRules; i++) {
                var rule = rules[i];
                if (rule.exists()) {
                    var ruleName = rule.getName();
                    if (!_.isNil(this.defaultRuleStyles[ruleName])) {
                        var style = this.defaultRuleStyles[ruleName];
                        if (style) {
                            this.styleRule(rule, style);
                        }
                    }
                }
            }
        }
        if (this.defaultTokenStyles) {
            var tokens = this.parser.getAllTokens();
            var numberOfTokens = tokens.length;
            for (var i = 0; i < numberOfTokens; i++) {
                var token = tokens[i];
                if (token.exists()) {
                    var text = token.getText();
                    var style = this.defaultTokenStyles[text];
                    if (style) {
                        this.styleToken(token, style);
                        continue;
                    }
                    var name_1 = token.getName();
                    style = this.defaultTokenStyles[name_1];
                    if (style) {
                        this.styleToken(token, style);
                    }
                }
            }
        }
    };
    CodeMirrorEditor.prototype.willValueChange = function (newValue) {
        var oldValue = this.editorImplementation.getValue();
        return oldValue !== newValue;
    };
    return CodeMirrorEditor;
}());
exports.CodeMirrorEditor = CodeMirrorEditor;

},{"../../completion/generic-completion-popup":2,"../../handler/auto-completion-handler":5,"../../util/dom":16,"./bookmark/codemirror-bookmark":7,"./decoration/codemirror-rule-decoration":9,"./decoration/codemirror-token-decoration":10,"./event/codemirror-change-event":11,"./placeholder/codemirror-placeholder":13,"codemirror":101,"codemirror/addon/display/autorefresh":92,"codemirror/addon/display/placeholder":93,"codemirror/addon/lint/lint":96,"codemirror/addon/runmode/runmode":97,"codemirror/addon/selection/active-line":99,"codemirror/keymap/vim":100,"lodash":111,"rxjs/index":112,"rxjs/internal/operators":193}],9:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var CodeMirrorRuleDecoration = /** @class */ (function () {
    function CodeMirrorRuleDecoration(editor, rule, domElement) {
        var _this = this;
        this.editor = editor;
        this.rule = rule;
        this.domElement = domElement;
        this.clearOnEnter = true;
        this.toggleOnExit = true;
        this.hidden = false;
        var changed = false;
        this.cursorActivityFunction = function () {
            if (changed) {
                changed = false;
            }
            else if (_this.rule.exists()) {
                var pos = _this.editor.getCursorPosition();
                var range = _this.rule.getRange();
                if (_this.rule.inRange(pos) || (range[1].line === pos.line && range[1].column === pos.column)) {
                    _this.handleRuleWhenWithin();
                }
                else {
                    if (_this.hidden && _this.toggleOnExit) {
                        _this.show();
                    }
                }
            }
        };
        this.changeEventFunction = function () {
            changed = true;
        };
        //
        // Make sure the rule exists, before defaulting on a show
        //
        if (this.editor.getDisplayDecorations()) {
            this.show();
            this.cursorActivityFunction();
        }
        else {
            this.hidden = true;
        }
    }
    CodeMirrorRuleDecoration.prototype.getRule = function () {
        return this.rule;
    };
    CodeMirrorRuleDecoration.prototype.getDomElement = function () {
        return this.domElement;
    };
    CodeMirrorRuleDecoration.prototype.isHidden = function () {
        return this.hidden;
    };
    CodeMirrorRuleDecoration.prototype.show = function () {
        if (!this.mark && this.editor.getDisplayDecorations()) {
            var ruleRange = this.rule.getRange();
            this.mark = this.editor.editorImplementation.getDoc()
                .markText({ ch: ruleRange[0].column, line: ruleRange[0].line }, {
                ch: ruleRange[1].column,
                line: ruleRange[1].line
            }, { replacedWith: this.domElement });
            this.hidden = false;
            this.editor.editorImplementation.on('change', this.changeEventFunction);
            this.editor.editorImplementation.on('cursorActivity', this.cursorActivityFunction);
        }
    };
    CodeMirrorRuleDecoration.prototype.hide = function () {
        if (!this.hidden) {
            this.mark.clear();
            this.hidden = true;
            this.mark = null;
        }
    };
    CodeMirrorRuleDecoration.prototype.remove = function () {
        if (this.mark) {
            this.hide();
            this.editor.editorImplementation.off('change', this.changeEventFunction);
            this.editor.editorImplementation.off('cursorActivity', this.cursorActivityFunction);
        }
    };
    CodeMirrorRuleDecoration.prototype.handleRuleWhenWithin = function () {
        if (this.clearOnEnter && this.mark) {
            this.hide();
        }
    };
    return CodeMirrorRuleDecoration;
}());
exports.CodeMirrorRuleDecoration = CodeMirrorRuleDecoration;

},{}],10:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var CodeMirrorTokenDecoration = /** @class */ (function () {
    function CodeMirrorTokenDecoration(editor, token, domElement) {
        var _this = this;
        this.editor = editor;
        this.token = token;
        this.domElement = domElement;
        this.clearOnEnter = true;
        this.toggleOnExit = true;
        this.hidden = false;
        var changed = false;
        this.cursorActivityFunction = function () {
            if (changed) {
                changed = false;
            }
            else if (_this.token.exists()) {
                var pos = _this.editor.getCursorPosition();
                var range = _this.token.getRange();
                if (_this.token.inRange(pos) || (range[1].line === pos.line && range[1].column === pos.column)) {
                    _this.handleRuleWhenWithin();
                }
                else {
                    if (_this.hidden && _this.toggleOnExit) {
                        _this.show();
                    }
                }
            }
        };
        this.changeEventFunction = function () {
            changed = true;
        };
        //
        // Make sure the rule exists, before defaulting on a show
        //
        if (this.editor.getDisplayDecorations()) {
            this.show();
            this.cursorActivityFunction();
        }
        else {
            this.hidden = true;
        }
    }
    CodeMirrorTokenDecoration.prototype.getToken = function () {
        return this.token;
    };
    CodeMirrorTokenDecoration.prototype.getDomElement = function () {
        return this.domElement;
    };
    CodeMirrorTokenDecoration.prototype.isHidden = function () {
        return this.hidden;
    };
    CodeMirrorTokenDecoration.prototype.show = function () {
        if (!this.mark) {
            var tokenRange = this.token.getRange();
            this.mark = this.editor.editorImplementation.getDoc()
                .markText({ ch: tokenRange[0].column, line: tokenRange[0].line }, {
                ch: tokenRange[1].column,
                line: tokenRange[1].line
            }, { replacedWith: this.domElement });
            this.hidden = false;
            this.editor.editorImplementation.on('change', this.changeEventFunction);
            this.editor.editorImplementation.on('cursorActivity', this.cursorActivityFunction);
        }
    };
    CodeMirrorTokenDecoration.prototype.hide = function () {
        if (!this.hidden) {
            this.mark.clear();
            this.hidden = true;
            this.mark = null;
        }
    };
    CodeMirrorTokenDecoration.prototype.remove = function () {
        if (this.mark) {
            this.hide();
            this.editor.editorImplementation.off('change', this.changeEventFunction);
            this.editor.editorImplementation.off('cursorActivity', this.cursorActivityFunction);
        }
    };
    CodeMirrorTokenDecoration.prototype.handleRuleWhenWithin = function () {
        if (this.clearOnEnter && this.mark) {
            this.hide();
        }
    };
    return CodeMirrorTokenDecoration;
}());
exports.CodeMirrorTokenDecoration = CodeMirrorTokenDecoration;

},{}],11:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _ = require("lodash");
var CodeMirrorChangeEvent = /** @class */ (function () {
    function CodeMirrorChangeEvent(editor, changeEvents) {
        this.editor = editor;
        this.changeEvents = changeEvents;
    }
    CodeMirrorChangeEvent.prototype.hasDeleteEditChange = function () {
        var removedText = _.flatten(this.changeEvents.filter(function (evt) { return evt.origin !== 'setValue'; }).map(function (ev) { return ev.removed; })).join('').trim();
        return (!_.isEmpty(removedText));
    };
    CodeMirrorChangeEvent.prototype.hasInsertEditChange = function () {
        var changedText = _.flatten(this.changeEvents.filter(function (evt) { return evt.origin !== 'setValue'; }).map(function (ev) { return ev.text; })).join('').trim();
        return (!_.isEmpty(changedText));
    };
    return CodeMirrorChangeEvent;
}());
exports.CodeMirrorChangeEvent = CodeMirrorChangeEvent;

},{"lodash":111}],12:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var codemirror_editor_1 = require("./codemirror-editor");
function createEditor(parser, domElement) {
    return new codemirror_editor_1.CodeMirrorEditor(parser, domElement);
}
exports.createEditor = createEditor;

},{"./codemirror-editor":8}],13:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var codemirror_editor_1 = require("../codemirror-editor");
var _ = require("lodash");
var generic_completion_popup_1 = require("../../../completion/generic-completion-popup");
var placeholder_auto_complete_event_1 = require("../../../event/placeholder-auto-complete-event");
var CodeMirrorPlaceholder = /** @class */ (function () {
    function CodeMirrorPlaceholder(editor, domContainer, range) {
        this.editor = editor;
        this.domContainer = domContainer;
        this.range = range;
        var el = document.createElement('span');
        el.contentEditable = 'true';
        el.className = 'antlr-placeholder-element';
        this.inputElement = el;
        this.domContainer.appendChild(el);
        this.domContainer.style.display = 'inline-block';
        this.domContainer.style.position = 'relative';
        this.mark = this.editor.editorImplementation.getDoc()
            .markText({ ch: range[0].column, line: range[0].line }, {
            ch: range[1].column,
            line: range[1].line
        }, { replacedWith: this.domContainer });
    }
    CodeMirrorPlaceholder.prototype.addChangeListener = function (listener) {
        var _this = this;
        this.inputElement.addEventListener('input', function (event) {
            event.stopPropagation();
            listener(new placeholder_auto_complete_event_1.PlaceHolderAutoCompleteEvent(_this, _this.inputElement.innerText, _this.editor));
        });
    };
    CodeMirrorPlaceholder.prototype.getTextRange = function () {
        return this.range;
    };
    CodeMirrorPlaceholder.prototype.showCompletions = function (completions) {
        var _this = this;
        this.clearCompletions();
        var popup = new generic_completion_popup_1.GenericCompletionPopup(this.editor.autoCompleteContainer, this.editor);
        this.currentCompletionPopup = popup;
        setTimeout(function () {
            popup.singleCompletionCssClass = codemirror_editor_1.HINT_CLASS;
            popup.completionsCssClass = codemirror_editor_1.HINTS_CLASS;
            popup.activeCompletionCssClass = codemirror_editor_1.ACTIVE_HINT_CLASS;
            popup.showHints(_this.domContainer, completions);
            popup.afterSelection = function (completion) {
                _this.range = completion.range;
                _this.editor.focus();
            };
        });
        return popup;
    };
    CodeMirrorPlaceholder.prototype.getDomElement = function () {
        return this.domContainer;
    };
    CodeMirrorPlaceholder.prototype.getInputElement = function () {
        return this.inputElement;
    };
    CodeMirrorPlaceholder.prototype.setRangeWithText = function (text) {
        this.range = this.editor.replaceRange(this.range, text);
    };
    CodeMirrorPlaceholder.prototype.setPlaceHolderText = function (text) {
        this.placeHolderText = text;
        this.inputElement.setAttribute('placeholder', this.placeHolderText);
    };
    CodeMirrorPlaceholder.prototype.getPlaceHolderText = function () {
        return this.placeHolderText;
    };
    CodeMirrorPlaceholder.prototype.focus = function () {
        var _this = this;
        setTimeout(function () { return _this.inputElement.focus(); }, 20);
    };
    CodeMirrorPlaceholder.prototype.exists = function () {
        return this.getDomElement().contains(this.domContainer);
    };
    CodeMirrorPlaceholder.prototype.enableDefaultKeyEventHandlers = function () {
        var _this = this;
        this.inputElement.addEventListener('keypress', function (e) { return e.code !== 'Enter'; });
        this.inputElement.addEventListener('keypress', function (event) {
            event.stopImmediatePropagation();
        });
        this.inputElement.addEventListener('keyup', function (event) {
            event.stopImmediatePropagation();
        });
        this.inputElement.addEventListener('keydown', function (event) {
            event.stopImmediatePropagation();
            switch (event.code) {
                case 'Backspace':
                case 'Delete':
                    if (_.isEmpty(_this.inputElement.innerText)) {
                        event.preventDefault();
                        _this.clearMark();
                        _this.editor.focus();
                    }
                    return;
                case 'Escape':
                    event.preventDefault();
                    _this.clearMark();
                    _this.editor.focus();
                    return;
                case 'Enter':
                    event.preventDefault();
                    if (_this.currentCompletionPopup && _this.currentCompletionPopup.hasHints()) {
                        _this.currentCompletionPopup.select();
                    }
                    else {
                        _this.setRangeWithText(_this.inputElement.innerText);
                    }
                    return;
                case 'ArrowLeft':
                    if (_.isEmpty(_this.inputElement.innerText)) {
                        var cursor = _this.range[0];
                        _this.editor.focus();
                        _this.inputElement.style.left = '';
                        _this.editor.setCursorPosition(cursor);
                    }
                    return;
                case 'ArrowRight':
                    if (_.isEmpty(_this.inputElement.innerText)) {
                        var position = { column: _this.range[1].column, line: _this.range[1].line };
                        _this.editor.focus();
                        _this.editor.setCursorPosition(position);
                    }
                    return;
                case 'ArrowDown':
                    _this.chooseNextCompletion();
                    return;
                case 'ArrowUp':
                    _this.choosePrevCompletion();
                    return;
            }
        });
    };
    CodeMirrorPlaceholder.prototype.choosePrevCompletion = function () {
        if (this.currentCompletionPopup) {
            this.currentCompletionPopup.choosePrevCompletion();
        }
    };
    CodeMirrorPlaceholder.prototype.chooseNextCompletion = function () {
        if (this.currentCompletionPopup) {
            this.currentCompletionPopup.chooseNextCompletion();
        }
    };
    CodeMirrorPlaceholder.prototype.clearMark = function () {
        if (this.mark) {
            this.mark.clear();
            this.mark = undefined;
        }
    };
    CodeMirrorPlaceholder.prototype.clearCompletions = function () {
        if (!_.isNil(this.currentCompletionPopup)) {
            this.currentCompletionPopup.removeCompletions();
        }
    };
    return CodeMirrorPlaceholder;
}());
exports.CodeMirrorPlaceholder = CodeMirrorPlaceholder;

},{"../../../completion/generic-completion-popup":2,"../../../event/placeholder-auto-complete-event":4,"../codemirror-editor":8,"lodash":111}],14:[function(require,module,exports){
"use strict";
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(require("./completion/generic-completion-popup"));
__export(require("./event/placeholder-auto-complete-event"));
__export(require("./event/auto-complete-event"));
__export(require("./event/placeholder-auto-complete-event"));
__export(require("./handler/auto-completion-handler"));
__export(require("./handler/completion-template-handler"));
__export(require("./toolbar/simple-toolbar"));

},{"./completion/generic-completion-popup":2,"./event/auto-complete-event":3,"./event/placeholder-auto-complete-event":4,"./handler/auto-completion-handler":5,"./handler/completion-template-handler":6,"./toolbar/simple-toolbar":15}],15:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var SimpleToolbar = /** @class */ (function () {
    function SimpleToolbar(editor) {
        this.editor = editor;
    }
    SimpleToolbar.prototype.create = function () {
        var toolbar = this.createToolBar();
        var btn = this.createVimButton();
        toolbar.appendChild(btn);
        return toolbar;
    };
    SimpleToolbar.prototype.createToolBar = function () {
        var el = document.createElement('div');
        el.className = 'antlr-toolbar';
        return el;
    };
    SimpleToolbar.prototype.createVimButton = function () {
        var _this = this;
        var url = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAACXBIWXMAAA7EAAAOxAGVKw4bAAACWElEQVQ4y4WTXUiTURjHf+/2hvMT3/mVueaUQIOBIaSC0k0Ru1AvDLwIQxF2kZRQZhcRlZUREt5WpsNKItxFdBN5MSI/QEkmSqOQRFTSWm2Ga1/uffd2YS4n087Vec75//7Pcx7OI7DHSiuSNIYzpS0IAl9ffR70ffFGE+mERIfpxZLGeKXc5lbXmwHytPqny70zrRvznmhCA6vVWmyxWJq2Y092oPzR4sv6Ff9aTFiVWTbcoqt17UiqOhyOIRFAkqSTFRUVtwRBEABUVWVqfZadBoWZhsbKsspYrKqq6nQ6V0WAnp6efoPBYGpoaLgG8Nj1gtcrDgTNVrLc5CzOHqmLwbIsy52dnW12u31A3HqzXhDNGeaYQtTE4PzkHPpqujGkHAQgosjcHumdHJl9NwCoYppJ0hg7ym2r0R/1uxtUkJLHk+pu8lNyAdhUIlyduM97+UPN4cvHbMsPnK2iVGtsceNt3g0bUw/RV32XvORsAMLyJh0T3YyvOxEEAbfibZbqCkdFz6Jbm3o0Pw42pRfQX3OPHJ0egJAc5tL4HSZ/zfG3zwB4Fr5rxcDbb4PanKRTlNC4fWEpOBETBSMh2se7mN5wxf2a0LR32P9mbVBEUSO+50tNVAYzKMWysxL/ZoCLY13M/P4UV2Fo2jvse7bUhKJGRAAUNVKSVjQJ/wx8YT8Xxm4y55/fEwYQY6UGg8r2fiPso230Bq7Awr5w3CyYzWazzWYbAWi3X/+4YPp5+n9womFKAkArRNPPFQ7pjusb94P3nEYANBzQVWWdBwhNeR8mggH+AGOO/TZ3cOjxAAAAAElFTkSuQmCC';
        var img = document.createElement('img');
        img.src = url;
        var btn = document.createElement('button');
        btn.className = 'antlr-toolbar__button';
        btn.appendChild(img);
        var enableFunction = function (enable) {
            _this.editor.setEnableVim(enable);
            if (enable) {
                btn.classList.add('antlr-toolbar__button__disabled');
                btn.classList.remove('antlr-toolbar__button__enabled');
                btn.title = 'Disable Vim Mode';
            }
            else {
                btn.classList.add('antlr-toolbar__button__enabled');
                btn.classList.remove('antlr-toolbar__button__disabled');
                btn.title = 'Enable Vim Mode';
            }
        };
        var inVimMode = this.editor.getEnableVim();
        enableFunction(inVimMode);
        btn.addEventListener('click', function (event) {
            event.stopPropagation();
            event.preventDefault();
            inVimMode = (!inVimMode);
            enableFunction(inVimMode);
            _this.editor.focus();
        });
        return btn;
    };
    return SimpleToolbar;
}());
exports.SimpleToolbar = SimpleToolbar;

},{}],16:[function(require,module,exports){
"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
function removeElement(el) {
    if (el) {
        var parent_1 = el.parentNode;
        if (parent_1) {
            parent_1.removeChild(el);
        }
    }
}
exports.removeElement = removeElement;
function addClass(el, className) {
    if (el) {
        el.classList.add(className);
    }
}
exports.addClass = addClass;
function removeClass(el, className) {
    if (el) {
        el.classList.remove(className);
    }
}
exports.removeClass = removeClass;
function createElement(tagName, className) {
    if (className === void 0) { className = ''; }
    var el = document.createElement(tagName);
    el.className = className;
    return el;
}
exports.createElement = createElement;
function getPosition(el, relativeTarget) {
    var xPos = 0;
    var yPos = el.getBoundingClientRect().height;
    while (el !== relativeTarget) {
        xPos += (el.offsetLeft - el.scrollLeft + el.clientLeft);
        yPos += (el.offsetTop - el.scrollTop + el.clientTop);
        if (el.offsetParent) {
            el = el.offsetParent;
        }
        else {
            break;
        }
    }
    return [xPos, yPos];
}
exports.getPosition = getPosition;
function setPosition(el, position) {
    var _a = __read(position, 2), left = _a[0], top = _a[1];
    el.style.top = top + "px";
    el.style.left = left + "px";
}
exports.setPosition = setPosition;

},{}],17:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function isRuleParent(root, child) {
    while (child) {
        if (child === root) {
            return true;
        }
        child = child.parentCtx;
    }
    return false;
}
exports.isRuleParent = isRuleParent;

},{}],18:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var AntlrFactoryBuilder = /** @class */ (function () {
    function AntlrFactoryBuilder() {
        this.createLexer = function () { return null; };
        this.createParser = function () { return null; };
        this.createRootRule = function () { return null; };
    }
    AntlrFactoryBuilder.prototype.lexer = function (lexer) {
        this.createLexer = lexer;
        return this;
    };
    AntlrFactoryBuilder.prototype.parser = function (parser) {
        this.createParser = parser;
        return this;
    };
    AntlrFactoryBuilder.prototype.rootRule = function (rootRule) {
        this.createRootRule = rootRule;
        return this;
    };
    AntlrFactoryBuilder.prototype.build = function () {
        return {
            createLexer: this.createLexer,
            createParser: this.createParser,
            createAndInvokeRootRule: this.createRootRule
        };
    };
    return AntlrFactoryBuilder;
}());
exports.AntlrFactoryBuilder = AntlrFactoryBuilder;

},{}],19:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var __1 = require("../");
/**
 * Creates an {@link AntlrFactoryBuilder}
 *
 * @returns {AntlrFactoryBuilder}
 */
function createFactoryBuilder() {
    return new __1.AntlrFactoryBuilder();
}
exports.createFactoryBuilder = createFactoryBuilder;
/**
 * Creates a default Parser
 *
 * @param {AntlrFactory} factory
 * @returns {MutableAntlrParser}
 */
function createParser(factory) {
    return new __1.MutableAntlrParser(createImmutableParser(factory));
}
exports.createParser = createParser;
/**
 * Creates an Immutable Parser
 *
 * @param {AntlrFactory} factory
 * @returns {AntlrParser}
 */
function createImmutableParser(factory) {
    return new __1.ImmutableAntlrParser(factory);
}
exports.createImmutableParser = createImmutableParser;

},{"../":20}],20:[function(require,module,exports){
"use strict";
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(require("./factory/antlr-factory"));
__export(require("./parser/immutable-antlr-parser"));
__export(require("./parser/mutable-antlr-parser"));
__export(require("./parser/antlr-rule-error"));
__export(require("./parser/mutable-antlr-token-wrapper"));
__export(require("./parser/immutable-antlr-token-wrapper"));
__export(require("./parser/immutable-antlr-rule-wrapper"));
__export(require("./parser/mutable-antlr-rule-wrapper"));
__export(require("./functions"));

},{"./factory/antlr-factory":18,"./functions":19,"./parser/antlr-rule-error":22,"./parser/immutable-antlr-parser":25,"./parser/immutable-antlr-rule-wrapper":26,"./parser/immutable-antlr-token-wrapper":27,"./parser/mutable-antlr-parser":29,"./parser/mutable-antlr-rule-wrapper":30,"./parser/mutable-antlr-token-wrapper":31}],21:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _ = require('lodash');
var AntlrParserWrapper = /** @class */ (function () {
    function AntlrParserWrapper(parser) {
        this.parser = parser;
    }
    Object.defineProperty(AntlrParserWrapper.prototype, "literalNames", {
        get: function () {
            var parser = this.parser;
            return parser.literalNames;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AntlrParserWrapper.prototype, "ruleNames", {
        get: function () {
            var parser = this.parser;
            return parser.ruleNames;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AntlrParserWrapper.prototype, "symbolicNames", {
        get: function () {
            var parser = this.parser;
            return parser.symbolicNames;
        },
        enumerable: true,
        configurable: true
    });
    AntlrParserWrapper.prototype.getTokenTypeToSymoblMap = function () {
        var map = new Map();
        var clazz = this.parser.constructor;
        this.symbolicNames.forEach(function (val) {
            if (val) {
                map.set(clazz[val], val);
            }
        });
        return map;
    };
    AntlrParserWrapper.prototype.getSymbolToTypeMap = function () {
        var map = new Map();
        var clazz = this.parser.constructor;
        this.symbolicNames.forEach(function (val) {
            if (val) {
                map.set(val, clazz[val]);
            }
        });
        return map;
    };
    AntlrParserWrapper.prototype.getRuleIndexToNameMap = function () {
        var map = new Map();
        this.getRuleNameToIndexMap().forEach(function (val, key) {
            map.set(val, key);
        });
        return map;
    };
    AntlrParserWrapper.prototype.getRuleNameToIndexMap = function () {
        var map = new Map();
        var rules = this.ruleNames;
        var clazz = this.parser.constructor;
        rules.forEach(function (rule) {
            map.set(rule, clazz["RULE_" + rule]);
        });
        map.set('<EOF>', -1);
        return map;
    };
    return AntlrParserWrapper;
}());
exports.AntlrParserWrapper = AntlrParserWrapper;

},{"lodash":111}],22:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var AntlrRuleError = /** @class */ (function () {
    function AntlrRuleError() {
        this.severity = 'error';
    }
    return AntlrRuleError;
}());
exports.AntlrRuleError = AntlrRuleError;

},{}],23:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var antlr4_1 = require("antlr4");
var utils_1 = require("text-manipulation/dist/buffer/utils");
var _ = require("lodash");
var error_1 = require("antlr4/error");
var antlr_rule_error_1 = require("./antlr-rule-error");
var rule_table_1 = require("./rule-table");
var immutable_antlr_rule_wrapper_1 = require("./immutable-antlr-rule-wrapper");
var max = Math.max;
var ErrorRuleHandler = /** @class */ (function (_super) {
    __extends(ErrorRuleHandler, _super);
    function ErrorRuleHandler(parser, buffer) {
        var _this = _super.call(this) || this;
        _this.parser = parser;
        _this.buffer = buffer;
        _this.ruleTable = new rule_table_1.RuleTable(buffer, _this.parser);
        _this.errors = new Map();
        return _this;
    }
    ErrorRuleHandler.prototype.getErrors = function () {
        return Array.from(this.errors.values());
    };
    ErrorRuleHandler.prototype.getErrorRuleTable = function () {
        return this.ruleTable.ruleTable;
    };
    ErrorRuleHandler.prototype.processRuleWithError = function (rule) {
        var range = this.getRuleRangeSafely(rule);
        if (this.cmp(range[0], range[1]) === 0) {
            range[1] = this.nextColumn(range[1]);
        }
        var width = this.buffer.getColumnCount(range[0].line);
        if (range[1].column > width) {
            range[0] = this.previousColumn(range[0]);
        }
        var error = this.buildError(rule, range);
        this.addError(error);
    };
    ErrorRuleHandler.prototype.getErrorRuleAt = function (column, line) {
        return this.ruleTable.getRuleAt(column, line);
    };
    ErrorRuleHandler.prototype.addError = function (error) {
        if (this.errors.has(error.rule)) {
            error.message = this.errors.get(error.rule).message;
        }
        this.errors.set(error.rule, error);
        this.ruleTable.addRule(error.rule, this.getRuleRangeSafely(error.rule));
    };
    /**
     * (Internal use only)
     *
     * @param {Recognizer} recognizer
     * @param {Token} offendingSymbol
     * @param {number} line
     * @param {number} column
     * @param {string} msg
     * @param e
     */
    ErrorRuleHandler.prototype.syntaxError = function (recognizer, offendingSymbol, line, column, msg, e) {
        if (e instanceof error_1.RecognitionException) {
            //
            // If we have a known exception let's process it
            //
            this.processRecognitionException(e);
        }
        else {
            //
            // If we don't have a clear syntax exception then we
            // should build a basic error, using only the recognizer.
            //
            var rule = recognizer._ctx;
            var error = this.buildError(rule, this.getRuleRangeSafely(rule));
            error.message = msg;
            error.exception = e;
            this.addError(error);
        }
    };
    ErrorRuleHandler.prototype.processRecognitionException = function (e) {
        if (!_.isNil(e) && !_.isNil(e.ctx)) {
            //
            // Process the exception as long as it has a rule context
            //
            var rule = e.ctx;
            this.processRuleWithFailures(rule);
        }
    };
    /**
     * Process all the rule along with all it's children.
     * This method's goal is primarily to add the rule into the ruleTable
     * @param {ParserRuleContext} rule
     */
    ErrorRuleHandler.prototype.processRuleWithFailures = function (rule) {
        this.processRuleWithError(rule);
        var n = rule.getChildCount();
        for (var i = 0; i < n; i++) {
            var child = rule.getChild(i);
            // Recurse on child
            if (child instanceof antlr4_1.ParserRuleContext) {
                this.processRuleWithFailures(child);
            }
        }
    };
    ErrorRuleHandler.prototype.buildError = function (rule, range) {
        var error = new antlr_rule_error_1.AntlrRuleError();
        error.start = range[0];
        error.end = range[1];
        error.rule = rule;
        error.ruleWrapper = new immutable_antlr_rule_wrapper_1.ImmutableAntlrRuleWrapper(rule, this.parser, range);
        error.exception = rule.exception;
        error.message = "Error matching the " + this.parser.getRuleName(rule) + " rule";
        return error;
    };
    ErrorRuleHandler.prototype.nextColumn = function (position) {
        return { column: position.column + 1, line: position.line };
    };
    ErrorRuleHandler.prototype.tokenIntervalText = function (token) {
        return this.parser.getInputStream().getText(token.start, token.stop);
    };
    ErrorRuleHandler.prototype.previousColumn = function (position) {
        return { column: Math.max(position.column - 1, 0), line: position.line };
    };
    ErrorRuleHandler.prototype.getRuleRangeSafely = function (rule) {
        if (rule && rule.start && rule.stop) {
            // Return a correct rule
            var from = { column: rule.start.column, line: rule.start.line - 1 };
            var text = this.tokenIntervalText(rule.stop);
            var len = (rule.stop.type === -1) ? 0 : max((text.length), 0);
            var to = { column: rule.stop.column + len, line: rule.stop.line - 1 };
            return utils_1.sortRange([from, to]);
        }
        else if (rule && rule.start) {
            var from = void 0, to = void 0;
            var token = rule.start;
            var sibling = this.parser.getRuleBefore(rule);
            if (sibling) {
                var start = (sibling.stop) ? sibling.stop : sibling.start;
                var text = this.tokenIntervalText(start);
                from = { column: start.column + text.length, line: start.line - 1 };
                to = { column: token.column, line: token.line - 1 };
            }
            else if (rule && rule.exception) {
                var offendingToken = rule.exception.offendingToken;
                var text = this.tokenIntervalText(offendingToken);
                from = { column: max(token.column - 1, 0), line: token.line - 1 };
                to = { column: offendingToken.column + text.length, line: offendingToken.line - 1 };
            }
            else {
                var text = this.tokenIntervalText(token);
                from = { column: max(token.column - 1, 0), line: token.line - 1 };
                to = { column: token.column + text.length, line: token.line - 1 };
            }
            return utils_1.sortRange([from, to]);
        }
        else {
            var pos = { column: 0, line: 0 };
            return [pos, pos];
        }
    };
    ErrorRuleHandler.prototype.cmp = function (a, b) {
        return (a.line - b.line) || (a.column - b.column);
    };
    return ErrorRuleHandler;
}(error_1.ErrorListener));
exports.ErrorRuleHandler = ErrorRuleHandler;

},{"./antlr-rule-error":22,"./immutable-antlr-rule-wrapper":26,"./rule-table":33,"antlr4":84,"antlr4/error":83,"lodash":111,"text-manipulation/dist/buffer/utils":317}],24:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var index_1 = require("../index");
var FunctionalRuleParser = /** @class */ (function () {
    function FunctionalRuleParser(parser) {
        this.parser = parser;
        this.resetStack();
    }
    FunctionalRuleParser.prototype.every = function (predicate) {
        this.resetStack();
        var n = this.stack.length;
        var data = this.stack;
        for (var i = 0; i < n; i++) {
            var val = predicate(this.wrapRule(data[i]), i);
            if (!val) {
                return false;
            }
        }
        return true;
    };
    FunctionalRuleParser.prototype.findLast = function (filterFunction) {
        this.filter(filterFunction);
        var list = [];
        var n = this.stack.length;
        var data = this.stack;
        this.resetStack();
        if (n > 0) {
            return this.wrapRule(data[data.length - 1]);
        }
        else {
            return undefined;
        }
    };
    FunctionalRuleParser.prototype.find = function (filterFunction) {
        this.filter(filterFunction);
        var list = [];
        var n = this.stack.length;
        var data = this.stack;
        this.resetStack();
        if (n > 0) {
            return this.wrapRule(data[0]);
        }
        else {
            return undefined;
        }
    };
    FunctionalRuleParser.prototype.findAll = function (filterFunction) {
        this.filter(filterFunction);
        var list = [];
        var n = this.stack.length;
        var data = this.stack;
        for (var i = 0; i < n; i++) {
            list.push(this.wrapRule(data[i]));
        }
        this.resetStack();
        return list;
    };
    FunctionalRuleParser.prototype.filter = function (filterFunction) {
        var len = this.stack.length;
        this._stack = Array.from(this.stack);
        var stackPosition = 0;
        for (var i = 0; i < len; i++) {
            var rule = this.stack[stackPosition];
            if (!filterFunction(this.wrapRule(rule), i)) {
                // Filter out rule
                this._stack.splice(stackPosition, 1);
                this.stackHasChanged = true;
            }
            else {
                stackPosition++;
            }
        }
        return this;
    };
    FunctionalRuleParser.prototype.forEach = function (eachFunction) {
        var len = this.stack.length;
        for (var i = 0; i < len; i++) {
            var rule = this.stack[i];
            eachFunction(this.wrapRule(rule), i);
        }
        this.resetStack();
    };
    FunctionalRuleParser.prototype.map = function (mapFunction) {
        var len = this.stack.length;
        var results = [];
        for (var i = 0; i < len; i++) {
            var rule = this.stack[i];
            results[i] = mapFunction(this.wrapRule(rule), i);
        }
        this.resetStack();
        return results;
    };
    FunctionalRuleParser.prototype.reduce = function (reduceFunction, accumulator) {
        var len = this.stack.length;
        for (var i = 0; i < len; i++) {
            var rule = this.stack[i];
            accumulator = reduceFunction(accumulator, this.wrapRule(rule), i);
        }
        this.resetStack();
        return accumulator;
    };
    Object.defineProperty(FunctionalRuleParser.prototype, "stack", {
        get: function () {
            var rules = this.parser.getRuleStack();
            if (this.stackHasChanged) {
                return this._stack;
            }
            return rules;
        },
        enumerable: true,
        configurable: true
    });
    FunctionalRuleParser.prototype.resetStack = function () {
        this._stack = [];
        this.stackHasChanged = false;
    };
    FunctionalRuleParser.prototype.wrapRule = function (rule) {
        if (this.parser instanceof index_1.MutableAntlrParser) {
            return new index_1.MutableAntlrRuleWrapper(rule, this.parser);
        }
        return new index_1.ImmutableAntlrRuleWrapper(rule, this.parser);
    };
    return FunctionalRuleParser;
}());
exports.FunctionalRuleParser = FunctionalRuleParser;

},{"../index":20}],25:[function(require,module,exports){
"use strict";
var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
Object.defineProperty(exports, "__esModule", { value: true });
var antlr4_1 = require("antlr4");
var Tree_1 = require("antlr4/tree/Tree");
var index_1 = require("rxjs/index");
var operators_1 = require("rxjs/operators");
var _ = require("lodash");
var antlr_parser_wrapper_1 = require("./antlr-parser-wrapper");
var rule_table_1 = require("./rule-table");
var text_manipulation_1 = require("text-manipulation");
var error_rule_handler_1 = require("./error-rule-handler");
var antlr_rule_error_1 = require("./antlr-rule-error");
var lex_error_handler_1 = require("./lex-error-handler");
var token_table_1 = require("./token-table");
var immutable_antlr_token_wrapper_1 = require("./immutable-antlr-token-wrapper");
var immutable_antlr_rule_wrapper_1 = require("./immutable-antlr-rule-wrapper");
var functional_rule_parser_1 = require("./functional-rule-parser");
var xpath_1 = require("../xpath/xpath");
var ImmutableAntlrParser = /** @class */ (function () {
    /**
     * Provide an AntlrFactory to construct
     * @param {AntlrFactory} factory
     */
    function ImmutableAntlrParser(factory) {
        this.factory = factory;
        this.parseStartedSubject = new index_1.Subject();
        this.tokenSubject = new index_1.Subject();
        this.enterRuleSubject = new index_1.Subject();
        this.exitRuleSubject = new index_1.Subject();
        this.customValidatorSubject = new index_1.Subject();
        this.parseCompleteSubject = new index_1.Subject();
    }
    ImmutableAntlrParser.prototype.getInputStream = function () {
        return this.inputStream;
    };
    ImmutableAntlrParser.prototype.setLexer = function (lexer) {
        this.lexer = lexer;
    };
    ImmutableAntlrParser.prototype.getFactory = function () {
        return this.factory;
    };
    ImmutableAntlrParser.prototype.getRoot = function () {
        return new immutable_antlr_rule_wrapper_1.ImmutableAntlrRuleWrapper(this.rootRule, this);
    };
    ImmutableAntlrParser.prototype.getAllRules = function () {
        return this.ruleWrapperStack;
    };
    ImmutableAntlrParser.prototype.getAllTokens = function () {
        var _this = this;
        return Array.from(this.tokenTable.tokenMap.keys()).map(function (token) { return new immutable_antlr_token_wrapper_1.ImmutableAntlrTokenWrapper(token, _this); });
    };
    ImmutableAntlrParser.prototype.hasTextChanged = function () {
        return false;
    };
    ImmutableAntlrParser.prototype.reparse = function () {
        return this.parse(this.getText());
    };
    ImmutableAntlrParser.prototype.doesRuleExist = function (rule) {
        return this.ruleTable.ruleMap.has(rule);
    };
    ImmutableAntlrParser.prototype.doesTokenExist = function (token) {
        return this.tokenTable.tokenMap.has(token);
    };
    /**
     * Parse the input string
     *
     * @param {string} input
     * @returns {ParserRuleContext} - the invoked root rule
     */
    ImmutableAntlrParser.prototype.parse = function (input) {
        var _this = this;
        this.stack = [];
        this.ruleWrapperStack = [];
        this.functionalRuleParser = new functional_rule_parser_1.FunctionalRuleParser(this);
        this.inputStream = new antlr4_1.InputStream(input);
        this.textBuffer = text_manipulation_1.createBuffer(input);
        this.errorHandler = new error_rule_handler_1.ErrorRuleHandler(this, this.textBuffer);
        this.ruleTable = new rule_table_1.RuleTable(this.textBuffer, this);
        this.tokenTable = new token_table_1.TokenTable(this.textBuffer, this);
        if (this.lexer === undefined) {
            this.lexer = this.factory.createLexer(this.inputStream);
        }
        else {
            this.lexer.inputStream = this.inputStream;
            this.lexer.reset();
        }
        var lexer = this.lexer;
        lexer.removeErrorListeners();
        lexer.addErrorListener(new lex_error_handler_1.LexErrorHandler(this.errorHandler));
        var tokenStream = new antlr4_1.CommonTokenStream(lexer);
        var parser = this.factory.createParser(tokenStream);
        parser.removeErrorListeners();
        parser.addErrorListener(this.errorHandler);
        this.parserWrapper = new antlr_parser_wrapper_1.AntlrParserWrapper(parser);
        this.ruleIndexToNameMap = this.parserWrapper.getRuleIndexToNameMap();
        this.tokenTypeToSymoblMap = this.parserWrapper.getTokenTypeToSymoblMap();
        parser.addParseListener(this);
        this.parseStartedSubject.next(null);
        var rootRule = this.factory.createAndInvokeRootRule(parser);
        this.parseCompleteSubject.next(null);
        this.getErrors().forEach(function (err) {
            _this.ruleTable.addToRuleMap(err.rule, [err.start, err.end]);
            if (err.rule) {
                _this.errorHandler.processRuleWithError(err.rule);
            }
        });
        this.rootRule = rootRule;
        return rootRule;
    };
    ImmutableAntlrParser.prototype.getLineCount = function () {
        return this.textBuffer.getLineCount();
    };
    ImmutableAntlrParser.prototype.getColumnCount = function (line) {
        return this.textBuffer.getColumnCount(line);
    };
    ImmutableAntlrParser.prototype.checkForErrors = function () {
        if (this.hasErrors()) {
            throw new SyntaxError(this.getRelevantError().message);
        }
    };
    /**
     * Get the range of a given token, where the first object
     * is the start position and the last is the end position
     *
     * @param {Token } token
     * @returns {AntlrRange}
     */
    ImmutableAntlrParser.prototype.getTokenRange = function (token) {
        var text = this.tokenIntervalText(token);
        var table = text.split('\n');
        var lineCount = table.length;
        var start = { column: token.column, line: token.line - 1 };
        var stop = {
            column: token.column + table[table.length - 1].length,
            line: (token.line - 1) + (lineCount - 1)
        };
        return [start, stop];
    };
    ImmutableAntlrParser.prototype.getTextRange = function (range) {
        return this.textBuffer.getRangeText(text_manipulation_1.createTextRange(range[0], range[1]));
    };
    /**
     * Retrieve a token a the specified position
     *
     * @param {number} column
     * @param {number} line
     * @returns {Token}
     */
    ImmutableAntlrParser.prototype.getTokenAt = function (column, line) {
        var token = this.tokenTable.getTokenAt(column, line);
        if (token) {
            return new immutable_antlr_token_wrapper_1.ImmutableAntlrTokenWrapper(token, this);
        }
        return undefined;
    };
    /**
     * Get the text of a given token
     *
     * @param {Token} token
     * @returns {string}
     */
    ImmutableAntlrParser.prototype.getTokenText = function (token) {
        var range = this.getTokenRange(token);
        var textRange = new text_manipulation_1.ImmutableTextRange(range);
        return this.textBuffer.getRangeText(textRange);
    };
    /**
     * Get the complete text of a completely parsed rule
     *
     * @param {ParserRuleContext} rule
     * @returns {string}
     */
    ImmutableAntlrParser.prototype.getRuleText = function (rule) {
        var start = rule.start.start;
        var stop = rule.stop.stop;
        return this.inputStream.getText(start, stop);
    };
    ImmutableAntlrParser.prototype.tokenIntervalText = function (token) {
        return this.inputStream.getText(token.start, token.stop);
    };
    /**
     * Get the range of a given rule, where the first object
     * is the start position and the last is the end position
     *
     * @param {ParserRuleContext} rule
     * @returns {AntlrRange}
     */
    ImmutableAntlrParser.prototype.getRuleRange = function (rule) {
        if (rule.start && rule.stop) {
            var start = { column: rule.start.column, line: rule.start.line - 1 };
            var stopText = this.tokenIntervalText(rule.stop);
            var end = { column: rule.stop.column + stopText.length, line: rule.stop.line - 1 };
            return [start, end];
        }
        else if (rule.start) {
            var start = { column: 0, line: rule.start.line - 1 };
            var end = { column: rule.start.column, line: rule.start.line - 1 };
            return [start, end];
        }
        else if (rule.stop) {
            var start = { column: 0, line: rule.stop.line - 1 };
            var stopText = this.tokenIntervalText(rule.stop);
            var end = { column: rule.stop.column + stopText.length, line: rule.stop.line - 1 };
            return [start, end];
        }
        else {
            var start = { column: 0, line: 0 };
            return [start, start];
        }
    };
    /**
     * Checks if a rule matches the ruleClass given
     *
     * @param {ParserRuleContext} rule
     * @param {AntlrRuleClass<any>} ruleClass
     * @returns {boolean}
     */
    ImmutableAntlrParser.prototype.doesRuleMatchClass = function (rule, ruleClass) {
        return ruleClass && rule && rule instanceof antlr4_1.ParserRuleContext &&
            rule.constructor.name === ruleClass.name;
    };
    ImmutableAntlrParser.prototype.addParserStartListener = function (listener) {
        this.parseStartedSubject.asObservable().subscribe(listener);
    };
    ImmutableAntlrParser.prototype.addParserCompleteListener = function (listener) {
        this.parseCompleteSubject.asObservable().subscribe(listener);
    };
    ImmutableAntlrParser.prototype.addEnterRuleListener = function (ruleClass, listener) {
        var _this = this;
        if (ruleClass) {
            this.enterRuleSubject.asObservable()
                .pipe(operators_1.filter(function (rule) { return _this.doesRuleMatchClass(rule, ruleClass); }))
                .subscribe(listener);
        }
        else {
            this.enterRuleSubject.asObservable().subscribe(listener);
        }
    };
    ImmutableAntlrParser.prototype.addExitRuleListener = function (ruleClass, listener) {
        var _this = this;
        if (ruleClass) {
            this.exitRuleSubject.asObservable()
                .pipe(operators_1.filter(function (rule) { return _this.doesRuleMatchClass(rule, ruleClass); }))
                .subscribe(listener);
        }
        else {
            this.exitRuleSubject.asObservable().subscribe(listener);
        }
    };
    ImmutableAntlrParser.prototype.onParseStart = function (callback) {
        this.parseStartedSubject.asObservable().subscribe(callback);
    };
    ImmutableAntlrParser.prototype.addTokenListener = function (listener) {
        this.tokenSubject.asObservable().subscribe(listener);
    };
    ImmutableAntlrParser.prototype.addValidator = function (ruleName, validator) {
        var _this = this;
        this.customValidatorSubject.asObservable()
            .pipe(operators_1.filter(function (rule) { return _this.getRuleName(rule) === ruleName; }))
            .subscribe(function (rule) {
            var wrapper = new immutable_antlr_rule_wrapper_1.ImmutableAntlrRuleWrapper(rule, _this);
            var error = validator(wrapper);
            if (!_.isNil(error)) {
                _this.errorHandler.addError(error);
            }
        });
    };
    ImmutableAntlrParser.prototype.addCustomRuleValidator = function (ruleClass, validator) {
        var _this = this;
        this.customValidatorSubject.asObservable()
            .pipe(operators_1.filter(function (rule) { return _this.doesRuleMatchClass(rule, ruleClass); }))
            .subscribe(function (rule) {
            var error = validator(rule);
            if (!_.isNil(error)) {
                _this.errorHandler.addError(error);
            }
        });
    };
    ImmutableAntlrParser.prototype.getRulesInLine = function (line) {
        var _this = this;
        var table = this.getRulePositionTable();
        if (table[line]) {
            var map = new Map();
            var set = table[line]
                .map(function (rule) { return rule; })
                .filter(function (rule) { return rule !== undefined; });
            var ruleSet = new Set(set);
            var wrapperSet = Array.from(ruleSet).map(function (rule) { return new immutable_antlr_rule_wrapper_1.ImmutableAntlrRuleWrapper(rule, _this); });
            return new Set(wrapperSet);
        }
        return new Set([]);
    };
    ImmutableAntlrParser.prototype.getTokensInLine = function (line) {
        var table = this.getTokenPositionTable();
        if (table[line]) {
            var set = table[line].map(function (token) { return token; }).filter(function (token) { return token !== undefined; });
            return new Set(set);
        }
        return new Set([]);
    };
    ImmutableAntlrParser.prototype.getLine = function (line) {
        return this.textBuffer.getLine(line);
    };
    ImmutableAntlrParser.prototype.getSiblings = function (rule) {
        var parent = rule.parentCtx;
        var children = [];
        if (parent && parent.getChildCount() > 0) {
            for (var i = 0; i < parent.getChildCount(); i++) {
                var child = parent.getChild(i);
                if (rule !== child && child instanceof antlr4_1.ParserRuleContext) {
                    children.push(child);
                }
            }
        }
        return children;
    };
    ImmutableAntlrParser.prototype.getRuleBefore = function (rule) {
        var parent = rule.parentCtx;
        var choice;
        if (parent && parent.getChildCount() > 0) {
            for (var i = 0; i < parent.getChildCount(); i++) {
                var child = parent.getChild(i);
                if (child && child === rule) {
                    return choice;
                }
                if (rule !== child && child instanceof antlr4_1.ParserRuleContext) {
                    choice = rule;
                }
            }
        }
        return undefined;
    };
    ImmutableAntlrParser.prototype.siblingsHaveNoErrors = function (rule) {
        var e_1, _a;
        var siblings = this.getSiblings(rule);
        try {
            for (var siblings_1 = __values(siblings), siblings_1_1 = siblings_1.next(); !siblings_1_1.done; siblings_1_1 = siblings_1.next()) {
                var sibling = siblings_1_1.value;
                if (sibling.exception || this.hasErrorNode(sibling)) {
                    return false;
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (siblings_1_1 && !siblings_1_1.done && (_a = siblings_1.return)) _a.call(siblings_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return true;
    };
    ImmutableAntlrParser.prototype.hasErrorNode = function (ctx) {
        var n = ctx.getChildCount();
        for (var i = 0; i < n; i++) {
            var child = ctx.getChild(i);
            if (child instanceof Tree_1.ErrorNodeImpl) {
                return true;
            }
        }
        return false;
    };
    ImmutableAntlrParser.prototype.getRuleStack = function () {
        return this.stack;
    };
    ImmutableAntlrParser.prototype.getText = function () {
        if (this.textBuffer) {
            return this.textBuffer.getText();
        }
        else {
            return '';
        }
    };
    ImmutableAntlrParser.prototype.getErrors = function () {
        if (this.errorHandler) {
            return this.errorHandler.getErrors().filter(function (err) { return err.severity === 'error'; });
        }
        return [];
    };
    ImmutableAntlrParser.prototype.getWarnings = function () {
        if (this.errorHandler) {
            return this.errorHandler.getErrors().filter(function (err) { return err.severity === 'warning'; });
        }
        return [];
    };
    ImmutableAntlrParser.prototype.comparePositions = function (a, b) {
        return (a.line - b.line) || (a.column - b.column);
    };
    ImmutableAntlrParser.prototype.getTokenPositionTable = function () {
        return this.tokenTable.tokenTable;
    };
    ImmutableAntlrParser.prototype.getRulePositionTable = function () {
        return this.ruleTable.ruleTable;
    };
    ImmutableAntlrParser.prototype.getErrorRuleAt = function (column, line) {
        var rule = this.errorHandler.getErrorRuleAt(column, line);
        if (rule) {
            return new immutable_antlr_rule_wrapper_1.ImmutableAntlrRuleWrapper(this.errorHandler.getErrorRuleAt(column, line), this);
        }
        return undefined;
    };
    ImmutableAntlrParser.prototype.getErrorRuleTable = function () {
        return this.errorHandler.getErrorRuleTable();
    };
    ImmutableAntlrParser.prototype.hasErrors = function () {
        return this.getErrors().length > 0;
    };
    ImmutableAntlrParser.prototype.hasWarnings = function () {
        return this.getWarnings().length > 0;
    };
    ImmutableAntlrParser.prototype.getRelevantError = function () {
        if (this.hasErrors()) {
            return _.last(this.getErrors());
        }
    };
    ImmutableAntlrParser.prototype.createRuleError = function (rule) {
        var range = this.getRuleRange(rule);
        var error = new antlr_rule_error_1.AntlrRuleError();
        error.rule = rule;
        error.ruleWrapper = new immutable_antlr_rule_wrapper_1.ImmutableAntlrRuleWrapper(rule, this);
        error.start = range[0];
        error.end = range[1];
        error.message = "Error matching the " + this.getRuleName(rule) + " rule";
        return error;
    };
    ImmutableAntlrParser.prototype.getRuleAt = function (column, line) {
        var rule = this.ruleTable.getRuleAt(column, line);
        if (rule) {
            return new immutable_antlr_rule_wrapper_1.ImmutableAntlrRuleWrapper(rule, this);
        }
        return undefined;
    };
    ImmutableAntlrParser.prototype.getCharacterAt = function (column, line) {
        return this.textBuffer.charAt(column, line);
    };
    ImmutableAntlrParser.prototype.getRuleName = function (rule) {
        return this.ruleIndexToNameMap.get(rule.ruleIndex);
    };
    ImmutableAntlrParser.prototype.getTokenName = function (token) {
        return this.tokenTypeToSymoblMap.get(token.type);
    };
    ImmutableAntlrParser.prototype.getRuleParent = function (rule) {
        if (rule) {
            return rule.parentCtx;
        }
        return undefined;
    };
    /**
     * (For internal use only)
     *
     * @param {TerminalNode} node
     */
    ImmutableAntlrParser.prototype.visitTerminal = function (node) {
        var token = node.symbol;
        if (token.start !== -1 && token.stop !== -1) {
            this.tokenTable.addToken(token);
            this.tokenSubject.next(token);
        }
    };
    /**
     * (For internal use only)
     * @param {ErrorNode} node
     */
    ImmutableAntlrParser.prototype.visitErrorNode = function (node) {
    };
    /**
     * (For internal use only)
     *
     * @param {ParserRuleContext} ctx
     */
    ImmutableAntlrParser.prototype.enterEveryRule = function (ctx) {
        this.stack.push(ctx);
        this.ruleWrapperStack.push(new immutable_antlr_rule_wrapper_1.ImmutableAntlrRuleWrapper(ctx, this));
        this.enterRuleSubject.next(ctx);
    };
    ImmutableAntlrParser.prototype.onRuleEnter = function (ruleName, callback) {
        var _this = this;
        this.enterRuleSubject.asObservable()
            .pipe(operators_1.filter(function (rule) { return _this.getRuleName(rule) === ruleName; }))
            .subscribe(function (rule) {
            var wrapper = new immutable_antlr_rule_wrapper_1.ImmutableAntlrRuleWrapper(rule, _this);
            callback(wrapper);
        });
    };
    ImmutableAntlrParser.prototype.onRuleExit = function (ruleName, callback) {
        var _this = this;
        this.exitRuleSubject.asObservable()
            .pipe(operators_1.filter(function (rule) { return _this.getRuleName(rule) === ruleName; }))
            .subscribe(function (rule) {
            var wrapper = new immutable_antlr_rule_wrapper_1.ImmutableAntlrRuleWrapper(rule, _this);
            callback(wrapper);
        });
    };
    ImmutableAntlrParser.prototype.onParseComplete = function (callback) {
        this.parseCompleteSubject.asObservable().subscribe(callback);
    };
    /**
     * (For internal use only)
     *
     * @param {ParserRuleContext} ctx
     */
    ImmutableAntlrParser.prototype.exitEveryRule = function (ctx) {
        if (this.hasErrorNode(ctx) && this.siblingsHaveNoErrors(ctx)) {
            this.errorHandler.processRuleWithError(ctx);
        }
        else if (this.getErrors().length === 0) {
            if (ctx.stop && ctx.start) {
                this.customValidatorSubject.next(ctx);
                if (this.getErrors().length === 0) {
                    this.ruleTable.addRule(ctx);
                    this.exitRuleSubject.next(ctx);
                }
            }
            // this.errorHandler.processRecognitionException(ctx.exception);
        }
    };
    ImmutableAntlrParser.prototype.setTokenText = function (token, text) {
        throw new Error('Cannot set token text on ImmutableAntlrParser');
    };
    ImmutableAntlrParser.prototype.setRuleText = function (rule, text) {
        throw new Error('Cannot set rule text on ImmutableAntlrParser');
    };
    ImmutableAntlrParser.prototype.replaceRange = function (range, text) {
        throw new Error('Cannot replace range text on ImmutableAntlrParser');
    };
    ImmutableAntlrParser.prototype.filter = function (filterFunction) {
        this.functionalRuleParser.filter(filterFunction);
        return this;
    };
    ImmutableAntlrParser.prototype.forEach = function (eachFunction) {
        this.functionalRuleParser.forEach(eachFunction);
        this.functionalRuleParser = new functional_rule_parser_1.FunctionalRuleParser(this);
    };
    ImmutableAntlrParser.prototype.map = function (mapFunction) {
        var results = this.functionalRuleParser.map(mapFunction);
        this.functionalRuleParser = new functional_rule_parser_1.FunctionalRuleParser(this);
        return results;
    };
    ImmutableAntlrParser.prototype.reduce = function (reduceFunction, accumulator) {
        var results = this.functionalRuleParser.reduce(reduceFunction, accumulator);
        this.functionalRuleParser = new functional_rule_parser_1.FunctionalRuleParser(this);
        return results;
    };
    ImmutableAntlrParser.prototype.findLast = function (filterFunction) {
        var results = this.functionalRuleParser.findLast(filterFunction);
        this.functionalRuleParser = new functional_rule_parser_1.FunctionalRuleParser(this);
        return results;
    };
    ImmutableAntlrParser.prototype.find = function (filterFunction) {
        var results = this.functionalRuleParser.find(filterFunction);
        this.functionalRuleParser = new functional_rule_parser_1.FunctionalRuleParser(this);
        return results;
    };
    ImmutableAntlrParser.prototype.findAll = function (filterFunction) {
        var results = this.functionalRuleParser.findAll(filterFunction);
        this.functionalRuleParser = new functional_rule_parser_1.FunctionalRuleParser(this);
        return results;
    };
    ImmutableAntlrParser.prototype.every = function (predicate) {
        var results = this.functionalRuleParser.every(predicate);
        this.functionalRuleParser = new functional_rule_parser_1.FunctionalRuleParser(this);
        return results;
    };
    ImmutableAntlrParser.prototype.findRuleByName = function (ruleName) {
        return this.find(function (rule) { return rule.getName() === ruleName; });
    };
    ImmutableAntlrParser.prototype.findRulesByName = function (ruleName) {
        return this.findAll(function (rule) { return rule.getName() === ruleName; });
    };
    ImmutableAntlrParser.prototype.findRulesByPath = function (path) {
        var xpath = new xpath_1.XPath(this.getRoot());
        return xpath.findRulesByPath(path);
    };
    ImmutableAntlrParser.prototype.findRuleByPath = function (path) {
        var rules = this.findRulesByPath(path);
        if (rules.length > 0) {
            return rules[0];
        }
        return undefined;
    };
    return ImmutableAntlrParser;
}());
exports.ImmutableAntlrParser = ImmutableAntlrParser;

},{"../xpath/xpath":42,"./antlr-parser-wrapper":21,"./antlr-rule-error":22,"./error-rule-handler":23,"./functional-rule-parser":24,"./immutable-antlr-rule-wrapper":26,"./immutable-antlr-token-wrapper":27,"./lex-error-handler":28,"./rule-table":33,"./token-table":34,"antlr4":84,"antlr4/tree/Tree":87,"lodash":111,"rxjs/index":112,"rxjs/operators":312,"text-manipulation":318}],26:[function(require,module,exports){
"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var Tree_1 = require("antlr4/tree/Tree");
var immutable_antlr_token_wrapper_1 = require("./immutable-antlr-token-wrapper");
var utils_1 = require("text-manipulation/dist/buffer/utils");
var xpath_1 = require("../xpath/xpath");
var ImmutableAntlrRuleWrapper = /** @class */ (function () {
    function ImmutableAntlrRuleWrapper(rule, parser, fixedRange) {
        this.rule = rule;
        this.parser = parser;
        this.fixedRange = fixedRange;
        if (fixedRange) {
            this.fixedRange = utils_1.sortRange(fixedRange);
        }
    }
    ImmutableAntlrRuleWrapper.prototype.exists = function () {
        return this.parser.doesRuleExist(this.rule);
    };
    ImmutableAntlrRuleWrapper.prototype.inRange = function (pos) {
        var _a = __read(this.getRange(), 2), start = _a[0], end = _a[1];
        if (this.exists()) {
            return this.parser.comparePositions(start, pos) <= 0 && this.parser.comparePositions(pos, end) < 0;
        }
        return false;
    };
    ImmutableAntlrRuleWrapper.prototype.getTokens = function (tokenRuleName) {
        var count = this.rule.getChildCount();
        var list = [];
        for (var i = 0; i < count; i++) {
            var token = this.rule.getChild(i);
            if ((token instanceof Tree_1.TerminalNode)) {
                var wrapper = new immutable_antlr_token_wrapper_1.ImmutableAntlrTokenWrapper(token.symbol, this.parser);
                if (tokenRuleName === undefined || wrapper.getName() === tokenRuleName) {
                    list.push(wrapper);
                }
            }
        }
        return list;
    };
    ImmutableAntlrRuleWrapper.prototype.hasToken = function (tokenRuleName) {
        return this.getTokens(tokenRuleName).length > 0;
    };
    ImmutableAntlrRuleWrapper.prototype.getChildren = function () {
        var count = this.rule.getChildCount();
        var list = [];
        for (var i = 0; i < count; i++) {
            var rule = this.rule.getChild(i);
            if (!(rule instanceof Tree_1.TerminalNode)) {
                list.push(new ImmutableAntlrRuleWrapper(rule, this.parser));
            }
        }
        return list;
    };
    ImmutableAntlrRuleWrapper.prototype.getSiblings = function () {
        var _this = this;
        var siblings = this.parser.getSiblings(this.rule)
            .map(function (sibling) { return new ImmutableAntlrRuleWrapper(sibling, _this.parser); });
        return siblings;
    };
    ImmutableAntlrRuleWrapper.prototype.setText = function (text) {
        throw new Error(this.getName() + " is an immutable AntlrRuleWrapper");
    };
    ImmutableAntlrRuleWrapper.prototype.getParent = function () {
        var parent = this.parser.getRuleParent(this.rule);
        if (parent) {
            return new ImmutableAntlrRuleWrapper(parent, this.parser);
        }
        return undefined;
    };
    ImmutableAntlrRuleWrapper.prototype.getToken = function (tokenRuleName) {
        var tokens = this.getTokens(tokenRuleName);
        if (tokens.length > 0) {
            return tokens[0];
        }
        return undefined;
    };
    ImmutableAntlrRuleWrapper.prototype.getRule = function () {
        return this.rule;
    };
    ImmutableAntlrRuleWrapper.prototype.getName = function () {
        return this.parser.getRuleName(this.rule);
    };
    ImmutableAntlrRuleWrapper.prototype.getText = function () {
        if (this.fixedRange) {
            return this.parser.getTextRange(this.fixedRange);
        }
        return this.parser.getRuleText(this.rule);
    };
    ImmutableAntlrRuleWrapper.prototype.getRange = function () {
        if (this.fixedRange) {
            return this.fixedRange;
        }
        return this.parser.getRuleRange(this.rule);
    };
    ImmutableAntlrRuleWrapper.prototype.createRuleError = function () {
        return this.parser.createRuleError(this.getRule());
    };
    ImmutableAntlrRuleWrapper.prototype.findRulesByName = function (ruleName) {
        var stack = [this];
        var results = [];
        while (stack.length > 0) {
            var root = stack.pop();
            if (root !== this && root.getName() === ruleName) {
                results.push(root);
            }
            root.getChildren().forEach(function (child) {
                stack.push(child);
            });
        }
        return results;
    };
    ImmutableAntlrRuleWrapper.prototype.findRuleByName = function (ruleName) {
        var stack = [this];
        while (stack.length > 0) {
            var root = stack.pop();
            if (root !== this && root.getName() === ruleName) {
                return root;
            }
            root.getChildren().forEach(function (child) {
                stack.push(child);
            });
        }
        return undefined;
    };
    ImmutableAntlrRuleWrapper.prototype.findRuleByPath = function (path) {
        var rules = this.findRulesByPath(path);
        if (rules.length > 0) {
            return rules[0];
        }
        return undefined;
    };
    ImmutableAntlrRuleWrapper.prototype.findRulesByPath = function (path) {
        var xpath = new xpath_1.XPath(this);
        return xpath.findRulesByPath(path);
    };
    return ImmutableAntlrRuleWrapper;
}());
exports.ImmutableAntlrRuleWrapper = ImmutableAntlrRuleWrapper;

},{"../xpath/xpath":42,"./immutable-antlr-token-wrapper":27,"antlr4/tree/Tree":87,"text-manipulation/dist/buffer/utils":317}],27:[function(require,module,exports){
"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var ImmutableAntlrTokenWrapper = /** @class */ (function () {
    function ImmutableAntlrTokenWrapper(token, parser) {
        this.token = token;
        this.parser = parser;
    }
    ImmutableAntlrTokenWrapper.prototype.exists = function () {
        return this.parser.doesTokenExist(this.token);
    };
    ImmutableAntlrTokenWrapper.prototype.inRange = function (pos) {
        var _a = __read(this.getRange(), 2), start = _a[0], end = _a[1];
        if (this.exists()) {
            return this.parser.comparePositions(start, pos) <= 0 && this.parser.comparePositions(pos, end) < 0;
        }
        return false;
    };
    ImmutableAntlrTokenWrapper.prototype.setText = function (text) {
        throw new Error(this.getName() + " is an immutable AntlrTokenWrapper");
    };
    ImmutableAntlrTokenWrapper.prototype.getToken = function () {
        return this.token;
    };
    ImmutableAntlrTokenWrapper.prototype.getName = function () {
        return this.parser.getTokenName(this.token);
    };
    ImmutableAntlrTokenWrapper.prototype.getText = function () {
        return this.parser.getTokenText(this.token);
    };
    ImmutableAntlrTokenWrapper.prototype.getRange = function () {
        return this.parser.getTokenRange(this.token);
    };
    return ImmutableAntlrTokenWrapper;
}());
exports.ImmutableAntlrTokenWrapper = ImmutableAntlrTokenWrapper;

},{}],28:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var error_1 = require("antlr4/error");
var antlr_rule_error_1 = require("./antlr-rule-error");
var LexErrorHandler = /** @class */ (function (_super) {
    __extends(LexErrorHandler, _super);
    function LexErrorHandler(errorHandler) {
        var _this = _super.call(this) || this;
        _this.errorHandler = errorHandler;
        return _this;
    }
    LexErrorHandler.prototype.syntaxError = function (recognizer, offendingSymbol, line, column, msg, e) {
        var ch = column;
        var editorLine = line - 1;
        var from = { column: Math.max(0, ch), line: editorLine };
        var to = { column: ch + 1, line: editorLine };
        var error = new antlr_rule_error_1.AntlrRuleError();
        error.start = from;
        error.end = to;
        error.message = msg;
        error.exception = e;
        error.rule = null;
        this.errorHandler.addError(error);
    };
    return LexErrorHandler;
}(error_1.ErrorListener));
exports.LexErrorHandler = LexErrorHandler;

},{"./antlr-rule-error":22,"antlr4/error":83}],29:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var text_manipulation_1 = require("text-manipulation");
var rule_table_1 = require("./rule-table");
var mutable_antlr_rule_wrapper_1 = require("./mutable-antlr-rule-wrapper");
var token_table_1 = require("./token-table");
var functional_rule_parser_1 = require("./functional-rule-parser");
var mutable_antlr_token_wrapper_1 = require("./mutable-antlr-token-wrapper");
var xpath_1 = require("../xpath/xpath");
/**
 * The MutableAntlrParser allows for text manipulation at the rule and token level.
 * Once the parse is complete the {@link getText} method enables one to see the complete
 * text of all the changes.
 *
 * <br/>
 * @example
 * <br/>
 *
 * <code>
 * <pre>
 *  ...
 * const parser = antlrHelper.createParser(factory);
 * ...
 * parser.addExitRuleListener(ExpressionContext, (rule)=>{
 *     parser.setRuleText(rule, 'replaced expression');
 *     console.log(parser.getRuleText(rule));
 * });
 *
 * parser.parse(text);
 *
 * console.log(parser.getText());
 *
 * </pre>
 * </code>
 *
 * @class MutableAntlrParser
 */
var MutableAntlrParser = /** @class */ (function () {
    /**
     * Provide an AntlrFactory to construct
     * @param {AntlrFactory | AntlrParser} parser
     */
    function MutableAntlrParser(parser) {
        var _this = this;
        this.parser = parser;
        this.textChanged = false;
        this.parser.addExitRuleListener(null, function (rule) {
            _this.ruleTable.addRule(rule);
        });
        this.parser.addTokenListener(function (token) {
            _this.tokenTable.addToken(token);
        });
        this.parser.addParserCompleteListener(function () {
            _this.getErrors().forEach(function (err) {
                _this.ruleTable.addToRuleMap(err.rule, [err.start, err.end]);
            });
        });
    }
    MutableAntlrParser.prototype.getInputStream = function () {
        return this.parser.getInputStream();
    };
    MutableAntlrParser.prototype.setLexer = function (lexer) {
        this.parser.setLexer(lexer);
    };
    MutableAntlrParser.prototype.getRoot = function () {
        return new mutable_antlr_rule_wrapper_1.MutableAntlrRuleWrapper(this.parser.getRoot().getRule(), this);
    };
    MutableAntlrParser.prototype.getFactory = function () {
        return this.parser.getFactory();
    };
    MutableAntlrParser.prototype.getAllRules = function () {
        var _this = this;
        return this.parser.getAllRules().map(function (rule) { return new mutable_antlr_rule_wrapper_1.MutableAntlrRuleWrapper(rule.getRule(), _this); });
    };
    MutableAntlrParser.prototype.getAllTokens = function () {
        var _this = this;
        return Array.from(this.tokenTable.tokenMap.keys()).map(function (token) { return new mutable_antlr_token_wrapper_1.MutableAntlrTokenWrapper(token, _this); });
    };
    MutableAntlrParser.prototype.doesRuleExist = function (rule) {
        return this.ruleTable.ruleMap.has(rule);
    };
    MutableAntlrParser.prototype.doesTokenExist = function (token) {
        return this.tokenTable.tokenMap.has(token);
    };
    MutableAntlrParser.prototype.hasTextChanged = function () {
        return this.textChanged;
    };
    MutableAntlrParser.prototype.reparse = function () {
        return this.parse(this.getText());
    };
    /**
     * Parse the input string
     * (The internal text model is changed on each parse)
     *
     * @param {string} input
     * @returns {ParserRuleContext} - the invoked root rule
     */
    MutableAntlrParser.prototype.parse = function (input) {
        // clear rule & token change maps
        this.functionalRuleParser = new functional_rule_parser_1.FunctionalRuleParser(this);
        this.textChanged = false;
        this.textBuffer = text_manipulation_1.createBuffer(input);
        this.ruleTable = new rule_table_1.RuleTable(this.textBuffer, this);
        this.tokenTable = new token_table_1.TokenTable(this.textBuffer, this);
        return this.parser.parse(input);
    };
    /**
     * Change the text of the token
     *
     * @param {Token} token
     * @param {string} text
     */
    MutableAntlrParser.prototype.setTokenText = function (token, text) {
        if (this.tokenTable.tokenMap.has(token)) {
            var range = new text_manipulation_1.MutableTextRange(this.getTokenRange(token), this.textBuffer);
            this.textChanged = true;
            var originalRange = [range.start, range.end];
            range.setText(text);
            this.tokenTable.updateToken(originalRange, token, text);
        }
    };
    /**
     * Get the range of a given token, where the first object
     * is the start position and the last is the end position
     *
     * @param {Token} token
     *
     * @returns {AntlrRange}
     */
    MutableAntlrParser.prototype.getTokenRange = function (token) {
        var range = this.tokenTable.tokenMap.get(token);
        if (range === undefined) {
            return this.parser.getTokenRange(token);
        }
        return [range.start, range.end];
    };
    /**
     * Get the text of a given token
     *
     * @param {Token} token
     * @returns {string}
     */
    MutableAntlrParser.prototype.getTokenText = function (token) {
        if (this.tokenTable.tokenMap.has(token)) {
            var res = this.tokenTable.tokenMap.get(token);
            return res.getText();
        }
        return this.parser.getTokenText(token);
    };
    MutableAntlrParser.prototype.getTextRange = function (range) {
        return this.textBuffer.getRangeText(text_manipulation_1.createTextRange(range[0], range[1]));
    };
    /**
     * Get the text of the completely parsed rule
     *
     * @param {ParserRuleContext} rule
     * @returns {string}
     */
    MutableAntlrParser.prototype.getRuleText = function (rule) {
        if (this.ruleTable.ruleMap.has(rule)) {
            return this.ruleTable.ruleMap.get(rule).getText();
        }
        else {
            return this.parser.getRuleText(rule);
        }
    };
    /**
     * Change the text of the completely parsed rule
     *
     * @param {ParserRuleContext} rule
     * @param {string} text
     */
    MutableAntlrParser.prototype.setRuleText = function (rule, text) {
        if (this.ruleTable.ruleMap.has(rule)) {
            this.textChanged = true;
            var range = this.ruleTable.ruleMap.get(rule);
            var originalRange = [range.start, range.end];
            range.setText(text);
            this.ruleTable.updateRule(originalRange, rule, text);
        }
    };
    MutableAntlrParser.prototype.replaceRange = function (range, text) {
        var textRange = text_manipulation_1.createTextRange(range[0], range[1]);
        var newRange = this.textBuffer.replaceRange(textRange, text);
        return [newRange.start, newRange.end];
    };
    MutableAntlrParser.prototype.getRuleAt = function (column, line) {
        var rule = this.ruleTable.getRuleAt(column, line);
        if (rule) {
            return new mutable_antlr_rule_wrapper_1.MutableAntlrRuleWrapper(rule, this);
        }
        return undefined;
    };
    MutableAntlrParser.prototype.getCharacterAt = function (column, line) {
        return this.textBuffer.charAt(column, line);
    };
    MutableAntlrParser.prototype.getTokenPositionTable = function () {
        return this.tokenTable.tokenTable;
    };
    MutableAntlrParser.prototype.getRulePositionTable = function () {
        return this.ruleTable.ruleTable;
    };
    /**
     * Add a listener for when the parser enters a given rule. See example below
     *
     * <br/>
     *
     * @example
     * <br/>
     *
     * <pre>
     * <code>
     * parser.addEnterRuleListener(ExpressionContext, (rule)=>{
     *     console.log("entering an expression rule");
     * });
     * </code>
     * </pre>
     *
     * @param {AntlrRuleClass<ParserRuleContext>} ruleClass
     * @param {(rule: T) => void} listener
     */
    MutableAntlrParser.prototype.addEnterRuleListener = function (ruleClass, listener) {
        this.parser.addEnterRuleListener(ruleClass, listener);
    };
    /**
     * Add a listener for when the parser exits a given rule.
     * Within this listener is where you would typically call methods such as
     * {@link setRuleText}, {@link getRuleText} ,{@link setTokenText} and {@link  getTokenText}
     *
     * See example below:
     *
     * <br/>
     *
     * @example
     * <br/>
     *
     * <pre>
     * <code>
     * parser.addExitRuleListener(ExpressionContext, (rule)=>{
     *     console.log(parser.getRuleText(rule));
     * });
     * </code>
     * </pre>
     *
     * @param {AntlrRuleClass<ParserRuleContext>} ruleClass
     * @param {(rule: T) => void} listener
     */
    MutableAntlrParser.prototype.addExitRuleListener = function (ruleClass, listener) {
        this.parser.addExitRuleListener(ruleClass, listener);
    };
    MutableAntlrParser.prototype.addValidator = function (ruleName, validator) {
        var _this = this;
        this.parser.addValidator(ruleName, function (wrapper) {
            return validator(new mutable_antlr_rule_wrapper_1.MutableAntlrRuleWrapper(wrapper.getRule(), _this));
        });
    };
    MutableAntlrParser.prototype.addCustomRuleValidator = function (ruleClass, validator) {
        this.parser.addCustomRuleValidator(ruleClass, validator);
    };
    MutableAntlrParser.prototype.onRuleEnter = function (ruleName, callback) {
        var _this = this;
        this.parser.onRuleEnter(ruleName, function (ruleWrapper) {
            callback(new mutable_antlr_rule_wrapper_1.MutableAntlrRuleWrapper(ruleWrapper.getRule(), _this));
        });
    };
    MutableAntlrParser.prototype.onRuleExit = function (ruleName, callback) {
        var _this = this;
        this.parser.onRuleExit(ruleName, function (ruleWrapper) {
            callback(new mutable_antlr_rule_wrapper_1.MutableAntlrRuleWrapper(ruleWrapper.getRule(), _this));
        });
    };
    MutableAntlrParser.prototype.onParseComplete = function (callback) {
        this.parser.onParseComplete(callback);
    };
    MutableAntlrParser.prototype.onParseStart = function (callback) {
        this.parser.onParseStart(callback);
    };
    MutableAntlrParser.prototype.addParserStartListener = function (listener) {
        this.parser.addParserStartListener(listener);
    };
    MutableAntlrParser.prototype.addTokenListener = function (listener) {
        this.parser.addTokenListener(listener);
    };
    MutableAntlrParser.prototype.addParserCompleteListener = function (listener) {
        this.parser.addParserCompleteListener(listener);
    };
    MutableAntlrParser.prototype.getRuleStack = function () {
        return this.parser.getRuleStack();
    };
    /**
     * Get the complete parsed and transformed text
     *
     * @returns {string}
     */
    MutableAntlrParser.prototype.getText = function () {
        if (this.textBuffer) {
            return this.textBuffer.getText();
        }
        else {
            return '';
        }
    };
    MutableAntlrParser.prototype.getLineCount = function () {
        return this.textBuffer.getLineCount();
    };
    MutableAntlrParser.prototype.getColumnCount = function (line) {
        return this.textBuffer.getColumnCount(line);
    };
    MutableAntlrParser.prototype.checkForErrors = function () {
        this.parser.checkForErrors();
    };
    MutableAntlrParser.prototype.getTokenAt = function (column, line) {
        var token = this.parser.getTokenAt(column, line);
        if (token) {
            return new mutable_antlr_token_wrapper_1.MutableAntlrTokenWrapper(token.getToken(), this);
        }
        return undefined;
    };
    MutableAntlrParser.prototype.getRuleRange = function (rule) {
        var range = this.ruleTable.ruleMap.get(rule);
        if (range) {
            return [range.start, range.end];
        }
        else {
            return this.parser.getRuleRange(rule);
        }
    };
    MutableAntlrParser.prototype.getErrors = function () {
        return this.parser.getErrors();
    };
    MutableAntlrParser.prototype.getWarnings = function () {
        return this.parser.getWarnings();
    };
    MutableAntlrParser.prototype.hasErrors = function () {
        return this.parser.hasErrors();
    };
    MutableAntlrParser.prototype.hasWarnings = function () {
        return this.parser.hasWarnings();
    };
    MutableAntlrParser.prototype.getRelevantError = function () {
        return this.parser.getRelevantError();
    };
    MutableAntlrParser.prototype.getRuleName = function (rule) {
        return this.parser.getRuleName(rule);
    };
    MutableAntlrParser.prototype.getTokenName = function (token) {
        return this.parser.getTokenName(token);
    };
    MutableAntlrParser.prototype.getRuleParent = function (rule) {
        return this.parser.getRuleParent(rule);
    };
    MutableAntlrParser.prototype.createRuleError = function (rule) {
        return this.parser.createRuleError(rule);
    };
    MutableAntlrParser.prototype.hasErrorNode = function (ctx) {
        return this.parser.hasErrorNode(ctx);
    };
    MutableAntlrParser.prototype.getSiblings = function (rule) {
        return this.parser.getSiblings(rule);
    };
    MutableAntlrParser.prototype.siblingsHaveNoErrors = function (rule) {
        return this.parser.siblingsHaveNoErrors(rule);
    };
    MutableAntlrParser.prototype.getRuleBefore = function (rule) {
        return this.parser.getRuleBefore(rule);
    };
    MutableAntlrParser.prototype.getLine = function (line) {
        return this.textBuffer.getLine(line);
    };
    MutableAntlrParser.prototype.getRulesInLine = function (line) {
        var _this = this;
        var table = this.getRulePositionTable();
        if (table[line]) {
            var map = new Map();
            var set = table[line]
                .map(function (rule) { return rule; })
                .filter(function (rule) { return rule !== undefined; });
            var ruleSet = new Set(set);
            var wrapperSet = Array.from(ruleSet).map(function (rule) { return new mutable_antlr_rule_wrapper_1.MutableAntlrRuleWrapper(rule, _this); });
            return new Set(wrapperSet);
        }
        return new Set([]);
    };
    MutableAntlrParser.prototype.comparePositions = function (a, b) {
        return this.parser.comparePositions(a, b);
    };
    MutableAntlrParser.prototype.getTokensInLine = function (line) {
        return new Set([]);
    };
    MutableAntlrParser.prototype.getErrorRuleAt = function (column, line) {
        var rule = this.parser.getErrorRuleAt(column, line);
        if (rule) {
            try {
                return new mutable_antlr_rule_wrapper_1.MutableAntlrRuleWrapper(rule.getRule(), this, rule.getRange());
            }
            catch (e) {
            }
        }
        return undefined;
    };
    MutableAntlrParser.prototype.filter = function (filterFunction) {
        this.functionalRuleParser.filter(filterFunction);
        return this;
    };
    MutableAntlrParser.prototype.forEach = function (eachFunction) {
        this.functionalRuleParser.forEach(eachFunction);
        this.functionalRuleParser = new functional_rule_parser_1.FunctionalRuleParser(this);
    };
    MutableAntlrParser.prototype.map = function (mapFunction) {
        var results = this.functionalRuleParser.map(mapFunction);
        this.functionalRuleParser = new functional_rule_parser_1.FunctionalRuleParser(this);
        return results;
    };
    MutableAntlrParser.prototype.reduce = function (reduceFunction, accumulator) {
        var results = this.functionalRuleParser.reduce(reduceFunction, accumulator);
        this.functionalRuleParser = new functional_rule_parser_1.FunctionalRuleParser(this);
        return results;
    };
    MutableAntlrParser.prototype.every = function (predicate) {
        var results = this.functionalRuleParser.every(predicate);
        this.functionalRuleParser = new functional_rule_parser_1.FunctionalRuleParser(this);
        return results;
    };
    MutableAntlrParser.prototype.findLast = function (filterFunction) {
        var results = this.functionalRuleParser.findLast(filterFunction);
        this.functionalRuleParser = new functional_rule_parser_1.FunctionalRuleParser(this);
        return results;
    };
    MutableAntlrParser.prototype.find = function (filterFunction) {
        var results = this.functionalRuleParser.find(filterFunction);
        this.functionalRuleParser = new functional_rule_parser_1.FunctionalRuleParser(this);
        return results;
    };
    MutableAntlrParser.prototype.findAll = function (filterFunction) {
        var results = this.functionalRuleParser.findAll(filterFunction);
        this.functionalRuleParser = new functional_rule_parser_1.FunctionalRuleParser(this);
        return results;
    };
    MutableAntlrParser.prototype.findRuleByName = function (ruleName) {
        return this.find(function (rule) { return rule.getName() === ruleName; });
    };
    MutableAntlrParser.prototype.findRulesByName = function (ruleName) {
        return this.findAll(function (rule) { return rule.getName() === ruleName; });
    };
    MutableAntlrParser.prototype.findRulesByPath = function (path) {
        var xpath = new xpath_1.XPath(this.getRoot());
        return xpath.findRulesByPath(path);
    };
    MutableAntlrParser.prototype.findRuleByPath = function (path) {
        var rules = this.findRulesByPath(path);
        if (rules.length > 0) {
            return rules[0];
        }
        return undefined;
    };
    return MutableAntlrParser;
}());
exports.MutableAntlrParser = MutableAntlrParser;

},{"../xpath/xpath":42,"./functional-rule-parser":24,"./mutable-antlr-rule-wrapper":30,"./mutable-antlr-token-wrapper":31,"./rule-table":33,"./token-table":34,"text-manipulation":318}],30:[function(require,module,exports){
"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var Tree_1 = require("antlr4/tree/Tree");
var mutable_antlr_token_wrapper_1 = require("./mutable-antlr-token-wrapper");
var utils_1 = require("text-manipulation/dist/buffer/utils");
var xpath_1 = require("../xpath/xpath");
var MutableAntlrRuleWrapper = /** @class */ (function () {
    function MutableAntlrRuleWrapper(rule, parser, fixedRange) {
        this.rule = rule;
        this.parser = parser;
        this.fixedRange = fixedRange;
        if (fixedRange) {
            this.fixedRange = utils_1.sortRange(fixedRange);
        }
    }
    MutableAntlrRuleWrapper.prototype.exists = function () {
        return this.parser.doesRuleExist(this.rule);
    };
    MutableAntlrRuleWrapper.prototype.inRange = function (pos) {
        var _a = __read(this.getRange(), 2), start = _a[0], end = _a[1];
        if (this.exists()) {
            return this.parser.comparePositions(start, pos) <= 0 && this.parser.comparePositions(pos, end) < 0;
        }
        return false;
    };
    MutableAntlrRuleWrapper.prototype.getTokens = function (tokenRuleName) {
        var count = this.rule.getChildCount();
        var list = [];
        for (var i = 0; i < count; i++) {
            var token = this.rule.getChild(i);
            if ((token instanceof Tree_1.TerminalNode)) {
                var wrapper = new mutable_antlr_token_wrapper_1.MutableAntlrTokenWrapper(token.symbol, this.parser);
                if (tokenRuleName === undefined || wrapper.getName() === tokenRuleName) {
                    list.push(wrapper);
                }
            }
        }
        return list;
    };
    MutableAntlrRuleWrapper.prototype.hasToken = function (tokenRuleName) {
        return this.getTokens(tokenRuleName).length > 0;
    };
    MutableAntlrRuleWrapper.prototype.getChildren = function () {
        var count = this.rule.getChildCount();
        var list = [];
        for (var i = 0; i < count; i++) {
            var rule = this.rule.getChild(i);
            if (!(rule instanceof Tree_1.TerminalNode)) {
                list.push(new MutableAntlrRuleWrapper(rule, this.parser));
            }
        }
        return list;
    };
    MutableAntlrRuleWrapper.prototype.getRule = function () {
        return this.rule;
    };
    MutableAntlrRuleWrapper.prototype.getText = function () {
        if (this.fixedRange) {
            return this.parser.getTextRange(this.fixedRange);
        }
        return this.parser.getRuleText(this.rule);
    };
    MutableAntlrRuleWrapper.prototype.setText = function (text) {
        this.fixedRange = undefined;
        return this.parser.setRuleText(this.rule, text);
    };
    MutableAntlrRuleWrapper.prototype.getName = function () {
        return this.parser.getRuleName(this.rule);
    };
    MutableAntlrRuleWrapper.prototype.getRange = function () {
        if (this.fixedRange) {
            return this.fixedRange;
        }
        return this.parser.getRuleRange(this.rule);
    };
    MutableAntlrRuleWrapper.prototype.getParent = function () {
        var parent = this.parser.getRuleParent(this.rule);
        if (parent) {
            return new MutableAntlrRuleWrapper(parent, this.parser);
        }
        return undefined;
    };
    MutableAntlrRuleWrapper.prototype.getSiblings = function () {
        var _this = this;
        var siblings = this.parser.getSiblings(this.rule)
            .map(function (sibling) { return new MutableAntlrRuleWrapper(sibling, _this.parser); });
        return siblings;
    };
    MutableAntlrRuleWrapper.prototype.getToken = function (tokenRuleName) {
        var tokens = this.getTokens(tokenRuleName);
        if (tokens.length > 0) {
            return tokens[0];
        }
        return undefined;
    };
    MutableAntlrRuleWrapper.prototype.createRuleError = function () {
        return this.parser.createRuleError(this.getRule());
    };
    MutableAntlrRuleWrapper.prototype.findRulesByName = function (ruleName) {
        var stack = [this];
        var results = [];
        while (stack.length > 0) {
            var root = stack.pop();
            if (root !== this && root.getName() === ruleName) {
                results.push(root);
            }
            root.getChildren().forEach(function (child) {
                stack.push(child);
            });
        }
        return results;
    };
    MutableAntlrRuleWrapper.prototype.findRuleByName = function (ruleName) {
        var stack = [this];
        while (stack.length > 0) {
            var root = stack.pop();
            if (root !== this && root.getName() === ruleName) {
                return root;
            }
            root.getChildren().forEach(function (child) {
                stack.push(child);
            });
        }
        return undefined;
    };
    MutableAntlrRuleWrapper.prototype.findRuleByPath = function (path) {
        var rules = this.findRulesByPath(path);
        if (rules.length > 0) {
            return rules[0];
        }
        return undefined;
    };
    MutableAntlrRuleWrapper.prototype.findRulesByPath = function (path) {
        var xpath = new xpath_1.XPath(this);
        return xpath.findRulesByPath(path);
    };
    return MutableAntlrRuleWrapper;
}());
exports.MutableAntlrRuleWrapper = MutableAntlrRuleWrapper;

},{"../xpath/xpath":42,"./mutable-antlr-token-wrapper":31,"antlr4/tree/Tree":87,"text-manipulation/dist/buffer/utils":317}],31:[function(require,module,exports){
"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var MutableAntlrTokenWrapper = /** @class */ (function () {
    function MutableAntlrTokenWrapper(token, parser) {
        this.token = token;
        this.parser = parser;
    }
    MutableAntlrTokenWrapper.prototype.inRange = function (pos) {
        var _a = __read(this.getRange(), 2), start = _a[0], end = _a[1];
        if (this.exists()) {
            return this.parser.comparePositions(start, pos) <= 0 && this.parser.comparePositions(pos, end) < 0;
        }
        return false;
    };
    MutableAntlrTokenWrapper.prototype.exists = function () {
        return this.parser.doesTokenExist(this.token);
    };
    MutableAntlrTokenWrapper.prototype.getToken = function () {
        return this.token;
    };
    MutableAntlrTokenWrapper.prototype.getName = function () {
        return this.parser.getTokenName(this.token);
    };
    MutableAntlrTokenWrapper.prototype.getText = function () {
        return this.parser.getTokenText(this.token);
    };
    MutableAntlrTokenWrapper.prototype.setText = function (text) {
        return this.parser.setTokenText(this.token, text);
    };
    MutableAntlrTokenWrapper.prototype.getRange = function () {
        return this.parser.getTokenRange(this.token);
    };
    return MutableAntlrTokenWrapper;
}());
exports.MutableAntlrTokenWrapper = MutableAntlrTokenWrapper;

},{}],32:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var RuleAndRange = /** @class */ (function () {
    function RuleAndRange(range, rule) {
        this.range = range;
        this.rule = rule;
    }
    return RuleAndRange;
}());
exports.RuleAndRange = RuleAndRange;

},{}],33:[function(require,module,exports){
"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var utils_1 = require("text-manipulation/dist/buffer/utils");
var text_manipulation_1 = require("text-manipulation");
var rule_and_range_1 = require("./rule-and-range");
var _ = require("lodash");
var RuleTable = /** @class */ (function () {
    function RuleTable(buffer, parser) {
        this.buffer = buffer;
        this.parser = parser;
        this.ruleTable = [];
        this.ruleMap = new Map();
    }
    RuleTable.prototype.getRuleAt = function (column, line) {
        if (this.ruleTable[line]) {
            return this.ruleTable[line][column];
        }
        return undefined;
    };
    RuleTable.prototype.recomputeRanges = function () {
        var ruleRanges = [];
        var startCol = 0;
        var startLine = 0;
        var currentRule;
        var numOfLines = this.ruleTable.length;
        for (var line = 0; line < numOfLines; line++) {
            var numOfColumns = this.ruleTable[line].length;
            for (var col = 0; col <= numOfColumns; col++) {
                var rule = this.ruleTable[line][col];
                if (currentRule === undefined && rule) {
                    currentRule = rule;
                    startCol = col;
                    startLine = line;
                }
                if (currentRule !== rule) {
                    if (rule === undefined && col === numOfColumns) {
                        if (line !== (numOfLines - 1)) {
                            continue;
                        }
                    }
                    var range = new text_manipulation_1.MutableTextRange([{ column: startCol, line: startLine }, {
                            column: col,
                            line: line
                        }], this.buffer);
                    var ruleAndRange = new rule_and_range_1.RuleAndRange(range, currentRule);
                    ruleRanges.push(ruleAndRange);
                    this.ruleMap.set(ruleAndRange.rule, ruleAndRange.range);
                    // Start new range
                    startCol = col;
                    startLine = line;
                    currentRule = rule;
                }
            }
        }
        return ruleRanges;
    };
    RuleTable.prototype.updateRule = function (originalRange, rule, ruleText) {
        var removedPosition = this.removeRange(originalRange);
        var lastChangedLine = removedPosition.line;
        var lastChangedCol = removedPosition.column;
        if (this.ruleTable[lastChangedLine] === undefined) {
            while (!this.ruleTable[lastChangedLine] === undefined && lastChangedLine > 0) {
                lastChangedLine--;
            }
            if (this.ruleTable[lastChangedLine] !== undefined) {
                this.ruleTable.push([]);
                lastChangedLine++;
            }
            else {
                // If text is empty
                this.ruleTable[lastChangedLine] = [];
            }
        }
        this.insertRule(lastChangedCol, lastChangedLine, ruleText, rule);
        this.recomputeRanges();
    };
    RuleTable.prototype.removeRange = function (range) {
        range = utils_1.sortRange([range[0], range[1]]);
        var start = range[0];
        var end = range[1];
        var line = start.line;
        var startCol = start.column;
        var prefixRules = [];
        for (var i = start.line; i <= end.line; i++) {
            if (i > start.line) {
                //
                // Remove the previous line if empty, as we continue further in the range
                //
                if (this.ruleTable[line].length === 0) {
                    this.ruleTable.splice(line, 1);
                }
            }
            var colEnd = (i === end.line) ? end.column : this.ruleTable[line].length;
            for (var col = startCol; col < colEnd; col++) {
                this.ruleTable[line].splice(startCol, 1);
            }
            if (this.ruleTable[line].length !== 0) {
                if (i !== end.line) {
                    prefixRules = this.ruleTable[line];
                    this.ruleTable.splice(line, 1);
                    startCol = 0;
                }
                else {
                    this.ruleTable[line] = prefixRules.concat(this.ruleTable[line]);
                }
            }
        }
        return { line: line, column: (prefixRules.length > 0) ? prefixRules.length : startCol };
    };
    RuleTable.prototype.addRule = function (rule, range) {
        range = (range === undefined) ? utils_1.sortRange(this.parser.getRuleRange(rule)) : range;
        var _a = __read(range, 2), start = _a[0], end = _a[1];
        var startLine = start.line;
        var endLine = end.line;
        var startCol = start.line;
        var endCol = end.column;
        for (var i = startLine; i <= endLine; i++) {
            if (i === startLine) {
                startCol = start.column;
            }
            else {
                startCol = 0;
            }
            if (i === endLine) {
                endCol = end.column;
            }
            else {
                endCol = this.buffer.getColumnCount(i);
            }
            if (this.ruleTable[i] === undefined) {
                this.ruleTable[i] = [];
            }
            for (var j = startCol; j < endCol; j++) {
                if (this.ruleTable[i][j] !== undefined) {
                    var oldVal = this.computeRulePriority(this.ruleTable[i][j]);
                    var newVal = this.computeRulePriority(rule);
                    if (newVal >= oldVal) {
                        this.ruleTable[i][j] = rule;
                    }
                    this.addToRuleMap(rule, range);
                }
                else {
                    this.ruleTable[i][j] = rule;
                    this.addToRuleMap(rule, range);
                }
            }
        }
    };
    RuleTable.prototype.addToRuleMap = function (rule, range) {
        this.ruleMap.set(rule, new text_manipulation_1.MutableTextRange(range, this.buffer));
    };
    RuleTable.prototype.computeRulePriority = function (rule) {
        return rule.depth() * rule.invokingState;
    };
    RuleTable.prototype.insertRule = function (column, line, currentRuleText, rule) {
        var buffer = text_manipulation_1.createBuffer(currentRuleText);
        if (buffer.getLineCount() > 1) {
            //
            // Case 2: We're given a rule with multiple lines
            //
            var n = buffer.getLineCount();
            for (var i = 0; i < n; i++) {
                var numOfColumns = buffer.getColumnCount(i);
                var rules = _.times(numOfColumns).map(function () { return rule; });
                //
                // Ensure that the line exists in the ruleTable
                //
                if (this.ruleTable[line] === undefined) {
                    this.ruleTable[line] = [];
                }
                if (i === (n - 1)) {
                    //
                    // Insert new rules up and before the endRange column.
                    // This is in case there are rules that must be merged
                    // onto an existing line.
                    //
                    for (var j = 0; j < numOfColumns; j++) {
                        this.ruleTable[line].splice(column + j, 0, rules[j]);
                    }
                }
                else {
                    if (i === 0) {
                        //
                        // If the rule's first line merges with an existing line,
                        // merge the new rules with the exising line.
                        //
                        var previousRulesOnLine = [];
                        for (var j = 0; j < column; j++) {
                            previousRulesOnLine.push(this.ruleTable[i][j]);
                            this.ruleTable[line].splice(0, 1);
                        }
                        this.ruleTable.splice(line++, 0, previousRulesOnLine.concat(rules));
                    }
                    else {
                        // Insert new line of rules
                        this.ruleTable.splice(line++, 0, rules);
                    }
                }
            }
        }
        else {
            //
            // Case 1: This rule only ranges on a single line
            //
            if (!this.ruleTable[line]) {
                this.ruleTable = [];
            }
            for (var i = 0; i < buffer.getColumnCount(0); i++) {
                // Insert at starting range column
                this.ruleTable[line].splice(column + i, 0, rule);
            }
        }
    };
    return RuleTable;
}());
exports.RuleTable = RuleTable;

},{"./rule-and-range":32,"lodash":111,"text-manipulation":318,"text-manipulation/dist/buffer/utils":317}],34:[function(require,module,exports){
"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var utils_1 = require("text-manipulation/dist/buffer/utils");
var text_manipulation_1 = require("text-manipulation");
var _ = require("lodash");
var TokenTable = /** @class */ (function () {
    function TokenTable(buffer, parser) {
        this.buffer = buffer;
        this.parser = parser;
        this.tokenTable = [];
        this.tokenMap = new Map();
    }
    TokenTable.prototype.getTokenAt = function (column, line) {
        if (this.tokenTable[line]) {
            return this.tokenTable[line][column];
        }
        return undefined;
    };
    TokenTable.prototype.addToken = function (token) {
        var range = utils_1.sortRange(this.parser.getTokenRange(token));
        var _a = __read(range, 2), start = _a[0], end = _a[1];
        var startLine = start.line;
        var endLine = end.line;
        var startCol = start.line;
        var endCol = end.column;
        for (var i = startLine; i <= endLine; i++) {
            if (i === startLine) {
                startCol = start.column;
            }
            else {
                startCol = 0;
            }
            if (i === endLine) {
                endCol = end.column;
            }
            else {
                endCol = this.buffer.getColumnCount(i);
            }
            if (this.tokenTable[i] === undefined) {
                this.tokenTable[i] = [];
            }
            for (var j = startCol; j < endCol; j++) {
                this.tokenTable[i][j] = token;
                this.tokenMap.set(token, new text_manipulation_1.MutableTextRange(this.parser.getTokenRange(token), this.buffer));
            }
        }
    };
    TokenTable.prototype.updateToken = function (originalRange, token, ruleText) {
        var removedPosition = this.clearRange(originalRange);
        var lastChangedLine = removedPosition.line;
        var lastChangedCol = removedPosition.column;
        if (this.tokenTable[lastChangedLine] === undefined) {
            while (!this.tokenTable[lastChangedLine] === undefined && lastChangedLine > 0) {
                lastChangedLine--;
            }
            if (this.tokenTable[lastChangedLine] !== undefined) {
                this.tokenTable.push([]);
                lastChangedLine++;
            }
            else {
                // If text is empty
                this.tokenTable[lastChangedLine] = [];
            }
        }
        this.insertToken(lastChangedCol, lastChangedLine, ruleText, token);
        this.recomputeRanges();
    };
    TokenTable.prototype.clearRange = function (range) {
        range = utils_1.sortRange([range[0], range[1]]);
        var start = range[0];
        var end = range[1];
        var line = start.line;
        var startCol = start.column;
        var prefixTokens = [];
        for (var i = start.line; i <= end.line; i++) {
            if (i > start.line) {
                //
                // Remove the previous line if empty, as we continue further in the range
                //
                if (this.tokenTable[line].length === 0) {
                    this.tokenTable.splice(line, 1);
                }
            }
            var colEnd = (i === end.line) ? end.column : this.tokenTable[line].length;
            for (var col = startCol; col < colEnd; col++) {
                this.tokenTable[line].splice(startCol, 1);
            }
            if (this.tokenTable[line].length !== 0) {
                if (i !== end.line) {
                    prefixTokens = this.tokenTable[line];
                    this.tokenTable.splice(line, 1);
                    startCol = 0;
                }
                else {
                    this.tokenTable[line] = prefixTokens.concat(this.tokenTable[line]);
                }
            }
        }
        return { line: line, column: (prefixTokens.length > 0) ? prefixTokens.length : startCol };
    };
    TokenTable.prototype.insertToken = function (column, line, currentRuleText, token) {
        var buffer = text_manipulation_1.createBuffer(currentRuleText);
        if (buffer.getLineCount() > 1) {
            //
            // Case 2: We're given a rule with multiple lines
            //
            var n = buffer.getLineCount();
            for (var i = 0; i < n; i++) {
                var numOfColumns = buffer.getColumnCount(i);
                var tokens = _.times(numOfColumns).map(function () { return token; });
                if (this.tokenTable[line] === undefined) {
                    this.tokenTable[line] = [];
                }
                if (i === (n - 1)) {
                    //
                    // Insert new rules up and before the endRange column.
                    // This is in case there are rules that must be merged
                    // onto an existing line.
                    //
                    for (var j = 0; j < numOfColumns; j++) {
                        this.tokenTable[line].splice(column + j, 0, tokens[j]);
                    }
                }
                else {
                    if (i === 0) {
                        //
                        // If the rule's first line merges with an existing line,
                        // merge the new rules with the exising line.
                        //
                        var previousTokensOnLine = [];
                        for (var j = 0; j < column; j++) {
                            previousTokensOnLine.push(this.tokenTable[i][j]);
                            this.tokenTable[line].splice(0, 1);
                        }
                        this.tokenTable.splice(line++, 0, previousTokensOnLine.concat(tokens));
                    }
                    else {
                        // Insert new line of rules
                        this.tokenTable.splice(line++, 0, tokens);
                    }
                }
            }
        }
        else {
            //
            // Case 1: This rule only ranges on a single line
            //
            if (!this.tokenTable[line]) {
                this.tokenTable = [];
            }
            for (var i = 0; i < buffer.getColumnCount(0); i++) {
                // Insert at starting range column
                this.tokenTable[line].splice(column + i, 0, token);
            }
        }
    };
    TokenTable.prototype.recomputeRanges = function () {
        var startCol = 0;
        var startLine = 0;
        var currentToken;
        var numOfLines = this.tokenTable.length;
        for (var line = 0; line < numOfLines; line++) {
            var numOfColumns = this.tokenTable[line].length;
            for (var col = 0; col <= numOfColumns; col++) {
                var token = this.tokenTable[line][col];
                if (currentToken === undefined && token) {
                    currentToken = token;
                    startCol = col;
                    startLine = line;
                }
                if (currentToken !== token) {
                    if (token === undefined && col === numOfColumns) {
                        if (line !== (numOfLines - 1)) {
                            continue;
                        }
                    }
                    var range = new text_manipulation_1.MutableTextRange([{ column: startCol, line: startLine }, {
                            column: col,
                            line: line
                        }], this.buffer);
                    this.tokenMap.set(currentToken, range);
                    // Start new range
                    startCol = col;
                    startLine = line;
                    currentToken = token;
                }
            }
        }
    };
    return TokenTable;
}());
exports.TokenTable = TokenTable;

},{"lodash":111,"text-manipulation":318,"text-manipulation/dist/buffer/utils":317}],35:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ExprEvaluator = /** @class */ (function () {
    function ExprEvaluator(expr, rule, index, numberOfElement) {
        this.expr = expr;
        this.rule = rule;
        this.index = index;
        this.numberOfElement = numberOfElement;
    }
    ExprEvaluator.prototype.evaluate = function () {
        var functionCall = this.expr.findRuleByName('functionCall');
        var primaryExpr = this.expr.findRuleByName('primaryExpr');
        var step = this.expr.findRuleByName('step');
        if (functionCall) {
            var parts = functionCall.getChildren();
            // const tokens = functionCall.getTokens();
            var name_1 = parts[0].getText();
            switch (name_1) {
                case 'position':
                    return this.index;
            }
        }
        else if (step) {
            var axisSpecifier = step.findRuleByName('axisSpecifier');
            var nameTest = step.findRuleByName('nameTest');
            if (axisSpecifier && axisSpecifier.getText() === '@') {
                var tokenName = nameTest.getText();
                var tokens = this.rule.getTokens(tokenName);
                if (tokens.length > 0) {
                    return tokens[0].getText();
                }
            }
        }
        else if (primaryExpr) {
            var numberTokens = primaryExpr.getTokens('Number');
            if (numberTokens.length > 0) {
                return Number(numberTokens[0].getText());
            }
        }
        return undefined;
    };
    return ExprEvaluator;
}());
exports.ExprEvaluator = ExprEvaluator;

},{}],36:[function(require,module,exports){
// Generated from xpath.g4 by ANTLR 4.7
// jshint ignore: start
var antlr4 = require('antlr4/index');


var serializedATN = ["\u0003\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964",
    "\u0002&\u0197\b\u0001\u0004\u0002\t\u0002\u0004\u0003\t\u0003\u0004",
    "\u0004\t\u0004\u0004\u0005\t\u0005\u0004\u0006\t\u0006\u0004\u0007\t",
    "\u0007\u0004\b\t\b\u0004\t\t\t\u0004\n\t\n\u0004\u000b\t\u000b\u0004",
    "\f\t\f\u0004\r\t\r\u0004\u000e\t\u000e\u0004\u000f\t\u000f\u0004\u0010",
    "\t\u0010\u0004\u0011\t\u0011\u0004\u0012\t\u0012\u0004\u0013\t\u0013",
    "\u0004\u0014\t\u0014\u0004\u0015\t\u0015\u0004\u0016\t\u0016\u0004\u0017",
    "\t\u0017\u0004\u0018\t\u0018\u0004\u0019\t\u0019\u0004\u001a\t\u001a",
    "\u0004\u001b\t\u001b\u0004\u001c\t\u001c\u0004\u001d\t\u001d\u0004\u001e",
    "\t\u001e\u0004\u001f\t\u001f\u0004 \t \u0004!\t!\u0004\"\t\"\u0004#",
    "\t#\u0004$\t$\u0004%\t%\u0004&\t&\u0004\'\t\'\u0004(\t(\u0003\u0002",
    "\u0003\u0002\u0003\u0002\u0003\u0002\u0003\u0002\u0003\u0002\u0003\u0002",
    "\u0003\u0002\u0003\u0002\u0003\u0002\u0003\u0002\u0003\u0002\u0003\u0002",
    "\u0003\u0002\u0003\u0002\u0003\u0002\u0003\u0002\u0003\u0002\u0003\u0002",
    "\u0003\u0002\u0003\u0002\u0003\u0002\u0003\u0002\u0003\u0003\u0003\u0003",
    "\u0003\u0003\u0003\u0004\u0003\u0004\u0003\u0004\u0003\u0004\u0003\u0005",
    "\u0003\u0005\u0003\u0006\u0003\u0006\u0003\u0006\u0003\u0007\u0003\u0007",
    "\u0003\u0007\u0003\u0007\u0003\b\u0003\b\u0003\b\u0003\b\u0003\t\u0003",
    "\t\u0003\n\u0003\n\u0003\n\u0003\n\u0003\n\u0003\n\u0003\n\u0003\n\u0003",
    "\n\u0003\n\u0003\n\u0003\n\u0003\n\u0003\n\u0003\n\u0003\n\u0003\n\u0003",
    "\n\u0003\n\u0003\n\u0003\n\u0003\n\u0003\n\u0003\n\u0003\n\u0003\n\u0003",
    "\n\u0003\n\u0003\n\u0003\n\u0003\n\u0003\n\u0003\n\u0003\n\u0003\n\u0003",
    "\n\u0003\n\u0005\n\u00a4\n\n\u0003\u000b\u0003\u000b\u0003\u000b\u0005",
    "\u000b\u00a9\n\u000b\u0005\u000b\u00ab\n\u000b\u0003\u000b\u0003\u000b",
    "\u0005\u000b\u00af\n\u000b\u0003\f\u0006\f\u00b2\n\f\r\f\u000e\f\u00b3",
    "\u0003\r\u0003\r\u0003\r\u0003\r\u0003\r\u0003\r\u0003\r\u0003\r\u0003",
    "\r\u0003\r\u0003\r\u0003\r\u0003\r\u0003\r\u0003\r\u0003\r\u0003\r\u0003",
    "\r\u0003\r\u0003\r\u0003\r\u0003\r\u0003\r\u0003\r\u0003\r\u0003\r\u0003",
    "\r\u0003\r\u0003\r\u0003\r\u0003\r\u0003\r\u0003\r\u0003\r\u0003\r\u0003",
    "\r\u0003\r\u0003\r\u0003\r\u0003\r\u0003\r\u0003\r\u0003\r\u0003\r\u0003",
    "\r\u0003\r\u0003\r\u0003\r\u0003\r\u0003\r\u0003\r\u0003\r\u0003\r\u0003",
    "\r\u0003\r\u0003\r\u0003\r\u0003\r\u0003\r\u0003\r\u0003\r\u0003\r\u0003",
    "\r\u0003\r\u0003\r\u0003\r\u0003\r\u0003\r\u0003\r\u0003\r\u0003\r\u0003",
    "\r\u0003\r\u0003\r\u0003\r\u0003\r\u0003\r\u0003\r\u0003\r\u0003\r\u0003",
    "\r\u0003\r\u0003\r\u0003\r\u0003\r\u0003\r\u0003\r\u0003\r\u0003\r\u0003",
    "\r\u0003\r\u0003\r\u0003\r\u0003\r\u0003\r\u0003\r\u0003\r\u0003\r\u0003",
    "\r\u0003\r\u0003\r\u0003\r\u0003\r\u0003\r\u0003\r\u0003\r\u0003\r\u0003",
    "\r\u0003\r\u0003\r\u0003\r\u0003\r\u0003\r\u0003\r\u0003\r\u0003\r\u0003",
    "\r\u0003\r\u0003\r\u0003\r\u0003\r\u0003\r\u0003\r\u0003\r\u0003\r\u0003",
    "\r\u0003\r\u0003\r\u0003\r\u0003\r\u0003\r\u0003\r\u0003\r\u0003\r\u0003",
    "\r\u0003\r\u0003\r\u0005\r\u013f\n\r\u0003\u000e\u0003\u000e\u0003\u000f",
    "\u0003\u000f\u0003\u000f\u0003\u0010\u0003\u0010\u0003\u0011\u0003\u0011",
    "\u0003\u0012\u0003\u0012\u0003\u0013\u0003\u0013\u0003\u0014\u0003\u0014",
    "\u0003\u0015\u0003\u0015\u0003\u0016\u0003\u0016\u0003\u0017\u0003\u0017",
    "\u0003\u0018\u0003\u0018\u0003\u0018\u0003\u0019\u0003\u0019\u0003\u001a",
    "\u0003\u001a\u0003\u001b\u0003\u001b\u0003\u001c\u0003\u001c\u0003\u001d",
    "\u0003\u001d\u0003\u001e\u0003\u001e\u0003\u001e\u0003\u001f\u0003\u001f",
    "\u0003\u001f\u0003 \u0003 \u0003!\u0003!\u0003!\u0003\"\u0003\"\u0003",
    "#\u0003#\u0003$\u0003$\u0007$\u0174\n$\f$\u000e$\u0177\u000b$\u0003",
    "$\u0003$\u0003$\u0007$\u017c\n$\f$\u000e$\u017f\u000b$\u0003$\u0005",
    "$\u0182\n$\u0003%\u0006%\u0185\n%\r%\u000e%\u0186\u0003%\u0003%\u0003",
    "&\u0003&\u0007&\u018d\n&\f&\u000e&\u0190\u000b&\u0003\'\u0003\'\u0003",
    "(\u0003(\u0005(\u0196\n(\u0002\u0002)\u0003\u0003\u0005\u0004\u0007",
    "\u0005\t\u0006\u000b\u0007\r\b\u000f\t\u0011\n\u0013\u000b\u0015\f\u0017",
    "\u0002\u0019\r\u001b\u000e\u001d\u000f\u001f\u0010!\u0011#\u0012%\u0013",
    "\'\u0014)\u0015+\u0016-\u0017/\u00181\u00193\u001a5\u001b7\u001c9\u001d",
    ";\u001e=\u001f? A!C\"E#G$I%K&M\u0002O\u0002\u0003\u0002\u0007\u0003",
    "\u0002$$\u0003\u0002))\u0005\u0002\u000b\f\u000f\u000f\"\"\u0010\u0002",
    "C\\aac|\u00c2\u00d8\u00da\u00f8\u00fa\u0301\u0372\u037f\u0381\u2001",
    "\u200e\u200f\u2072\u2191\u2c02\u2ff1\u3003\ud801\uf902\ufdd1\ufdf2\uffff",
    "\u0007\u0002/02;\u00b9\u00b9\u0302\u0371\u2041\u2042\u0002\u01ac\u0002",
    "\u0003\u0003\u0002\u0002\u0002\u0002\u0005\u0003\u0002\u0002\u0002\u0002",
    "\u0007\u0003\u0002\u0002\u0002\u0002\t\u0003\u0002\u0002\u0002\u0002",
    "\u000b\u0003\u0002\u0002\u0002\u0002\r\u0003\u0002\u0002\u0002\u0002",
    "\u000f\u0003\u0002\u0002\u0002\u0002\u0011\u0003\u0002\u0002\u0002\u0002",
    "\u0013\u0003\u0002\u0002\u0002\u0002\u0015\u0003\u0002\u0002\u0002\u0002",
    "\u0019\u0003\u0002\u0002\u0002\u0002\u001b\u0003\u0002\u0002\u0002\u0002",
    "\u001d\u0003\u0002\u0002\u0002\u0002\u001f\u0003\u0002\u0002\u0002\u0002",
    "!\u0003\u0002\u0002\u0002\u0002#\u0003\u0002\u0002\u0002\u0002%\u0003",
    "\u0002\u0002\u0002\u0002\'\u0003\u0002\u0002\u0002\u0002)\u0003\u0002",
    "\u0002\u0002\u0002+\u0003\u0002\u0002\u0002\u0002-\u0003\u0002\u0002",
    "\u0002\u0002/\u0003\u0002\u0002\u0002\u00021\u0003\u0002\u0002\u0002",
    "\u00023\u0003\u0002\u0002\u0002\u00025\u0003\u0002\u0002\u0002\u0002",
    "7\u0003\u0002\u0002\u0002\u00029\u0003\u0002\u0002\u0002\u0002;\u0003",
    "\u0002\u0002\u0002\u0002=\u0003\u0002\u0002\u0002\u0002?\u0003\u0002",
    "\u0002\u0002\u0002A\u0003\u0002\u0002\u0002\u0002C\u0003\u0002\u0002",
    "\u0002\u0002E\u0003\u0002\u0002\u0002\u0002G\u0003\u0002\u0002\u0002",
    "\u0002I\u0003\u0002\u0002\u0002\u0002K\u0003\u0002\u0002\u0002\u0003",
    "Q\u0003\u0002\u0002\u0002\u0005h\u0003\u0002\u0002\u0002\u0007k\u0003",
    "\u0002\u0002\u0002\to\u0003\u0002\u0002\u0002\u000bq\u0003\u0002\u0002",
    "\u0002\rt\u0003\u0002\u0002\u0002\u000fx\u0003\u0002\u0002\u0002\u0011",
    "|\u0003\u0002\u0002\u0002\u0013\u00a3\u0003\u0002\u0002\u0002\u0015",
    "\u00ae\u0003\u0002\u0002\u0002\u0017\u00b1\u0003\u0002\u0002\u0002\u0019",
    "\u013e\u0003\u0002\u0002\u0002\u001b\u0140\u0003\u0002\u0002\u0002\u001d",
    "\u0142\u0003\u0002\u0002\u0002\u001f\u0145\u0003\u0002\u0002\u0002!",
    "\u0147\u0003\u0002\u0002\u0002#\u0149\u0003\u0002\u0002\u0002%\u014b",
    "\u0003\u0002\u0002\u0002\'\u014d\u0003\u0002\u0002\u0002)\u014f\u0003",
    "\u0002\u0002\u0002+\u0151\u0003\u0002\u0002\u0002-\u0153\u0003\u0002",
    "\u0002\u0002/\u0155\u0003\u0002\u0002\u00021\u0158\u0003\u0002\u0002",
    "\u00023\u015a\u0003\u0002\u0002\u00025\u015c\u0003\u0002\u0002\u0002",
    "7\u015e\u0003\u0002\u0002\u00029\u0160\u0003\u0002\u0002\u0002;\u0162",
    "\u0003\u0002\u0002\u0002=\u0165\u0003\u0002\u0002\u0002?\u0168\u0003",
    "\u0002\u0002\u0002A\u016a\u0003\u0002\u0002\u0002C\u016d\u0003\u0002",
    "\u0002\u0002E\u016f\u0003\u0002\u0002\u0002G\u0181\u0003\u0002\u0002",
    "\u0002I\u0184\u0003\u0002\u0002\u0002K\u018a\u0003\u0002\u0002\u0002",
    "M\u0191\u0003\u0002\u0002\u0002O\u0195\u0003\u0002\u0002\u0002QR\u0007",
    "r\u0002\u0002RS\u0007t\u0002\u0002ST\u0007q\u0002\u0002TU\u0007e\u0002",
    "\u0002UV\u0007g\u0002\u0002VW\u0007u\u0002\u0002WX\u0007u\u0002\u0002",
    "XY\u0007k\u0002\u0002YZ\u0007p\u0002\u0002Z[\u0007i\u0002\u0002[\\\u0007",
    "/\u0002\u0002\\]\u0007k\u0002\u0002]^\u0007p\u0002\u0002^_\u0007u\u0002",
    "\u0002_`\u0007v\u0002\u0002`a\u0007t\u0002\u0002ab\u0007w\u0002\u0002",
    "bc\u0007e\u0002\u0002cd\u0007v\u0002\u0002de\u0007k\u0002\u0002ef\u0007",
    "q\u0002\u0002fg\u0007p\u0002\u0002g\u0004\u0003\u0002\u0002\u0002hi",
    "\u0007q\u0002\u0002ij\u0007t\u0002\u0002j\u0006\u0003\u0002\u0002\u0002",
    "kl\u0007c\u0002\u0002lm\u0007p\u0002\u0002mn\u0007f\u0002\u0002n\b\u0003",
    "\u0002\u0002\u0002op\u0007?\u0002\u0002p\n\u0003\u0002\u0002\u0002q",
    "r\u0007#\u0002\u0002rs\u0007?\u0002\u0002s\f\u0003\u0002\u0002\u0002",
    "tu\u0007f\u0002\u0002uv\u0007k\u0002\u0002vw\u0007x\u0002\u0002w\u000e",
    "\u0003\u0002\u0002\u0002xy\u0007o\u0002\u0002yz\u0007q\u0002\u0002z",
    "{\u0007f\u0002\u0002{\u0010\u0003\u0002\u0002\u0002|}\u0007&\u0002\u0002",
    "}\u0012\u0003\u0002\u0002\u0002~\u007f\u0007e\u0002\u0002\u007f\u0080",
    "\u0007q\u0002\u0002\u0080\u0081\u0007o\u0002\u0002\u0081\u0082\u0007",
    "o\u0002\u0002\u0082\u0083\u0007g\u0002\u0002\u0083\u0084\u0007p\u0002",
    "\u0002\u0084\u00a4\u0007v\u0002\u0002\u0085\u0086\u0007v\u0002\u0002",
    "\u0086\u0087\u0007g\u0002\u0002\u0087\u0088\u0007z\u0002\u0002\u0088",
    "\u00a4\u0007v\u0002\u0002\u0089\u008a\u0007r\u0002\u0002\u008a\u008b",
    "\u0007t\u0002\u0002\u008b\u008c\u0007q\u0002\u0002\u008c\u008d\u0007",
    "e\u0002\u0002\u008d\u008e\u0007g\u0002\u0002\u008e\u008f\u0007u\u0002",
    "\u0002\u008f\u0090\u0007u\u0002\u0002\u0090\u0091\u0007k\u0002\u0002",
    "\u0091\u0092\u0007p\u0002\u0002\u0092\u0093\u0007i\u0002\u0002\u0093",
    "\u0094\u0007/\u0002\u0002\u0094\u0095\u0007k\u0002\u0002\u0095\u0096",
    "\u0007p\u0002\u0002\u0096\u0097\u0007u\u0002\u0002\u0097\u0098\u0007",
    "v\u0002\u0002\u0098\u0099\u0007t\u0002\u0002\u0099\u009a\u0007w\u0002",
    "\u0002\u009a\u009b\u0007e\u0002\u0002\u009b\u009c\u0007v\u0002\u0002",
    "\u009c\u009d\u0007k\u0002\u0002\u009d\u009e\u0007q\u0002\u0002\u009e",
    "\u00a4\u0007p\u0002\u0002\u009f\u00a0\u0007p\u0002\u0002\u00a0\u00a1",
    "\u0007q\u0002\u0002\u00a1\u00a2\u0007f\u0002\u0002\u00a2\u00a4\u0007",
    "g\u0002\u0002\u00a3~\u0003\u0002\u0002\u0002\u00a3\u0085\u0003\u0002",
    "\u0002\u0002\u00a3\u0089\u0003\u0002\u0002\u0002\u00a3\u009f\u0003\u0002",
    "\u0002\u0002\u00a4\u0014\u0003\u0002\u0002\u0002\u00a5\u00aa\u0005\u0017",
    "\f\u0002\u00a6\u00a8\u00070\u0002\u0002\u00a7\u00a9\u0005\u0017\f\u0002",
    "\u00a8\u00a7\u0003\u0002\u0002\u0002\u00a8\u00a9\u0003\u0002\u0002\u0002",
    "\u00a9\u00ab\u0003\u0002\u0002\u0002\u00aa\u00a6\u0003\u0002\u0002\u0002",
    "\u00aa\u00ab\u0003\u0002\u0002\u0002\u00ab\u00af\u0003\u0002\u0002\u0002",
    "\u00ac\u00ad\u00070\u0002\u0002\u00ad\u00af\u0005\u0017\f\u0002\u00ae",
    "\u00a5\u0003\u0002\u0002\u0002\u00ae\u00ac\u0003\u0002\u0002\u0002\u00af",
    "\u0016\u0003\u0002\u0002\u0002\u00b0\u00b2\u00042;\u0002\u00b1\u00b0",
    "\u0003\u0002\u0002\u0002\u00b2\u00b3\u0003\u0002\u0002\u0002\u00b3\u00b1",
    "\u0003\u0002\u0002\u0002\u00b3\u00b4\u0003\u0002\u0002\u0002\u00b4\u0018",
    "\u0003\u0002\u0002\u0002\u00b5\u00b6\u0007c\u0002\u0002\u00b6\u00b7",
    "\u0007p\u0002\u0002\u00b7\u00b8\u0007e\u0002\u0002\u00b8\u00b9\u0007",
    "g\u0002\u0002\u00b9\u00ba\u0007u\u0002\u0002\u00ba\u00bb\u0007v\u0002",
    "\u0002\u00bb\u00bc\u0007q\u0002\u0002\u00bc\u013f\u0007t\u0002\u0002",
    "\u00bd\u00be\u0007c\u0002\u0002\u00be\u00bf\u0007p\u0002\u0002\u00bf",
    "\u00c0\u0007e\u0002\u0002\u00c0\u00c1\u0007g\u0002\u0002\u00c1\u00c2",
    "\u0007u\u0002\u0002\u00c2\u00c3\u0007v\u0002\u0002\u00c3\u00c4\u0007",
    "q\u0002\u0002\u00c4\u00c5\u0007t\u0002\u0002\u00c5\u00c6\u0007/\u0002",
    "\u0002\u00c6\u00c7\u0007q\u0002\u0002\u00c7\u00c8\u0007t\u0002\u0002",
    "\u00c8\u00c9\u0007/\u0002\u0002\u00c9\u00ca\u0007u\u0002\u0002\u00ca",
    "\u00cb\u0007g\u0002\u0002\u00cb\u00cc\u0007n\u0002\u0002\u00cc\u013f",
    "\u0007h\u0002\u0002\u00cd\u00ce\u0007c\u0002\u0002\u00ce\u00cf\u0007",
    "v\u0002\u0002\u00cf\u00d0\u0007v\u0002\u0002\u00d0\u00d1\u0007t\u0002",
    "\u0002\u00d1\u00d2\u0007k\u0002\u0002\u00d2\u00d3\u0007d\u0002\u0002",
    "\u00d3\u00d4\u0007w\u0002\u0002\u00d4\u00d5\u0007v\u0002\u0002\u00d5",
    "\u013f\u0007g\u0002\u0002\u00d6\u00d7\u0007e\u0002\u0002\u00d7\u00d8",
    "\u0007j\u0002\u0002\u00d8\u00d9\u0007k\u0002\u0002\u00d9\u00da\u0007",
    "n\u0002\u0002\u00da\u013f\u0007f\u0002\u0002\u00db\u00dc\u0007f\u0002",
    "\u0002\u00dc\u00dd\u0007g\u0002\u0002\u00dd\u00de\u0007u\u0002\u0002",
    "\u00de\u00df\u0007e\u0002\u0002\u00df\u00e0\u0007g\u0002\u0002\u00e0",
    "\u00e1\u0007p\u0002\u0002\u00e1\u00e2\u0007f\u0002\u0002\u00e2\u00e3",
    "\u0007c\u0002\u0002\u00e3\u00e4\u0007p\u0002\u0002\u00e4\u013f\u0007",
    "v\u0002\u0002\u00e5\u00e6\u0007f\u0002\u0002\u00e6\u00e7\u0007g\u0002",
    "\u0002\u00e7\u00e8\u0007u\u0002\u0002\u00e8\u00e9\u0007e\u0002\u0002",
    "\u00e9\u00ea\u0007g\u0002\u0002\u00ea\u00eb\u0007p\u0002\u0002\u00eb",
    "\u00ec\u0007f\u0002\u0002\u00ec\u00ed\u0007c\u0002\u0002\u00ed\u00ee",
    "\u0007p\u0002\u0002\u00ee\u00ef\u0007v\u0002\u0002\u00ef\u00f0\u0007",
    "/\u0002\u0002\u00f0\u00f1\u0007q\u0002\u0002\u00f1\u00f2\u0007t\u0002",
    "\u0002\u00f2\u00f3\u0007/\u0002\u0002\u00f3\u00f4\u0007u\u0002\u0002",
    "\u00f4\u00f5\u0007g\u0002\u0002\u00f5\u00f6\u0007n\u0002\u0002\u00f6",
    "\u013f\u0007h\u0002\u0002\u00f7\u00f8\u0007h\u0002\u0002\u00f8\u00f9",
    "\u0007q\u0002\u0002\u00f9\u00fa\u0007n\u0002\u0002\u00fa\u00fb\u0007",
    "n\u0002\u0002\u00fb\u00fc\u0007q\u0002\u0002\u00fc\u00fd\u0007y\u0002",
    "\u0002\u00fd\u00fe\u0007k\u0002\u0002\u00fe\u00ff\u0007p\u0002\u0002",
    "\u00ff\u013f\u0007i\u0002\u0002\u0100\u0101\u0007h\u0002\u0002\u0101",
    "\u0102\u0007q\u0002\u0002\u0102\u0103\u0007n\u0002\u0002\u0103\u0104",
    "\u0007n\u0002\u0002\u0104\u0105\u0007q\u0002\u0002\u0105\u0106\u0007",
    "y\u0002\u0002\u0106\u0107\u0007k\u0002\u0002\u0107\u0108\u0007p\u0002",
    "\u0002\u0108\u0109\u0007i\u0002\u0002\u0109\u010a\u0007/\u0002\u0002",
    "\u010a\u010b\u0007u\u0002\u0002\u010b\u010c\u0007k\u0002\u0002\u010c",
    "\u010d\u0007d\u0002\u0002\u010d\u010e\u0007n\u0002\u0002\u010e\u010f",
    "\u0007k\u0002\u0002\u010f\u0110\u0007p\u0002\u0002\u0110\u013f\u0007",
    "i\u0002\u0002\u0111\u0112\u0007p\u0002\u0002\u0112\u0113\u0007c\u0002",
    "\u0002\u0113\u0114\u0007o\u0002\u0002\u0114\u0115\u0007g\u0002\u0002",
    "\u0115\u0116\u0007u\u0002\u0002\u0116\u0117\u0007r\u0002\u0002\u0117",
    "\u0118\u0007c\u0002\u0002\u0118\u0119\u0007e\u0002\u0002\u0119\u013f",
    "\u0007g\u0002\u0002\u011a\u011b\u0007r\u0002\u0002\u011b\u011c\u0007",
    "c\u0002\u0002\u011c\u011d\u0007t\u0002\u0002\u011d\u011e\u0007g\u0002",
    "\u0002\u011e\u011f\u0007p\u0002\u0002\u011f\u013f\u0007v\u0002\u0002",
    "\u0120\u0121\u0007r\u0002\u0002\u0121\u0122\u0007t\u0002\u0002\u0122",
    "\u0123\u0007g\u0002\u0002\u0123\u0124\u0007e\u0002\u0002\u0124\u0125",
    "\u0007g\u0002\u0002\u0125\u0126\u0007f\u0002\u0002\u0126\u0127\u0007",
    "k\u0002\u0002\u0127\u0128\u0007p\u0002\u0002\u0128\u013f\u0007i\u0002",
    "\u0002\u0129\u012a\u0007r\u0002\u0002\u012a\u012b\u0007t\u0002\u0002",
    "\u012b\u012c\u0007g\u0002\u0002\u012c\u012d\u0007e\u0002\u0002\u012d",
    "\u012e\u0007g\u0002\u0002\u012e\u012f\u0007f\u0002\u0002\u012f\u0130",
    "\u0007k\u0002\u0002\u0130\u0131\u0007p\u0002\u0002\u0131\u0132\u0007",
    "i\u0002\u0002\u0132\u0133\u0007/\u0002\u0002\u0133\u0134\u0007u\u0002",
    "\u0002\u0134\u0135\u0007k\u0002\u0002\u0135\u0136\u0007d\u0002\u0002",
    "\u0136\u0137\u0007n\u0002\u0002\u0137\u0138\u0007k\u0002\u0002\u0138",
    "\u0139\u0007p\u0002\u0002\u0139\u013f\u0007i\u0002\u0002\u013a\u013b",
    "\u0007u\u0002\u0002\u013b\u013c\u0007g\u0002\u0002\u013c\u013d\u0007",
    "n\u0002\u0002\u013d\u013f\u0007h\u0002\u0002\u013e\u00b5\u0003\u0002",
    "\u0002\u0002\u013e\u00bd\u0003\u0002\u0002\u0002\u013e\u00cd\u0003\u0002",
    "\u0002\u0002\u013e\u00d6\u0003\u0002\u0002\u0002\u013e\u00db\u0003\u0002",
    "\u0002\u0002\u013e\u00e5\u0003\u0002\u0002\u0002\u013e\u00f7\u0003\u0002",
    "\u0002\u0002\u013e\u0100\u0003\u0002\u0002\u0002\u013e\u0111\u0003\u0002",
    "\u0002\u0002\u013e\u011a\u0003\u0002\u0002\u0002\u013e\u0120\u0003\u0002",
    "\u0002\u0002\u013e\u0129\u0003\u0002\u0002\u0002\u013e\u013a\u0003\u0002",
    "\u0002\u0002\u013f\u001a\u0003\u0002\u0002\u0002\u0140\u0141\u00071",
    "\u0002\u0002\u0141\u001c\u0003\u0002\u0002\u0002\u0142\u0143\u00071",
    "\u0002\u0002\u0143\u0144\u00071\u0002\u0002\u0144\u001e\u0003\u0002",
    "\u0002\u0002\u0145\u0146\u0007*\u0002\u0002\u0146 \u0003\u0002\u0002",
    "\u0002\u0147\u0148\u0007+\u0002\u0002\u0148\"\u0003\u0002\u0002\u0002",
    "\u0149\u014a\u0007]\u0002\u0002\u014a$\u0003\u0002\u0002\u0002\u014b",
    "\u014c\u0007_\u0002\u0002\u014c&\u0003\u0002\u0002\u0002\u014d\u014e",
    "\u0007/\u0002\u0002\u014e(\u0003\u0002\u0002\u0002\u014f\u0150\u0007",
    "-\u0002\u0002\u0150*\u0003\u0002\u0002\u0002\u0151\u0152\u00070\u0002",
    "\u0002\u0152,\u0003\u0002\u0002\u0002\u0153\u0154\u0007,\u0002\u0002",
    "\u0154.\u0003\u0002\u0002\u0002\u0155\u0156\u00070\u0002\u0002\u0156",
    "\u0157\u00070\u0002\u0002\u01570\u0003\u0002\u0002\u0002\u0158\u0159",
    "\u0007B\u0002\u0002\u01592\u0003\u0002\u0002\u0002\u015a\u015b\u0007",
    ".\u0002\u0002\u015b4\u0003\u0002\u0002\u0002\u015c\u015d\u0007~\u0002",
    "\u0002\u015d6\u0003\u0002\u0002\u0002\u015e\u015f\u0007>\u0002\u0002",
    "\u015f8\u0003\u0002\u0002\u0002\u0160\u0161\u0007@\u0002\u0002\u0161",
    ":\u0003\u0002\u0002\u0002\u0162\u0163\u0007>\u0002\u0002\u0163\u0164",
    "\u0007?\u0002\u0002\u0164<\u0003\u0002\u0002\u0002\u0165\u0166\u0007",
    "@\u0002\u0002\u0166\u0167\u0007?\u0002\u0002\u0167>\u0003\u0002\u0002",
    "\u0002\u0168\u0169\u0007<\u0002\u0002\u0169@\u0003\u0002\u0002\u0002",
    "\u016a\u016b\u0007<\u0002\u0002\u016b\u016c\u0007<\u0002\u0002\u016c",
    "B\u0003\u0002\u0002\u0002\u016d\u016e\u0007)\u0002\u0002\u016eD\u0003",
    "\u0002\u0002\u0002\u016f\u0170\u0007$\u0002\u0002\u0170F\u0003\u0002",
    "\u0002\u0002\u0171\u0175\u0007$\u0002\u0002\u0172\u0174\n\u0002\u0002",
    "\u0002\u0173\u0172\u0003\u0002\u0002\u0002\u0174\u0177\u0003\u0002\u0002",
    "\u0002\u0175\u0173\u0003\u0002\u0002\u0002\u0175\u0176\u0003\u0002\u0002",
    "\u0002\u0176\u0178\u0003\u0002\u0002\u0002\u0177\u0175\u0003\u0002\u0002",
    "\u0002\u0178\u0182\u0007$\u0002\u0002\u0179\u017d\u0007)\u0002\u0002",
    "\u017a\u017c\n\u0003\u0002\u0002\u017b\u017a\u0003\u0002\u0002\u0002",
    "\u017c\u017f\u0003\u0002\u0002\u0002\u017d\u017b\u0003\u0002\u0002\u0002",
    "\u017d\u017e\u0003\u0002\u0002\u0002\u017e\u0180\u0003\u0002\u0002\u0002",
    "\u017f\u017d\u0003\u0002\u0002\u0002\u0180\u0182\u0007)\u0002\u0002",
    "\u0181\u0171\u0003\u0002\u0002\u0002\u0181\u0179\u0003\u0002\u0002\u0002",
    "\u0182H\u0003\u0002\u0002\u0002\u0183\u0185\t\u0004\u0002\u0002\u0184",
    "\u0183\u0003\u0002\u0002\u0002\u0185\u0186\u0003\u0002\u0002\u0002\u0186",
    "\u0184\u0003\u0002\u0002\u0002\u0186\u0187\u0003\u0002\u0002\u0002\u0187",
    "\u0188\u0003\u0002\u0002\u0002\u0188\u0189\b%\u0002\u0002\u0189J\u0003",
    "\u0002\u0002\u0002\u018a\u018e\u0005M\'\u0002\u018b\u018d\u0005O(\u0002",
    "\u018c\u018b\u0003\u0002\u0002\u0002\u018d\u0190\u0003\u0002\u0002\u0002",
    "\u018e\u018c\u0003\u0002\u0002\u0002\u018e\u018f\u0003\u0002\u0002\u0002",
    "\u018fL\u0003\u0002\u0002\u0002\u0190\u018e\u0003\u0002\u0002\u0002",
    "\u0191\u0192\t\u0005\u0002\u0002\u0192N\u0003\u0002\u0002\u0002\u0193",
    "\u0196\u0005M\'\u0002\u0194\u0196\t\u0006\u0002\u0002\u0195\u0193\u0003",
    "\u0002\u0002\u0002\u0195\u0194\u0003\u0002\u0002\u0002\u0196P\u0003",
    "\u0002\u0002\u0002\u000f\u0002\u00a3\u00a8\u00aa\u00ae\u00b3\u013e\u0175",
    "\u017d\u0181\u0186\u018e\u0195\u0003\b\u0002\u0002"].join("");


var atn = new antlr4.atn.ATNDeserializer().deserialize(serializedATN);

var decisionsToDFA = atn.decisionToState.map( function(ds, index) { return new antlr4.dfa.DFA(ds, index); });

function xpathLexer(input) {
	antlr4.Lexer.call(this, input);
    this._interp = new antlr4.atn.LexerATNSimulator(this, atn, decisionsToDFA, new antlr4.PredictionContextCache());
    return this;
}

xpathLexer.prototype = Object.create(antlr4.Lexer.prototype);
xpathLexer.prototype.constructor = xpathLexer;

xpathLexer.EOF = antlr4.Token.EOF;
xpathLexer.T__0 = 1;
xpathLexer.T__1 = 2;
xpathLexer.T__2 = 3;
xpathLexer.T__3 = 4;
xpathLexer.T__4 = 5;
xpathLexer.T__5 = 6;
xpathLexer.T__6 = 7;
xpathLexer.T__7 = 8;
xpathLexer.NodeType = 9;
xpathLexer.Number = 10;
xpathLexer.AxisName = 11;
xpathLexer.PATHSEP = 12;
xpathLexer.ABRPATH = 13;
xpathLexer.LPAR = 14;
xpathLexer.RPAR = 15;
xpathLexer.LBRAC = 16;
xpathLexer.RBRAC = 17;
xpathLexer.MINUS = 18;
xpathLexer.PLUS = 19;
xpathLexer.DOT = 20;
xpathLexer.MUL = 21;
xpathLexer.DOTDOT = 22;
xpathLexer.AT = 23;
xpathLexer.COMMA = 24;
xpathLexer.PIPE = 25;
xpathLexer.LESS = 26;
xpathLexer.MORE_ = 27;
xpathLexer.LE = 28;
xpathLexer.GE = 29;
xpathLexer.COLON = 30;
xpathLexer.CC = 31;
xpathLexer.APOS = 32;
xpathLexer.QUOT = 33;
xpathLexer.Literal = 34;
xpathLexer.Whitespace = 35;
xpathLexer.NCName = 36;

xpathLexer.prototype.channelNames = [ "DEFAULT_TOKEN_CHANNEL", "HIDDEN" ];

xpathLexer.prototype.modeNames = [ "DEFAULT_MODE" ];

xpathLexer.prototype.literalNames = [ null, "'processing-instruction'", 
                                      "'or'", "'and'", "'='", "'!='", "'div'", 
                                      "'mod'", "'$'", null, null, null, 
                                      "'/'", "'//'", "'('", "')'", "'['", 
                                      "']'", "'-'", "'+'", "'.'", "'*'", 
                                      "'..'", "'@'", "','", "'|'", "'<'", 
                                      "'>'", "'<='", "'>='", "':'", "'::'", 
                                      "'''", "'\"'" ];

xpathLexer.prototype.symbolicNames = [ null, null, null, null, null, null, 
                                       null, null, null, "NodeType", "Number", 
                                       "AxisName", "PATHSEP", "ABRPATH", 
                                       "LPAR", "RPAR", "LBRAC", "RBRAC", 
                                       "MINUS", "PLUS", "DOT", "MUL", "DOTDOT", 
                                       "AT", "COMMA", "PIPE", "LESS", "MORE_", 
                                       "LE", "GE", "COLON", "CC", "APOS", 
                                       "QUOT", "Literal", "Whitespace", 
                                       "NCName" ];

xpathLexer.prototype.ruleNames = [ "T__0", "T__1", "T__2", "T__3", "T__4", 
                                   "T__5", "T__6", "T__7", "NodeType", "Number", 
                                   "Digits", "AxisName", "PATHSEP", "ABRPATH", 
                                   "LPAR", "RPAR", "LBRAC", "RBRAC", "MINUS", 
                                   "PLUS", "DOT", "MUL", "DOTDOT", "AT", 
                                   "COMMA", "PIPE", "LESS", "MORE_", "LE", 
                                   "GE", "COLON", "CC", "APOS", "QUOT", 
                                   "Literal", "Whitespace", "NCName", "NCNameStartChar", 
                                   "NCNameChar" ];

xpathLexer.prototype.grammarFileName = "xpath.g4";



exports.xpathLexer = xpathLexer;


},{"antlr4/index":84}],37:[function(require,module,exports){
// Generated from xpath.g4 by ANTLR 4.7
// jshint ignore: start
var antlr4 = require('antlr4/index');

// This class defines a complete listener for a parse tree produced by xpathParser.
function xpathListener() {
	antlr4.tree.ParseTreeListener.call(this);
	return this;
}

xpathListener.prototype = Object.create(antlr4.tree.ParseTreeListener.prototype);
xpathListener.prototype.constructor = xpathListener;

// Enter a parse tree produced by xpathParser#main.
xpathListener.prototype.enterMain = function(ctx) {
};

// Exit a parse tree produced by xpathParser#main.
xpathListener.prototype.exitMain = function(ctx) {
};


// Enter a parse tree produced by xpathParser#locationPath.
xpathListener.prototype.enterLocationPath = function(ctx) {
};

// Exit a parse tree produced by xpathParser#locationPath.
xpathListener.prototype.exitLocationPath = function(ctx) {
};


// Enter a parse tree produced by xpathParser#absoluteLocationPathNoroot.
xpathListener.prototype.enterAbsoluteLocationPathNoroot = function(ctx) {
};

// Exit a parse tree produced by xpathParser#absoluteLocationPathNoroot.
xpathListener.prototype.exitAbsoluteLocationPathNoroot = function(ctx) {
};


// Enter a parse tree produced by xpathParser#relativeLocationPath.
xpathListener.prototype.enterRelativeLocationPath = function(ctx) {
};

// Exit a parse tree produced by xpathParser#relativeLocationPath.
xpathListener.prototype.exitRelativeLocationPath = function(ctx) {
};


// Enter a parse tree produced by xpathParser#step.
xpathListener.prototype.enterStep = function(ctx) {
};

// Exit a parse tree produced by xpathParser#step.
xpathListener.prototype.exitStep = function(ctx) {
};


// Enter a parse tree produced by xpathParser#axisSpecifier.
xpathListener.prototype.enterAxisSpecifier = function(ctx) {
};

// Exit a parse tree produced by xpathParser#axisSpecifier.
xpathListener.prototype.exitAxisSpecifier = function(ctx) {
};


// Enter a parse tree produced by xpathParser#nodeTest.
xpathListener.prototype.enterNodeTest = function(ctx) {
};

// Exit a parse tree produced by xpathParser#nodeTest.
xpathListener.prototype.exitNodeTest = function(ctx) {
};


// Enter a parse tree produced by xpathParser#predicate.
xpathListener.prototype.enterPredicate = function(ctx) {
};

// Exit a parse tree produced by xpathParser#predicate.
xpathListener.prototype.exitPredicate = function(ctx) {
};


// Enter a parse tree produced by xpathParser#abbreviatedStep.
xpathListener.prototype.enterAbbreviatedStep = function(ctx) {
};

// Exit a parse tree produced by xpathParser#abbreviatedStep.
xpathListener.prototype.exitAbbreviatedStep = function(ctx) {
};


// Enter a parse tree produced by xpathParser#expr.
xpathListener.prototype.enterExpr = function(ctx) {
};

// Exit a parse tree produced by xpathParser#expr.
xpathListener.prototype.exitExpr = function(ctx) {
};


// Enter a parse tree produced by xpathParser#primaryExpr.
xpathListener.prototype.enterPrimaryExpr = function(ctx) {
};

// Exit a parse tree produced by xpathParser#primaryExpr.
xpathListener.prototype.exitPrimaryExpr = function(ctx) {
};


// Enter a parse tree produced by xpathParser#functionCall.
xpathListener.prototype.enterFunctionCall = function(ctx) {
};

// Exit a parse tree produced by xpathParser#functionCall.
xpathListener.prototype.exitFunctionCall = function(ctx) {
};


// Enter a parse tree produced by xpathParser#unionExprNoRoot.
xpathListener.prototype.enterUnionExprNoRoot = function(ctx) {
};

// Exit a parse tree produced by xpathParser#unionExprNoRoot.
xpathListener.prototype.exitUnionExprNoRoot = function(ctx) {
};


// Enter a parse tree produced by xpathParser#pathExprNoRoot.
xpathListener.prototype.enterPathExprNoRoot = function(ctx) {
};

// Exit a parse tree produced by xpathParser#pathExprNoRoot.
xpathListener.prototype.exitPathExprNoRoot = function(ctx) {
};


// Enter a parse tree produced by xpathParser#filterExpr.
xpathListener.prototype.enterFilterExpr = function(ctx) {
};

// Exit a parse tree produced by xpathParser#filterExpr.
xpathListener.prototype.exitFilterExpr = function(ctx) {
};


// Enter a parse tree produced by xpathParser#orExpr.
xpathListener.prototype.enterOrExpr = function(ctx) {
};

// Exit a parse tree produced by xpathParser#orExpr.
xpathListener.prototype.exitOrExpr = function(ctx) {
};


// Enter a parse tree produced by xpathParser#andExpr.
xpathListener.prototype.enterAndExpr = function(ctx) {
};

// Exit a parse tree produced by xpathParser#andExpr.
xpathListener.prototype.exitAndExpr = function(ctx) {
};


// Enter a parse tree produced by xpathParser#equalityExpr.
xpathListener.prototype.enterEqualityExpr = function(ctx) {
};

// Exit a parse tree produced by xpathParser#equalityExpr.
xpathListener.prototype.exitEqualityExpr = function(ctx) {
};


// Enter a parse tree produced by xpathParser#relationalExpr.
xpathListener.prototype.enterRelationalExpr = function(ctx) {
};

// Exit a parse tree produced by xpathParser#relationalExpr.
xpathListener.prototype.exitRelationalExpr = function(ctx) {
};


// Enter a parse tree produced by xpathParser#additiveExpr.
xpathListener.prototype.enterAdditiveExpr = function(ctx) {
};

// Exit a parse tree produced by xpathParser#additiveExpr.
xpathListener.prototype.exitAdditiveExpr = function(ctx) {
};


// Enter a parse tree produced by xpathParser#multiplicativeExpr.
xpathListener.prototype.enterMultiplicativeExpr = function(ctx) {
};

// Exit a parse tree produced by xpathParser#multiplicativeExpr.
xpathListener.prototype.exitMultiplicativeExpr = function(ctx) {
};


// Enter a parse tree produced by xpathParser#unaryExprNoRoot.
xpathListener.prototype.enterUnaryExprNoRoot = function(ctx) {
};

// Exit a parse tree produced by xpathParser#unaryExprNoRoot.
xpathListener.prototype.exitUnaryExprNoRoot = function(ctx) {
};


// Enter a parse tree produced by xpathParser#qName.
xpathListener.prototype.enterQName = function(ctx) {
};

// Exit a parse tree produced by xpathParser#qName.
xpathListener.prototype.exitQName = function(ctx) {
};


// Enter a parse tree produced by xpathParser#functionName.
xpathListener.prototype.enterFunctionName = function(ctx) {
};

// Exit a parse tree produced by xpathParser#functionName.
xpathListener.prototype.exitFunctionName = function(ctx) {
};


// Enter a parse tree produced by xpathParser#variableReference.
xpathListener.prototype.enterVariableReference = function(ctx) {
};

// Exit a parse tree produced by xpathParser#variableReference.
xpathListener.prototype.exitVariableReference = function(ctx) {
};


// Enter a parse tree produced by xpathParser#nameTest.
xpathListener.prototype.enterNameTest = function(ctx) {
};

// Exit a parse tree produced by xpathParser#nameTest.
xpathListener.prototype.exitNameTest = function(ctx) {
};


// Enter a parse tree produced by xpathParser#nCName.
xpathListener.prototype.enterNCName = function(ctx) {
};

// Exit a parse tree produced by xpathParser#nCName.
xpathListener.prototype.exitNCName = function(ctx) {
};



exports.xpathListener = xpathListener;
},{"antlr4/index":84}],38:[function(require,module,exports){
// Generated from xpath.g4 by ANTLR 4.7
// jshint ignore: start
var antlr4 = require('antlr4/index');
var xpathListener = require('./xpathListener').xpathListener;
var xpathVisitor = require('./xpathVisitor').xpathVisitor;

var grammarFileName = "xpath.g4";

var serializedATN = ["\u0003\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964",
    "\u0003&\u00f9\u0004\u0002\t\u0002\u0004\u0003\t\u0003\u0004\u0004\t",
    "\u0004\u0004\u0005\t\u0005\u0004\u0006\t\u0006\u0004\u0007\t\u0007\u0004",
    "\b\t\b\u0004\t\t\t\u0004\n\t\n\u0004\u000b\t\u000b\u0004\f\t\f\u0004",
    "\r\t\r\u0004\u000e\t\u000e\u0004\u000f\t\u000f\u0004\u0010\t\u0010\u0004",
    "\u0011\t\u0011\u0004\u0012\t\u0012\u0004\u0013\t\u0013\u0004\u0014\t",
    "\u0014\u0004\u0015\t\u0015\u0004\u0016\t\u0016\u0004\u0017\t\u0017\u0004",
    "\u0018\t\u0018\u0004\u0019\t\u0019\u0004\u001a\t\u001a\u0004\u001b\t",
    "\u001b\u0004\u001c\t\u001c\u0003\u0002\u0003\u0002\u0003\u0003\u0003",
    "\u0003\u0005\u0003=\n\u0003\u0003\u0004\u0003\u0004\u0003\u0004\u0003",
    "\u0004\u0005\u0004C\n\u0004\u0003\u0005\u0003\u0005\u0003\u0005\u0007",
    "\u0005H\n\u0005\f\u0005\u000e\u0005K\u000b\u0005\u0003\u0006\u0003\u0006",
    "\u0003\u0006\u0007\u0006P\n\u0006\f\u0006\u000e\u0006S\u000b\u0006\u0003",
    "\u0006\u0005\u0006V\n\u0006\u0003\u0007\u0003\u0007\u0003\u0007\u0005",
    "\u0007[\n\u0007\u0005\u0007]\n\u0007\u0003\b\u0003\b\u0003\b\u0003\b",
    "\u0003\b\u0003\b\u0003\b\u0003\b\u0005\bg\n\b\u0003\t\u0003\t\u0003",
    "\t\u0003\t\u0003\n\u0003\n\u0003\u000b\u0003\u000b\u0003\f\u0003\f\u0003",
    "\f\u0003\f\u0003\f\u0003\f\u0003\f\u0003\f\u0005\fy\n\f\u0003\r\u0003",
    "\r\u0003\r\u0003\r\u0003\r\u0007\r\u0080\n\r\f\r\u000e\r\u0083\u000b",
    "\r\u0005\r\u0085\n\r\u0003\r\u0003\r\u0003\u000e\u0003\u000e\u0003\u000e",
    "\u0005\u000e\u008c\n\u000e\u0003\u000e\u0003\u000e\u0003\u000e\u0003",
    "\u000e\u0005\u000e\u0092\n\u000e\u0003\u000f\u0003\u000f\u0003\u000f",
    "\u0003\u000f\u0005\u000f\u0098\n\u000f\u0005\u000f\u009a\n\u000f\u0003",
    "\u0010\u0003\u0010\u0007\u0010\u009e\n\u0010\f\u0010\u000e\u0010\u00a1",
    "\u000b\u0010\u0003\u0011\u0003\u0011\u0003\u0011\u0007\u0011\u00a6\n",
    "\u0011\f\u0011\u000e\u0011\u00a9\u000b\u0011\u0003\u0012\u0003\u0012",
    "\u0003\u0012\u0007\u0012\u00ae\n\u0012\f\u0012\u000e\u0012\u00b1\u000b",
    "\u0012\u0003\u0013\u0003\u0013\u0003\u0013\u0007\u0013\u00b6\n\u0013",
    "\f\u0013\u000e\u0013\u00b9\u000b\u0013\u0003\u0014\u0003\u0014\u0003",
    "\u0014\u0007\u0014\u00be\n\u0014\f\u0014\u000e\u0014\u00c1\u000b\u0014",
    "\u0003\u0015\u0003\u0015\u0003\u0015\u0007\u0015\u00c6\n\u0015\f\u0015",
    "\u000e\u0015\u00c9\u000b\u0015\u0003\u0016\u0003\u0016\u0003\u0016\u0005",
    "\u0016\u00ce\n\u0016\u0003\u0016\u0003\u0016\u0003\u0016\u0005\u0016",
    "\u00d3\n\u0016\u0005\u0016\u00d5\n\u0016\u0003\u0017\u0007\u0017\u00d8",
    "\n\u0017\f\u0017\u000e\u0017\u00db\u000b\u0017\u0003\u0017\u0003\u0017",
    "\u0003\u0018\u0003\u0018\u0003\u0018\u0005\u0018\u00e2\n\u0018\u0003",
    "\u0019\u0003\u0019\u0003\u0019\u0003\u0019\u0003\u0019\u0003\u0019\u0005",
    "\u0019\u00ea\n\u0019\u0003\u001a\u0003\u001a\u0003\u001a\u0003\u001b",
    "\u0003\u001b\u0003\u001b\u0003\u001b\u0003\u001b\u0003\u001b\u0005\u001b",
    "\u00f5\n\u001b\u0003\u001c\u0003\u001c\u0003\u001c\u0002\u0002\u001d",
    "\u0002\u0004\u0006\b\n\f\u000e\u0010\u0012\u0014\u0016\u0018\u001a\u001c",
    "\u001e \"$&(*,.0246\u0002\n\u0003\u0002\u000e\u000f\u0004\u0002\u0016",
    "\u0016\u0018\u0018\u0003\u0002\u0006\u0007\u0003\u0002\u001c\u001f\u0003",
    "\u0002\u0014\u0015\u0004\u0002\b\t\u0017\u0017\u0003\u0002\b\t\u0005",
    "\u0002\u000b\u000b\r\r&&\u0002\u0100\u00028\u0003\u0002\u0002\u0002",
    "\u0004<\u0003\u0002\u0002\u0002\u0006B\u0003\u0002\u0002\u0002\bD\u0003",
    "\u0002\u0002\u0002\nU\u0003\u0002\u0002\u0002\f\\\u0003\u0002\u0002",
    "\u0002\u000ef\u0003\u0002\u0002\u0002\u0010h\u0003\u0002\u0002\u0002",
    "\u0012l\u0003\u0002\u0002\u0002\u0014n\u0003\u0002\u0002\u0002\u0016",
    "x\u0003\u0002\u0002\u0002\u0018z\u0003\u0002\u0002\u0002\u001a\u0091",
    "\u0003\u0002\u0002\u0002\u001c\u0099\u0003\u0002\u0002\u0002\u001e\u009b",
    "\u0003\u0002\u0002\u0002 \u00a2\u0003\u0002\u0002\u0002\"\u00aa\u0003",
    "\u0002\u0002\u0002$\u00b2\u0003\u0002\u0002\u0002&\u00ba\u0003\u0002",
    "\u0002\u0002(\u00c2\u0003\u0002\u0002\u0002*\u00d4\u0003\u0002\u0002",
    "\u0002,\u00d9\u0003\u0002\u0002\u0002.\u00de\u0003\u0002\u0002\u0002",
    "0\u00e9\u0003\u0002\u0002\u00022\u00eb\u0003\u0002\u0002\u00024\u00f4",
    "\u0003\u0002\u0002\u00026\u00f6\u0003\u0002\u0002\u000289\u0005\u0014",
    "\u000b\u00029\u0003\u0003\u0002\u0002\u0002:=\u0005\b\u0005\u0002;=",
    "\u0005\u0006\u0004\u0002<:\u0003\u0002\u0002\u0002<;\u0003\u0002\u0002",
    "\u0002=\u0005\u0003\u0002\u0002\u0002>?\u0007\u000e\u0002\u0002?C\u0005",
    "\b\u0005\u0002@A\u0007\u000f\u0002\u0002AC\u0005\b\u0005\u0002B>\u0003",
    "\u0002\u0002\u0002B@\u0003\u0002\u0002\u0002C\u0007\u0003\u0002\u0002",
    "\u0002DI\u0005\n\u0006\u0002EF\t\u0002\u0002\u0002FH\u0005\n\u0006\u0002",
    "GE\u0003\u0002\u0002\u0002HK\u0003\u0002\u0002\u0002IG\u0003\u0002\u0002",
    "\u0002IJ\u0003\u0002\u0002\u0002J\t\u0003\u0002\u0002\u0002KI\u0003",
    "\u0002\u0002\u0002LM\u0005\f\u0007\u0002MQ\u0005\u000e\b\u0002NP\u0005",
    "\u0010\t\u0002ON\u0003\u0002\u0002\u0002PS\u0003\u0002\u0002\u0002Q",
    "O\u0003\u0002\u0002\u0002QR\u0003\u0002\u0002\u0002RV\u0003\u0002\u0002",
    "\u0002SQ\u0003\u0002\u0002\u0002TV\u0005\u0012\n\u0002UL\u0003\u0002",
    "\u0002\u0002UT\u0003\u0002\u0002\u0002V\u000b\u0003\u0002\u0002\u0002",
    "WX\u0007\r\u0002\u0002X]\u0007!\u0002\u0002Y[\u0007\u0019\u0002\u0002",
    "ZY\u0003\u0002\u0002\u0002Z[\u0003\u0002\u0002\u0002[]\u0003\u0002\u0002",
    "\u0002\\W\u0003\u0002\u0002\u0002\\Z\u0003\u0002\u0002\u0002]\r\u0003",
    "\u0002\u0002\u0002^g\u00054\u001b\u0002_`\u0007\u000b\u0002\u0002`a",
    "\u0007\u0010\u0002\u0002ag\u0007\u0011\u0002\u0002bc\u0007\u0003\u0002",
    "\u0002cd\u0007\u0010\u0002\u0002de\u0007$\u0002\u0002eg\u0007\u0011",
    "\u0002\u0002f^\u0003\u0002\u0002\u0002f_\u0003\u0002\u0002\u0002fb\u0003",
    "\u0002\u0002\u0002g\u000f\u0003\u0002\u0002\u0002hi\u0007\u0012\u0002",
    "\u0002ij\u0005\u0014\u000b\u0002jk\u0007\u0013\u0002\u0002k\u0011\u0003",
    "\u0002\u0002\u0002lm\t\u0003\u0002\u0002m\u0013\u0003\u0002\u0002\u0002",
    "no\u0005 \u0011\u0002o\u0015\u0003\u0002\u0002\u0002py\u00052\u001a",
    "\u0002qr\u0007\u0010\u0002\u0002rs\u0005\u0014\u000b\u0002st\u0007\u0011",
    "\u0002\u0002ty\u0003\u0002\u0002\u0002uy\u0007$\u0002\u0002vy\u0007",
    "\f\u0002\u0002wy\u0005\u0018\r\u0002xp\u0003\u0002\u0002\u0002xq\u0003",
    "\u0002\u0002\u0002xu\u0003\u0002\u0002\u0002xv\u0003\u0002\u0002\u0002",
    "xw\u0003\u0002\u0002\u0002y\u0017\u0003\u0002\u0002\u0002z{\u00050\u0019",
    "\u0002{\u0084\u0007\u0010\u0002\u0002|\u0081\u0005\u0014\u000b\u0002",
    "}~\u0007\u001a\u0002\u0002~\u0080\u0005\u0014\u000b\u0002\u007f}\u0003",
    "\u0002\u0002\u0002\u0080\u0083\u0003\u0002\u0002\u0002\u0081\u007f\u0003",
    "\u0002\u0002\u0002\u0081\u0082\u0003\u0002\u0002\u0002\u0082\u0085\u0003",
    "\u0002\u0002\u0002\u0083\u0081\u0003\u0002\u0002\u0002\u0084|\u0003",
    "\u0002\u0002\u0002\u0084\u0085\u0003\u0002\u0002\u0002\u0085\u0086\u0003",
    "\u0002\u0002\u0002\u0086\u0087\u0007\u0011\u0002\u0002\u0087\u0019\u0003",
    "\u0002\u0002\u0002\u0088\u008b\u0005\u001c\u000f\u0002\u0089\u008a\u0007",
    "\u001b\u0002\u0002\u008a\u008c\u0005\u001a\u000e\u0002\u008b\u0089\u0003",
    "\u0002\u0002\u0002\u008b\u008c\u0003\u0002\u0002\u0002\u008c\u0092\u0003",
    "\u0002\u0002\u0002\u008d\u008e\u0007\u000e\u0002\u0002\u008e\u008f\u0007",
    "\u001b\u0002\u0002\u008f\u0092\u0005\u001a\u000e\u0002\u0090\u0092\u0007",
    "\u000e\u0002\u0002\u0091\u0088\u0003\u0002\u0002\u0002\u0091\u008d\u0003",
    "\u0002\u0002\u0002\u0091\u0090\u0003\u0002\u0002\u0002\u0092\u001b\u0003",
    "\u0002\u0002\u0002\u0093\u009a\u0005\u0004\u0003\u0002\u0094\u0097\u0005",
    "\u001e\u0010\u0002\u0095\u0096\t\u0002\u0002\u0002\u0096\u0098\u0005",
    "\b\u0005\u0002\u0097\u0095\u0003\u0002\u0002\u0002\u0097\u0098\u0003",
    "\u0002\u0002\u0002\u0098\u009a\u0003\u0002\u0002\u0002\u0099\u0093\u0003",
    "\u0002\u0002\u0002\u0099\u0094\u0003\u0002\u0002\u0002\u009a\u001d\u0003",
    "\u0002\u0002\u0002\u009b\u009f\u0005\u0016\f\u0002\u009c\u009e\u0005",
    "\u0010\t\u0002\u009d\u009c\u0003\u0002\u0002\u0002\u009e\u00a1\u0003",
    "\u0002\u0002\u0002\u009f\u009d\u0003\u0002\u0002\u0002\u009f\u00a0\u0003",
    "\u0002\u0002\u0002\u00a0\u001f\u0003\u0002\u0002\u0002\u00a1\u009f\u0003",
    "\u0002\u0002\u0002\u00a2\u00a7\u0005\"\u0012\u0002\u00a3\u00a4\u0007",
    "\u0004\u0002\u0002\u00a4\u00a6\u0005\"\u0012\u0002\u00a5\u00a3\u0003",
    "\u0002\u0002\u0002\u00a6\u00a9\u0003\u0002\u0002\u0002\u00a7\u00a5\u0003",
    "\u0002\u0002\u0002\u00a7\u00a8\u0003\u0002\u0002\u0002\u00a8!\u0003",
    "\u0002\u0002\u0002\u00a9\u00a7\u0003\u0002\u0002\u0002\u00aa\u00af\u0005",
    "$\u0013\u0002\u00ab\u00ac\u0007\u0005\u0002\u0002\u00ac\u00ae\u0005",
    "$\u0013\u0002\u00ad\u00ab\u0003\u0002\u0002\u0002\u00ae\u00b1\u0003",
    "\u0002\u0002\u0002\u00af\u00ad\u0003\u0002\u0002\u0002\u00af\u00b0\u0003",
    "\u0002\u0002\u0002\u00b0#\u0003\u0002\u0002\u0002\u00b1\u00af\u0003",
    "\u0002\u0002\u0002\u00b2\u00b7\u0005&\u0014\u0002\u00b3\u00b4\t\u0004",
    "\u0002\u0002\u00b4\u00b6\u0005&\u0014\u0002\u00b5\u00b3\u0003\u0002",
    "\u0002\u0002\u00b6\u00b9\u0003\u0002\u0002\u0002\u00b7\u00b5\u0003\u0002",
    "\u0002\u0002\u00b7\u00b8\u0003\u0002\u0002\u0002\u00b8%\u0003\u0002",
    "\u0002\u0002\u00b9\u00b7\u0003\u0002\u0002\u0002\u00ba\u00bf\u0005(",
    "\u0015\u0002\u00bb\u00bc\t\u0005\u0002\u0002\u00bc\u00be\u0005(\u0015",
    "\u0002\u00bd\u00bb\u0003\u0002\u0002\u0002\u00be\u00c1\u0003\u0002\u0002",
    "\u0002\u00bf\u00bd\u0003\u0002\u0002\u0002\u00bf\u00c0\u0003\u0002\u0002",
    "\u0002\u00c0\'\u0003\u0002\u0002\u0002\u00c1\u00bf\u0003\u0002\u0002",
    "\u0002\u00c2\u00c7\u0005*\u0016\u0002\u00c3\u00c4\t\u0006\u0002\u0002",
    "\u00c4\u00c6\u0005*\u0016\u0002\u00c5\u00c3\u0003\u0002\u0002\u0002",
    "\u00c6\u00c9\u0003\u0002\u0002\u0002\u00c7\u00c5\u0003\u0002\u0002\u0002",
    "\u00c7\u00c8\u0003\u0002\u0002\u0002\u00c8)\u0003\u0002\u0002\u0002",
    "\u00c9\u00c7\u0003\u0002\u0002\u0002\u00ca\u00cd\u0005,\u0017\u0002",
    "\u00cb\u00cc\t\u0007\u0002\u0002\u00cc\u00ce\u0005*\u0016\u0002\u00cd",
    "\u00cb\u0003\u0002\u0002\u0002\u00cd\u00ce\u0003\u0002\u0002\u0002\u00ce",
    "\u00d5\u0003\u0002\u0002\u0002\u00cf\u00d2\u0007\u000e\u0002\u0002\u00d0",
    "\u00d1\t\b\u0002\u0002\u00d1\u00d3\u0005*\u0016\u0002\u00d2\u00d0\u0003",
    "\u0002\u0002\u0002\u00d2\u00d3\u0003\u0002\u0002\u0002\u00d3\u00d5\u0003",
    "\u0002\u0002\u0002\u00d4\u00ca\u0003\u0002\u0002\u0002\u00d4\u00cf\u0003",
    "\u0002\u0002\u0002\u00d5+\u0003\u0002\u0002\u0002\u00d6\u00d8\u0007",
    "\u0014\u0002\u0002\u00d7\u00d6\u0003\u0002\u0002\u0002\u00d8\u00db\u0003",
    "\u0002\u0002\u0002\u00d9\u00d7\u0003\u0002\u0002\u0002\u00d9\u00da\u0003",
    "\u0002\u0002\u0002\u00da\u00dc\u0003\u0002\u0002\u0002\u00db\u00d9\u0003",
    "\u0002\u0002\u0002\u00dc\u00dd\u0005\u001a\u000e\u0002\u00dd-\u0003",
    "\u0002\u0002\u0002\u00de\u00e1\u00056\u001c\u0002\u00df\u00e0\u0007",
    " \u0002\u0002\u00e0\u00e2\u00056\u001c\u0002\u00e1\u00df\u0003\u0002",
    "\u0002\u0002\u00e1\u00e2\u0003\u0002\u0002\u0002\u00e2/\u0003\u0002",
    "\u0002\u0002\u00e3\u00e4\u00056\u001c\u0002\u00e4\u00e5\u0007 \u0002",
    "\u0002\u00e5\u00e6\u00056\u001c\u0002\u00e6\u00ea\u0003\u0002\u0002",
    "\u0002\u00e7\u00ea\u0007&\u0002\u0002\u00e8\u00ea\u0007\r\u0002\u0002",
    "\u00e9\u00e3\u0003\u0002\u0002\u0002\u00e9\u00e7\u0003\u0002\u0002\u0002",
    "\u00e9\u00e8\u0003\u0002\u0002\u0002\u00ea1\u0003\u0002\u0002\u0002",
    "\u00eb\u00ec\u0007\n\u0002\u0002\u00ec\u00ed\u0005.\u0018\u0002\u00ed",
    "3\u0003\u0002\u0002\u0002\u00ee\u00f5\u0007\u0017\u0002\u0002\u00ef",
    "\u00f0\u00056\u001c\u0002\u00f0\u00f1\u0007 \u0002\u0002\u00f1\u00f2",
    "\u0007\u0017\u0002\u0002\u00f2\u00f5\u0003\u0002\u0002\u0002\u00f3\u00f5",
    "\u0005.\u0018\u0002\u00f4\u00ee\u0003\u0002\u0002\u0002\u00f4\u00ef",
    "\u0003\u0002\u0002\u0002\u00f4\u00f3\u0003\u0002\u0002\u0002\u00f55",
    "\u0003\u0002\u0002\u0002\u00f6\u00f7\t\t\u0002\u0002\u00f77\u0003\u0002",
    "\u0002\u0002\u001e<BIQUZ\\fx\u0081\u0084\u008b\u0091\u0097\u0099\u009f",
    "\u00a7\u00af\u00b7\u00bf\u00c7\u00cd\u00d2\u00d4\u00d9\u00e1\u00e9\u00f4"].join("");


var atn = new antlr4.atn.ATNDeserializer().deserialize(serializedATN);

var decisionsToDFA = atn.decisionToState.map( function(ds, index) { return new antlr4.dfa.DFA(ds, index); });

var sharedContextCache = new antlr4.PredictionContextCache();

var literalNames = [ null, "'processing-instruction'", "'or'", "'and'", 
                     "'='", "'!='", "'div'", "'mod'", "'$'", null, null, 
                     null, "'/'", "'//'", "'('", "')'", "'['", "']'", "'-'", 
                     "'+'", "'.'", "'*'", "'..'", "'@'", "','", "'|'", "'<'", 
                     "'>'", "'<='", "'>='", "':'", "'::'", "'''", "'\"'" ];

var symbolicNames = [ null, null, null, null, null, null, null, null, null, 
                      "NodeType", "Number", "AxisName", "PATHSEP", "ABRPATH", 
                      "LPAR", "RPAR", "LBRAC", "RBRAC", "MINUS", "PLUS", 
                      "DOT", "MUL", "DOTDOT", "AT", "COMMA", "PIPE", "LESS", 
                      "MORE_", "LE", "GE", "COLON", "CC", "APOS", "QUOT", 
                      "Literal", "Whitespace", "NCName" ];

var ruleNames =  [ "main", "locationPath", "absoluteLocationPathNoroot", 
                   "relativeLocationPath", "step", "axisSpecifier", "nodeTest", 
                   "predicate", "abbreviatedStep", "expr", "primaryExpr", 
                   "functionCall", "unionExprNoRoot", "pathExprNoRoot", 
                   "filterExpr", "orExpr", "andExpr", "equalityExpr", "relationalExpr", 
                   "additiveExpr", "multiplicativeExpr", "unaryExprNoRoot", 
                   "qName", "functionName", "variableReference", "nameTest", 
                   "nCName" ];

function xpathParser (input) {
	antlr4.Parser.call(this, input);
    this._interp = new antlr4.atn.ParserATNSimulator(this, atn, decisionsToDFA, sharedContextCache);
    this.ruleNames = ruleNames;
    this.literalNames = literalNames;
    this.symbolicNames = symbolicNames;
    return this;
}

xpathParser.prototype = Object.create(antlr4.Parser.prototype);
xpathParser.prototype.constructor = xpathParser;

Object.defineProperty(xpathParser.prototype, "atn", {
	get : function() {
		return atn;
	}
});

xpathParser.EOF = antlr4.Token.EOF;
xpathParser.T__0 = 1;
xpathParser.T__1 = 2;
xpathParser.T__2 = 3;
xpathParser.T__3 = 4;
xpathParser.T__4 = 5;
xpathParser.T__5 = 6;
xpathParser.T__6 = 7;
xpathParser.T__7 = 8;
xpathParser.NodeType = 9;
xpathParser.Number = 10;
xpathParser.AxisName = 11;
xpathParser.PATHSEP = 12;
xpathParser.ABRPATH = 13;
xpathParser.LPAR = 14;
xpathParser.RPAR = 15;
xpathParser.LBRAC = 16;
xpathParser.RBRAC = 17;
xpathParser.MINUS = 18;
xpathParser.PLUS = 19;
xpathParser.DOT = 20;
xpathParser.MUL = 21;
xpathParser.DOTDOT = 22;
xpathParser.AT = 23;
xpathParser.COMMA = 24;
xpathParser.PIPE = 25;
xpathParser.LESS = 26;
xpathParser.MORE_ = 27;
xpathParser.LE = 28;
xpathParser.GE = 29;
xpathParser.COLON = 30;
xpathParser.CC = 31;
xpathParser.APOS = 32;
xpathParser.QUOT = 33;
xpathParser.Literal = 34;
xpathParser.Whitespace = 35;
xpathParser.NCName = 36;

xpathParser.RULE_main = 0;
xpathParser.RULE_locationPath = 1;
xpathParser.RULE_absoluteLocationPathNoroot = 2;
xpathParser.RULE_relativeLocationPath = 3;
xpathParser.RULE_step = 4;
xpathParser.RULE_axisSpecifier = 5;
xpathParser.RULE_nodeTest = 6;
xpathParser.RULE_predicate = 7;
xpathParser.RULE_abbreviatedStep = 8;
xpathParser.RULE_expr = 9;
xpathParser.RULE_primaryExpr = 10;
xpathParser.RULE_functionCall = 11;
xpathParser.RULE_unionExprNoRoot = 12;
xpathParser.RULE_pathExprNoRoot = 13;
xpathParser.RULE_filterExpr = 14;
xpathParser.RULE_orExpr = 15;
xpathParser.RULE_andExpr = 16;
xpathParser.RULE_equalityExpr = 17;
xpathParser.RULE_relationalExpr = 18;
xpathParser.RULE_additiveExpr = 19;
xpathParser.RULE_multiplicativeExpr = 20;
xpathParser.RULE_unaryExprNoRoot = 21;
xpathParser.RULE_qName = 22;
xpathParser.RULE_functionName = 23;
xpathParser.RULE_variableReference = 24;
xpathParser.RULE_nameTest = 25;
xpathParser.RULE_nCName = 26;

function MainContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = xpathParser.RULE_main;
    return this;
}

MainContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
MainContext.prototype.constructor = MainContext;

MainContext.prototype.expr = function() {
    return this.getTypedRuleContext(ExprContext,0);
};

MainContext.prototype.enterRule = function(listener) {
    if(listener instanceof xpathListener ) {
        listener.enterMain(this);
	}
};

MainContext.prototype.exitRule = function(listener) {
    if(listener instanceof xpathListener ) {
        listener.exitMain(this);
	}
};

MainContext.prototype.accept = function(visitor) {
    if ( visitor instanceof xpathVisitor ) {
        return visitor.visitMain(this);
    } else {
        return visitor.visitChildren(this);
    }
};




xpathParser.MainContext = MainContext;

xpathParser.prototype.main = function() {

    var localctx = new MainContext(this, this._ctx, this.state);
    this.enterRule(localctx, 0, xpathParser.RULE_main);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 54;
        this.expr();
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function LocationPathContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = xpathParser.RULE_locationPath;
    return this;
}

LocationPathContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
LocationPathContext.prototype.constructor = LocationPathContext;

LocationPathContext.prototype.relativeLocationPath = function() {
    return this.getTypedRuleContext(RelativeLocationPathContext,0);
};

LocationPathContext.prototype.absoluteLocationPathNoroot = function() {
    return this.getTypedRuleContext(AbsoluteLocationPathNorootContext,0);
};

LocationPathContext.prototype.enterRule = function(listener) {
    if(listener instanceof xpathListener ) {
        listener.enterLocationPath(this);
	}
};

LocationPathContext.prototype.exitRule = function(listener) {
    if(listener instanceof xpathListener ) {
        listener.exitLocationPath(this);
	}
};

LocationPathContext.prototype.accept = function(visitor) {
    if ( visitor instanceof xpathVisitor ) {
        return visitor.visitLocationPath(this);
    } else {
        return visitor.visitChildren(this);
    }
};




xpathParser.LocationPathContext = LocationPathContext;

xpathParser.prototype.locationPath = function() {

    var localctx = new LocationPathContext(this, this._ctx, this.state);
    this.enterRule(localctx, 2, xpathParser.RULE_locationPath);
    try {
        this.state = 58;
        this._errHandler.sync(this);
        switch(this._input.LA(1)) {
        case xpathParser.T__0:
        case xpathParser.NodeType:
        case xpathParser.AxisName:
        case xpathParser.DOT:
        case xpathParser.MUL:
        case xpathParser.DOTDOT:
        case xpathParser.AT:
        case xpathParser.NCName:
            this.enterOuterAlt(localctx, 1);
            this.state = 56;
            this.relativeLocationPath();
            break;
        case xpathParser.PATHSEP:
        case xpathParser.ABRPATH:
            this.enterOuterAlt(localctx, 2);
            this.state = 57;
            this.absoluteLocationPathNoroot();
            break;
        default:
            throw new antlr4.error.NoViableAltException(this);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function AbsoluteLocationPathNorootContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = xpathParser.RULE_absoluteLocationPathNoroot;
    return this;
}

AbsoluteLocationPathNorootContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
AbsoluteLocationPathNorootContext.prototype.constructor = AbsoluteLocationPathNorootContext;

AbsoluteLocationPathNorootContext.prototype.relativeLocationPath = function() {
    return this.getTypedRuleContext(RelativeLocationPathContext,0);
};

AbsoluteLocationPathNorootContext.prototype.enterRule = function(listener) {
    if(listener instanceof xpathListener ) {
        listener.enterAbsoluteLocationPathNoroot(this);
	}
};

AbsoluteLocationPathNorootContext.prototype.exitRule = function(listener) {
    if(listener instanceof xpathListener ) {
        listener.exitAbsoluteLocationPathNoroot(this);
	}
};

AbsoluteLocationPathNorootContext.prototype.accept = function(visitor) {
    if ( visitor instanceof xpathVisitor ) {
        return visitor.visitAbsoluteLocationPathNoroot(this);
    } else {
        return visitor.visitChildren(this);
    }
};




xpathParser.AbsoluteLocationPathNorootContext = AbsoluteLocationPathNorootContext;

xpathParser.prototype.absoluteLocationPathNoroot = function() {

    var localctx = new AbsoluteLocationPathNorootContext(this, this._ctx, this.state);
    this.enterRule(localctx, 4, xpathParser.RULE_absoluteLocationPathNoroot);
    try {
        this.state = 64;
        this._errHandler.sync(this);
        switch(this._input.LA(1)) {
        case xpathParser.PATHSEP:
            this.enterOuterAlt(localctx, 1);
            this.state = 60;
            this.match(xpathParser.PATHSEP);
            this.state = 61;
            this.relativeLocationPath();
            break;
        case xpathParser.ABRPATH:
            this.enterOuterAlt(localctx, 2);
            this.state = 62;
            this.match(xpathParser.ABRPATH);
            this.state = 63;
            this.relativeLocationPath();
            break;
        default:
            throw new antlr4.error.NoViableAltException(this);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function RelativeLocationPathContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = xpathParser.RULE_relativeLocationPath;
    return this;
}

RelativeLocationPathContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
RelativeLocationPathContext.prototype.constructor = RelativeLocationPathContext;

RelativeLocationPathContext.prototype.step = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(StepContext);
    } else {
        return this.getTypedRuleContext(StepContext,i);
    }
};

RelativeLocationPathContext.prototype.enterRule = function(listener) {
    if(listener instanceof xpathListener ) {
        listener.enterRelativeLocationPath(this);
	}
};

RelativeLocationPathContext.prototype.exitRule = function(listener) {
    if(listener instanceof xpathListener ) {
        listener.exitRelativeLocationPath(this);
	}
};

RelativeLocationPathContext.prototype.accept = function(visitor) {
    if ( visitor instanceof xpathVisitor ) {
        return visitor.visitRelativeLocationPath(this);
    } else {
        return visitor.visitChildren(this);
    }
};




xpathParser.RelativeLocationPathContext = RelativeLocationPathContext;

xpathParser.prototype.relativeLocationPath = function() {

    var localctx = new RelativeLocationPathContext(this, this._ctx, this.state);
    this.enterRule(localctx, 6, xpathParser.RULE_relativeLocationPath);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 66;
        this.step();
        this.state = 71;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while(_la===xpathParser.PATHSEP || _la===xpathParser.ABRPATH) {
            this.state = 67;
            _la = this._input.LA(1);
            if(!(_la===xpathParser.PATHSEP || _la===xpathParser.ABRPATH)) {
            this._errHandler.recoverInline(this);
            }
            else {
            	this._errHandler.reportMatch(this);
                this.consume();
            }
            this.state = 68;
            this.step();
            this.state = 73;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function StepContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = xpathParser.RULE_step;
    return this;
}

StepContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
StepContext.prototype.constructor = StepContext;

StepContext.prototype.axisSpecifier = function() {
    return this.getTypedRuleContext(AxisSpecifierContext,0);
};

StepContext.prototype.nodeTest = function() {
    return this.getTypedRuleContext(NodeTestContext,0);
};

StepContext.prototype.predicate = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(PredicateContext);
    } else {
        return this.getTypedRuleContext(PredicateContext,i);
    }
};

StepContext.prototype.abbreviatedStep = function() {
    return this.getTypedRuleContext(AbbreviatedStepContext,0);
};

StepContext.prototype.enterRule = function(listener) {
    if(listener instanceof xpathListener ) {
        listener.enterStep(this);
	}
};

StepContext.prototype.exitRule = function(listener) {
    if(listener instanceof xpathListener ) {
        listener.exitStep(this);
	}
};

StepContext.prototype.accept = function(visitor) {
    if ( visitor instanceof xpathVisitor ) {
        return visitor.visitStep(this);
    } else {
        return visitor.visitChildren(this);
    }
};




xpathParser.StepContext = StepContext;

xpathParser.prototype.step = function() {

    var localctx = new StepContext(this, this._ctx, this.state);
    this.enterRule(localctx, 8, xpathParser.RULE_step);
    var _la = 0; // Token type
    try {
        this.state = 83;
        this._errHandler.sync(this);
        switch(this._input.LA(1)) {
        case xpathParser.T__0:
        case xpathParser.NodeType:
        case xpathParser.AxisName:
        case xpathParser.MUL:
        case xpathParser.AT:
        case xpathParser.NCName:
            this.enterOuterAlt(localctx, 1);
            this.state = 74;
            this.axisSpecifier();
            this.state = 75;
            this.nodeTest();
            this.state = 79;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            while(_la===xpathParser.LBRAC) {
                this.state = 76;
                this.predicate();
                this.state = 81;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
            }
            break;
        case xpathParser.DOT:
        case xpathParser.DOTDOT:
            this.enterOuterAlt(localctx, 2);
            this.state = 82;
            this.abbreviatedStep();
            break;
        default:
            throw new antlr4.error.NoViableAltException(this);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function AxisSpecifierContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = xpathParser.RULE_axisSpecifier;
    return this;
}

AxisSpecifierContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
AxisSpecifierContext.prototype.constructor = AxisSpecifierContext;

AxisSpecifierContext.prototype.AxisName = function() {
    return this.getToken(xpathParser.AxisName, 0);
};

AxisSpecifierContext.prototype.enterRule = function(listener) {
    if(listener instanceof xpathListener ) {
        listener.enterAxisSpecifier(this);
	}
};

AxisSpecifierContext.prototype.exitRule = function(listener) {
    if(listener instanceof xpathListener ) {
        listener.exitAxisSpecifier(this);
	}
};

AxisSpecifierContext.prototype.accept = function(visitor) {
    if ( visitor instanceof xpathVisitor ) {
        return visitor.visitAxisSpecifier(this);
    } else {
        return visitor.visitChildren(this);
    }
};




xpathParser.AxisSpecifierContext = AxisSpecifierContext;

xpathParser.prototype.axisSpecifier = function() {

    var localctx = new AxisSpecifierContext(this, this._ctx, this.state);
    this.enterRule(localctx, 10, xpathParser.RULE_axisSpecifier);
    var _la = 0; // Token type
    try {
        this.state = 90;
        this._errHandler.sync(this);
        var la_ = this._interp.adaptivePredict(this._input,6,this._ctx);
        switch(la_) {
        case 1:
            this.enterOuterAlt(localctx, 1);
            this.state = 85;
            this.match(xpathParser.AxisName);
            this.state = 86;
            this.match(xpathParser.CC);
            break;

        case 2:
            this.enterOuterAlt(localctx, 2);
            this.state = 88;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if(_la===xpathParser.AT) {
                this.state = 87;
                this.match(xpathParser.AT);
            }

            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function NodeTestContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = xpathParser.RULE_nodeTest;
    return this;
}

NodeTestContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
NodeTestContext.prototype.constructor = NodeTestContext;

NodeTestContext.prototype.nameTest = function() {
    return this.getTypedRuleContext(NameTestContext,0);
};

NodeTestContext.prototype.NodeType = function() {
    return this.getToken(xpathParser.NodeType, 0);
};

NodeTestContext.prototype.Literal = function() {
    return this.getToken(xpathParser.Literal, 0);
};

NodeTestContext.prototype.enterRule = function(listener) {
    if(listener instanceof xpathListener ) {
        listener.enterNodeTest(this);
	}
};

NodeTestContext.prototype.exitRule = function(listener) {
    if(listener instanceof xpathListener ) {
        listener.exitNodeTest(this);
	}
};

NodeTestContext.prototype.accept = function(visitor) {
    if ( visitor instanceof xpathVisitor ) {
        return visitor.visitNodeTest(this);
    } else {
        return visitor.visitChildren(this);
    }
};




xpathParser.NodeTestContext = NodeTestContext;

xpathParser.prototype.nodeTest = function() {

    var localctx = new NodeTestContext(this, this._ctx, this.state);
    this.enterRule(localctx, 12, xpathParser.RULE_nodeTest);
    try {
        this.state = 100;
        this._errHandler.sync(this);
        var la_ = this._interp.adaptivePredict(this._input,7,this._ctx);
        switch(la_) {
        case 1:
            this.enterOuterAlt(localctx, 1);
            this.state = 92;
            this.nameTest();
            break;

        case 2:
            this.enterOuterAlt(localctx, 2);
            this.state = 93;
            this.match(xpathParser.NodeType);
            this.state = 94;
            this.match(xpathParser.LPAR);
            this.state = 95;
            this.match(xpathParser.RPAR);
            break;

        case 3:
            this.enterOuterAlt(localctx, 3);
            this.state = 96;
            this.match(xpathParser.T__0);
            this.state = 97;
            this.match(xpathParser.LPAR);
            this.state = 98;
            this.match(xpathParser.Literal);
            this.state = 99;
            this.match(xpathParser.RPAR);
            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function PredicateContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = xpathParser.RULE_predicate;
    return this;
}

PredicateContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
PredicateContext.prototype.constructor = PredicateContext;

PredicateContext.prototype.expr = function() {
    return this.getTypedRuleContext(ExprContext,0);
};

PredicateContext.prototype.enterRule = function(listener) {
    if(listener instanceof xpathListener ) {
        listener.enterPredicate(this);
	}
};

PredicateContext.prototype.exitRule = function(listener) {
    if(listener instanceof xpathListener ) {
        listener.exitPredicate(this);
	}
};

PredicateContext.prototype.accept = function(visitor) {
    if ( visitor instanceof xpathVisitor ) {
        return visitor.visitPredicate(this);
    } else {
        return visitor.visitChildren(this);
    }
};




xpathParser.PredicateContext = PredicateContext;

xpathParser.prototype.predicate = function() {

    var localctx = new PredicateContext(this, this._ctx, this.state);
    this.enterRule(localctx, 14, xpathParser.RULE_predicate);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 102;
        this.match(xpathParser.LBRAC);
        this.state = 103;
        this.expr();
        this.state = 104;
        this.match(xpathParser.RBRAC);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function AbbreviatedStepContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = xpathParser.RULE_abbreviatedStep;
    return this;
}

AbbreviatedStepContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
AbbreviatedStepContext.prototype.constructor = AbbreviatedStepContext;


AbbreviatedStepContext.prototype.enterRule = function(listener) {
    if(listener instanceof xpathListener ) {
        listener.enterAbbreviatedStep(this);
	}
};

AbbreviatedStepContext.prototype.exitRule = function(listener) {
    if(listener instanceof xpathListener ) {
        listener.exitAbbreviatedStep(this);
	}
};

AbbreviatedStepContext.prototype.accept = function(visitor) {
    if ( visitor instanceof xpathVisitor ) {
        return visitor.visitAbbreviatedStep(this);
    } else {
        return visitor.visitChildren(this);
    }
};




xpathParser.AbbreviatedStepContext = AbbreviatedStepContext;

xpathParser.prototype.abbreviatedStep = function() {

    var localctx = new AbbreviatedStepContext(this, this._ctx, this.state);
    this.enterRule(localctx, 16, xpathParser.RULE_abbreviatedStep);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 106;
        _la = this._input.LA(1);
        if(!(_la===xpathParser.DOT || _la===xpathParser.DOTDOT)) {
        this._errHandler.recoverInline(this);
        }
        else {
        	this._errHandler.reportMatch(this);
            this.consume();
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function ExprContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = xpathParser.RULE_expr;
    return this;
}

ExprContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ExprContext.prototype.constructor = ExprContext;

ExprContext.prototype.orExpr = function() {
    return this.getTypedRuleContext(OrExprContext,0);
};

ExprContext.prototype.enterRule = function(listener) {
    if(listener instanceof xpathListener ) {
        listener.enterExpr(this);
	}
};

ExprContext.prototype.exitRule = function(listener) {
    if(listener instanceof xpathListener ) {
        listener.exitExpr(this);
	}
};

ExprContext.prototype.accept = function(visitor) {
    if ( visitor instanceof xpathVisitor ) {
        return visitor.visitExpr(this);
    } else {
        return visitor.visitChildren(this);
    }
};




xpathParser.ExprContext = ExprContext;

xpathParser.prototype.expr = function() {

    var localctx = new ExprContext(this, this._ctx, this.state);
    this.enterRule(localctx, 18, xpathParser.RULE_expr);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 108;
        this.orExpr();
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function PrimaryExprContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = xpathParser.RULE_primaryExpr;
    return this;
}

PrimaryExprContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
PrimaryExprContext.prototype.constructor = PrimaryExprContext;

PrimaryExprContext.prototype.variableReference = function() {
    return this.getTypedRuleContext(VariableReferenceContext,0);
};

PrimaryExprContext.prototype.expr = function() {
    return this.getTypedRuleContext(ExprContext,0);
};

PrimaryExprContext.prototype.Literal = function() {
    return this.getToken(xpathParser.Literal, 0);
};

PrimaryExprContext.prototype.Number = function() {
    return this.getToken(xpathParser.Number, 0);
};

PrimaryExprContext.prototype.functionCall = function() {
    return this.getTypedRuleContext(FunctionCallContext,0);
};

PrimaryExprContext.prototype.enterRule = function(listener) {
    if(listener instanceof xpathListener ) {
        listener.enterPrimaryExpr(this);
	}
};

PrimaryExprContext.prototype.exitRule = function(listener) {
    if(listener instanceof xpathListener ) {
        listener.exitPrimaryExpr(this);
	}
};

PrimaryExprContext.prototype.accept = function(visitor) {
    if ( visitor instanceof xpathVisitor ) {
        return visitor.visitPrimaryExpr(this);
    } else {
        return visitor.visitChildren(this);
    }
};




xpathParser.PrimaryExprContext = PrimaryExprContext;

xpathParser.prototype.primaryExpr = function() {

    var localctx = new PrimaryExprContext(this, this._ctx, this.state);
    this.enterRule(localctx, 20, xpathParser.RULE_primaryExpr);
    try {
        this.state = 118;
        this._errHandler.sync(this);
        switch(this._input.LA(1)) {
        case xpathParser.T__7:
            this.enterOuterAlt(localctx, 1);
            this.state = 110;
            this.variableReference();
            break;
        case xpathParser.LPAR:
            this.enterOuterAlt(localctx, 2);
            this.state = 111;
            this.match(xpathParser.LPAR);
            this.state = 112;
            this.expr();
            this.state = 113;
            this.match(xpathParser.RPAR);
            break;
        case xpathParser.Literal:
            this.enterOuterAlt(localctx, 3);
            this.state = 115;
            this.match(xpathParser.Literal);
            break;
        case xpathParser.Number:
            this.enterOuterAlt(localctx, 4);
            this.state = 116;
            this.match(xpathParser.Number);
            break;
        case xpathParser.NodeType:
        case xpathParser.AxisName:
        case xpathParser.NCName:
            this.enterOuterAlt(localctx, 5);
            this.state = 117;
            this.functionCall();
            break;
        default:
            throw new antlr4.error.NoViableAltException(this);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function FunctionCallContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = xpathParser.RULE_functionCall;
    return this;
}

FunctionCallContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
FunctionCallContext.prototype.constructor = FunctionCallContext;

FunctionCallContext.prototype.functionName = function() {
    return this.getTypedRuleContext(FunctionNameContext,0);
};

FunctionCallContext.prototype.expr = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(ExprContext);
    } else {
        return this.getTypedRuleContext(ExprContext,i);
    }
};

FunctionCallContext.prototype.enterRule = function(listener) {
    if(listener instanceof xpathListener ) {
        listener.enterFunctionCall(this);
	}
};

FunctionCallContext.prototype.exitRule = function(listener) {
    if(listener instanceof xpathListener ) {
        listener.exitFunctionCall(this);
	}
};

FunctionCallContext.prototype.accept = function(visitor) {
    if ( visitor instanceof xpathVisitor ) {
        return visitor.visitFunctionCall(this);
    } else {
        return visitor.visitChildren(this);
    }
};




xpathParser.FunctionCallContext = FunctionCallContext;

xpathParser.prototype.functionCall = function() {

    var localctx = new FunctionCallContext(this, this._ctx, this.state);
    this.enterRule(localctx, 22, xpathParser.RULE_functionCall);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 120;
        this.functionName();
        this.state = 121;
        this.match(xpathParser.LPAR);
        this.state = 130;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << xpathParser.T__0) | (1 << xpathParser.T__7) | (1 << xpathParser.NodeType) | (1 << xpathParser.Number) | (1 << xpathParser.AxisName) | (1 << xpathParser.PATHSEP) | (1 << xpathParser.ABRPATH) | (1 << xpathParser.LPAR) | (1 << xpathParser.MINUS) | (1 << xpathParser.DOT) | (1 << xpathParser.MUL) | (1 << xpathParser.DOTDOT) | (1 << xpathParser.AT))) !== 0) || _la===xpathParser.Literal || _la===xpathParser.NCName) {
            this.state = 122;
            this.expr();
            this.state = 127;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            while(_la===xpathParser.COMMA) {
                this.state = 123;
                this.match(xpathParser.COMMA);
                this.state = 124;
                this.expr();
                this.state = 129;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
            }
        }

        this.state = 132;
        this.match(xpathParser.RPAR);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function UnionExprNoRootContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = xpathParser.RULE_unionExprNoRoot;
    return this;
}

UnionExprNoRootContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
UnionExprNoRootContext.prototype.constructor = UnionExprNoRootContext;

UnionExprNoRootContext.prototype.pathExprNoRoot = function() {
    return this.getTypedRuleContext(PathExprNoRootContext,0);
};

UnionExprNoRootContext.prototype.unionExprNoRoot = function() {
    return this.getTypedRuleContext(UnionExprNoRootContext,0);
};

UnionExprNoRootContext.prototype.enterRule = function(listener) {
    if(listener instanceof xpathListener ) {
        listener.enterUnionExprNoRoot(this);
	}
};

UnionExprNoRootContext.prototype.exitRule = function(listener) {
    if(listener instanceof xpathListener ) {
        listener.exitUnionExprNoRoot(this);
	}
};

UnionExprNoRootContext.prototype.accept = function(visitor) {
    if ( visitor instanceof xpathVisitor ) {
        return visitor.visitUnionExprNoRoot(this);
    } else {
        return visitor.visitChildren(this);
    }
};




xpathParser.UnionExprNoRootContext = UnionExprNoRootContext;

xpathParser.prototype.unionExprNoRoot = function() {

    var localctx = new UnionExprNoRootContext(this, this._ctx, this.state);
    this.enterRule(localctx, 24, xpathParser.RULE_unionExprNoRoot);
    var _la = 0; // Token type
    try {
        this.state = 143;
        this._errHandler.sync(this);
        var la_ = this._interp.adaptivePredict(this._input,12,this._ctx);
        switch(la_) {
        case 1:
            this.enterOuterAlt(localctx, 1);
            this.state = 134;
            this.pathExprNoRoot();
            this.state = 137;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if(_la===xpathParser.PIPE) {
                this.state = 135;
                this.match(xpathParser.PIPE);
                this.state = 136;
                this.unionExprNoRoot();
            }

            break;

        case 2:
            this.enterOuterAlt(localctx, 2);
            this.state = 139;
            this.match(xpathParser.PATHSEP);
            this.state = 140;
            this.match(xpathParser.PIPE);
            this.state = 141;
            this.unionExprNoRoot();
            break;

        case 3:
            this.enterOuterAlt(localctx, 3);
            this.state = 142;
            this.match(xpathParser.PATHSEP);
            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function PathExprNoRootContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = xpathParser.RULE_pathExprNoRoot;
    return this;
}

PathExprNoRootContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
PathExprNoRootContext.prototype.constructor = PathExprNoRootContext;

PathExprNoRootContext.prototype.locationPath = function() {
    return this.getTypedRuleContext(LocationPathContext,0);
};

PathExprNoRootContext.prototype.filterExpr = function() {
    return this.getTypedRuleContext(FilterExprContext,0);
};

PathExprNoRootContext.prototype.relativeLocationPath = function() {
    return this.getTypedRuleContext(RelativeLocationPathContext,0);
};

PathExprNoRootContext.prototype.enterRule = function(listener) {
    if(listener instanceof xpathListener ) {
        listener.enterPathExprNoRoot(this);
	}
};

PathExprNoRootContext.prototype.exitRule = function(listener) {
    if(listener instanceof xpathListener ) {
        listener.exitPathExprNoRoot(this);
	}
};

PathExprNoRootContext.prototype.accept = function(visitor) {
    if ( visitor instanceof xpathVisitor ) {
        return visitor.visitPathExprNoRoot(this);
    } else {
        return visitor.visitChildren(this);
    }
};




xpathParser.PathExprNoRootContext = PathExprNoRootContext;

xpathParser.prototype.pathExprNoRoot = function() {

    var localctx = new PathExprNoRootContext(this, this._ctx, this.state);
    this.enterRule(localctx, 26, xpathParser.RULE_pathExprNoRoot);
    var _la = 0; // Token type
    try {
        this.state = 151;
        this._errHandler.sync(this);
        var la_ = this._interp.adaptivePredict(this._input,14,this._ctx);
        switch(la_) {
        case 1:
            this.enterOuterAlt(localctx, 1);
            this.state = 145;
            this.locationPath();
            break;

        case 2:
            this.enterOuterAlt(localctx, 2);
            this.state = 146;
            this.filterExpr();
            this.state = 149;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if(_la===xpathParser.PATHSEP || _la===xpathParser.ABRPATH) {
                this.state = 147;
                _la = this._input.LA(1);
                if(!(_la===xpathParser.PATHSEP || _la===xpathParser.ABRPATH)) {
                this._errHandler.recoverInline(this);
                }
                else {
                	this._errHandler.reportMatch(this);
                    this.consume();
                }
                this.state = 148;
                this.relativeLocationPath();
            }

            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function FilterExprContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = xpathParser.RULE_filterExpr;
    return this;
}

FilterExprContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
FilterExprContext.prototype.constructor = FilterExprContext;

FilterExprContext.prototype.primaryExpr = function() {
    return this.getTypedRuleContext(PrimaryExprContext,0);
};

FilterExprContext.prototype.predicate = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(PredicateContext);
    } else {
        return this.getTypedRuleContext(PredicateContext,i);
    }
};

FilterExprContext.prototype.enterRule = function(listener) {
    if(listener instanceof xpathListener ) {
        listener.enterFilterExpr(this);
	}
};

FilterExprContext.prototype.exitRule = function(listener) {
    if(listener instanceof xpathListener ) {
        listener.exitFilterExpr(this);
	}
};

FilterExprContext.prototype.accept = function(visitor) {
    if ( visitor instanceof xpathVisitor ) {
        return visitor.visitFilterExpr(this);
    } else {
        return visitor.visitChildren(this);
    }
};




xpathParser.FilterExprContext = FilterExprContext;

xpathParser.prototype.filterExpr = function() {

    var localctx = new FilterExprContext(this, this._ctx, this.state);
    this.enterRule(localctx, 28, xpathParser.RULE_filterExpr);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 153;
        this.primaryExpr();
        this.state = 157;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while(_la===xpathParser.LBRAC) {
            this.state = 154;
            this.predicate();
            this.state = 159;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function OrExprContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = xpathParser.RULE_orExpr;
    return this;
}

OrExprContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
OrExprContext.prototype.constructor = OrExprContext;

OrExprContext.prototype.andExpr = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(AndExprContext);
    } else {
        return this.getTypedRuleContext(AndExprContext,i);
    }
};

OrExprContext.prototype.enterRule = function(listener) {
    if(listener instanceof xpathListener ) {
        listener.enterOrExpr(this);
	}
};

OrExprContext.prototype.exitRule = function(listener) {
    if(listener instanceof xpathListener ) {
        listener.exitOrExpr(this);
	}
};

OrExprContext.prototype.accept = function(visitor) {
    if ( visitor instanceof xpathVisitor ) {
        return visitor.visitOrExpr(this);
    } else {
        return visitor.visitChildren(this);
    }
};




xpathParser.OrExprContext = OrExprContext;

xpathParser.prototype.orExpr = function() {

    var localctx = new OrExprContext(this, this._ctx, this.state);
    this.enterRule(localctx, 30, xpathParser.RULE_orExpr);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 160;
        this.andExpr();
        this.state = 165;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while(_la===xpathParser.T__1) {
            this.state = 161;
            this.match(xpathParser.T__1);
            this.state = 162;
            this.andExpr();
            this.state = 167;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function AndExprContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = xpathParser.RULE_andExpr;
    return this;
}

AndExprContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
AndExprContext.prototype.constructor = AndExprContext;

AndExprContext.prototype.equalityExpr = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(EqualityExprContext);
    } else {
        return this.getTypedRuleContext(EqualityExprContext,i);
    }
};

AndExprContext.prototype.enterRule = function(listener) {
    if(listener instanceof xpathListener ) {
        listener.enterAndExpr(this);
	}
};

AndExprContext.prototype.exitRule = function(listener) {
    if(listener instanceof xpathListener ) {
        listener.exitAndExpr(this);
	}
};

AndExprContext.prototype.accept = function(visitor) {
    if ( visitor instanceof xpathVisitor ) {
        return visitor.visitAndExpr(this);
    } else {
        return visitor.visitChildren(this);
    }
};




xpathParser.AndExprContext = AndExprContext;

xpathParser.prototype.andExpr = function() {

    var localctx = new AndExprContext(this, this._ctx, this.state);
    this.enterRule(localctx, 32, xpathParser.RULE_andExpr);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 168;
        this.equalityExpr();
        this.state = 173;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while(_la===xpathParser.T__2) {
            this.state = 169;
            this.match(xpathParser.T__2);
            this.state = 170;
            this.equalityExpr();
            this.state = 175;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function EqualityExprContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = xpathParser.RULE_equalityExpr;
    return this;
}

EqualityExprContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
EqualityExprContext.prototype.constructor = EqualityExprContext;

EqualityExprContext.prototype.relationalExpr = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(RelationalExprContext);
    } else {
        return this.getTypedRuleContext(RelationalExprContext,i);
    }
};

EqualityExprContext.prototype.enterRule = function(listener) {
    if(listener instanceof xpathListener ) {
        listener.enterEqualityExpr(this);
	}
};

EqualityExprContext.prototype.exitRule = function(listener) {
    if(listener instanceof xpathListener ) {
        listener.exitEqualityExpr(this);
	}
};

EqualityExprContext.prototype.accept = function(visitor) {
    if ( visitor instanceof xpathVisitor ) {
        return visitor.visitEqualityExpr(this);
    } else {
        return visitor.visitChildren(this);
    }
};




xpathParser.EqualityExprContext = EqualityExprContext;

xpathParser.prototype.equalityExpr = function() {

    var localctx = new EqualityExprContext(this, this._ctx, this.state);
    this.enterRule(localctx, 34, xpathParser.RULE_equalityExpr);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 176;
        this.relationalExpr();
        this.state = 181;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while(_la===xpathParser.T__3 || _la===xpathParser.T__4) {
            this.state = 177;
            _la = this._input.LA(1);
            if(!(_la===xpathParser.T__3 || _la===xpathParser.T__4)) {
            this._errHandler.recoverInline(this);
            }
            else {
            	this._errHandler.reportMatch(this);
                this.consume();
            }
            this.state = 178;
            this.relationalExpr();
            this.state = 183;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function RelationalExprContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = xpathParser.RULE_relationalExpr;
    return this;
}

RelationalExprContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
RelationalExprContext.prototype.constructor = RelationalExprContext;

RelationalExprContext.prototype.additiveExpr = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(AdditiveExprContext);
    } else {
        return this.getTypedRuleContext(AdditiveExprContext,i);
    }
};

RelationalExprContext.prototype.enterRule = function(listener) {
    if(listener instanceof xpathListener ) {
        listener.enterRelationalExpr(this);
	}
};

RelationalExprContext.prototype.exitRule = function(listener) {
    if(listener instanceof xpathListener ) {
        listener.exitRelationalExpr(this);
	}
};

RelationalExprContext.prototype.accept = function(visitor) {
    if ( visitor instanceof xpathVisitor ) {
        return visitor.visitRelationalExpr(this);
    } else {
        return visitor.visitChildren(this);
    }
};




xpathParser.RelationalExprContext = RelationalExprContext;

xpathParser.prototype.relationalExpr = function() {

    var localctx = new RelationalExprContext(this, this._ctx, this.state);
    this.enterRule(localctx, 36, xpathParser.RULE_relationalExpr);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 184;
        this.additiveExpr();
        this.state = 189;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << xpathParser.LESS) | (1 << xpathParser.MORE_) | (1 << xpathParser.LE) | (1 << xpathParser.GE))) !== 0)) {
            this.state = 185;
            _la = this._input.LA(1);
            if(!((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << xpathParser.LESS) | (1 << xpathParser.MORE_) | (1 << xpathParser.LE) | (1 << xpathParser.GE))) !== 0))) {
            this._errHandler.recoverInline(this);
            }
            else {
            	this._errHandler.reportMatch(this);
                this.consume();
            }
            this.state = 186;
            this.additiveExpr();
            this.state = 191;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function AdditiveExprContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = xpathParser.RULE_additiveExpr;
    return this;
}

AdditiveExprContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
AdditiveExprContext.prototype.constructor = AdditiveExprContext;

AdditiveExprContext.prototype.multiplicativeExpr = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(MultiplicativeExprContext);
    } else {
        return this.getTypedRuleContext(MultiplicativeExprContext,i);
    }
};

AdditiveExprContext.prototype.enterRule = function(listener) {
    if(listener instanceof xpathListener ) {
        listener.enterAdditiveExpr(this);
	}
};

AdditiveExprContext.prototype.exitRule = function(listener) {
    if(listener instanceof xpathListener ) {
        listener.exitAdditiveExpr(this);
	}
};

AdditiveExprContext.prototype.accept = function(visitor) {
    if ( visitor instanceof xpathVisitor ) {
        return visitor.visitAdditiveExpr(this);
    } else {
        return visitor.visitChildren(this);
    }
};




xpathParser.AdditiveExprContext = AdditiveExprContext;

xpathParser.prototype.additiveExpr = function() {

    var localctx = new AdditiveExprContext(this, this._ctx, this.state);
    this.enterRule(localctx, 38, xpathParser.RULE_additiveExpr);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 192;
        this.multiplicativeExpr();
        this.state = 197;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while(_la===xpathParser.MINUS || _la===xpathParser.PLUS) {
            this.state = 193;
            _la = this._input.LA(1);
            if(!(_la===xpathParser.MINUS || _la===xpathParser.PLUS)) {
            this._errHandler.recoverInline(this);
            }
            else {
            	this._errHandler.reportMatch(this);
                this.consume();
            }
            this.state = 194;
            this.multiplicativeExpr();
            this.state = 199;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function MultiplicativeExprContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = xpathParser.RULE_multiplicativeExpr;
    return this;
}

MultiplicativeExprContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
MultiplicativeExprContext.prototype.constructor = MultiplicativeExprContext;

MultiplicativeExprContext.prototype.unaryExprNoRoot = function() {
    return this.getTypedRuleContext(UnaryExprNoRootContext,0);
};

MultiplicativeExprContext.prototype.multiplicativeExpr = function() {
    return this.getTypedRuleContext(MultiplicativeExprContext,0);
};

MultiplicativeExprContext.prototype.enterRule = function(listener) {
    if(listener instanceof xpathListener ) {
        listener.enterMultiplicativeExpr(this);
	}
};

MultiplicativeExprContext.prototype.exitRule = function(listener) {
    if(listener instanceof xpathListener ) {
        listener.exitMultiplicativeExpr(this);
	}
};

MultiplicativeExprContext.prototype.accept = function(visitor) {
    if ( visitor instanceof xpathVisitor ) {
        return visitor.visitMultiplicativeExpr(this);
    } else {
        return visitor.visitChildren(this);
    }
};




xpathParser.MultiplicativeExprContext = MultiplicativeExprContext;

xpathParser.prototype.multiplicativeExpr = function() {

    var localctx = new MultiplicativeExprContext(this, this._ctx, this.state);
    this.enterRule(localctx, 40, xpathParser.RULE_multiplicativeExpr);
    var _la = 0; // Token type
    try {
        this.state = 210;
        this._errHandler.sync(this);
        var la_ = this._interp.adaptivePredict(this._input,23,this._ctx);
        switch(la_) {
        case 1:
            this.enterOuterAlt(localctx, 1);
            this.state = 200;
            this.unaryExprNoRoot();
            this.state = 203;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << xpathParser.T__5) | (1 << xpathParser.T__6) | (1 << xpathParser.MUL))) !== 0)) {
                this.state = 201;
                _la = this._input.LA(1);
                if(!((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << xpathParser.T__5) | (1 << xpathParser.T__6) | (1 << xpathParser.MUL))) !== 0))) {
                this._errHandler.recoverInline(this);
                }
                else {
                	this._errHandler.reportMatch(this);
                    this.consume();
                }
                this.state = 202;
                this.multiplicativeExpr();
            }

            break;

        case 2:
            this.enterOuterAlt(localctx, 2);
            this.state = 205;
            this.match(xpathParser.PATHSEP);
            this.state = 208;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if(_la===xpathParser.T__5 || _la===xpathParser.T__6) {
                this.state = 206;
                _la = this._input.LA(1);
                if(!(_la===xpathParser.T__5 || _la===xpathParser.T__6)) {
                this._errHandler.recoverInline(this);
                }
                else {
                	this._errHandler.reportMatch(this);
                    this.consume();
                }
                this.state = 207;
                this.multiplicativeExpr();
            }

            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function UnaryExprNoRootContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = xpathParser.RULE_unaryExprNoRoot;
    return this;
}

UnaryExprNoRootContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
UnaryExprNoRootContext.prototype.constructor = UnaryExprNoRootContext;

UnaryExprNoRootContext.prototype.unionExprNoRoot = function() {
    return this.getTypedRuleContext(UnionExprNoRootContext,0);
};

UnaryExprNoRootContext.prototype.enterRule = function(listener) {
    if(listener instanceof xpathListener ) {
        listener.enterUnaryExprNoRoot(this);
	}
};

UnaryExprNoRootContext.prototype.exitRule = function(listener) {
    if(listener instanceof xpathListener ) {
        listener.exitUnaryExprNoRoot(this);
	}
};

UnaryExprNoRootContext.prototype.accept = function(visitor) {
    if ( visitor instanceof xpathVisitor ) {
        return visitor.visitUnaryExprNoRoot(this);
    } else {
        return visitor.visitChildren(this);
    }
};




xpathParser.UnaryExprNoRootContext = UnaryExprNoRootContext;

xpathParser.prototype.unaryExprNoRoot = function() {

    var localctx = new UnaryExprNoRootContext(this, this._ctx, this.state);
    this.enterRule(localctx, 42, xpathParser.RULE_unaryExprNoRoot);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 215;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while(_la===xpathParser.MINUS) {
            this.state = 212;
            this.match(xpathParser.MINUS);
            this.state = 217;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
        }
        this.state = 218;
        this.unionExprNoRoot();
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function QNameContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = xpathParser.RULE_qName;
    return this;
}

QNameContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
QNameContext.prototype.constructor = QNameContext;

QNameContext.prototype.nCName = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(NCNameContext);
    } else {
        return this.getTypedRuleContext(NCNameContext,i);
    }
};

QNameContext.prototype.enterRule = function(listener) {
    if(listener instanceof xpathListener ) {
        listener.enterQName(this);
	}
};

QNameContext.prototype.exitRule = function(listener) {
    if(listener instanceof xpathListener ) {
        listener.exitQName(this);
	}
};

QNameContext.prototype.accept = function(visitor) {
    if ( visitor instanceof xpathVisitor ) {
        return visitor.visitQName(this);
    } else {
        return visitor.visitChildren(this);
    }
};




xpathParser.QNameContext = QNameContext;

xpathParser.prototype.qName = function() {

    var localctx = new QNameContext(this, this._ctx, this.state);
    this.enterRule(localctx, 44, xpathParser.RULE_qName);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 220;
        this.nCName();
        this.state = 223;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if(_la===xpathParser.COLON) {
            this.state = 221;
            this.match(xpathParser.COLON);
            this.state = 222;
            this.nCName();
        }

    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function FunctionNameContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = xpathParser.RULE_functionName;
    return this;
}

FunctionNameContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
FunctionNameContext.prototype.constructor = FunctionNameContext;

FunctionNameContext.prototype.nCName = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(NCNameContext);
    } else {
        return this.getTypedRuleContext(NCNameContext,i);
    }
};

FunctionNameContext.prototype.NCName = function() {
    return this.getToken(xpathParser.NCName, 0);
};

FunctionNameContext.prototype.AxisName = function() {
    return this.getToken(xpathParser.AxisName, 0);
};

FunctionNameContext.prototype.enterRule = function(listener) {
    if(listener instanceof xpathListener ) {
        listener.enterFunctionName(this);
	}
};

FunctionNameContext.prototype.exitRule = function(listener) {
    if(listener instanceof xpathListener ) {
        listener.exitFunctionName(this);
	}
};

FunctionNameContext.prototype.accept = function(visitor) {
    if ( visitor instanceof xpathVisitor ) {
        return visitor.visitFunctionName(this);
    } else {
        return visitor.visitChildren(this);
    }
};




xpathParser.FunctionNameContext = FunctionNameContext;

xpathParser.prototype.functionName = function() {

    var localctx = new FunctionNameContext(this, this._ctx, this.state);
    this.enterRule(localctx, 46, xpathParser.RULE_functionName);
    try {
        this.state = 231;
        this._errHandler.sync(this);
        var la_ = this._interp.adaptivePredict(this._input,26,this._ctx);
        switch(la_) {
        case 1:
            this.enterOuterAlt(localctx, 1);
            this.state = 225;
            this.nCName();
            this.state = 226;
            this.match(xpathParser.COLON);
            this.state = 227;
            this.nCName();
            break;

        case 2:
            this.enterOuterAlt(localctx, 2);
            this.state = 229;
            this.match(xpathParser.NCName);
            break;

        case 3:
            this.enterOuterAlt(localctx, 3);
            this.state = 230;
            this.match(xpathParser.AxisName);
            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function VariableReferenceContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = xpathParser.RULE_variableReference;
    return this;
}

VariableReferenceContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
VariableReferenceContext.prototype.constructor = VariableReferenceContext;

VariableReferenceContext.prototype.qName = function() {
    return this.getTypedRuleContext(QNameContext,0);
};

VariableReferenceContext.prototype.enterRule = function(listener) {
    if(listener instanceof xpathListener ) {
        listener.enterVariableReference(this);
	}
};

VariableReferenceContext.prototype.exitRule = function(listener) {
    if(listener instanceof xpathListener ) {
        listener.exitVariableReference(this);
	}
};

VariableReferenceContext.prototype.accept = function(visitor) {
    if ( visitor instanceof xpathVisitor ) {
        return visitor.visitVariableReference(this);
    } else {
        return visitor.visitChildren(this);
    }
};




xpathParser.VariableReferenceContext = VariableReferenceContext;

xpathParser.prototype.variableReference = function() {

    var localctx = new VariableReferenceContext(this, this._ctx, this.state);
    this.enterRule(localctx, 48, xpathParser.RULE_variableReference);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 233;
        this.match(xpathParser.T__7);
        this.state = 234;
        this.qName();
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function NameTestContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = xpathParser.RULE_nameTest;
    return this;
}

NameTestContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
NameTestContext.prototype.constructor = NameTestContext;

NameTestContext.prototype.nCName = function() {
    return this.getTypedRuleContext(NCNameContext,0);
};

NameTestContext.prototype.qName = function() {
    return this.getTypedRuleContext(QNameContext,0);
};

NameTestContext.prototype.enterRule = function(listener) {
    if(listener instanceof xpathListener ) {
        listener.enterNameTest(this);
	}
};

NameTestContext.prototype.exitRule = function(listener) {
    if(listener instanceof xpathListener ) {
        listener.exitNameTest(this);
	}
};

NameTestContext.prototype.accept = function(visitor) {
    if ( visitor instanceof xpathVisitor ) {
        return visitor.visitNameTest(this);
    } else {
        return visitor.visitChildren(this);
    }
};




xpathParser.NameTestContext = NameTestContext;

xpathParser.prototype.nameTest = function() {

    var localctx = new NameTestContext(this, this._ctx, this.state);
    this.enterRule(localctx, 50, xpathParser.RULE_nameTest);
    try {
        this.state = 242;
        this._errHandler.sync(this);
        var la_ = this._interp.adaptivePredict(this._input,27,this._ctx);
        switch(la_) {
        case 1:
            this.enterOuterAlt(localctx, 1);
            this.state = 236;
            this.match(xpathParser.MUL);
            break;

        case 2:
            this.enterOuterAlt(localctx, 2);
            this.state = 237;
            this.nCName();
            this.state = 238;
            this.match(xpathParser.COLON);
            this.state = 239;
            this.match(xpathParser.MUL);
            break;

        case 3:
            this.enterOuterAlt(localctx, 3);
            this.state = 241;
            this.qName();
            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function NCNameContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = xpathParser.RULE_nCName;
    return this;
}

NCNameContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
NCNameContext.prototype.constructor = NCNameContext;

NCNameContext.prototype.NCName = function() {
    return this.getToken(xpathParser.NCName, 0);
};

NCNameContext.prototype.AxisName = function() {
    return this.getToken(xpathParser.AxisName, 0);
};

NCNameContext.prototype.NodeType = function() {
    return this.getToken(xpathParser.NodeType, 0);
};

NCNameContext.prototype.enterRule = function(listener) {
    if(listener instanceof xpathListener ) {
        listener.enterNCName(this);
	}
};

NCNameContext.prototype.exitRule = function(listener) {
    if(listener instanceof xpathListener ) {
        listener.exitNCName(this);
	}
};

NCNameContext.prototype.accept = function(visitor) {
    if ( visitor instanceof xpathVisitor ) {
        return visitor.visitNCName(this);
    } else {
        return visitor.visitChildren(this);
    }
};




xpathParser.NCNameContext = NCNameContext;

xpathParser.prototype.nCName = function() {

    var localctx = new NCNameContext(this, this._ctx, this.state);
    this.enterRule(localctx, 52, xpathParser.RULE_nCName);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 244;
        _la = this._input.LA(1);
        if(!(((((_la - 9)) & ~0x1f) == 0 && ((1 << (_la - 9)) & ((1 << (xpathParser.NodeType - 9)) | (1 << (xpathParser.AxisName - 9)) | (1 << (xpathParser.NCName - 9)))) !== 0))) {
        this._errHandler.recoverInline(this);
        }
        else {
        	this._errHandler.reportMatch(this);
            this.consume();
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


exports.xpathParser = xpathParser;
exports.MainContext = MainContext;
xpathParser.MainContext = MainContext;
exports.LocationPathContext = LocationPathContext;
xpathParser.LocationPathContext = LocationPathContext;
exports.AbsoluteLocationPathNorootContext = AbsoluteLocationPathNorootContext;
xpathParser.AbsoluteLocationPathNorootContext = AbsoluteLocationPathNorootContext;
exports.RelativeLocationPathContext = RelativeLocationPathContext;
xpathParser.RelativeLocationPathContext = RelativeLocationPathContext;
exports.StepContext = StepContext;
xpathParser.StepContext = StepContext;
exports.AxisSpecifierContext = AxisSpecifierContext;
xpathParser.AxisSpecifierContext = AxisSpecifierContext;
exports.NodeTestContext = NodeTestContext;
xpathParser.NodeTestContext = NodeTestContext;
exports.PredicateContext = PredicateContext;
xpathParser.PredicateContext = PredicateContext;
exports.AbbreviatedStepContext = AbbreviatedStepContext;
xpathParser.AbbreviatedStepContext = AbbreviatedStepContext;
exports.ExprContext = ExprContext;
xpathParser.ExprContext = ExprContext;
exports.PrimaryExprContext = PrimaryExprContext;
xpathParser.PrimaryExprContext = PrimaryExprContext;
exports.FunctionCallContext = FunctionCallContext;
xpathParser.FunctionCallContext = FunctionCallContext;
exports.UnionExprNoRootContext = UnionExprNoRootContext;
xpathParser.UnionExprNoRootContext = UnionExprNoRootContext;
exports.PathExprNoRootContext = PathExprNoRootContext;
xpathParser.PathExprNoRootContext = PathExprNoRootContext;
exports.FilterExprContext = FilterExprContext;
xpathParser.FilterExprContext = FilterExprContext;
exports.OrExprContext = OrExprContext;
xpathParser.OrExprContext = OrExprContext;
exports.AndExprContext = AndExprContext;
xpathParser.AndExprContext = AndExprContext;
exports.EqualityExprContext = EqualityExprContext;
xpathParser.EqualityExprContext = EqualityExprContext;
exports.RelationalExprContext = RelationalExprContext;
xpathParser.RelationalExprContext = RelationalExprContext;
exports.AdditiveExprContext = AdditiveExprContext;
xpathParser.AdditiveExprContext = AdditiveExprContext;
exports.MultiplicativeExprContext = MultiplicativeExprContext;
xpathParser.MultiplicativeExprContext = MultiplicativeExprContext;
exports.UnaryExprNoRootContext = UnaryExprNoRootContext;
xpathParser.UnaryExprNoRootContext = UnaryExprNoRootContext;
exports.QNameContext = QNameContext;
xpathParser.QNameContext = QNameContext;
exports.FunctionNameContext = FunctionNameContext;
xpathParser.FunctionNameContext = FunctionNameContext;
exports.VariableReferenceContext = VariableReferenceContext;
xpathParser.VariableReferenceContext = VariableReferenceContext;
exports.NameTestContext = NameTestContext;
xpathParser.NameTestContext = NameTestContext;
exports.NCNameContext = NCNameContext;
xpathParser.NCNameContext = NCNameContext;

},{"./xpathListener":37,"./xpathVisitor":39,"antlr4/index":84}],39:[function(require,module,exports){
// Generated from xpath.g4 by ANTLR 4.7
// jshint ignore: start
var antlr4 = require('antlr4/index');

// This class defines a complete generic visitor for a parse tree produced by xpathParser.

function xpathVisitor() {
	antlr4.tree.ParseTreeVisitor.call(this);
	return this;
}

xpathVisitor.prototype = Object.create(antlr4.tree.ParseTreeVisitor.prototype);
xpathVisitor.prototype.constructor = xpathVisitor;

// Visit a parse tree produced by xpathParser#main.
xpathVisitor.prototype.visitMain = function(ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by xpathParser#locationPath.
xpathVisitor.prototype.visitLocationPath = function(ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by xpathParser#absoluteLocationPathNoroot.
xpathVisitor.prototype.visitAbsoluteLocationPathNoroot = function(ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by xpathParser#relativeLocationPath.
xpathVisitor.prototype.visitRelativeLocationPath = function(ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by xpathParser#step.
xpathVisitor.prototype.visitStep = function(ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by xpathParser#axisSpecifier.
xpathVisitor.prototype.visitAxisSpecifier = function(ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by xpathParser#nodeTest.
xpathVisitor.prototype.visitNodeTest = function(ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by xpathParser#predicate.
xpathVisitor.prototype.visitPredicate = function(ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by xpathParser#abbreviatedStep.
xpathVisitor.prototype.visitAbbreviatedStep = function(ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by xpathParser#expr.
xpathVisitor.prototype.visitExpr = function(ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by xpathParser#primaryExpr.
xpathVisitor.prototype.visitPrimaryExpr = function(ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by xpathParser#functionCall.
xpathVisitor.prototype.visitFunctionCall = function(ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by xpathParser#unionExprNoRoot.
xpathVisitor.prototype.visitUnionExprNoRoot = function(ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by xpathParser#pathExprNoRoot.
xpathVisitor.prototype.visitPathExprNoRoot = function(ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by xpathParser#filterExpr.
xpathVisitor.prototype.visitFilterExpr = function(ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by xpathParser#orExpr.
xpathVisitor.prototype.visitOrExpr = function(ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by xpathParser#andExpr.
xpathVisitor.prototype.visitAndExpr = function(ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by xpathParser#equalityExpr.
xpathVisitor.prototype.visitEqualityExpr = function(ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by xpathParser#relationalExpr.
xpathVisitor.prototype.visitRelationalExpr = function(ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by xpathParser#additiveExpr.
xpathVisitor.prototype.visitAdditiveExpr = function(ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by xpathParser#multiplicativeExpr.
xpathVisitor.prototype.visitMultiplicativeExpr = function(ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by xpathParser#unaryExprNoRoot.
xpathVisitor.prototype.visitUnaryExprNoRoot = function(ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by xpathParser#qName.
xpathVisitor.prototype.visitQName = function(ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by xpathParser#functionName.
xpathVisitor.prototype.visitFunctionName = function(ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by xpathParser#variableReference.
xpathVisitor.prototype.visitVariableReference = function(ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by xpathParser#nameTest.
xpathVisitor.prototype.visitNameTest = function(ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by xpathParser#nCName.
xpathVisitor.prototype.visitNCName = function(ctx) {
  return this.visitChildren(ctx);
};



exports.xpathVisitor = xpathVisitor;
},{"antlr4/index":84}],40:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var path_node_1 = require("./path-node");
var PathExpr = /** @class */ (function () {
    function PathExpr(pathRule) {
        this.pathRule = pathRule;
        if (pathRule) {
            this.initNodes();
        }
        else {
            var node = new path_node_1.PathNode(true, '/', undefined, false, false, false, undefined);
            this.nodes = [];
            this.nodes.push(node);
        }
    }
    PathExpr.prototype.getNodes = function () {
        return this.nodes;
    };
    PathExpr.prototype.isAbsolutePath = function () {
        return this.pathRule === undefined || this.pathRule.findRuleByName('absoluteLocationPathNoroot') !== undefined || this.pathRule.getText().trim() === '/';
    };
    PathExpr.prototype.initNodes = function () {
        var _this = this;
        this.nodes = [];
        var pathText = this.pathRule.getText().trim();
        if (pathText !== '/' && pathText !== '..' && pathText !== '.') {
            var relativeLocationPath = this.pathRule.findRuleByName('relativeLocationPath');
            var absoluteLocationPathNoroot = this.pathRule.findRuleByName('absoluteLocationPathNoroot');
            var children = relativeLocationPath.getChildren();
            var pathDelimiters_1 = relativeLocationPath.getTokens();
            if (this.isAbsolutePath()) {
                var rootDelimiter = absoluteLocationPathNoroot.getTokens()[0];
                var n = children.length;
                for (var i = 0; i < n; i++) {
                    var child = children[i];
                    var nameTest = child.findRuleByName('nameTest');
                    var axisSpecifier = child.findRuleByName('axisSpecifier');
                    var abbreviatedStep = child.findRuleByName('abbreviatedStep');
                    var isAbbreviatedStep = abbreviatedStep !== undefined;
                    var isSingleDot = (isAbbreviatedStep && abbreviatedStep.getText().trim() === '.');
                    var isParent = (isAbbreviatedStep && abbreviatedStep.getText().trim() === '..');
                    var isRoot = i === 0;
                    var name_1 = (isAbbreviatedStep) ? abbreviatedStep.getText() : nameTest.getText();
                    var predicate = child.findRuleByName('predicate');
                    var selectAll = isRoot ? this.isSelectAll(rootDelimiter) : this.isSelectAll(pathDelimiters_1[i - 1]);
                    var node = new path_node_1.PathNode(isRoot, name_1, axisSpecifier, selectAll, isSingleDot, isParent, predicate);
                    this.nodes.push(node);
                }
            }
            else {
                children.forEach(function (child, i) {
                    var abbreviatedStep = child.findRuleByName('abbreviatedStep');
                    var nameTest = child.findRuleByName('nameTest');
                    var axisSpecifier = child.findRuleByName('axisSpecifier');
                    var isAbbreviatedStep = abbreviatedStep !== undefined;
                    var isSingleDot = (isAbbreviatedStep && abbreviatedStep.getText().trim() === '.');
                    var isParent = (isAbbreviatedStep && abbreviatedStep.getText().trim() === '..');
                    var predicate = child.findRuleByName('predicate');
                    var name = (isAbbreviatedStep) ? abbreviatedStep.getText() : nameTest.getText();
                    if (i === 0) {
                        var node = new path_node_1.PathNode(false, name, axisSpecifier, false, isSingleDot, isParent, predicate);
                        _this.nodes.push(node);
                    }
                    else {
                        var selectAll = _this.isSelectAll(pathDelimiters_1[i - 1]);
                        var node = new path_node_1.PathNode(false, name, axisSpecifier, selectAll, isSingleDot, isParent, predicate);
                        _this.nodes.push(node);
                    }
                });
            }
        }
        else if (pathText === '/' || pathText === '.') {
            var abbreviatedStep = this.pathRule.findRuleByName('abbreviatedStep');
            var isAbbreviatedStep = abbreviatedStep !== undefined;
            var isSingleDot = (isAbbreviatedStep && abbreviatedStep.getText().trim() === '.');
            var node = new path_node_1.PathNode(true, pathText, undefined, false, isSingleDot, false, undefined);
            this.nodes.push(node);
        }
    };
    PathExpr.prototype.isSelectAll = function (token) {
        return token.getText().trim() === '//';
    };
    return PathExpr;
}());
exports.PathExpr = PathExpr;

},{"./path-node":41}],41:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var expr_evaluator_1 = require("./expr-evaluator");
var _ = require("lodash");
var PathNode = /** @class */ (function () {
    function PathNode(isRoot, name, axisSpecifier, selectAllDescendants, isSingleDot, isParent, predicateRule) {
        this.isRoot = isRoot;
        this.name = name;
        this.axisSpecifier = axisSpecifier;
        this.selectAllDescendants = selectAllDescendants;
        this.isSingleDot = isSingleDot;
        this.isParent = isParent;
        this.predicateRule = predicateRule;
    }
    PathNode.prototype.testNodeWithPredicate = function (rule, index, numberOfElement) {
        if (this.predicateRule) {
            var primaryExpr = this.predicateRule.findRuleByName('primaryExpr');
            var relationalExpr = this.predicateRule.findRuleByName('relationalExpr');
            if (relationalExpr) {
                var additiveExprs = relationalExpr.findRulesByName('additiveExpr').reverse();
                var op = relationalExpr.getTokens()[0].getText();
                var lhs = this.evaluateExpr(additiveExprs[0], rule, index, numberOfElement);
                var rhs = this.evaluateExpr(additiveExprs[1], rule, index, numberOfElement);
                if (_.isNil(rhs) || _.isNil(lhs)) {
                    return true;
                }
                lhs = Number(lhs);
                rhs = Number(rhs);
                switch (op) {
                    case '<':
                        return lhs < rhs;
                    case '<=':
                        return lhs <= rhs;
                    case '>':
                        return lhs > rhs;
                    case '>=':
                        return lhs >= rhs;
                }
            }
            else if (primaryExpr) {
                var numberTokens = primaryExpr.getTokens('Number');
                var functionCall = primaryExpr.findRuleByName('functionCall');
                if (functionCall) {
                    return this.callPredicateFunction(functionCall, rule, index, numberOfElement);
                }
                else if (numberTokens.length > 0) {
                    var num = Number(numberTokens[0].getText());
                    return index === num;
                }
            }
        }
        return true;
    };
    PathNode.prototype.evaluateExpr = function (expr, rule, index, numberOfElement) {
        var evaluator = new expr_evaluator_1.ExprEvaluator(expr, rule, index, numberOfElement);
        return evaluator.evaluate();
    };
    PathNode.prototype.callPredicateFunction = function (functionCall, rule, index, numberOfElement) {
        var parts = functionCall.getChildren();
        // const tokens = functionCall.getTokens();
        var name = parts[0].getText();
        switch (name) {
            case 'last':
                return index === (numberOfElement - 1);
        }
        return true;
    };
    return PathNode;
}());
exports.PathNode = PathNode;

},{"./expr-evaluator":35,"lodash":111}],42:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var __1 = require("../");
var functions_1 = require("../functions");
var xpathLexer_1 = require("./parser/xpathLexer");
var xpathParser_1 = require("./parser/xpathParser");
var path_expr_1 = require("./path-expr");
var _ = require("lodash");
var XPath = /** @class */ (function () {
    function XPath(root) {
        this.root = root;
        this.xpathParser = this.createXPathParser();
    }
    XPath.prototype.findRulesByPath = function (path) {
        var _this = this;
        this.xpathParser.parse(path);
        if (this.xpathParser.hasErrors()) {
            return [];
        }
        this.xpathParser.checkForErrors();
        var pathExprs = this.createPathExprs();
        return _.flatten(pathExprs.map(function (expr) { return _this.processPathExpr(expr); }));
    };
    XPath.prototype.isAbsolutePath = function () {
        return this.xpathParser.findRuleByName('absoluteLocationPathNoroot') !== undefined;
    };
    XPath.prototype.processPathExpr = function (pathExpr) {
        var _this = this;
        var lastNodes = [];
        var pathNodes = pathExpr.getNodes();
        pathNodes.forEach(function (node) {
            if (node.isRoot) {
                var rootNode = _this.root;
                if (node.name === '/' || node.name === '.' || node.name === '*') {
                    var children = rootNode.getChildren();
                    var n_1 = children.length;
                    lastNodes = children.filter((function (rule, i) { return node.testNodeWithPredicate(rule, i, n_1); }));
                }
                else {
                    var children = rootNode.getChildren();
                    var n_2 = children.length;
                    lastNodes = children
                        .filter(function (childOfRoot) { return childOfRoot.getName() === node.name; })
                        .filter((function (rule, i) { return node.testNodeWithPredicate(rule, i, n_2); }));
                }
            }
            else {
                if (lastNodes.length > 0) {
                    if (node.isSingleDot) {
                        //
                        // 	Select the current node
                        //
                        return;
                    }
                    var nodes_1 = [];
                    var childNodes = void 0;
                    if (node.selectAllDescendants) {
                        //
                        // Select all descendant nodes
                        //
                        childNodes = _.flatten(lastNodes.map(function (lastNode) {
                            if (node.isParent) {
                                if (lastNode.getParent()) {
                                    return lastNode.getParent().findRulesByName(node.name);
                                }
                            }
                            else {
                                return lastNode.findRulesByName(node.name);
                            }
                        })
                            .filter(function (rules) { return !!rules; })
                            .map(function (rules) {
                            var n = rules.length;
                            var children = rules.filter(function (rule, i) { return node.testNodeWithPredicate(rule, i, n); });
                            return children;
                        }));
                    }
                    else {
                        //
                        // Select all child nodes
                        //
                        var nodeList = lastNodes
                            .map(function (rules) {
                            if (node.isParent) {
                                if (rules.getParent()) {
                                    return rules.getParent().getChildren();
                                }
                            }
                            else {
                                return rules.getChildren();
                            }
                        })
                            .filter(function (rules) { return !!rules; })
                            .map(function (rules) {
                            var n = rules.length;
                            var children = rules.filter(function (rule, i) { return node.testNodeWithPredicate(rule, i, n); });
                            return children;
                        });
                        childNodes = _.flatten(nodeList);
                    }
                    childNodes.forEach(function (child) {
                        if (node.name === '*') {
                            nodes_1.push(child);
                        }
                        else if (node.name === child.getName()) {
                            nodes_1.push(child);
                        }
                    });
                    lastNodes = nodes_1;
                }
                else if (node.isSingleDot || node.name === '*') {
                    //
                    // If the first path node is a dot, then select the root rules
                    //
                    var rules = _this.root.getChildren();
                    lastNodes = rules;
                }
                else {
                    //
                    // If the first path node is a relative name, then select the root rules
                    //
                    var rules = _this.root.getChildren().filter(function (rule) { return rule.getName() === node.name; });
                    lastNodes = rules;
                }
            }
        });
        return lastNodes;
    };
    XPath.prototype.createPathExprs = function () {
        var pathExprs = [];
        var orExpr = this.xpathParser.findRuleByName('orExpr');
        var unionExprNoRoot = orExpr.findRuleByName('unionExprNoRoot');
        var tokens = unionExprNoRoot.getTokens();
        var tokenTextList = unionExprNoRoot.getTokens().map(function (t) { return t.getText(); }).filter(function (str) { return str === '/'; });
        if (unionExprNoRoot) {
            unionExprNoRoot.getChildren()
                .forEach(function (rule) {
                var children = rule.getChildren();
                if (children.length === 1) {
                    pathExprs.push(new path_expr_1.PathExpr(rule));
                }
                else {
                    children.forEach(function (rule1) {
                        pathExprs.push(new path_expr_1.PathExpr(rule1));
                    });
                }
            });
            if (tokenTextList.length > 0) {
                pathExprs.push(new path_expr_1.PathExpr(undefined));
            }
        }
        else {
            pathExprs.push(new path_expr_1.PathExpr(this.xpathParser.getRoot()));
        }
        return pathExprs;
    };
    XPath.prototype.createXPathParser = function () {
        var factory = functions_1.createFactoryBuilder()
            .lexer(function (input) { return new xpathLexer_1.xpathLexer(input); })
            .parser(function (input) { return new xpathParser_1.xpathParser(input); })
            .rootRule(function (parser) { return parser.main(); })
            .build();
        return new __1.ImmutableAntlrParser(factory);
    };
    return XPath;
}());
exports.XPath = XPath;

},{"../":20,"../functions":19,"./parser/xpathLexer":36,"./parser/xpathParser":38,"./path-expr":40,"lodash":111}],43:[function(require,module,exports){
//
/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

// This implementation of {@link TokenStream} loads tokens from a
// {@link TokenSource} on-demand, and places the tokens in a buffer to provide
// access to any previous token by index.
//
// <p>
// This token stream ignores the value of {@link Token//getChannel}. If your
// parser requires the token stream filter tokens to only those on a particular
// channel, such as {@link Token//DEFAULT_CHANNEL} or
// {@link Token//HIDDEN_CHANNEL}, use a filtering token stream such a
// {@link CommonTokenStream}.</p>

var Token = require('./Token').Token;
var Lexer = require('./Lexer').Lexer;
var Interval = require('./IntervalSet').Interval;

// this is just to keep meaningful parameter types to Parser
function TokenStream() {
	return this;
}

function BufferedTokenStream(tokenSource) {

	TokenStream.call(this);
	// The {@link TokenSource} from which tokens for this stream are fetched.
	this.tokenSource = tokenSource;

	// A collection of all tokens fetched from the token source. The list is
	// considered a complete view of the input once {@link //fetchedEOF} is set
	// to {@code true}.
	this.tokens = [];

	// The index into {@link //tokens} of the current token (next token to
	// {@link //consume}). {@link //tokens}{@code [}{@link //p}{@code ]} should
	// be
	// {@link //LT LT(1)}.
	//
	// <p>This field is set to -1 when the stream is first constructed or when
	// {@link //setTokenSource} is called, indicating that the first token has
	// not yet been fetched from the token source. For additional information,
	// see the documentation of {@link IntStream} for a description of
	// Initializing Methods.</p>
	this.index = -1;

	// Indicates whether the {@link Token//EOF} token has been fetched from
	// {@link //tokenSource} and added to {@link //tokens}. This field improves
	// performance for the following cases:
	//
	// <ul>
	// <li>{@link //consume}: The lookahead check in {@link //consume} to
	// prevent
	// consuming the EOF symbol is optimized by checking the values of
	// {@link //fetchedEOF} and {@link //p} instead of calling {@link
	// //LA}.</li>
	// <li>{@link //fetch}: The check to prevent adding multiple EOF symbols
	// into
	// {@link //tokens} is trivial with this field.</li>
	// <ul>
	this.fetchedEOF = false;
	return this;
}

BufferedTokenStream.prototype = Object.create(TokenStream.prototype);
BufferedTokenStream.prototype.constructor = BufferedTokenStream;

BufferedTokenStream.prototype.mark = function() {
	return 0;
};

BufferedTokenStream.prototype.release = function(marker) {
	// no resources to release
};

BufferedTokenStream.prototype.reset = function() {
	this.seek(0);
};

BufferedTokenStream.prototype.seek = function(index) {
	this.lazyInit();
	this.index = this.adjustSeekIndex(index);
};

BufferedTokenStream.prototype.get = function(index) {
	this.lazyInit();
	return this.tokens[index];
};

BufferedTokenStream.prototype.consume = function() {
	var skipEofCheck = false;
	if (this.index >= 0) {
		if (this.fetchedEOF) {
			// the last token in tokens is EOF. skip check if p indexes any
			// fetched token except the last.
			skipEofCheck = this.index < this.tokens.length - 1;
		} else {
			// no EOF token in tokens. skip check if p indexes a fetched token.
			skipEofCheck = this.index < this.tokens.length;
		}
	} else {
		// not yet initialized
		skipEofCheck = false;
	}
	if (!skipEofCheck && this.LA(1) === Token.EOF) {
		throw "cannot consume EOF";
	}
	if (this.sync(this.index + 1)) {
		this.index = this.adjustSeekIndex(this.index + 1);
	}
};

// Make sure index {@code i} in tokens has a token.
//
// @return {@code true} if a token is located at index {@code i}, otherwise
// {@code false}.
// @see //get(int i)
// /
BufferedTokenStream.prototype.sync = function(i) {
	var n = i - this.tokens.length + 1; // how many more elements we need?
	if (n > 0) {
		var fetched = this.fetch(n);
		return fetched >= n;
	}
	return true;
};

// Add {@code n} elements to buffer.
//
// @return The actual number of elements added to the buffer.
// /
BufferedTokenStream.prototype.fetch = function(n) {
	if (this.fetchedEOF) {
		return 0;
	}
	for (var i = 0; i < n; i++) {
		var t = this.tokenSource.nextToken();
		t.tokenIndex = this.tokens.length;
		this.tokens.push(t);
		if (t.type === Token.EOF) {
			this.fetchedEOF = true;
			return i + 1;
		}
	}
	return n;
};

// Get all tokens from start..stop inclusively///
BufferedTokenStream.prototype.getTokens = function(start, stop, types) {
	if (types === undefined) {
		types = null;
	}
	if (start < 0 || stop < 0) {
		return null;
	}
	this.lazyInit();
	var subset = [];
	if (stop >= this.tokens.length) {
		stop = this.tokens.length - 1;
	}
	for (var i = start; i < stop; i++) {
		var t = this.tokens[i];
		if (t.type === Token.EOF) {
			break;
		}
		if (types === null || types.contains(t.type)) {
			subset.push(t);
		}
	}
	return subset;
};

BufferedTokenStream.prototype.LA = function(i) {
	return this.LT(i).type;
};

BufferedTokenStream.prototype.LB = function(k) {
	if (this.index - k < 0) {
		return null;
	}
	return this.tokens[this.index - k];
};

BufferedTokenStream.prototype.LT = function(k) {
	this.lazyInit();
	if (k === 0) {
		return null;
	}
	if (k < 0) {
		return this.LB(-k);
	}
	var i = this.index + k - 1;
	this.sync(i);
	if (i >= this.tokens.length) { // return EOF token
		// EOF must be last token
		return this.tokens[this.tokens.length - 1];
	}
	return this.tokens[i];
};

// Allowed derived classes to modify the behavior of operations which change
// the current stream position by adjusting the target token index of a seek
// operation. The default implementation simply returns {@code i}. If an
// exception is thrown in this method, the current stream index should not be
// changed.
//
// <p>For example, {@link CommonTokenStream} overrides this method to ensure
// that
// the seek target is always an on-channel token.</p>
//
// @param i The target token index.
// @return The adjusted target token index.

BufferedTokenStream.prototype.adjustSeekIndex = function(i) {
	return i;
};

BufferedTokenStream.prototype.lazyInit = function() {
	if (this.index === -1) {
		this.setup();
	}
};

BufferedTokenStream.prototype.setup = function() {
	this.sync(0);
	this.index = this.adjustSeekIndex(0);
};

// Reset this token stream by setting its token source.///
BufferedTokenStream.prototype.setTokenSource = function(tokenSource) {
	this.tokenSource = tokenSource;
	this.tokens = [];
	this.index = -1;
	this.fetchedEOF = false;
};


// Given a starting index, return the index of the next token on channel.
// Return i if tokens[i] is on channel. Return -1 if there are no tokens
// on channel between i and EOF.
// /
BufferedTokenStream.prototype.nextTokenOnChannel = function(i, channel) {
	this.sync(i);
	if (i >= this.tokens.length) {
		return -1;
	}
	var token = this.tokens[i];
	while (token.channel !== this.channel) {
		if (token.type === Token.EOF) {
			return -1;
		}
		i += 1;
		this.sync(i);
		token = this.tokens[i];
	}
	return i;
};

// Given a starting index, return the index of the previous token on channel.
// Return i if tokens[i] is on channel. Return -1 if there are no tokens
// on channel between i and 0.
BufferedTokenStream.prototype.previousTokenOnChannel = function(i, channel) {
	while (i >= 0 && this.tokens[i].channel !== channel) {
		i -= 1;
	}
	return i;
};

// Collect all tokens on specified channel to the right of
// the current token up until we see a token on DEFAULT_TOKEN_CHANNEL or
// EOF. If channel is -1, find any non default channel token.
BufferedTokenStream.prototype.getHiddenTokensToRight = function(tokenIndex,
		channel) {
	if (channel === undefined) {
		channel = -1;
	}
	this.lazyInit();
	if (tokenIndex < 0 || tokenIndex >= this.tokens.length) {
		throw "" + tokenIndex + " not in 0.." + this.tokens.length - 1;
	}
	var nextOnChannel = this.nextTokenOnChannel(tokenIndex + 1, Lexer.DEFAULT_TOKEN_CHANNEL);
	var from_ = tokenIndex + 1;
	// if none onchannel to right, nextOnChannel=-1 so set to = last token
	var to = nextOnChannel === -1 ? this.tokens.length - 1 : nextOnChannel;
	return this.filterForChannel(from_, to, channel);
};

// Collect all tokens on specified channel to the left of
// the current token up until we see a token on DEFAULT_TOKEN_CHANNEL.
// If channel is -1, find any non default channel token.
BufferedTokenStream.prototype.getHiddenTokensToLeft = function(tokenIndex,
		channel) {
	if (channel === undefined) {
		channel = -1;
	}
	this.lazyInit();
	if (tokenIndex < 0 || tokenIndex >= this.tokens.length) {
		throw "" + tokenIndex + " not in 0.." + this.tokens.length - 1;
	}
	var prevOnChannel = this.previousTokenOnChannel(tokenIndex - 1, Lexer.DEFAULT_TOKEN_CHANNEL);
	if (prevOnChannel === tokenIndex - 1) {
		return null;
	}
	// if none on channel to left, prevOnChannel=-1 then from=0
	var from_ = prevOnChannel + 1;
	var to = tokenIndex - 1;
	return this.filterForChannel(from_, to, channel);
};

BufferedTokenStream.prototype.filterForChannel = function(left, right, channel) {
	var hidden = [];
	for (var i = left; i < right + 1; i++) {
		var t = this.tokens[i];
		if (channel === -1) {
			if (t.channel !== Lexer.DEFAULT_TOKEN_CHANNEL) {
				hidden.push(t);
			}
		} else if (t.channel === channel) {
			hidden.push(t);
		}
	}
	if (hidden.length === 0) {
		return null;
	}
	return hidden;
};

BufferedTokenStream.prototype.getSourceName = function() {
	return this.tokenSource.getSourceName();
};

// Get the text of all tokens in this buffer.///
BufferedTokenStream.prototype.getText = function(interval) {
	this.lazyInit();
	this.fill();
	if (interval === undefined || interval === null) {
		interval = new Interval(0, this.tokens.length - 1);
	}
	var start = interval.start;
	if (start instanceof Token) {
		start = start.tokenIndex;
	}
	var stop = interval.stop;
	if (stop instanceof Token) {
		stop = stop.tokenIndex;
	}
	if (start === null || stop === null || start < 0 || stop < 0) {
		return "";
	}
	if (stop >= this.tokens.length) {
		stop = this.tokens.length - 1;
	}
	var s = "";
	for (var i = start; i < stop + 1; i++) {
		var t = this.tokens[i];
		if (t.type === Token.EOF) {
			break;
		}
		s = s + t.text;
	}
	return s;
};

// Get all tokens from lexer until EOF///
BufferedTokenStream.prototype.fill = function() {
	this.lazyInit();
	while (this.fetch(1000) === 1000) {
		continue;
	}
};

exports.BufferedTokenStream = BufferedTokenStream;

},{"./IntervalSet":49,"./Lexer":51,"./Token":57}],44:[function(require,module,exports){
//
/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
//

var InputStream = require('./InputStream').InputStream;

var isNodeJs = typeof window === 'undefined' && typeof importScripts === 'undefined';
var fs = isNodeJs ? require("fs") : null;

// Utility functions to create InputStreams from various sources.
//
// All returned InputStreams support the full range of Unicode
// up to U+10FFFF (the default behavior of InputStream only supports
// code points up to U+FFFF).
var CharStreams = {
  // Creates an InputStream from a string.
  fromString: function(str) {
    return new InputStream(str, true);
  },

  // Asynchronously creates an InputStream from a blob given the
  // encoding of the bytes in that blob (defaults to 'utf8' if
  // encoding is null).
  //
  // Invokes onLoad(result) on success, onError(error) on
  // failure.
  fromBlob: function(blob, encoding, onLoad, onError) {
    var reader = FileReader();
    reader.onload = function(e) {
      var is = new InputStream(e.target.result, true);
      onLoad(is);
    };
    reader.onerror = onError;
    reader.readAsText(blob, encoding);
  },

  // Creates an InputStream from a Buffer given the
  // encoding of the bytes in that buffer (defaults to 'utf8' if
  // encoding is null).
  fromBuffer: function(buffer, encoding) {
    return new InputStream(buffer.toString(encoding), true);
  },

  // Asynchronously creates an InputStream from a file on disk given
  // the encoding of the bytes in that file (defaults to 'utf8' if
  // encoding is null).
  //
  // Invokes callback(error, result) on completion.
  fromPath: function(path, encoding, callback) {
    fs.readFile(path, encoding, function(err, data) {
      var is = null;
      if (data !== null) {
        is = new InputStream(data, true);
      }
      callback(err, is);
    });
  },

  // Synchronously creates an InputStream given a path to a file
  // on disk and the encoding of the bytes in that file (defaults to
  // 'utf8' if encoding is null).
  fromPathSync: function(path, encoding) {
    var data = fs.readFileSync(path, encoding);
    return new InputStream(data, true);
  }
};

exports.CharStreams = CharStreams;

},{"./InputStream":48,"fs":90}],45:[function(require,module,exports){
//
/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
//

//
// This default implementation of {@link TokenFactory} creates
// {@link CommonToken} objects.
//

var CommonToken = require('./Token').CommonToken;

function TokenFactory() {
	return this;
}

function CommonTokenFactory(copyText) {
	TokenFactory.call(this);
    // Indicates whether {@link CommonToken//setText} should be called after
    // constructing tokens to explicitly set the text. This is useful for cases
    // where the input stream might not be able to provide arbitrary substrings
    // of text from the input after the lexer creates a token (e.g. the
    // implementation of {@link CharStream//getText} in
    // {@link UnbufferedCharStream} throws an
    // {@link UnsupportedOperationException}). Explicitly setting the token text
    // allows {@link Token//getText} to be called at any time regardless of the
    // input stream implementation.
    //
    // <p>
    // The default value is {@code false} to avoid the performance and memory
    // overhead of copying text for every token unless explicitly requested.</p>
    //
    this.copyText = copyText===undefined ? false : copyText;
	return this;
}

CommonTokenFactory.prototype = Object.create(TokenFactory.prototype);
CommonTokenFactory.prototype.constructor = CommonTokenFactory;

//
// The default {@link CommonTokenFactory} instance.
//
// <p>
// This token factory does not explicitly copy token text when constructing
// tokens.</p>
//
CommonTokenFactory.DEFAULT = new CommonTokenFactory();

CommonTokenFactory.prototype.create = function(source, type, text, channel, start, stop, line, column) {
    var t = new CommonToken(source, type, channel, start, stop);
    t.line = line;
    t.column = column;
    if (text !==null) {
        t.text = text;
    } else if (this.copyText && source[1] !==null) {
        t.text = source[1].getText(start,stop);
    }
    return t;
};

CommonTokenFactory.prototype.createThin = function(type, text) {
    var t = new CommonToken(null, type);
    t.text = text;
    return t;
};

exports.CommonTokenFactory = CommonTokenFactory;

},{"./Token":57}],46:[function(require,module,exports){
//
/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
///

//
// This class extends {@link BufferedTokenStream} with functionality to filter
// token streams to tokens on a particular channel (tokens where
// {@link Token//getChannel} returns a particular value).
//
// <p>
// This token stream provides access to all tokens by index or when calling
// methods like {@link //getText}. The channel filtering is only used for code
// accessing tokens via the lookahead methods {@link //LA}, {@link //LT}, and
// {@link //LB}.</p>
//
// <p>
// By default, tokens are placed on the default channel
// ({@link Token//DEFAULT_CHANNEL}), but may be reassigned by using the
// {@code ->channel(HIDDEN)} lexer command, or by using an embedded action to
// call {@link Lexer//setChannel}.
// </p>
//
// <p>
// Note: lexer rules which use the {@code ->skip} lexer command or call
// {@link Lexer//skip} do not produce tokens at all, so input text matched by
// such a rule will not be available as part of the token stream, regardless of
// channel.</p>
///

var Token = require('./Token').Token;
var BufferedTokenStream = require('./BufferedTokenStream').BufferedTokenStream;

function CommonTokenStream(lexer, channel) {
	BufferedTokenStream.call(this, lexer);
    this.channel = channel===undefined ? Token.DEFAULT_CHANNEL : channel;
    return this;
}

CommonTokenStream.prototype = Object.create(BufferedTokenStream.prototype);
CommonTokenStream.prototype.constructor = CommonTokenStream;

CommonTokenStream.prototype.adjustSeekIndex = function(i) {
    return this.nextTokenOnChannel(i, this.channel);
};

CommonTokenStream.prototype.LB = function(k) {
    if (k===0 || this.index-k<0) {
        return null;
    }
    var i = this.index;
    var n = 1;
    // find k good tokens looking backwards
    while (n <= k) {
        // skip off-channel tokens
        i = this.previousTokenOnChannel(i - 1, this.channel);
        n += 1;
    }
    if (i < 0) {
        return null;
    }
    return this.tokens[i];
};

CommonTokenStream.prototype.LT = function(k) {
    this.lazyInit();
    if (k === 0) {
        return null;
    }
    if (k < 0) {
        return this.LB(-k);
    }
    var i = this.index;
    var n = 1; // we know tokens[pos] is a good one
    // find k good tokens
    while (n < k) {
        // skip off-channel tokens, but make sure to not look past EOF
        if (this.sync(i + 1)) {
            i = this.nextTokenOnChannel(i + 1, this.channel);
        }
        n += 1;
    }
    return this.tokens[i];
};

// Count EOF just once.///
CommonTokenStream.prototype.getNumberOfOnChannelTokens = function() {
    var n = 0;
    this.fill();
    for (var i =0; i< this.tokens.length;i++) {
        var t = this.tokens[i];
        if( t.channel===this.channel) {
            n += 1;
        }
        if( t.type===Token.EOF) {
            break;
        }
    }
    return n;
};

exports.CommonTokenStream = CommonTokenStream;
},{"./BufferedTokenStream":43,"./Token":57}],47:[function(require,module,exports){
//
/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
//

//
//  This is an InputStream that is loaded from a file all at once
//  when you construct the object.
//
var InputStream = require('./InputStream').InputStream;
var isNodeJs = typeof window === 'undefined' && typeof importScripts === 'undefined';
var fs = isNodeJs ? require("fs") : null;

function FileStream(fileName, decodeToUnicodeCodePoints) {
	var data = fs.readFileSync(fileName, "utf8");
	InputStream.call(this, data, decodeToUnicodeCodePoints);
	this.fileName = fileName;
	return this;
}

FileStream.prototype = Object.create(InputStream.prototype);
FileStream.prototype.constructor = FileStream;

exports.FileStream = FileStream;

},{"./InputStream":48,"fs":90}],48:[function(require,module,exports){
//
/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
//

var Token = require('./Token').Token;
require('./polyfills/codepointat');
require('./polyfills/fromcodepoint');

// Vacuum all input from a string and then treat it like a buffer.

function _loadString(stream) {
	stream._index = 0;
	stream.data = [];
	if (stream.decodeToUnicodeCodePoints) {
		for (var i = 0; i < stream.strdata.length; ) {
			var codePoint = stream.strdata.codePointAt(i);
			stream.data.push(codePoint);
			i += codePoint <= 0xFFFF ? 1 : 2;
		}
	} else {
		for (var i = 0; i < stream.strdata.length; i++) {
			var codeUnit = stream.strdata.charCodeAt(i);
			stream.data.push(codeUnit);
		}
	}
	stream._size = stream.data.length;
}

// If decodeToUnicodeCodePoints is true, the input is treated
// as a series of Unicode code points.
//
// Otherwise, the input is treated as a series of 16-bit UTF-16 code
// units.
function InputStream(data, decodeToUnicodeCodePoints) {
	this.name = "<empty>";
	this.strdata = data;
	this.decodeToUnicodeCodePoints = decodeToUnicodeCodePoints || false;
	_loadString(this);
	return this;
}

Object.defineProperty(InputStream.prototype, "index", {
	get : function() {
		return this._index;
	}
});

Object.defineProperty(InputStream.prototype, "size", {
	get : function() {
		return this._size;
	}
});

// Reset the stream so that it's in the same state it was
// when the object was created *except* the data array is not
// touched.
//
InputStream.prototype.reset = function() {
	this._index = 0;
};

InputStream.prototype.consume = function() {
	if (this._index >= this._size) {
		// assert this.LA(1) == Token.EOF
		throw ("cannot consume EOF");
	}
	this._index += 1;
};

InputStream.prototype.LA = function(offset) {
	if (offset === 0) {
		return 0; // undefined
	}
	if (offset < 0) {
		offset += 1; // e.g., translate LA(-1) to use offset=0
	}
	var pos = this._index + offset - 1;
	if (pos < 0 || pos >= this._size) { // invalid
		return Token.EOF;
	}
	return this.data[pos];
};

InputStream.prototype.LT = function(offset) {
	return this.LA(offset);
};

// mark/release do nothing; we have entire buffer
InputStream.prototype.mark = function() {
	return -1;
};

InputStream.prototype.release = function(marker) {
};

// consume() ahead until p==_index; can't just set p=_index as we must
// update line and column. If we seek backwards, just set p
//
InputStream.prototype.seek = function(_index) {
	if (_index <= this._index) {
		this._index = _index; // just jump; don't update stream state (line,
								// ...)
		return;
	}
	// seek forward
	this._index = Math.min(_index, this._size);
};

InputStream.prototype.getText = function(start, stop) {
	if (stop >= this._size) {
		stop = this._size - 1;
	}
	if (start >= this._size) {
		return "";
	} else {
		if (this.decodeToUnicodeCodePoints) {
			var result = "";
			for (var i = start; i <= stop; i++) {
				result += String.fromCodePoint(this.data[i]);
			}
			return result;
		} else {
			return this.strdata.slice(start, stop + 1);
		}
	}
};

InputStream.prototype.toString = function() {
	return this.strdata;
};

exports.InputStream = InputStream;

},{"./Token":57,"./polyfills/codepointat":85,"./polyfills/fromcodepoint":86}],49:[function(require,module,exports){
/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

/*jslint smarttabs:true */

var Token = require('./Token').Token;

/* stop is not included! */
function Interval(start, stop) {
	this.start = start;
	this.stop = stop;
	return this;
}

Interval.prototype.contains = function(item) {
	return item >= this.start && item < this.stop;
};

Interval.prototype.toString = function() {
	if(this.start===this.stop-1) {
		return this.start.toString();
	} else {
		return this.start.toString() + ".." + (this.stop-1).toString();
	}
};


Object.defineProperty(Interval.prototype, "length", {
	get : function() {
		return this.stop - this.start;
	}
});

function IntervalSet() {
	this.intervals = null;
	this.readOnly = false;
}

IntervalSet.prototype.first = function(v) {
	if (this.intervals === null || this.intervals.length===0) {
		return Token.INVALID_TYPE;
	} else {
		return this.intervals[0].start;
	}
};

IntervalSet.prototype.addOne = function(v) {
	this.addInterval(new Interval(v, v + 1));
};

IntervalSet.prototype.addRange = function(l, h) {
	this.addInterval(new Interval(l, h + 1));
};

IntervalSet.prototype.addInterval = function(v) {
	if (this.intervals === null) {
		this.intervals = [];
		this.intervals.push(v);
	} else {
		// find insert pos
		for (var k = 0; k < this.intervals.length; k++) {
			var i = this.intervals[k];
			// distinct range -> insert
			if (v.stop < i.start) {
				this.intervals.splice(k, 0, v);
				return;
			}
			// contiguous range -> adjust
			else if (v.stop === i.start) {
				this.intervals[k].start = v.start;
				return;
			}
			// overlapping range -> adjust and reduce
			else if (v.start <= i.stop) {
				this.intervals[k] = new Interval(Math.min(i.start, v.start), Math.max(i.stop, v.stop));
				this.reduce(k);
				return;
			}
		}
		// greater than any existing
		this.intervals.push(v);
	}
};

IntervalSet.prototype.addSet = function(other) {
	if (other.intervals !== null) {
		for (var k = 0; k < other.intervals.length; k++) {
			var i = other.intervals[k];
			this.addInterval(new Interval(i.start, i.stop));
		}
	}
	return this;
};

IntervalSet.prototype.reduce = function(k) {
	// only need to reduce if k is not the last
	if (k < this.intervalslength - 1) {
		var l = this.intervals[k];
		var r = this.intervals[k + 1];
		// if r contained in l
		if (l.stop >= r.stop) {
			this.intervals.pop(k + 1);
			this.reduce(k);
		} else if (l.stop >= r.start) {
			this.intervals[k] = new Interval(l.start, r.stop);
			this.intervals.pop(k + 1);
		}
	}
};

IntervalSet.prototype.complement = function(start, stop) {
    var result = new IntervalSet();
    result.addInterval(new Interval(start,stop+1));
    for(var i=0; i<this.intervals.length; i++) {
        result.removeRange(this.intervals[i]);
    }
    return result;
};

IntervalSet.prototype.contains = function(item) {
	if (this.intervals === null) {
		return false;
	} else {
		for (var k = 0; k < this.intervals.length; k++) {
			if(this.intervals[k].contains(item)) {
				return true;
			}
		}
		return false;
	}
};

Object.defineProperty(IntervalSet.prototype, "length", {
	get : function() {
		var len = 0;
		this.intervals.map(function(i) {len += i.length;});
		return len;
	}
});

IntervalSet.prototype.removeRange = function(v) {
    if(v.start===v.stop-1) {
        this.removeOne(v.start);
    } else if (this.intervals!==null) {
        var k = 0;
        for(var n=0; n<this.intervals.length; n++) {
            var i = this.intervals[k];
            // intervals are ordered
            if (v.stop<=i.start) {
                return;
            }
            // check for including range, split it
            else if(v.start>i.start && v.stop<i.stop) {
                this.intervals[k] = new Interval(i.start, v.start);
                var x = new Interval(v.stop, i.stop);
                this.intervals.splice(k, 0, x);
                return;
            }
            // check for included range, remove it
            else if(v.start<=i.start && v.stop>=i.stop) {
                this.intervals.splice(k, 1);
                k = k - 1; // need another pass
            }
            // check for lower boundary
            else if(v.start<i.stop) {
                this.intervals[k] = new Interval(i.start, v.start);
            }
            // check for upper boundary
            else if(v.stop<i.stop) {
                this.intervals[k] = new Interval(v.stop, i.stop);
            }
            k += 1;
        }
    }
};

IntervalSet.prototype.removeOne = function(v) {
	if (this.intervals !== null) {
		for (var k = 0; k < this.intervals.length; k++) {
			var i = this.intervals[k];
			// intervals is ordered
			if (v < i.start) {
				return;
			}
			// check for single value range
			else if (v === i.start && v === i.stop - 1) {
				this.intervals.splice(k, 1);
				return;
			}
			// check for lower boundary
			else if (v === i.start) {
				this.intervals[k] = new Interval(i.start + 1, i.stop);
				return;
			}
			// check for upper boundary
			else if (v === i.stop - 1) {
				this.intervals[k] = new Interval(i.start, i.stop - 1);
				return;
			}
			// split existing range
			else if (v < i.stop - 1) {
				var x = new Interval(i.start, v);
				i.start = v + 1;
				this.intervals.splice(k, 0, x);
				return;
			}
		}
	}
};

IntervalSet.prototype.toString = function(literalNames, symbolicNames, elemsAreChar) {
	literalNames = literalNames || null;
	symbolicNames = symbolicNames || null;
	elemsAreChar = elemsAreChar || false;
	if (this.intervals === null) {
		return "{}";
	} else if(literalNames!==null || symbolicNames!==null) {
		return this.toTokenString(literalNames, symbolicNames);
	} else if(elemsAreChar) {
		return this.toCharString();
	} else {
		return this.toIndexString();
	}
};

IntervalSet.prototype.toCharString = function() {
	var names = [];
	for (var i = 0; i < this.intervals.length; i++) {
		var v = this.intervals[i];
		if(v.stop===v.start+1) {
			if ( v.start===Token.EOF ) {
				names.push("<EOF>");
			} else {
				names.push("'" + String.fromCharCode(v.start) + "'");
			}
		} else {
			names.push("'" + String.fromCharCode(v.start) + "'..'" + String.fromCharCode(v.stop-1) + "'");
		}
	}
	if (names.length > 1) {
		return "{" + names.join(", ") + "}";
	} else {
		return names[0];
	}
};


IntervalSet.prototype.toIndexString = function() {
	var names = [];
	for (var i = 0; i < this.intervals.length; i++) {
		var v = this.intervals[i];
		if(v.stop===v.start+1) {
			if ( v.start===Token.EOF ) {
				names.push("<EOF>");
			} else {
				names.push(v.start.toString());
			}
		} else {
			names.push(v.start.toString() + ".." + (v.stop-1).toString());
		}
	}
	if (names.length > 1) {
		return "{" + names.join(", ") + "}";
	} else {
		return names[0];
	}
};


IntervalSet.prototype.toTokenString = function(literalNames, symbolicNames) {
	var names = [];
	for (var i = 0; i < this.intervals.length; i++) {
		var v = this.intervals[i];
		for (var j = v.start; j < v.stop; j++) {
			names.push(this.elementName(literalNames, symbolicNames, j));
		}
	}
	if (names.length > 1) {
		return "{" + names.join(", ") + "}";
	} else {
		return names[0];
	}
};

IntervalSet.prototype.elementName = function(literalNames, symbolicNames, a) {
	if (a === Token.EOF) {
		return "<EOF>";
	} else if (a === Token.EPSILON) {
		return "<EPSILON>";
	} else {
		return literalNames[a] || symbolicNames[a];
	}
};

exports.Interval = Interval;
exports.IntervalSet = IntervalSet;

},{"./Token":57}],50:[function(require,module,exports){
//
/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
///

var Set = require('./Utils').Set;
var BitSet = require('./Utils').BitSet;
var Token = require('./Token').Token;
var ATNConfig = require('./atn/ATNConfig').ATNConfig;
var Interval = require('./IntervalSet').Interval;
var IntervalSet = require('./IntervalSet').IntervalSet;
var RuleStopState = require('./atn/ATNState').RuleStopState;
var RuleTransition = require('./atn/Transition').RuleTransition;
var NotSetTransition = require('./atn/Transition').NotSetTransition;
var WildcardTransition = require('./atn/Transition').WildcardTransition;
var AbstractPredicateTransition = require('./atn/Transition').AbstractPredicateTransition;

var pc = require('./PredictionContext');
var predictionContextFromRuleContext = pc.predictionContextFromRuleContext;
var PredictionContext = pc.PredictionContext;
var SingletonPredictionContext = pc.SingletonPredictionContext;

function LL1Analyzer (atn) {
    this.atn = atn;
}

//* Special value added to the lookahead sets to indicate that we hit
//  a predicate during analysis if {@code seeThruPreds==false}.
///
LL1Analyzer.HIT_PRED = Token.INVALID_TYPE;


//*
// Calculates the SLL(1) expected lookahead set for each outgoing transition
// of an {@link ATNState}. The returned array has one element for each
// outgoing transition in {@code s}. If the closure from transition
// <em>i</em> leads to a semantic predicate before matching a symbol, the
// element at index <em>i</em> of the result will be {@code null}.
//
// @param s the ATN state
// @return the expected symbols for each outgoing transition of {@code s}.
///
LL1Analyzer.prototype.getDecisionLookahead = function(s) {
    if (s === null) {
        return null;
    }
    var count = s.transitions.length;
    var look = [];
    for(var alt=0; alt< count; alt++) {
        look[alt] = new IntervalSet();
        var lookBusy = new Set();
        var seeThruPreds = false; // fail to get lookahead upon pred
        this._LOOK(s.transition(alt).target, null, PredictionContext.EMPTY,
              look[alt], lookBusy, new BitSet(), seeThruPreds, false);
        // Wipe out lookahead for this alternative if we found nothing
        // or we had a predicate when we !seeThruPreds
        if (look[alt].length===0 || look[alt].contains(LL1Analyzer.HIT_PRED)) {
            look[alt] = null;
        }
    }
    return look;
};

//*
// Compute set of tokens that can follow {@code s} in the ATN in the
// specified {@code ctx}.
//
// <p>If {@code ctx} is {@code null} and the end of the rule containing
// {@code s} is reached, {@link Token//EPSILON} is added to the result set.
// If {@code ctx} is not {@code null} and the end of the outermost rule is
// reached, {@link Token//EOF} is added to the result set.</p>
//
// @param s the ATN state
// @param stopState the ATN state to stop at. This can be a
// {@link BlockEndState} to detect epsilon paths through a closure.
// @param ctx the complete parser context, or {@code null} if the context
// should be ignored
//
// @return The set of tokens that can follow {@code s} in the ATN in the
// specified {@code ctx}.
///
LL1Analyzer.prototype.LOOK = function(s, stopState, ctx) {
    var r = new IntervalSet();
    var seeThruPreds = true; // ignore preds; get all lookahead
	ctx = ctx || null;
    var lookContext = ctx!==null ? predictionContextFromRuleContext(s.atn, ctx) : null;
    this._LOOK(s, stopState, lookContext, r, new Set(), new BitSet(), seeThruPreds, true);
    return r;
};

//*
// Compute set of tokens that can follow {@code s} in the ATN in the
// specified {@code ctx}.
//
// <p>If {@code ctx} is {@code null} and {@code stopState} or the end of the
// rule containing {@code s} is reached, {@link Token//EPSILON} is added to
// the result set. If {@code ctx} is not {@code null} and {@code addEOF} is
// {@code true} and {@code stopState} or the end of the outermost rule is
// reached, {@link Token//EOF} is added to the result set.</p>
//
// @param s the ATN state.
// @param stopState the ATN state to stop at. This can be a
// {@link BlockEndState} to detect epsilon paths through a closure.
// @param ctx The outer context, or {@code null} if the outer context should
// not be used.
// @param look The result lookahead set.
// @param lookBusy A set used for preventing epsilon closures in the ATN
// from causing a stack overflow. Outside code should pass
// {@code new Set<ATNConfig>} for this argument.
// @param calledRuleStack A set used for preventing left recursion in the
// ATN from causing a stack overflow. Outside code should pass
// {@code new BitSet()} for this argument.
// @param seeThruPreds {@code true} to true semantic predicates as
// implicitly {@code true} and "see through them", otherwise {@code false}
// to treat semantic predicates as opaque and add {@link //HIT_PRED} to the
// result if one is encountered.
// @param addEOF Add {@link Token//EOF} to the result if the end of the
// outermost context is reached. This parameter has no effect if {@code ctx}
// is {@code null}.
///
LL1Analyzer.prototype._LOOK = function(s, stopState , ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF) {
    var c = new ATNConfig({state:s, alt:0, context: ctx}, null);
    if (lookBusy.contains(c)) {
        return;
    }
    lookBusy.add(c);
    if (s === stopState) {
        if (ctx ===null) {
            look.addOne(Token.EPSILON);
            return;
        } else if (ctx.isEmpty() && addEOF) {
            look.addOne(Token.EOF);
            return;
        }
    }
    if (s instanceof RuleStopState ) {
        if (ctx ===null) {
            look.addOne(Token.EPSILON);
            return;
        } else if (ctx.isEmpty() && addEOF) {
            look.addOne(Token.EOF);
            return;
        }
        if (ctx !== PredictionContext.EMPTY) {
            // run thru all possible stack tops in ctx
            for(var i=0; i<ctx.length; i++) {
                var returnState = this.atn.states[ctx.getReturnState(i)];
                var removed = calledRuleStack.contains(returnState.ruleIndex);
                try {
                    calledRuleStack.remove(returnState.ruleIndex);
                    this._LOOK(returnState, stopState, ctx.getParent(i), look, lookBusy, calledRuleStack, seeThruPreds, addEOF);
                } finally {
                    if (removed) {
                        calledRuleStack.add(returnState.ruleIndex);
                    }
                }
            }
            return;
        }
    }
    for(var j=0; j<s.transitions.length; j++) {
        var t = s.transitions[j];
        if (t.constructor === RuleTransition) {
            if (calledRuleStack.contains(t.target.ruleIndex)) {
                continue;
            }
            var newContext = SingletonPredictionContext.create(ctx, t.followState.stateNumber);
            try {
                calledRuleStack.add(t.target.ruleIndex);
                this._LOOK(t.target, stopState, newContext, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);
            } finally {
                calledRuleStack.remove(t.target.ruleIndex);
            }
        } else if (t instanceof AbstractPredicateTransition ) {
            if (seeThruPreds) {
                this._LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);
            } else {
                look.addOne(LL1Analyzer.HIT_PRED);
            }
        } else if( t.isEpsilon) {
            this._LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);
        } else if (t.constructor === WildcardTransition) {
            look.addRange( Token.MIN_USER_TOKEN_TYPE, this.atn.maxTokenType );
        } else {
            var set = t.label;
            if (set !== null) {
                if (t instanceof NotSetTransition) {
                    set = set.complement(Token.MIN_USER_TOKEN_TYPE, this.atn.maxTokenType);
                }
                look.addSet(set);
            }
        }
    }
};

exports.LL1Analyzer = LL1Analyzer;


},{"./IntervalSet":49,"./PredictionContext":54,"./Token":57,"./Utils":58,"./atn/ATNConfig":60,"./atn/ATNState":65,"./atn/Transition":73}],51:[function(require,module,exports){
/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
///

// A lexer is recognizer that draws input symbols from a character stream.
//  lexer grammars result in a subclass of this object. A Lexer object
//  uses simplified match() and error recovery mechanisms in the interest of speed.

var Token = require('./Token').Token;
var Recognizer = require('./Recognizer').Recognizer;
var CommonTokenFactory = require('./CommonTokenFactory').CommonTokenFactory;
var RecognitionException  = require('./error/Errors').RecognitionException;
var LexerNoViableAltException = require('./error/Errors').LexerNoViableAltException;

function TokenSource() {
	return this;
}

function Lexer(input) {
	Recognizer.call(this);
	this._input = input;
	this._factory = CommonTokenFactory.DEFAULT;
	this._tokenFactorySourcePair = [ this, input ];

	this._interp = null; // child classes must populate this

	// The goal of all lexer rules/methods is to create a token object.
	// this is an instance variable as multiple rules may collaborate to
	// create a single token. nextToken will return this object after
	// matching lexer rule(s). If you subclass to allow multiple token
	// emissions, then set this to the last token to be matched or
	// something nonnull so that the auto token emit mechanism will not
	// emit another token.
	this._token = null;

	// What character index in the stream did the current token start at?
	// Needed, for example, to get the text for current token. Set at
	// the start of nextToken.
	this._tokenStartCharIndex = -1;

	// The line on which the first character of the token resides///
	this._tokenStartLine = -1;

	// The character position of first character within the line///
	this._tokenStartColumn = -1;

	// Once we see EOF on char stream, next token will be EOF.
	// If you have DONE : EOF ; then you see DONE EOF.
	this._hitEOF = false;

	// The channel number for the current token///
	this._channel = Token.DEFAULT_CHANNEL;

	// The token type for the current token///
	this._type = Token.INVALID_TYPE;

	this._modeStack = [];
	this._mode = Lexer.DEFAULT_MODE;

	// You can set the text for the current token to override what is in
	// the input char buffer. Use setText() or can set this instance var.
	// /
	this._text = null;

	return this;
}

Lexer.prototype = Object.create(Recognizer.prototype);
Lexer.prototype.constructor = Lexer;

Lexer.DEFAULT_MODE = 0;
Lexer.MORE = -2;
Lexer.SKIP = -3;

Lexer.DEFAULT_TOKEN_CHANNEL = Token.DEFAULT_CHANNEL;
Lexer.HIDDEN = Token.HIDDEN_CHANNEL;
Lexer.MIN_CHAR_VALUE = 0x0000;
Lexer.MAX_CHAR_VALUE = 0x10FFFF;

Lexer.prototype.reset = function() {
	// wack Lexer state variables
	if (this._input !== null) {
		this._input.seek(0); // rewind the input
	}
	this._token = null;
	this._type = Token.INVALID_TYPE;
	this._channel = Token.DEFAULT_CHANNEL;
	this._tokenStartCharIndex = -1;
	this._tokenStartColumn = -1;
	this._tokenStartLine = -1;
	this._text = null;

	this._hitEOF = false;
	this._mode = Lexer.DEFAULT_MODE;
	this._modeStack = [];

	this._interp.reset();
};

// Return a token from this source; i.e., match a token on the char stream.
Lexer.prototype.nextToken = function() {
	if (this._input === null) {
		throw "nextToken requires a non-null input stream.";
	}

	// Mark start location in char stream so unbuffered streams are
	// guaranteed at least have text of current token
	var tokenStartMarker = this._input.mark();
	try {
		while (true) {
			if (this._hitEOF) {
				this.emitEOF();
				return this._token;
			}
			this._token = null;
			this._channel = Token.DEFAULT_CHANNEL;
			this._tokenStartCharIndex = this._input.index;
			this._tokenStartColumn = this._interp.column;
			this._tokenStartLine = this._interp.line;
			this._text = null;
			var continueOuter = false;
			while (true) {
				this._type = Token.INVALID_TYPE;
				var ttype = Lexer.SKIP;
				try {
					ttype = this._interp.match(this._input, this._mode);
				} catch (e) {
				    if(e instanceof RecognitionException) {
                        this.notifyListeners(e); // report error
                        this.recover(e);
                    } else {
                        console.log(e.stack);
                        throw e;
                    }
				}
				if (this._input.LA(1) === Token.EOF) {
					this._hitEOF = true;
				}
				if (this._type === Token.INVALID_TYPE) {
					this._type = ttype;
				}
				if (this._type === Lexer.SKIP) {
					continueOuter = true;
					break;
				}
				if (this._type !== Lexer.MORE) {
					break;
				}
			}
			if (continueOuter) {
				continue;
			}
			if (this._token === null) {
				this.emit();
			}
			return this._token;
		}
	} finally {
		// make sure we release marker after match or
		// unbuffered char stream will keep buffering
		this._input.release(tokenStartMarker);
	}
};

// Instruct the lexer to skip creating a token for current lexer rule
// and look for another token. nextToken() knows to keep looking when
// a lexer rule finishes with token set to SKIP_TOKEN. Recall that
// if token==null at end of any token rule, it creates one for you
// and emits it.
// /
Lexer.prototype.skip = function() {
	this._type = Lexer.SKIP;
};

Lexer.prototype.more = function() {
	this._type = Lexer.MORE;
};

Lexer.prototype.mode = function(m) {
	this._mode = m;
};

Lexer.prototype.pushMode = function(m) {
	if (this._interp.debug) {
		console.log("pushMode " + m);
	}
	this._modeStack.push(this._mode);
	this.mode(m);
};

Lexer.prototype.popMode = function() {
	if (this._modeStack.length === 0) {
		throw "Empty Stack";
	}
	if (this._interp.debug) {
		console.log("popMode back to " + this._modeStack.slice(0, -1));
	}
	this.mode(this._modeStack.pop());
	return this._mode;
};

// Set the char stream and reset the lexer
Object.defineProperty(Lexer.prototype, "inputStream", {
	get : function() {
		return this._input;
	},
	set : function(input) {
		this._input = null;
		this._tokenFactorySourcePair = [ this, this._input ];
		this.reset();
		this._input = input;
		this._tokenFactorySourcePair = [ this, this._input ];
	}
});

Object.defineProperty(Lexer.prototype, "sourceName", {
	get : function sourceName() {
		return this._input.sourceName;
	}
});

// By default does not support multiple emits per nextToken invocation
// for efficiency reasons. Subclass and override this method, nextToken,
// and getToken (to push tokens into a list and pull from that list
// rather than a single variable as this implementation does).
// /
Lexer.prototype.emitToken = function(token) {
	this._token = token;
};

// The standard method called to automatically emit a token at the
// outermost lexical rule. The token object should point into the
// char buffer start..stop. If there is a text override in 'text',
// use that to set the token's text. Override this method to emit
// custom Token objects or provide a new factory.
// /
Lexer.prototype.emit = function() {
	var t = this._factory.create(this._tokenFactorySourcePair, this._type,
			this._text, this._channel, this._tokenStartCharIndex, this
					.getCharIndex() - 1, this._tokenStartLine,
			this._tokenStartColumn);
	this.emitToken(t);
	return t;
};

Lexer.prototype.emitEOF = function() {
	var cpos = this.column;
	var lpos = this.line;
	var eof = this._factory.create(this._tokenFactorySourcePair, Token.EOF,
			null, Token.DEFAULT_CHANNEL, this._input.index,
			this._input.index - 1, lpos, cpos);
	this.emitToken(eof);
	return eof;
};

Object.defineProperty(Lexer.prototype, "type", {
	get : function() {
		return this.type;
	},
	set : function(type) {
		this._type = type;
	}
});

Object.defineProperty(Lexer.prototype, "line", {
	get : function() {
		return this._interp.line;
	},
	set : function(line) {
		this._interp.line = line;
	}
});

Object.defineProperty(Lexer.prototype, "column", {
	get : function() {
		return this._interp.column;
	},
	set : function(column) {
		this._interp.column = column;
	}
});


// What is the index of the current character of lookahead?///
Lexer.prototype.getCharIndex = function() {
	return this._input.index;
};

// Return the text matched so far for the current token or any text override.
//Set the complete text of this token; it wipes any previous changes to the text.
Object.defineProperty(Lexer.prototype, "text", {
	get : function() {
		if (this._text !== null) {
			return this._text;
		} else {
			return this._interp.getText(this._input);
		}
	},
	set : function(text) {
		this._text = text;
	}
});
// Return a list of all Token objects in input char stream.
// Forces load of all tokens. Does not include EOF token.
// /
Lexer.prototype.getAllTokens = function() {
	var tokens = [];
	var t = this.nextToken();
	while (t.type !== Token.EOF) {
		tokens.push(t);
		t = this.nextToken();
	}
	return tokens;
};

Lexer.prototype.notifyListeners = function(e) {
	var start = this._tokenStartCharIndex;
	var stop = this._input.index;
	var text = this._input.getText(start, stop);
	var msg = "token recognition error at: '" + this.getErrorDisplay(text) + "'";
	var listener = this.getErrorListenerDispatch();
	listener.syntaxError(this, null, this._tokenStartLine,
			this._tokenStartColumn, msg, e);
};

Lexer.prototype.getErrorDisplay = function(s) {
	var d = [];
	for (var i = 0; i < s.length; i++) {
		d.push(s[i]);
	}
	return d.join('');
};

Lexer.prototype.getErrorDisplayForChar = function(c) {
	if (c.charCodeAt(0) === Token.EOF) {
		return "<EOF>";
	} else if (c === '\n') {
		return "\\n";
	} else if (c === '\t') {
		return "\\t";
	} else if (c === '\r') {
		return "\\r";
	} else {
		return c;
	}
};

Lexer.prototype.getCharErrorDisplay = function(c) {
	return "'" + this.getErrorDisplayForChar(c) + "'";
};

// Lexers can normally match any char in it's vocabulary after matching
// a token, so do the easy thing and just kill a character and hope
// it all works out. You can instead use the rule invocation stack
// to do sophisticated error recovery if you are in a fragment rule.
// /
Lexer.prototype.recover = function(re) {
	if (this._input.LA(1) !== Token.EOF) {
		if (re instanceof LexerNoViableAltException) {
			// skip a char and try again
			this._interp.consume(this._input);
		} else {
			// TODO: Do we lose character or line position information?
			this._input.consume();
		}
	}
};

exports.Lexer = Lexer;

},{"./CommonTokenFactory":45,"./Recognizer":55,"./Token":57,"./error/Errors":82}],52:[function(require,module,exports){
/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

var Token = require('./Token').Token;
var ParseTreeListener = require('./tree/Tree').ParseTreeListener;
var Recognizer = require('./Recognizer').Recognizer;
var DefaultErrorStrategy = require('./error/ErrorStrategy').DefaultErrorStrategy;
var ATNDeserializer = require('./atn/ATNDeserializer').ATNDeserializer;
var ATNDeserializationOptions = require('./atn/ATNDeserializationOptions').ATNDeserializationOptions;
var TerminalNode = require('./tree/Tree').TerminalNode;
var ErrorNode = require('./tree/Tree').ErrorNode;

function TraceListener(parser) {
	ParseTreeListener.call(this);
    this.parser = parser;
	return this;
}

TraceListener.prototype = Object.create(ParseTreeListener.prototype);
TraceListener.prototype.constructor = TraceListener;

TraceListener.prototype.enterEveryRule = function(ctx) {
	console.log("enter   " + this.parser.ruleNames[ctx.ruleIndex] + ", LT(1)=" + this.parser._input.LT(1).text);
};

TraceListener.prototype.visitTerminal = function( node) {
	console.log("consume " + node.symbol + " rule " + this.parser.ruleNames[this.parser._ctx.ruleIndex]);
};

TraceListener.prototype.exitEveryRule = function(ctx) {
	console.log("exit    " + this.parser.ruleNames[ctx.ruleIndex] + ", LT(1)=" + this.parser._input.LT(1).text);
};

// this is all the parsing support code essentially; most of it is error
// recovery stuff.//
function Parser(input) {
	Recognizer.call(this);
	// The input stream.
	this._input = null;
	// The error handling strategy for the parser. The default value is a new
	// instance of {@link DefaultErrorStrategy}.
	this._errHandler = new DefaultErrorStrategy();
	this._precedenceStack = [];
	this._precedenceStack.push(0);
	// The {@link ParserRuleContext} object for the currently executing rule.
	// this is always non-null during the parsing process.
	this._ctx = null;
	// Specifies whether or not the parser should construct a parse tree during
	// the parsing process. The default value is {@code true}.
	this.buildParseTrees = true;
	// When {@link //setTrace}{@code (true)} is called, a reference to the
	// {@link TraceListener} is stored here so it can be easily removed in a
	// later call to {@link //setTrace}{@code (false)}. The listener itself is
	// implemented as a parser listener so this field is not directly used by
	// other parser methods.
	this._tracer = null;
	// The list of {@link ParseTreeListener} listeners registered to receive
	// events during the parse.
	this._parseListeners = null;
	// The number of syntax errors reported during parsing. this value is
	// incremented each time {@link //notifyErrorListeners} is called.
	this._syntaxErrors = 0;
	this.setInputStream(input);
	return this;
}

Parser.prototype = Object.create(Recognizer.prototype);
Parser.prototype.contructor = Parser;

// this field maps from the serialized ATN string to the deserialized {@link
// ATN} with
// bypass alternatives.
//
// @see ATNDeserializationOptions//isGenerateRuleBypassTransitions()
//
Parser.bypassAltsAtnCache = {};

// reset the parser's state//
Parser.prototype.reset = function() {
	if (this._input !== null) {
		this._input.seek(0);
	}
	this._errHandler.reset(this);
	this._ctx = null;
	this._syntaxErrors = 0;
	this.setTrace(false);
	this._precedenceStack = [];
	this._precedenceStack.push(0);
	if (this._interp !== null) {
		this._interp.reset();
	}
};

// Match current input symbol against {@code ttype}. If the symbol type
// matches, {@link ANTLRErrorStrategy//reportMatch} and {@link //consume} are
// called to complete the match process.
//
// <p>If the symbol type does not match,
// {@link ANTLRErrorStrategy//recoverInline} is called on the current error
// strategy to attempt recovery. If {@link //getBuildParseTree} is
// {@code true} and the token index of the symbol returned by
// {@link ANTLRErrorStrategy//recoverInline} is -1, the symbol is added to
// the parse tree by calling {@link ParserRuleContext//addErrorNode}.</p>
//
// @param ttype the token type to match
// @return the matched symbol
// @throws RecognitionException if the current input symbol did not match
// {@code ttype} and the error strategy could not recover from the
// mismatched symbol

Parser.prototype.match = function(ttype) {
	var t = this.getCurrentToken();
	if (t.type === ttype) {
		this._errHandler.reportMatch(this);
		this.consume();
	} else {
		t = this._errHandler.recoverInline(this);
		if (this.buildParseTrees && t.tokenIndex === -1) {
			// we must have conjured up a new token during single token
			// insertion
			// if it's not the current symbol
			this._ctx.addErrorNode(t);
		}
	}
	return t;
};
// Match current input symbol as a wildcard. If the symbol type matches
// (i.e. has a value greater than 0), {@link ANTLRErrorStrategy//reportMatch}
// and {@link //consume} are called to complete the match process.
//
// <p>If the symbol type does not match,
// {@link ANTLRErrorStrategy//recoverInline} is called on the current error
// strategy to attempt recovery. If {@link //getBuildParseTree} is
// {@code true} and the token index of the symbol returned by
// {@link ANTLRErrorStrategy//recoverInline} is -1, the symbol is added to
// the parse tree by calling {@link ParserRuleContext//addErrorNode}.</p>
//
// @return the matched symbol
// @throws RecognitionException if the current input symbol did not match
// a wildcard and the error strategy could not recover from the mismatched
// symbol

Parser.prototype.matchWildcard = function() {
	var t = this.getCurrentToken();
	if (t.type > 0) {
		this._errHandler.reportMatch(this);
		this.consume();
	} else {
		t = this._errHandler.recoverInline(this);
		if (this._buildParseTrees && t.tokenIndex === -1) {
			// we must have conjured up a new token during single token
			// insertion
			// if it's not the current symbol
			this._ctx.addErrorNode(t);
		}
	}
	return t;
};

Parser.prototype.getParseListeners = function() {
	return this._parseListeners || [];
};

// Registers {@code listener} to receive events during the parsing process.
//
// <p>To support output-preserving grammar transformations (including but not
// limited to left-recursion removal, automated left-factoring, and
// optimized code generation), calls to listener methods during the parse
// may differ substantially from calls made by
// {@link ParseTreeWalker//DEFAULT} used after the parse is complete. In
// particular, rule entry and exit events may occur in a different order
// during the parse than after the parser. In addition, calls to certain
// rule entry methods may be omitted.</p>
//
// <p>With the following specific exceptions, calls to listener events are
// <em>deterministic</em>, i.e. for identical input the calls to listener
// methods will be the same.</p>
//
// <ul>
// <li>Alterations to the grammar used to generate code may change the
// behavior of the listener calls.</li>
// <li>Alterations to the command line options passed to ANTLR 4 when
// generating the parser may change the behavior of the listener calls.</li>
// <li>Changing the version of the ANTLR Tool used to generate the parser
// may change the behavior of the listener calls.</li>
// </ul>
//
// @param listener the listener to add
//
// @throws NullPointerException if {@code} listener is {@code null}
//
Parser.prototype.addParseListener = function(listener) {
	if (listener === null) {
		throw "listener";
	}
	if (this._parseListeners === null) {
		this._parseListeners = [];
	}
	this._parseListeners.push(listener);
};

//
// Remove {@code listener} from the list of parse listeners.
//
// <p>If {@code listener} is {@code null} or has not been added as a parse
// listener, this method does nothing.</p>
// @param listener the listener to remove
//
Parser.prototype.removeParseListener = function(listener) {
	if (this._parseListeners !== null) {
		var idx = this._parseListeners.indexOf(listener);
		if (idx >= 0) {
			this._parseListeners.splice(idx, 1);
		}
		if (this._parseListeners.length === 0) {
			this._parseListeners = null;
		}
	}
};

// Remove all parse listeners.
Parser.prototype.removeParseListeners = function() {
	this._parseListeners = null;
};

// Notify any parse listeners of an enter rule event.
Parser.prototype.triggerEnterRuleEvent = function() {
	if (this._parseListeners !== null) {
        var ctx = this._ctx;
		this._parseListeners.map(function(listener) {
			listener.enterEveryRule(ctx);
			ctx.enterRule(listener);
		});
	}
};

//
// Notify any parse listeners of an exit rule event.
//
// @see //addParseListener
//
Parser.prototype.triggerExitRuleEvent = function() {
	if (this._parseListeners !== null) {
		// reverse order walk of listeners
        var ctx = this._ctx;
		this._parseListeners.slice(0).reverse().map(function(listener) {
			ctx.exitRule(listener);
			listener.exitEveryRule(ctx);
		});
	}
};

Parser.prototype.getTokenFactory = function() {
	return this._input.tokenSource._factory;
};

// Tell our token source and error strategy about a new way to create tokens.//
Parser.prototype.setTokenFactory = function(factory) {
	this._input.tokenSource._factory = factory;
};

// The ATN with bypass alternatives is expensive to create so we create it
// lazily.
//
// @throws UnsupportedOperationException if the current parser does not
// implement the {@link //getSerializedATN()} method.
//
Parser.prototype.getATNWithBypassAlts = function() {
	var serializedAtn = this.getSerializedATN();
	if (serializedAtn === null) {
		throw "The current parser does not support an ATN with bypass alternatives.";
	}
	var result = this.bypassAltsAtnCache[serializedAtn];
	if (result === null) {
		var deserializationOptions = new ATNDeserializationOptions();
		deserializationOptions.generateRuleBypassTransitions = true;
		result = new ATNDeserializer(deserializationOptions)
				.deserialize(serializedAtn);
		this.bypassAltsAtnCache[serializedAtn] = result;
	}
	return result;
};

// The preferred method of getting a tree pattern. For example, here's a
// sample use:
//
// <pre>
// ParseTree t = parser.expr();
// ParseTreePattern p = parser.compileParseTreePattern("&lt;ID&gt;+0",
// MyParser.RULE_expr);
// ParseTreeMatch m = p.match(t);
// String id = m.get("ID");
// </pre>

var Lexer = require('./Lexer').Lexer;

Parser.prototype.compileParseTreePattern = function(pattern, patternRuleIndex, lexer) {
	lexer = lexer || null;
	if (lexer === null) {
		if (this.getTokenStream() !== null) {
			var tokenSource = this.getTokenStream().tokenSource;
			if (tokenSource instanceof Lexer) {
				lexer = tokenSource;
			}
		}
	}
	if (lexer === null) {
		throw "Parser can't discover a lexer to use";
	}
	var m = new ParseTreePatternMatcher(lexer, this);
	return m.compile(pattern, patternRuleIndex);
};

Parser.prototype.getInputStream = function() {
	return this.getTokenStream();
};

Parser.prototype.setInputStream = function(input) {
	this.setTokenStream(input);
};

Parser.prototype.getTokenStream = function() {
	return this._input;
};

// Set the token stream and reset the parser.//
Parser.prototype.setTokenStream = function(input) {
	this._input = null;
	this.reset();
	this._input = input;
};

// Match needs to return the current input symbol, which gets put
// into the label for the associated token ref; e.g., x=ID.
//
Parser.prototype.getCurrentToken = function() {
	return this._input.LT(1);
};

Parser.prototype.notifyErrorListeners = function(msg, offendingToken, err) {
	offendingToken = offendingToken || null;
	err = err || null;
	if (offendingToken === null) {
		offendingToken = this.getCurrentToken();
	}
	this._syntaxErrors += 1;
	var line = offendingToken.line;
	var column = offendingToken.column;
	var listener = this.getErrorListenerDispatch();
	listener.syntaxError(this, offendingToken, line, column, msg, err);
};

//
// Consume and return the {@linkplain //getCurrentToken current symbol}.
//
// <p>E.g., given the following input with {@code A} being the current
// lookahead symbol, this function moves the cursor to {@code B} and returns
// {@code A}.</p>
//
// <pre>
// A B
// ^
// </pre>
//
// If the parser is not in error recovery mode, the consumed symbol is added
// to the parse tree using {@link ParserRuleContext//addChild(Token)}, and
// {@link ParseTreeListener//visitTerminal} is called on any parse listeners.
// If the parser <em>is</em> in error recovery mode, the consumed symbol is
// added to the parse tree using
// {@link ParserRuleContext//addErrorNode(Token)}, and
// {@link ParseTreeListener//visitErrorNode} is called on any parse
// listeners.
//
Parser.prototype.consume = function() {
	var o = this.getCurrentToken();
	if (o.type !== Token.EOF) {
		this.getInputStream().consume();
	}
	var hasListener = this._parseListeners !== null && this._parseListeners.length > 0;
	if (this.buildParseTrees || hasListener) {
		var node;
		if (this._errHandler.inErrorRecoveryMode(this)) {
			node = this._ctx.addErrorNode(o);
		} else {
			node = this._ctx.addTokenNode(o);
		}
        node.invokingState = this.state;
		if (hasListener) {
			this._parseListeners.map(function(listener) {
				if (node instanceof ErrorNode || (node.isErrorNode !== undefined && node.isErrorNode())) {
					listener.visitErrorNode(node);
				} else if (node instanceof TerminalNode) {
					listener.visitTerminal(node);
				}
			});
		}
	}
	return o;
};

Parser.prototype.addContextToParseTree = function() {
	// add current context to parent if we have a parent
	if (this._ctx.parentCtx !== null) {
		this._ctx.parentCtx.addChild(this._ctx);
	}
};

// Always called by generated parsers upon entry to a rule. Access field
// {@link //_ctx} get the current context.

Parser.prototype.enterRule = function(localctx, state, ruleIndex) {
	this.state = state;
	this._ctx = localctx;
	this._ctx.start = this._input.LT(1);
	if (this.buildParseTrees) {
		this.addContextToParseTree();
	}
	if (this._parseListeners !== null) {
		this.triggerEnterRuleEvent();
	}
};

Parser.prototype.exitRule = function() {
	this._ctx.stop = this._input.LT(-1);
	// trigger event on _ctx, before it reverts to parent
	if (this._parseListeners !== null) {
		this.triggerExitRuleEvent();
	}
	this.state = this._ctx.invokingState;
	this._ctx = this._ctx.parentCtx;
};

Parser.prototype.enterOuterAlt = function(localctx, altNum) {
   	localctx.setAltNumber(altNum);
	// if we have new localctx, make sure we replace existing ctx
	// that is previous child of parse tree
	if (this.buildParseTrees && this._ctx !== localctx) {
		if (this._ctx.parentCtx !== null) {
			this._ctx.parentCtx.removeLastChild();
			this._ctx.parentCtx.addChild(localctx);
		}
	}
	this._ctx = localctx;
};

// Get the precedence level for the top-most precedence rule.
//
// @return The precedence level for the top-most precedence rule, or -1 if
// the parser context is not nested within a precedence rule.

Parser.prototype.getPrecedence = function() {
	if (this._precedenceStack.length === 0) {
		return -1;
	} else {
		return this._precedenceStack[this._precedenceStack.length-1];
	}
};

Parser.prototype.enterRecursionRule = function(localctx, state, ruleIndex,
		precedence) {
	this.state = state;
	this._precedenceStack.push(precedence);
	this._ctx = localctx;
	this._ctx.start = this._input.LT(1);
	if (this._parseListeners !== null) {
		this.triggerEnterRuleEvent(); // simulates rule entry for
										// left-recursive rules
	}
};

//
// Like {@link //enterRule} but for recursive rules.

Parser.prototype.pushNewRecursionContext = function(localctx, state, ruleIndex) {
	var previous = this._ctx;
	previous.parentCtx = localctx;
	previous.invokingState = state;
	previous.stop = this._input.LT(-1);

	this._ctx = localctx;
	this._ctx.start = previous.start;
	if (this.buildParseTrees) {
		this._ctx.addChild(previous);
	}
	if (this._parseListeners !== null) {
		this.triggerEnterRuleEvent(); // simulates rule entry for
										// left-recursive rules
	}
};

Parser.prototype.unrollRecursionContexts = function(parentCtx) {
	this._precedenceStack.pop();
	this._ctx.stop = this._input.LT(-1);
	var retCtx = this._ctx; // save current ctx (return value)
	// unroll so _ctx is as it was before call to recursive method
	if (this._parseListeners !== null) {
		while (this._ctx !== parentCtx) {
			this.triggerExitRuleEvent();
			this._ctx = this._ctx.parentCtx;
		}
	} else {
		this._ctx = parentCtx;
	}
	// hook into tree
	retCtx.parentCtx = parentCtx;
	if (this.buildParseTrees && parentCtx !== null) {
		// add return ctx into invoking rule's tree
		parentCtx.addChild(retCtx);
	}
};

Parser.prototype.getInvokingContext = function(ruleIndex) {
	var ctx = this._ctx;
	while (ctx !== null) {
		if (ctx.ruleIndex === ruleIndex) {
			return ctx;
		}
		ctx = ctx.parentCtx;
	}
	return null;
};

Parser.prototype.precpred = function(localctx, precedence) {
	return precedence >= this._precedenceStack[this._precedenceStack.length-1];
};

Parser.prototype.inContext = function(context) {
	// TODO: useful in parser?
	return false;
};

//
// Checks whether or not {@code symbol} can follow the current state in the
// ATN. The behavior of this method is equivalent to the following, but is
// implemented such that the complete context-sensitive follow set does not
// need to be explicitly constructed.
//
// <pre>
// return getExpectedTokens().contains(symbol);
// </pre>
//
// @param symbol the symbol type to check
// @return {@code true} if {@code symbol} can follow the current state in
// the ATN, otherwise {@code false}.

Parser.prototype.isExpectedToken = function(symbol) {
	var atn = this._interp.atn;
	var ctx = this._ctx;
	var s = atn.states[this.state];
	var following = atn.nextTokens(s);
	if (following.contains(symbol)) {
		return true;
	}
	if (!following.contains(Token.EPSILON)) {
		return false;
	}
	while (ctx !== null && ctx.invokingState >= 0 && following.contains(Token.EPSILON)) {
		var invokingState = atn.states[ctx.invokingState];
		var rt = invokingState.transitions[0];
		following = atn.nextTokens(rt.followState);
		if (following.contains(symbol)) {
			return true;
		}
		ctx = ctx.parentCtx;
	}
	if (following.contains(Token.EPSILON) && symbol === Token.EOF) {
		return true;
	} else {
		return false;
	}
};

// Computes the set of input symbols which could follow the current parser
// state and context, as given by {@link //getState} and {@link //getContext},
// respectively.
//
// @see ATN//getExpectedTokens(int, RuleContext)
//
Parser.prototype.getExpectedTokens = function() {
	return this._interp.atn.getExpectedTokens(this.state, this._ctx);
};

Parser.prototype.getExpectedTokensWithinCurrentRule = function() {
	var atn = this._interp.atn;
	var s = atn.states[this.state];
	return atn.nextTokens(s);
};

// Get a rule's index (i.e., {@code RULE_ruleName} field) or -1 if not found.//
Parser.prototype.getRuleIndex = function(ruleName) {
	var ruleIndex = this.getRuleIndexMap()[ruleName];
	if (ruleIndex !== null) {
		return ruleIndex;
	} else {
		return -1;
	}
};

// Return List&lt;String&gt; of the rule names in your parser instance
// leading up to a call to the current rule. You could override if
// you want more details such as the file/line info of where
// in the ATN a rule is invoked.
//
// this is very useful for error messages.
//
Parser.prototype.getRuleInvocationStack = function(p) {
	p = p || null;
	if (p === null) {
		p = this._ctx;
	}
	var stack = [];
	while (p !== null) {
		// compute what follows who invoked us
		var ruleIndex = p.ruleIndex;
		if (ruleIndex < 0) {
			stack.push("n/a");
		} else {
			stack.push(this.ruleNames[ruleIndex]);
		}
		p = p.parentCtx;
	}
	return stack;
};

// For debugging and other purposes.//
Parser.prototype.getDFAStrings = function() {
	return this._interp.decisionToDFA.toString();
};
// For debugging and other purposes.//
Parser.prototype.dumpDFA = function() {
	var seenOne = false;
	for (var i = 0; i < this._interp.decisionToDFA.length; i++) {
		var dfa = this._interp.decisionToDFA[i];
		if (dfa.states.length > 0) {
			if (seenOne) {
				console.log();
			}
			this.printer.println("Decision " + dfa.decision + ":");
			this.printer.print(dfa.toString(this.literalNames, this.symbolicNames));
			seenOne = true;
		}
	}
};

/*
"			printer = function() {\r\n" +
"				this.println = function(s) { document.getElementById('output') += s + '\\n'; }\r\n" +
"				this.print = function(s) { document.getElementById('output') += s; }\r\n" +
"			};\r\n" +
*/

Parser.prototype.getSourceName = function() {
	return this._input.sourceName;
};

// During a parse is sometimes useful to listen in on the rule entry and exit
// events as well as token matches. this is for quick and dirty debugging.
//
Parser.prototype.setTrace = function(trace) {
	if (!trace) {
		this.removeParseListener(this._tracer);
		this._tracer = null;
	} else {
		if (this._tracer !== null) {
			this.removeParseListener(this._tracer);
		}
		this._tracer = new TraceListener(this);
		this.addParseListener(this._tracer);
	}
};

exports.Parser = Parser;
},{"./Lexer":51,"./Recognizer":55,"./Token":57,"./atn/ATNDeserializationOptions":62,"./atn/ATNDeserializer":63,"./error/ErrorStrategy":81,"./tree/Tree":87}],53:[function(require,module,exports){
/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

//* A rule invocation record for parsing.
//
//  Contains all of the information about the current rule not stored in the
//  RuleContext. It handles parse tree children list, Any ATN state
//  tracing, and the default values available for rule indications:
//  start, stop, rule index, current alt number, current
//  ATN state.
//
//  Subclasses made for each rule and grammar track the parameters,
//  return values, locals, and labels specific to that rule. These
//  are the objects that are returned from rules.
//
//  Note text is not an actual field of a rule return value; it is computed
//  from start and stop using the input stream's toString() method.  I
//  could add a ctor to this so that we can pass in and store the input
//  stream, but I'm not sure we want to do that.  It would seem to be undefined
//  to get the .text property anyway if the rule matches tokens from multiple
//  input streams.
//
//  I do not use getters for fields of objects that are used simply to
//  group values such as this aggregate.  The getters/setters are there to
//  satisfy the superclass interface.

var RuleContext = require('./RuleContext').RuleContext;
var Tree = require('./tree/Tree');
var INVALID_INTERVAL = Tree.INVALID_INTERVAL;
var TerminalNode = Tree.TerminalNode;
var TerminalNodeImpl = Tree.TerminalNodeImpl;
var ErrorNodeImpl = Tree.ErrorNodeImpl;
var Interval = require("./IntervalSet").Interval;

function ParserRuleContext(parent, invokingStateNumber) {
	parent = parent || null;
	invokingStateNumber = invokingStateNumber || null;
	RuleContext.call(this, parent, invokingStateNumber);
	this.ruleIndex = -1;
    // * If we are debugging or building a parse tree for a visitor,
    // we need to track all of the tokens and rule invocations associated
    // with this rule's context. This is empty for parsing w/o tree constr.
    // operation because we don't the need to track the details about
    // how we parse this rule.
    // /
    this.children = null;
    this.start = null;
    this.stop = null;
    // The exception that forced this rule to return. If the rule successfully
    // completed, this is {@code null}.
    this.exception = null;
}

ParserRuleContext.prototype = Object.create(RuleContext.prototype);
ParserRuleContext.prototype.constructor = ParserRuleContext;

// * COPY a ctx (I'm deliberately not using copy constructor)///
ParserRuleContext.prototype.copyFrom = function(ctx) {
    // from RuleContext
    this.parentCtx = ctx.parentCtx;
    this.invokingState = ctx.invokingState;
    this.children = null;
    this.start = ctx.start;
    this.stop = ctx.stop;
    // copy any error nodes to alt label node
    if(ctx.children) {
        this.children = [];
        // reset parent pointer for any error nodes
    	ctx.children.map(function(child) {
    		if (child instanceof ErrorNodeImpl) {
                this.children.push(child);
                child.parentCtx = this;
            }
		}, this);
	}
};

// Double dispatch methods for listeners
ParserRuleContext.prototype.enterRule = function(listener) {
};

ParserRuleContext.prototype.exitRule = function(listener) {
};

// * Does not set parent link; other add methods do that///
ParserRuleContext.prototype.addChild = function(child) {
    if (this.children === null) {
        this.children = [];
    }
    this.children.push(child);
    return child;
};

// * Used by enterOuterAlt to toss out a RuleContext previously added as
// we entered a rule. If we have // label, we will need to remove
// generic ruleContext object.
// /
ParserRuleContext.prototype.removeLastChild = function() {
    if (this.children !== null) {
        this.children.pop();
    }
};

ParserRuleContext.prototype.addTokenNode = function(token) {
    var node = new TerminalNodeImpl(token);
    this.addChild(node);
    node.parentCtx = this;
    return node;
};

ParserRuleContext.prototype.addErrorNode = function(badToken) {
    var node = new ErrorNodeImpl(badToken);
    this.addChild(node);
    node.parentCtx = this;
    return node;
};

ParserRuleContext.prototype.getChild = function(i, type) {
	type = type || null;
	if (this.children === null || i < 0 || i >= this.children.length) {
		return null;
	}
	if (type === null) {
		return this.children[i];
	} else {
		for(var j=0; j<this.children.length; j++) {
			var child = this.children[j];
			if(child instanceof type) {
				if(i===0) {
					return child;
				} else {
					i -= 1;
				}
			}
		}
		return null;
    }
};


ParserRuleContext.prototype.getToken = function(ttype, i) {
	if (this.children === null || i < 0 || i >= this.children.length) {
		return null;
	}
	for(var j=0; j<this.children.length; j++) {
		var child = this.children[j];
		if (child instanceof TerminalNode) {
			if (child.symbol.type === ttype) {
				if(i===0) {
					return child;
				} else {
					i -= 1;
				}
			}
        }
	}
    return null;
};

ParserRuleContext.prototype.getTokens = function(ttype ) {
    if (this.children=== null) {
        return [];
    } else {
		var tokens = [];
		for(var j=0; j<this.children.length; j++) {
			var child = this.children[j];
			if (child instanceof TerminalNode) {
				if (child.symbol.type === ttype) {
					tokens.push(child);
				}
			}
		}
		return tokens;
    }
};

ParserRuleContext.prototype.getTypedRuleContext = function(ctxType, i) {
    return this.getChild(i, ctxType);
};

ParserRuleContext.prototype.getTypedRuleContexts = function(ctxType) {
    if (this.children=== null) {
        return [];
    } else {
		var contexts = [];
		for(var j=0; j<this.children.length; j++) {
			var child = this.children[j];
			if (child instanceof ctxType) {
				contexts.push(child);
			}
		}
		return contexts;
	}
};

ParserRuleContext.prototype.getChildCount = function() {
	if (this.children=== null) {
		return 0;
	} else {
		return this.children.length;
	}
};

ParserRuleContext.prototype.getSourceInterval = function() {
    if( this.start === null || this.stop === null) {
        return INVALID_INTERVAL;
    } else {
        return new Interval(this.start.tokenIndex, this.stop.tokenIndex);
    }
};

RuleContext.EMPTY = new ParserRuleContext();

function InterpreterRuleContext(parent, invokingStateNumber, ruleIndex) {
	ParserRuleContext.call(parent, invokingStateNumber);
    this.ruleIndex = ruleIndex;
    return this;
}

InterpreterRuleContext.prototype = Object.create(ParserRuleContext.prototype);
InterpreterRuleContext.prototype.constructor = InterpreterRuleContext;

exports.ParserRuleContext = ParserRuleContext;
},{"./IntervalSet":49,"./RuleContext":56,"./tree/Tree":87}],54:[function(require,module,exports){
//
/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
///

var RuleContext = require('./RuleContext').RuleContext;
var Hash = require('./Utils').Hash;
var Map = require('./Utils').Map;

function PredictionContext(cachedHashCode) {
	this.cachedHashCode = cachedHashCode;
}

// Represents {@code $} in local context prediction, which means wildcard.
// {@code//+x =//}.
// /
PredictionContext.EMPTY = null;

// Represents {@code $} in an array in full context mode, when {@code $}
// doesn't mean wildcard: {@code $ + x = [$,x]}. Here,
// {@code $} = {@link //EMPTY_RETURN_STATE}.
// /
PredictionContext.EMPTY_RETURN_STATE = 0x7FFFFFFF;

PredictionContext.globalNodeCount = 1;
PredictionContext.id = PredictionContext.globalNodeCount;

// Stores the computed hash code of this {@link PredictionContext}. The hash
// code is computed in parts to match the following reference algorithm.
//
// <pre>
// private int referenceHashCode() {
// int hash = {@link MurmurHash//initialize MurmurHash.initialize}({@link
// //INITIAL_HASH});
//
// for (int i = 0; i &lt; {@link //size()}; i++) {
// hash = {@link MurmurHash//update MurmurHash.update}(hash, {@link //getParent
// getParent}(i));
// }
//
// for (int i = 0; i &lt; {@link //size()}; i++) {
// hash = {@link MurmurHash//update MurmurHash.update}(hash, {@link
// //getReturnState getReturnState}(i));
// }
//
// hash = {@link MurmurHash//finish MurmurHash.finish}(hash, 2// {@link
// //size()});
// return hash;
// }
// </pre>
// /

// This means only the {@link //EMPTY} context is in set.
PredictionContext.prototype.isEmpty = function() {
	return this === PredictionContext.EMPTY;
};

PredictionContext.prototype.hasEmptyPath = function() {
	return this.getReturnState(this.length - 1) === PredictionContext.EMPTY_RETURN_STATE;
};

PredictionContext.prototype.hashCode = function() {
	return this.cachedHashCode;
};


PredictionContext.prototype.updateHashCode = function(hash) {
    hash.update(this.cachedHashCode);
};
/*
function calculateHashString(parent, returnState) {
	return "" + parent + returnState;
}
*/

// Used to cache {@link PredictionContext} objects. Its used for the shared
// context cash associated with contexts in DFA states. This cache
// can be used for both lexers and parsers.

function PredictionContextCache() {
	this.cache = new Map();
	return this;
}

// Add a context to the cache and return it. If the context already exists,
// return that one instead and do not add a new context to the cache.
// Protect shared cache from unsafe thread access.
//
PredictionContextCache.prototype.add = function(ctx) {
	if (ctx === PredictionContext.EMPTY) {
		return PredictionContext.EMPTY;
	}
	var existing = this.cache.get(ctx) || null;
	if (existing !== null) {
		return existing;
	}
	this.cache.put(ctx, ctx);
	return ctx;
};

PredictionContextCache.prototype.get = function(ctx) {
	return this.cache.get(ctx) || null;
};

Object.defineProperty(PredictionContextCache.prototype, "length", {
	get : function() {
		return this.cache.length;
	}
});

function SingletonPredictionContext(parent, returnState) {
	var hashCode = 0;
	var hash = new Hash();
	if(parent !== null) {
		hash.update(parent, returnState);
	} else {
		hash.update(1);
	}
	hashCode = hash.finish();
	PredictionContext.call(this, hashCode);
	this.parentCtx = parent;
	this.returnState = returnState;
}

SingletonPredictionContext.prototype = Object.create(PredictionContext.prototype);
SingletonPredictionContext.prototype.contructor = SingletonPredictionContext;

SingletonPredictionContext.create = function(parent, returnState) {
	if (returnState === PredictionContext.EMPTY_RETURN_STATE && parent === null) {
		// someone can pass in the bits of an array ctx that mean $
		return PredictionContext.EMPTY;
	} else {
		return new SingletonPredictionContext(parent, returnState);
	}
};

Object.defineProperty(SingletonPredictionContext.prototype, "length", {
	get : function() {
		return 1;
	}
});

SingletonPredictionContext.prototype.getParent = function(index) {
	return this.parentCtx;
};

SingletonPredictionContext.prototype.getReturnState = function(index) {
	return this.returnState;
};

SingletonPredictionContext.prototype.equals = function(other) {
	if (this === other) {
		return true;
	} else if (!(other instanceof SingletonPredictionContext)) {
		return false;
	} else if (this.hashCode() !== other.hashCode()) {
		return false; // can't be same if hash is different
	} else {
		if(this.returnState !== other.returnState)
            return false;
        else if(this.parentCtx==null)
            return other.parentCtx==null
		else
            return this.parentCtx.equals(other.parentCtx);
	}
};

SingletonPredictionContext.prototype.toString = function() {
	var up = this.parentCtx === null ? "" : this.parentCtx.toString();
	if (up.length === 0) {
		if (this.returnState === PredictionContext.EMPTY_RETURN_STATE) {
			return "$";
		} else {
			return "" + this.returnState;
		}
	} else {
		return "" + this.returnState + " " + up;
	}
};

function EmptyPredictionContext() {
	SingletonPredictionContext.call(this, null, PredictionContext.EMPTY_RETURN_STATE);
	return this;
}

EmptyPredictionContext.prototype = Object.create(SingletonPredictionContext.prototype);
EmptyPredictionContext.prototype.constructor = EmptyPredictionContext;

EmptyPredictionContext.prototype.isEmpty = function() {
	return true;
};

EmptyPredictionContext.prototype.getParent = function(index) {
	return null;
};

EmptyPredictionContext.prototype.getReturnState = function(index) {
	return this.returnState;
};

EmptyPredictionContext.prototype.equals = function(other) {
	return this === other;
};

EmptyPredictionContext.prototype.toString = function() {
	return "$";
};

PredictionContext.EMPTY = new EmptyPredictionContext();

function ArrayPredictionContext(parents, returnStates) {
	// Parent can be null only if full ctx mode and we make an array
	// from {@link //EMPTY} and non-empty. We merge {@link //EMPTY} by using
	// null parent and
	// returnState == {@link //EMPTY_RETURN_STATE}.
	var h = new Hash();
	h.update(parents, returnStates);
	var hashCode = h.finish();
	PredictionContext.call(this, hashCode);
	this.parents = parents;
	this.returnStates = returnStates;
	return this;
}

ArrayPredictionContext.prototype = Object.create(PredictionContext.prototype);
ArrayPredictionContext.prototype.constructor = ArrayPredictionContext;

ArrayPredictionContext.prototype.isEmpty = function() {
	// since EMPTY_RETURN_STATE can only appear in the last position, we
	// don't need to verify that size==1
	return this.returnStates[0] === PredictionContext.EMPTY_RETURN_STATE;
};

Object.defineProperty(ArrayPredictionContext.prototype, "length", {
	get : function() {
		return this.returnStates.length;
	}
});

ArrayPredictionContext.prototype.getParent = function(index) {
	return this.parents[index];
};

ArrayPredictionContext.prototype.getReturnState = function(index) {
	return this.returnStates[index];
};

ArrayPredictionContext.prototype.equals = function(other) {
	if (this === other) {
		return true;
	} else if (!(other instanceof ArrayPredictionContext)) {
		return false;
	} else if (this.hashCode() !== other.hashCode()) {
		return false; // can't be same if hash is different
	} else {
		return this.returnStates === other.returnStates &&
				this.parents === other.parents;
	}
};

ArrayPredictionContext.prototype.toString = function() {
	if (this.isEmpty()) {
		return "[]";
	} else {
		var s = "[";
		for (var i = 0; i < this.returnStates.length; i++) {
			if (i > 0) {
				s = s + ", ";
			}
			if (this.returnStates[i] === PredictionContext.EMPTY_RETURN_STATE) {
				s = s + "$";
				continue;
			}
			s = s + this.returnStates[i];
			if (this.parents[i] !== null) {
				s = s + " " + this.parents[i];
			} else {
				s = s + "null";
			}
		}
		return s + "]";
	}
};

// Convert a {@link RuleContext} tree to a {@link PredictionContext} graph.
// Return {@link //EMPTY} if {@code outerContext} is empty or null.
// /
function predictionContextFromRuleContext(atn, outerContext) {
	if (outerContext === undefined || outerContext === null) {
		outerContext = RuleContext.EMPTY;
	}
	// if we are in RuleContext of start rule, s, then PredictionContext
	// is EMPTY. Nobody called us. (if we are empty, return empty)
	if (outerContext.parentCtx === null || outerContext === RuleContext.EMPTY) {
		return PredictionContext.EMPTY;
	}
	// If we have a parent, convert it to a PredictionContext graph
	var parent = predictionContextFromRuleContext(atn, outerContext.parentCtx);
	var state = atn.states[outerContext.invokingState];
	var transition = state.transitions[0];
	return SingletonPredictionContext.create(parent, transition.followState.stateNumber);
}
/*
function calculateListsHashString(parents, returnStates) {
	var s = "";
	parents.map(function(p) {
		s = s + p;
	});
	returnStates.map(function(r) {
		s = s + r;
	});
	return s;
}
*/
function merge(a, b, rootIsWildcard, mergeCache) {
	// share same graph if both same
	if (a === b) {
		return a;
	}
	if (a instanceof SingletonPredictionContext && b instanceof SingletonPredictionContext) {
		return mergeSingletons(a, b, rootIsWildcard, mergeCache);
	}
	// At least one of a or b is array
	// If one is $ and rootIsWildcard, return $ as// wildcard
	if (rootIsWildcard) {
		if (a instanceof EmptyPredictionContext) {
			return a;
		}
		if (b instanceof EmptyPredictionContext) {
			return b;
		}
	}
	// convert singleton so both are arrays to normalize
	if (a instanceof SingletonPredictionContext) {
		a = new ArrayPredictionContext([a.getParent()], [a.returnState]);
	}
	if (b instanceof SingletonPredictionContext) {
		b = new ArrayPredictionContext([b.getParent()], [b.returnState]);
	}
	return mergeArrays(a, b, rootIsWildcard, mergeCache);
}

//
// Merge two {@link SingletonPredictionContext} instances.
//
// <p>Stack tops equal, parents merge is same; return left graph.<br>
// <embed src="images/SingletonMerge_SameRootSamePar.svg"
// type="image/svg+xml"/></p>
//
// <p>Same stack top, parents differ; merge parents giving array node, then
// remainders of those graphs. A new root node is created to point to the
// merged parents.<br>
// <embed src="images/SingletonMerge_SameRootDiffPar.svg"
// type="image/svg+xml"/></p>
//
// <p>Different stack tops pointing to same parent. Make array node for the
// root where both element in the root point to the same (original)
// parent.<br>
// <embed src="images/SingletonMerge_DiffRootSamePar.svg"
// type="image/svg+xml"/></p>
//
// <p>Different stack tops pointing to different parents. Make array node for
// the root where each element points to the corresponding original
// parent.<br>
// <embed src="images/SingletonMerge_DiffRootDiffPar.svg"
// type="image/svg+xml"/></p>
//
// @param a the first {@link SingletonPredictionContext}
// @param b the second {@link SingletonPredictionContext}
// @param rootIsWildcard {@code true} if this is a local-context merge,
// otherwise false to indicate a full-context merge
// @param mergeCache
// /
function mergeSingletons(a, b, rootIsWildcard, mergeCache) {
	if (mergeCache !== null) {
		var previous = mergeCache.get(a, b);
		if (previous !== null) {
			return previous;
		}
		previous = mergeCache.get(b, a);
		if (previous !== null) {
			return previous;
		}
	}

	var rootMerge = mergeRoot(a, b, rootIsWildcard);
	if (rootMerge !== null) {
		if (mergeCache !== null) {
			mergeCache.set(a, b, rootMerge);
		}
		return rootMerge;
	}
	if (a.returnState === b.returnState) {
		var parent = merge(a.parentCtx, b.parentCtx, rootIsWildcard, mergeCache);
		// if parent is same as existing a or b parent or reduced to a parent,
		// return it
		if (parent === a.parentCtx) {
			return a; // ax + bx = ax, if a=b
		}
		if (parent === b.parentCtx) {
			return b; // ax + bx = bx, if a=b
		}
		// else: ax + ay = a'[x,y]
		// merge parents x and y, giving array node with x,y then remainders
		// of those graphs. dup a, a' points at merged array
		// new joined parent so create new singleton pointing to it, a'
		var spc = SingletonPredictionContext.create(parent, a.returnState);
		if (mergeCache !== null) {
			mergeCache.set(a, b, spc);
		}
		return spc;
	} else { // a != b payloads differ
		// see if we can collapse parents due to $+x parents if local ctx
		var singleParent = null;
		if (a === b || (a.parentCtx !== null && a.parentCtx === b.parentCtx)) { // ax +
																				// bx =
																				// [a,b]x
			singleParent = a.parentCtx;
		}
		if (singleParent !== null) { // parents are same
			// sort payloads and use same parent
			var payloads = [ a.returnState, b.returnState ];
			if (a.returnState > b.returnState) {
				payloads[0] = b.returnState;
				payloads[1] = a.returnState;
			}
			var parents = [ singleParent, singleParent ];
			var apc = new ArrayPredictionContext(parents, payloads);
			if (mergeCache !== null) {
				mergeCache.set(a, b, apc);
			}
			return apc;
		}
		// parents differ and can't merge them. Just pack together
		// into array; can't merge.
		// ax + by = [ax,by]
		var payloads = [ a.returnState, b.returnState ];
		var parents = [ a.parentCtx, b.parentCtx ];
		if (a.returnState > b.returnState) { // sort by payload
			payloads[0] = b.returnState;
			payloads[1] = a.returnState;
			parents = [ b.parentCtx, a.parentCtx ];
		}
		var a_ = new ArrayPredictionContext(parents, payloads);
		if (mergeCache !== null) {
			mergeCache.set(a, b, a_);
		}
		return a_;
	}
}

//
// Handle case where at least one of {@code a} or {@code b} is
// {@link //EMPTY}. In the following diagrams, the symbol {@code $} is used
// to represent {@link //EMPTY}.
//
// <h2>Local-Context Merges</h2>
//
// <p>These local-context merge operations are used when {@code rootIsWildcard}
// is true.</p>
//
// <p>{@link //EMPTY} is superset of any graph; return {@link //EMPTY}.<br>
// <embed src="images/LocalMerge_EmptyRoot.svg" type="image/svg+xml"/></p>
//
// <p>{@link //EMPTY} and anything is {@code //EMPTY}, so merged parent is
// {@code //EMPTY}; return left graph.<br>
// <embed src="images/LocalMerge_EmptyParent.svg" type="image/svg+xml"/></p>
//
// <p>Special case of last merge if local context.<br>
// <embed src="images/LocalMerge_DiffRoots.svg" type="image/svg+xml"/></p>
//
// <h2>Full-Context Merges</h2>
//
// <p>These full-context merge operations are used when {@code rootIsWildcard}
// is false.</p>
//
// <p><embed src="images/FullMerge_EmptyRoots.svg" type="image/svg+xml"/></p>
//
// <p>Must keep all contexts; {@link //EMPTY} in array is a special value (and
// null parent).<br>
// <embed src="images/FullMerge_EmptyRoot.svg" type="image/svg+xml"/></p>
//
// <p><embed src="images/FullMerge_SameRoot.svg" type="image/svg+xml"/></p>
//
// @param a the first {@link SingletonPredictionContext}
// @param b the second {@link SingletonPredictionContext}
// @param rootIsWildcard {@code true} if this is a local-context merge,
// otherwise false to indicate a full-context merge
// /
function mergeRoot(a, b, rootIsWildcard) {
	if (rootIsWildcard) {
		if (a === PredictionContext.EMPTY) {
			return PredictionContext.EMPTY; // // + b =//
		}
		if (b === PredictionContext.EMPTY) {
			return PredictionContext.EMPTY; // a +// =//
		}
	} else {
		if (a === PredictionContext.EMPTY && b === PredictionContext.EMPTY) {
			return PredictionContext.EMPTY; // $ + $ = $
		} else if (a === PredictionContext.EMPTY) { // $ + x = [$,x]
			var payloads = [ b.returnState,
					PredictionContext.EMPTY_RETURN_STATE ];
			var parents = [ b.parentCtx, null ];
			return new ArrayPredictionContext(parents, payloads);
		} else if (b === PredictionContext.EMPTY) { // x + $ = [$,x] ($ is always first if present)
			var payloads = [ a.returnState, PredictionContext.EMPTY_RETURN_STATE ];
			var parents = [ a.parentCtx, null ];
			return new ArrayPredictionContext(parents, payloads);
		}
	}
	return null;
}

//
// Merge two {@link ArrayPredictionContext} instances.
//
// <p>Different tops, different parents.<br>
// <embed src="images/ArrayMerge_DiffTopDiffPar.svg" type="image/svg+xml"/></p>
//
// <p>Shared top, same parents.<br>
// <embed src="images/ArrayMerge_ShareTopSamePar.svg" type="image/svg+xml"/></p>
//
// <p>Shared top, different parents.<br>
// <embed src="images/ArrayMerge_ShareTopDiffPar.svg" type="image/svg+xml"/></p>
//
// <p>Shared top, all shared parents.<br>
// <embed src="images/ArrayMerge_ShareTopSharePar.svg"
// type="image/svg+xml"/></p>
//
// <p>Equal tops, merge parents and reduce top to
// {@link SingletonPredictionContext}.<br>
// <embed src="images/ArrayMerge_EqualTop.svg" type="image/svg+xml"/></p>
// /
function mergeArrays(a, b, rootIsWildcard, mergeCache) {
	if (mergeCache !== null) {
		var previous = mergeCache.get(a, b);
		if (previous !== null) {
			return previous;
		}
		previous = mergeCache.get(b, a);
		if (previous !== null) {
			return previous;
		}
	}
	// merge sorted payloads a + b => M
	var i = 0; // walks a
	var j = 0; // walks b
	var k = 0; // walks target M array

	var mergedReturnStates = [];
	var mergedParents = [];
	// walk and merge to yield mergedParents, mergedReturnStates
	while (i < a.returnStates.length && j < b.returnStates.length) {
		var a_parent = a.parents[i];
		var b_parent = b.parents[j];
		if (a.returnStates[i] === b.returnStates[j]) {
			// same payload (stack tops are equal), must yield merged singleton
			var payload = a.returnStates[i];
			// $+$ = $
			var bothDollars = payload === PredictionContext.EMPTY_RETURN_STATE &&
					a_parent === null && b_parent === null;
			var ax_ax = (a_parent !== null && b_parent !== null && a_parent === b_parent); // ax+ax
																							// ->
																							// ax
			if (bothDollars || ax_ax) {
				mergedParents[k] = a_parent; // choose left
				mergedReturnStates[k] = payload;
			} else { // ax+ay -> a'[x,y]
				var mergedParent = merge(a_parent, b_parent, rootIsWildcard, mergeCache);
				mergedParents[k] = mergedParent;
				mergedReturnStates[k] = payload;
			}
			i += 1; // hop over left one as usual
			j += 1; // but also skip one in right side since we merge
		} else if (a.returnStates[i] < b.returnStates[j]) { // copy a[i] to M
			mergedParents[k] = a_parent;
			mergedReturnStates[k] = a.returnStates[i];
			i += 1;
		} else { // b > a, copy b[j] to M
			mergedParents[k] = b_parent;
			mergedReturnStates[k] = b.returnStates[j];
			j += 1;
		}
		k += 1;
	}
	// copy over any payloads remaining in either array
	if (i < a.returnStates.length) {
		for (var p = i; p < a.returnStates.length; p++) {
			mergedParents[k] = a.parents[p];
			mergedReturnStates[k] = a.returnStates[p];
			k += 1;
		}
	} else {
		for (var p = j; p < b.returnStates.length; p++) {
			mergedParents[k] = b.parents[p];
			mergedReturnStates[k] = b.returnStates[p];
			k += 1;
		}
	}
	// trim merged if we combined a few that had same stack tops
	if (k < mergedParents.length) { // write index < last position; trim
		if (k === 1) { // for just one merged element, return singleton top
			var a_ = SingletonPredictionContext.create(mergedParents[0],
					mergedReturnStates[0]);
			if (mergeCache !== null) {
				mergeCache.set(a, b, a_);
			}
			return a_;
		}
		mergedParents = mergedParents.slice(0, k);
		mergedReturnStates = mergedReturnStates.slice(0, k);
	}

	var M = new ArrayPredictionContext(mergedParents, mergedReturnStates);

	// if we created same array as a or b, return that instead
	// TODO: track whether this is possible above during merge sort for speed
	if (M === a) {
		if (mergeCache !== null) {
			mergeCache.set(a, b, a);
		}
		return a;
	}
	if (M === b) {
		if (mergeCache !== null) {
			mergeCache.set(a, b, b);
		}
		return b;
	}
	combineCommonParents(mergedParents);

	if (mergeCache !== null) {
		mergeCache.set(a, b, M);
	}
	return M;
}

//
// Make pass over all <em>M</em> {@code parents}; merge any {@code equals()}
// ones.
// /
function combineCommonParents(parents) {
	var uniqueParents = new Map();

	for (var p = 0; p < parents.length; p++) {
		var parent = parents[p];
		if (!(uniqueParents.containsKey(parent))) {
			uniqueParents.put(parent, parent);
		}
	}
	for (var q = 0; q < parents.length; q++) {
		parents[q] = uniqueParents.get(parents[q]);
	}
}

function getCachedPredictionContext(context, contextCache, visited) {
	if (context.isEmpty()) {
		return context;
	}
	var existing = visited.get(context) || null;
	if (existing !== null) {
		return existing;
	}
	existing = contextCache.get(context);
	if (existing !== null) {
		visited.put(context, existing);
		return existing;
	}
	var changed = false;
	var parents = [];
	for (var i = 0; i < parents.length; i++) {
		var parent = getCachedPredictionContext(context.getParent(i), contextCache, visited);
		if (changed || parent !== context.getParent(i)) {
			if (!changed) {
				parents = [];
				for (var j = 0; j < context.length; j++) {
					parents[j] = context.getParent(j);
				}
				changed = true;
			}
			parents[i] = parent;
		}
	}
	if (!changed) {
		contextCache.add(context);
		visited.put(context, context);
		return context;
	}
	var updated = null;
	if (parents.length === 0) {
		updated = PredictionContext.EMPTY;
	} else if (parents.length === 1) {
		updated = SingletonPredictionContext.create(parents[0], context
				.getReturnState(0));
	} else {
		updated = new ArrayPredictionContext(parents, context.returnStates);
	}
	contextCache.add(updated);
	visited.put(updated, updated);
	visited.put(context, updated);

	return updated;
}

// ter's recursive version of Sam's getAllNodes()
function getAllContextNodes(context, nodes, visited) {
	if (nodes === null) {
		nodes = [];
		return getAllContextNodes(context, nodes, visited);
	} else if (visited === null) {
		visited = new Map();
		return getAllContextNodes(context, nodes, visited);
	} else {
		if (context === null || visited.containsKey(context)) {
			return nodes;
		}
		visited.put(context, context);
		nodes.push(context);
		for (var i = 0; i < context.length; i++) {
			getAllContextNodes(context.getParent(i), nodes, visited);
		}
		return nodes;
	}
}

exports.merge = merge;
exports.PredictionContext = PredictionContext;
exports.PredictionContextCache = PredictionContextCache;
exports.SingletonPredictionContext = SingletonPredictionContext;
exports.predictionContextFromRuleContext = predictionContextFromRuleContext;
exports.getCachedPredictionContext = getCachedPredictionContext;

},{"./RuleContext":56,"./Utils":58}],55:[function(require,module,exports){
//
/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
//

var Token = require('./Token').Token;
var ConsoleErrorListener = require('./error/ErrorListener').ConsoleErrorListener;
var ProxyErrorListener = require('./error/ErrorListener').ProxyErrorListener;

function Recognizer() {
    this._listeners = [ ConsoleErrorListener.INSTANCE ];
    this._interp = null;
    this._stateNumber = -1;
    return this;
}

Recognizer.tokenTypeMapCache = {};
Recognizer.ruleIndexMapCache = {};


Recognizer.prototype.checkVersion = function(toolVersion) {
    var runtimeVersion = "4.8";
    if (runtimeVersion!==toolVersion) {
        console.log("ANTLR runtime and generated code versions disagree: "+runtimeVersion+"!="+toolVersion);
    }
};

Recognizer.prototype.addErrorListener = function(listener) {
    this._listeners.push(listener);
};

Recognizer.prototype.removeErrorListeners = function() {
    this._listeners = [];
};

Recognizer.prototype.getTokenTypeMap = function() {
    var tokenNames = this.getTokenNames();
    if (tokenNames===null) {
        throw("The current recognizer does not provide a list of token names.");
    }
    var result = this.tokenTypeMapCache[tokenNames];
    if(result===undefined) {
        result = tokenNames.reduce(function(o, k, i) { o[k] = i; });
        result.EOF = Token.EOF;
        this.tokenTypeMapCache[tokenNames] = result;
    }
    return result;
};

// Get a map from rule names to rule indexes.
//
// <p>Used for XPath and tree pattern compilation.</p>
//
Recognizer.prototype.getRuleIndexMap = function() {
    var ruleNames = this.ruleNames;
    if (ruleNames===null) {
        throw("The current recognizer does not provide a list of rule names.");
    }
    var result = this.ruleIndexMapCache[ruleNames];
    if(result===undefined) {
        result = ruleNames.reduce(function(o, k, i) { o[k] = i; });
        this.ruleIndexMapCache[ruleNames] = result;
    }
    return result;
};

Recognizer.prototype.getTokenType = function(tokenName) {
    var ttype = this.getTokenTypeMap()[tokenName];
    if (ttype !==undefined) {
        return ttype;
    } else {
        return Token.INVALID_TYPE;
    }
};


// What is the error header, normally line/character position information?//
Recognizer.prototype.getErrorHeader = function(e) {
    var line = e.getOffendingToken().line;
    var column = e.getOffendingToken().column;
    return "line " + line + ":" + column;
};


// How should a token be displayed in an error message? The default
//  is to display just the text, but during development you might
//  want to have a lot of information spit out.  Override in that case
//  to use t.toString() (which, for CommonToken, dumps everything about
//  the token). This is better than forcing you to override a method in
//  your token objects because you don't have to go modify your lexer
//  so that it creates a new Java type.
//
// @deprecated This method is not called by the ANTLR 4 Runtime. Specific
// implementations of {@link ANTLRErrorStrategy} may provide a similar
// feature when necessary. For example, see
// {@link DefaultErrorStrategy//getTokenErrorDisplay}.
//
Recognizer.prototype.getTokenErrorDisplay = function(t) {
    if (t===null) {
        return "<no token>";
    }
    var s = t.text;
    if (s===null) {
        if (t.type===Token.EOF) {
            s = "<EOF>";
        } else {
            s = "<" + t.type + ">";
        }
    }
    s = s.replace("\n","\\n").replace("\r","\\r").replace("\t","\\t");
    return "'" + s + "'";
};

Recognizer.prototype.getErrorListenerDispatch = function() {
    return new ProxyErrorListener(this._listeners);
};

// subclass needs to override these if there are sempreds or actions
// that the ATN interp needs to execute
Recognizer.prototype.sempred = function(localctx, ruleIndex, actionIndex) {
    return true;
};

Recognizer.prototype.precpred = function(localctx , precedence) {
    return true;
};

//Indicate that the recognizer has changed internal state that is
//consistent with the ATN state passed in.  This way we always know
//where we are in the ATN as the parser goes along. The rule
//context objects form a stack that lets us see the stack of
//invoking rules. Combine this and we have complete ATN
//configuration information.

Object.defineProperty(Recognizer.prototype, "state", {
	get : function() {
		return this._stateNumber;
	},
	set : function(state) {
		this._stateNumber = state;
	}
});


exports.Recognizer = Recognizer;

},{"./Token":57,"./error/ErrorListener":80}],56:[function(require,module,exports){
/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
///

//  A rule context is a record of a single rule invocation. It knows
//  which context invoked it, if any. If there is no parent context, then
//  naturally the invoking state is not valid.  The parent link
//  provides a chain upwards from the current rule invocation to the root
//  of the invocation tree, forming a stack. We actually carry no
//  information about the rule associated with this context (except
//  when parsing). We keep only the state number of the invoking state from
//  the ATN submachine that invoked this. Contrast this with the s
//  pointer inside ParserRuleContext that tracks the current state
//  being "executed" for the current rule.
//
//  The parent contexts are useful for computing lookahead sets and
//  getting error information.
//
//  These objects are used during parsing and prediction.
//  For the special case of parsers, we use the subclass
//  ParserRuleContext.
//
//  @see ParserRuleContext
///

var RuleNode = require('./tree/Tree').RuleNode;
var INVALID_INTERVAL = require('./tree/Tree').INVALID_INTERVAL;
var INVALID_ALT_NUMBER = require('./atn/ATN').INVALID_ALT_NUMBER;

function RuleContext(parent, invokingState) {
	RuleNode.call(this);
	// What context invoked this rule?
	this.parentCtx = parent || null;
	// What state invoked the rule associated with this context?
	// The "return address" is the followState of invokingState
	// If parent is null, this should be -1.
	this.invokingState = invokingState || -1;
	return this;
}

RuleContext.prototype = Object.create(RuleNode.prototype);
RuleContext.prototype.constructor = RuleContext;

RuleContext.prototype.depth = function() {
	var n = 0;
	var p = this;
	while (p !== null) {
		p = p.parentCtx;
		n += 1;
	}
	return n;
};

// A context is empty if there is no invoking state; meaning nobody call
// current context.
RuleContext.prototype.isEmpty = function() {
	return this.invokingState === -1;
};

// satisfy the ParseTree / SyntaxTree interface

RuleContext.prototype.getSourceInterval = function() {
	return INVALID_INTERVAL;
};

RuleContext.prototype.getRuleContext = function() {
	return this;
};

RuleContext.prototype.getPayload = function() {
	return this;
};

// Return the combined text of all child nodes. This method only considers
// tokens which have been added to the parse tree.
// <p>
// Since tokens on hidden channels (e.g. whitespace or comments) are not
// added to the parse trees, they will not appear in the output of this
// method.
// /
RuleContext.prototype.getText = function() {
	if (this.getChildCount() === 0) {
		return "";
	} else {
		return this.children.map(function(child) {
			return child.getText();
		}).join("");
	}
};

// For rule associated with this parse tree internal node, return
// the outer alternative number used to match the input. Default
// implementation does not compute nor store this alt num. Create
// a subclass of ParserRuleContext with backing field and set
// option contextSuperClass.
// to set it.
RuleContext.prototype.getAltNumber = function() { return INVALID_ALT_NUMBER; }

// Set the outer alternative number for this context node. Default
// implementation does nothing to avoid backing field overhead for
// trees that don't need it.  Create
// a subclass of ParserRuleContext with backing field and set
// option contextSuperClass.
RuleContext.prototype.setAltNumber = function(altNumber) { }

RuleContext.prototype.getChild = function(i) {
	return null;
};

RuleContext.prototype.getChildCount = function() {
	return 0;
};

RuleContext.prototype.accept = function(visitor) {
	return visitor.visitChildren(this);
};

//need to manage circular dependencies, so export now
exports.RuleContext = RuleContext;
var Trees = require('./tree/Trees').Trees;


// Print out a whole tree, not just a node, in LISP format
// (root child1 .. childN). Print just a node if this is a leaf.
//

RuleContext.prototype.toStringTree = function(ruleNames, recog) {
	return Trees.toStringTree(this, ruleNames, recog);
};

RuleContext.prototype.toString = function(ruleNames, stop) {
	ruleNames = ruleNames || null;
	stop = stop || null;
	var p = this;
	var s = "[";
	while (p !== null && p !== stop) {
		if (ruleNames === null) {
			if (!p.isEmpty()) {
				s += p.invokingState;
			}
		} else {
			var ri = p.ruleIndex;
			var ruleName = (ri >= 0 && ri < ruleNames.length) ? ruleNames[ri]
					: "" + ri;
			s += ruleName;
		}
		if (p.parentCtx !== null && (ruleNames !== null || !p.parentCtx.isEmpty())) {
			s += " ";
		}
		p = p.parentCtx;
	}
	s += "]";
	return s;
};


},{"./atn/ATN":59,"./tree/Tree":87,"./tree/Trees":88}],57:[function(require,module,exports){
/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
//

// A token has properties: text, type, line, character position in the line
// (so we can ignore tabs), token channel, index, and source from which
// we obtained this token.

function Token() {
	this.source = null;
	this.type = null; // token type of the token
	this.channel = null; // The parser ignores everything not on DEFAULT_CHANNEL
	this.start = null; // optional; return -1 if not implemented.
	this.stop = null; // optional; return -1 if not implemented.
	this.tokenIndex = null; // from 0..n-1 of the token object in the input stream
	this.line = null; // line=1..n of the 1st character
	this.column = null; // beginning of the line at which it occurs, 0..n-1
	this._text = null; // text of the token.
	return this;
}

Token.INVALID_TYPE = 0;

// During lookahead operations, this "token" signifies we hit rule end ATN state
// and did not follow it despite needing to.
Token.EPSILON = -2;

Token.MIN_USER_TOKEN_TYPE = 1;

Token.EOF = -1;

// All tokens go to the parser (unless skip() is called in that rule)
// on a particular "channel". The parser tunes to a particular channel
// so that whitespace etc... can go to the parser on a "hidden" channel.

Token.DEFAULT_CHANNEL = 0;

// Anything on different channel than DEFAULT_CHANNEL is not parsed
// by parser.

Token.HIDDEN_CHANNEL = 1;

// Explicitly set the text for this token. If {code text} is not
// {@code null}, then {@link //getText} will return this value rather than
// extracting the text from the input.
//
// @param text The explicit text of the token, or {@code null} if the text
// should be obtained from the input along with the start and stop indexes
// of the token.

Object.defineProperty(Token.prototype, "text", {
	get : function() {
		return this._text;
	},
	set : function(text) {
		this._text = text;
	}
});

Token.prototype.getTokenSource = function() {
	return this.source[0];
};

Token.prototype.getInputStream = function() {
	return this.source[1];
};

function CommonToken(source, type, channel, start, stop) {
	Token.call(this);
	this.source = source !== undefined ? source : CommonToken.EMPTY_SOURCE;
	this.type = type !== undefined ? type : null;
	this.channel = channel !== undefined ? channel : Token.DEFAULT_CHANNEL;
	this.start = start !== undefined ? start : -1;
	this.stop = stop !== undefined ? stop : -1;
	this.tokenIndex = -1;
	if (this.source[0] !== null) {
		this.line = source[0].line;
		this.column = source[0].column;
	} else {
		this.column = -1;
	}
	return this;
}

CommonToken.prototype = Object.create(Token.prototype);
CommonToken.prototype.constructor = CommonToken;

// An empty {@link Pair} which is used as the default value of
// {@link //source} for tokens that do not have a source.
CommonToken.EMPTY_SOURCE = [ null, null ];

// Constructs a new {@link CommonToken} as a copy of another {@link Token}.
//
// <p>
// If {@code oldToken} is also a {@link CommonToken} instance, the newly
// constructed token will share a reference to the {@link //text} field and
// the {@link Pair} stored in {@link //source}. Otherwise, {@link //text} will
// be assigned the result of calling {@link //getText}, and {@link //source}
// will be constructed from the result of {@link Token//getTokenSource} and
// {@link Token//getInputStream}.</p>
//
// @param oldToken The token to copy.
//
CommonToken.prototype.clone = function() {
	var t = new CommonToken(this.source, this.type, this.channel, this.start,
			this.stop);
	t.tokenIndex = this.tokenIndex;
	t.line = this.line;
	t.column = this.column;
	t.text = this.text;
	return t;
};

Object.defineProperty(CommonToken.prototype, "text", {
	get : function() {
		if (this._text !== null) {
			return this._text;
		}
		var input = this.getInputStream();
		if (input === null) {
			return null;
		}
		var n = input.size;
		if (this.start < n && this.stop < n) {
			return input.getText(this.start, this.stop);
		} else {
			return "<EOF>";
		}
	},
	set : function(text) {
		this._text = text;
	}
});

CommonToken.prototype.toString = function() {
	var txt = this.text;
	if (txt !== null) {
		txt = txt.replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/\t/g, "\\t");
	} else {
		txt = "<no text>";
	}
	return "[@" + this.tokenIndex + "," + this.start + ":" + this.stop + "='" +
			txt + "',<" + this.type + ">" +
			(this.channel > 0 ? ",channel=" + this.channel : "") + "," +
			this.line + ":" + this.column + "]";
};

exports.Token = Token;
exports.CommonToken = CommonToken;

},{}],58:[function(require,module,exports){
/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

function arrayToString(a) {
    return "[" + a.join(", ") + "]";
}

String.prototype.seed = String.prototype.seed || Math.round(Math.random() * Math.pow(2, 32));

String.prototype.hashCode = function () {
    var remainder, bytes, h1, h1b, c1, c1b, c2, c2b, k1, i,
        key = this.toString();

    remainder = key.length & 3; // key.length % 4
    bytes = key.length - remainder;
    h1 = String.prototype.seed;
    c1 = 0xcc9e2d51;
    c2 = 0x1b873593;
    i = 0;

    while (i < bytes) {
        k1 =
            ((key.charCodeAt(i) & 0xff)) |
            ((key.charCodeAt(++i) & 0xff) << 8) |
            ((key.charCodeAt(++i) & 0xff) << 16) |
            ((key.charCodeAt(++i) & 0xff) << 24);
        ++i;

        k1 = ((((k1 & 0xffff) * c1) + ((((k1 >>> 16) * c1) & 0xffff) << 16))) & 0xffffffff;
        k1 = (k1 << 15) | (k1 >>> 17);
        k1 = ((((k1 & 0xffff) * c2) + ((((k1 >>> 16) * c2) & 0xffff) << 16))) & 0xffffffff;

        h1 ^= k1;
        h1 = (h1 << 13) | (h1 >>> 19);
        h1b = ((((h1 & 0xffff) * 5) + ((((h1 >>> 16) * 5) & 0xffff) << 16))) & 0xffffffff;
        h1 = (((h1b & 0xffff) + 0x6b64) + ((((h1b >>> 16) + 0xe654) & 0xffff) << 16));
    }

    k1 = 0;

    switch (remainder) {
        case 3:
            k1 ^= (key.charCodeAt(i + 2) & 0xff) << 16;
        case 2:
            k1 ^= (key.charCodeAt(i + 1) & 0xff) << 8;
        case 1:
            k1 ^= (key.charCodeAt(i) & 0xff);

            k1 = (((k1 & 0xffff) * c1) + ((((k1 >>> 16) * c1) & 0xffff) << 16)) & 0xffffffff;
            k1 = (k1 << 15) | (k1 >>> 17);
            k1 = (((k1 & 0xffff) * c2) + ((((k1 >>> 16) * c2) & 0xffff) << 16)) & 0xffffffff;
            h1 ^= k1;
    }

    h1 ^= key.length;

    h1 ^= h1 >>> 16;
    h1 = (((h1 & 0xffff) * 0x85ebca6b) + ((((h1 >>> 16) * 0x85ebca6b) & 0xffff) << 16)) & 0xffffffff;
    h1 ^= h1 >>> 13;
    h1 = ((((h1 & 0xffff) * 0xc2b2ae35) + ((((h1 >>> 16) * 0xc2b2ae35) & 0xffff) << 16))) & 0xffffffff;
    h1 ^= h1 >>> 16;

    return h1 >>> 0;
};

function standardEqualsFunction(a, b) {
    return a.equals(b);
}

function standardHashCodeFunction(a) {
    return a.hashCode();
}

function Set(hashFunction, equalsFunction) {
    this.data = {};
    this.hashFunction = hashFunction || standardHashCodeFunction;
    this.equalsFunction = equalsFunction || standardEqualsFunction;
    return this;
}

Object.defineProperty(Set.prototype, "length", {
    get: function () {
        var l = 0;
        for (var key in this.data) {
            if (key.indexOf("hash_") === 0) {
                l = l + this.data[key].length;
            }
        }
        return l;
    }
});

Set.prototype.add = function (value) {
    var hash = this.hashFunction(value);
    var key = "hash_" + hash;
    if (key in this.data) {
        var values = this.data[key];
        for (var i = 0; i < values.length; i++) {
            if (this.equalsFunction(value, values[i])) {
                return values[i];
            }
        }
        values.push(value);
        return value;
    } else {
        this.data[key] = [value];
        return value;
    }
};

Set.prototype.contains = function (value) {
    return this.get(value) != null;
};

Set.prototype.get = function (value) {
    var hash = this.hashFunction(value);
    var key = "hash_" + hash;
    if (key in this.data) {
        var values = this.data[key];
        for (var i = 0; i < values.length; i++) {
            if (this.equalsFunction(value, values[i])) {
                return values[i];
            }
        }
    }
    return null;
};

Set.prototype.values = function () {
    var l = [];
    for (var key in this.data) {
        if (key.indexOf("hash_") === 0) {
            l = l.concat(this.data[key]);
        }
    }
    return l;
};

Set.prototype.toString = function () {
    return arrayToString(this.values());
};

function BitSet() {
    this.data = [];
    return this;
}

BitSet.prototype.add = function (value) {
    this.data[value] = true;
};

BitSet.prototype.or = function (set) {
    var bits = this;
    Object.keys(set.data).map(function (alt) {
        bits.add(alt);
    });
};

BitSet.prototype.remove = function (value) {
    delete this.data[value];
};

BitSet.prototype.contains = function (value) {
    return this.data[value] === true;
};

BitSet.prototype.values = function () {
    return Object.keys(this.data);
};

BitSet.prototype.minValue = function () {
    return Math.min.apply(null, this.values());
};

BitSet.prototype.hashCode = function () {
    var hash = new Hash();
    hash.update(this.values());
    return hash.finish();
};

BitSet.prototype.equals = function (other) {
    if (!(other instanceof BitSet)) {
        return false;
    }
    return this.hashCode() === other.hashCode();
};

Object.defineProperty(BitSet.prototype, "length", {
    get: function () {
        return this.values().length;
    }
});

BitSet.prototype.toString = function () {
    return "{" + this.values().join(", ") + "}";
};

function Map(hashFunction, equalsFunction) {
    this.data = {};
    this.hashFunction = hashFunction || standardHashCodeFunction;
    this.equalsFunction = equalsFunction || standardEqualsFunction;
    return this;
}

Object.defineProperty(Map.prototype, "length", {
    get: function () {
        var l = 0;
        for (var hashKey in this.data) {
            if (hashKey.indexOf("hash_") === 0) {
                l = l + this.data[hashKey].length;
            }
        }
        return l;
    }
});

Map.prototype.put = function (key, value) {
    var hashKey = "hash_" + this.hashFunction(key);
    if (hashKey in this.data) {
        var entries = this.data[hashKey];
        for (var i = 0; i < entries.length; i++) {
            var entry = entries[i];
            if (this.equalsFunction(key, entry.key)) {
                var oldValue = entry.value;
                entry.value = value;
                return oldValue;
            }
        }
        entries.push({key:key, value:value});
        return value;
    } else {
        this.data[hashKey] = [{key:key, value:value}];
        return value;
    }
};

Map.prototype.containsKey = function (key) {
    var hashKey = "hash_" + this.hashFunction(key);
    if(hashKey in this.data) {
        var entries = this.data[hashKey];
        for (var i = 0; i < entries.length; i++) {
            var entry = entries[i];
            if (this.equalsFunction(key, entry.key))
                return true;
        }
    }
    return false;
};

Map.prototype.get = function (key) {
    var hashKey = "hash_" + this.hashFunction(key);
    if(hashKey in this.data) {
        var entries = this.data[hashKey];
        for (var i = 0; i < entries.length; i++) {
            var entry = entries[i];
            if (this.equalsFunction(key, entry.key))
                return entry.value;
        }
    }
    return null;
};

Map.prototype.entries = function () {
    var l = [];
    for (var key in this.data) {
        if (key.indexOf("hash_") === 0) {
            l = l.concat(this.data[key]);
        }
    }
    return l;
};


Map.prototype.getKeys = function () {
    return this.entries().map(function(e) {
        return e.key;
    });
};


Map.prototype.getValues = function () {
    return this.entries().map(function(e) {
            return e.value;
    });
};


Map.prototype.toString = function () {
    var ss = this.entries().map(function(entry) {
        return '{' + entry.key + ':' + entry.value + '}';
    });
    return '[' + ss.join(", ") + ']';
};


function AltDict() {
    this.data = {};
    return this;
}


AltDict.prototype.get = function (key) {
    key = "k-" + key;
    if (key in this.data) {
        return this.data[key];
    } else {
        return null;
    }
};

AltDict.prototype.put = function (key, value) {
    key = "k-" + key;
    this.data[key] = value;
};

AltDict.prototype.values = function () {
    var data = this.data;
    var keys = Object.keys(this.data);
    return keys.map(function (key) {
        return data[key];
    });
};

function DoubleDict(defaultMapCtor) {
    this.defaultMapCtor = defaultMapCtor || Map;
    this.cacheMap = new this.defaultMapCtor();
    return this;
}

function Hash() {
    this.count = 0;
    this.hash = 0;
    return this;
}

Hash.prototype.update = function () {
    for(var i=0;i<arguments.length;i++) {
        var value = arguments[i];
        if (value == null)
            continue;
        if(Array.isArray(value))
            this.update.apply(this, value);
        else {
            var k = 0;
            switch (typeof(value)) {
                case 'undefined':
                case 'function':
                    continue;
                case 'number':
                case 'boolean':
                    k = value;
                    break;
                case 'string':
                    k = value.hashCode();
                    break;
                default:
                    if(value.updateHashCode)
                        value.updateHashCode(this);
                    else
                        console.log("No updateHashCode for " + value.toString())
                    continue;
            }
            k = k * 0xCC9E2D51;
            k = (k << 15) | (k >>> (32 - 15));
            k = k * 0x1B873593;
            this.count = this.count + 1;
            var hash = this.hash ^ k;
            hash = (hash << 13) | (hash >>> (32 - 13));
            hash = hash * 5 + 0xE6546B64;
            this.hash = hash;
        }
    }
};

Hash.prototype.finish = function () {
    var hash = this.hash ^ (this.count * 4);
    hash = hash ^ (hash >>> 16);
    hash = hash * 0x85EBCA6B;
    hash = hash ^ (hash >>> 13);
    hash = hash * 0xC2B2AE35;
    hash = hash ^ (hash >>> 16);
    return hash;
};

function hashStuff() {
    var hash = new Hash();
    hash.update.apply(hash, arguments);
    return hash.finish();
}

DoubleDict.prototype.get = function (a, b) {
    var d = this.cacheMap.get(a) || null;
    return d === null ? null : (d.get(b) || null);
};

DoubleDict.prototype.set = function (a, b, o) {
    var d = this.cacheMap.get(a) || null;
    if (d === null) {
        d = new this.defaultMapCtor();
        this.cacheMap.put(a, d);
    }
    d.put(b, o);
};


function escapeWhitespace(s, escapeSpaces) {
    s = s.replace(/\t/g, "\\t")
         .replace(/\n/g, "\\n")
         .replace(/\r/g, "\\r");
    if (escapeSpaces) {
        s = s.replace(/ /g, "\u00B7");
    }
    return s;
}

function titleCase(str) {
    return str.replace(/\w\S*/g, function (txt) {
        return txt.charAt(0).toUpperCase() + txt.substr(1);
    });
};

function equalArrays(a, b)
{
    if (!Array.isArray(a) || !Array.isArray(b))
        return false;
    if (a == b)
        return true;
    if (a.length != b.length)
        return false;
    for (var i = 0; i < a.length; i++) {
        if (a[i] == b[i])
            continue;
        if (!a[i].equals(b[i]))
            return false;
    }
    return true;
};

exports.Hash = Hash;
exports.Set = Set;
exports.Map = Map;
exports.BitSet = BitSet;
exports.AltDict = AltDict;
exports.DoubleDict = DoubleDict;
exports.hashStuff = hashStuff;
exports.escapeWhitespace = escapeWhitespace;
exports.arrayToString = arrayToString;
exports.titleCase = titleCase;
exports.equalArrays = equalArrays;

},{}],59:[function(require,module,exports){
/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

var LL1Analyzer = require('./../LL1Analyzer').LL1Analyzer;
var IntervalSet = require('./../IntervalSet').IntervalSet;

function ATN(grammarType , maxTokenType) {

    // Used for runtime deserialization of ATNs from strings///
    // The type of the ATN.
    this.grammarType = grammarType;
    // The maximum value for any symbol recognized by a transition in the ATN.
    this.maxTokenType = maxTokenType;
    this.states = [];
    // Each subrule/rule is a decision point and we must track them so we
    //  can go back later and build DFA predictors for them.  This includes
    //  all the rules, subrules, optional blocks, ()+, ()* etc...
    this.decisionToState = [];
    // Maps from rule index to starting state number.
    this.ruleToStartState = [];
    // Maps from rule index to stop state number.
    this.ruleToStopState = null;
    this.modeNameToStartState = {};
    // For lexer ATNs, this maps the rule index to the resulting token type.
    // For parser ATNs, this maps the rule index to the generated bypass token
    // type if the
    // {@link ATNDeserializationOptions//isGenerateRuleBypassTransitions}
    // deserialization option was specified; otherwise, this is {@code null}.
    this.ruleToTokenType = null;
    // For lexer ATNs, this is an array of {@link LexerAction} objects which may
    // be referenced by action transitions in the ATN.
    this.lexerActions = null;
    this.modeToStartState = [];

    return this;
}

// Compute the set of valid tokens that can occur starting in state {@code s}.
//  If {@code ctx} is null, the set of tokens will not include what can follow
//  the rule surrounding {@code s}. In other words, the set will be
//  restricted to tokens reachable staying within {@code s}'s rule.
ATN.prototype.nextTokensInContext = function(s, ctx) {
    var anal = new LL1Analyzer(this);
    return anal.LOOK(s, null, ctx);
};

// Compute the set of valid tokens that can occur starting in {@code s} and
// staying in same rule. {@link Token//EPSILON} is in set if we reach end of
// rule.
ATN.prototype.nextTokensNoContext = function(s) {
    if (s.nextTokenWithinRule !== null ) {
        return s.nextTokenWithinRule;
    }
    s.nextTokenWithinRule = this.nextTokensInContext(s, null);
    s.nextTokenWithinRule.readOnly = true;
    return s.nextTokenWithinRule;
};

ATN.prototype.nextTokens = function(s, ctx) {
    if ( ctx===undefined ) {
        return this.nextTokensNoContext(s);
    } else {
        return this.nextTokensInContext(s, ctx);
    }
};

ATN.prototype.addState = function( state) {
    if ( state !== null ) {
        state.atn = this;
        state.stateNumber = this.states.length;
    }
    this.states.push(state);
};

ATN.prototype.removeState = function( state) {
    this.states[state.stateNumber] = null; // just free mem, don't shift states in list
};

ATN.prototype.defineDecisionState = function( s) {
    this.decisionToState.push(s);
    s.decision = this.decisionToState.length-1;
    return s.decision;
};

ATN.prototype.getDecisionState = function( decision) {
    if (this.decisionToState.length===0) {
        return null;
    } else {
        return this.decisionToState[decision];
    }
};

// Computes the set of input symbols which could follow ATN state number
// {@code stateNumber} in the specified full {@code context}. This method
// considers the complete parser context, but does not evaluate semantic
// predicates (i.e. all predicates encountered during the calculation are
// assumed true). If a path in the ATN exists from the starting state to the
// {@link RuleStopState} of the outermost context without matching any
// symbols, {@link Token//EOF} is added to the returned set.
//
// <p>If {@code context} is {@code null}, it is treated as
// {@link ParserRuleContext//EMPTY}.</p>
//
// @param stateNumber the ATN state number
// @param context the full parse context
// @return The set of potentially valid input symbols which could follow the
// specified state in the specified context.
// @throws IllegalArgumentException if the ATN does not contain a state with
// number {@code stateNumber}
var Token = require('./../Token').Token;

ATN.prototype.getExpectedTokens = function( stateNumber, ctx ) {
    if ( stateNumber < 0 || stateNumber >= this.states.length ) {
        throw("Invalid state number.");
    }
    var s = this.states[stateNumber];
    var following = this.nextTokens(s);
    if (!following.contains(Token.EPSILON)) {
        return following;
    }
    var expected = new IntervalSet();
    expected.addSet(following);
    expected.removeOne(Token.EPSILON);
    while (ctx !== null && ctx.invokingState >= 0 && following.contains(Token.EPSILON)) {
        var invokingState = this.states[ctx.invokingState];
        var rt = invokingState.transitions[0];
        following = this.nextTokens(rt.followState);
        expected.addSet(following);
        expected.removeOne(Token.EPSILON);
        ctx = ctx.parentCtx;
    }
    if (following.contains(Token.EPSILON)) {
        expected.addOne(Token.EOF);
    }
    return expected;
};

ATN.INVALID_ALT_NUMBER = 0;

exports.ATN = ATN;
},{"./../IntervalSet":49,"./../LL1Analyzer":50,"./../Token":57}],60:[function(require,module,exports){
//
/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
///

// A tuple: (ATN state, predicted alt, syntactic, semantic context).
//  The syntactic context is a graph-structured stack node whose
//  path(s) to the root is the rule invocation(s)
//  chain used to arrive at the state.  The semantic context is
//  the tree of semantic predicates encountered before reaching
//  an ATN state.
///

var DecisionState = require('./ATNState').DecisionState;
var SemanticContext = require('./SemanticContext').SemanticContext;
var Hash = require("../Utils").Hash;


function checkParams(params, isCfg) {
	if(params===null) {
		var result = { state:null, alt:null, context:null, semanticContext:null };
		if(isCfg) {
			result.reachesIntoOuterContext = 0;
		}
		return result;
	} else {
		var props = {};
		props.state = params.state || null;
		props.alt = (params.alt === undefined) ? null : params.alt;
		props.context = params.context || null;
		props.semanticContext = params.semanticContext || null;
		if(isCfg) {
			props.reachesIntoOuterContext = params.reachesIntoOuterContext || 0;
			props.precedenceFilterSuppressed = params.precedenceFilterSuppressed || false;
		}
		return props;
	}
}

function ATNConfig(params, config) {
	this.checkContext(params, config);
	params = checkParams(params);
	config = checkParams(config, true);
    // The ATN state associated with this configuration///
    this.state = params.state!==null ? params.state : config.state;
    // What alt (or lexer rule) is predicted by this configuration///
    this.alt = params.alt!==null ? params.alt : config.alt;
    // The stack of invoking states leading to the rule/states associated
    //  with this config.  We track only those contexts pushed during
    //  execution of the ATN simulator.
    this.context = params.context!==null ? params.context : config.context;
    this.semanticContext = params.semanticContext!==null ? params.semanticContext :
        (config.semanticContext!==null ? config.semanticContext : SemanticContext.NONE);
    // We cannot execute predicates dependent upon local context unless
    // we know for sure we are in the correct context. Because there is
    // no way to do this efficiently, we simply cannot evaluate
    // dependent predicates unless we are in the rule that initially
    // invokes the ATN simulator.
    //
    // closure() tracks the depth of how far we dip into the
    // outer context: depth &gt; 0.  Note that it may not be totally
    // accurate depth since I don't ever decrement. TODO: make it a boolean then
    this.reachesIntoOuterContext = config.reachesIntoOuterContext;
    this.precedenceFilterSuppressed = config.precedenceFilterSuppressed;
    return this;
}

ATNConfig.prototype.checkContext = function(params, config) {
	if((params.context===null || params.context===undefined) &&
			(config===null || config.context===null || config.context===undefined)) {
		this.context = null;
	}
};


ATNConfig.prototype.hashCode = function() {
    var hash = new Hash();
    this.updateHashCode(hash);
    return hash.finish();
};


ATNConfig.prototype.updateHashCode = function(hash) {
    hash.update(this.state.stateNumber, this.alt, this.context, this.semanticContext);
};

// An ATN configuration is equal to another if both have
//  the same state, they predict the same alternative, and
//  syntactic/semantic contexts are the same.

ATNConfig.prototype.equals = function(other) {
    if (this === other) {
        return true;
    } else if (! (other instanceof ATNConfig)) {
        return false;
    } else {
        return this.state.stateNumber===other.state.stateNumber &&
            this.alt===other.alt &&
            (this.context===null ? other.context===null : this.context.equals(other.context)) &&
            this.semanticContext.equals(other.semanticContext) &&
            this.precedenceFilterSuppressed===other.precedenceFilterSuppressed;
    }
};


ATNConfig.prototype.hashCodeForConfigSet = function() {
    var hash = new Hash();
    hash.update(this.state.stateNumber, this.alt, this.semanticContext);
    return hash.finish();
};


ATNConfig.prototype.equalsForConfigSet = function(other) {
    if (this === other) {
        return true;
    } else if (! (other instanceof ATNConfig)) {
        return false;
    } else {
        return this.state.stateNumber===other.state.stateNumber &&
            this.alt===other.alt &&
            this.semanticContext.equals(other.semanticContext);
    }
};


ATNConfig.prototype.toString = function() {
    return "(" + this.state + "," + this.alt +
        (this.context!==null ? ",[" + this.context.toString() + "]" : "") +
        (this.semanticContext !== SemanticContext.NONE ?
                ("," + this.semanticContext.toString())
                : "") +
        (this.reachesIntoOuterContext>0 ?
                (",up=" + this.reachesIntoOuterContext)
                : "") + ")";
};


function LexerATNConfig(params, config) {
	ATNConfig.call(this, params, config);

    // This is the backing field for {@link //getLexerActionExecutor}.
	var lexerActionExecutor = params.lexerActionExecutor || null;
    this.lexerActionExecutor = lexerActionExecutor || (config!==null ? config.lexerActionExecutor : null);
    this.passedThroughNonGreedyDecision = config!==null ? this.checkNonGreedyDecision(config, this.state) : false;
    return this;
}

LexerATNConfig.prototype = Object.create(ATNConfig.prototype);
LexerATNConfig.prototype.constructor = LexerATNConfig;

LexerATNConfig.prototype.updateHashCode = function(hash) {
    hash.update(this.state.stateNumber, this.alt, this.context, this.semanticContext, this.passedThroughNonGreedyDecision, this.lexerActionExecutor);
};

LexerATNConfig.prototype.equals = function(other) {
    return this === other ||
            (other instanceof LexerATNConfig &&
            this.passedThroughNonGreedyDecision == other.passedThroughNonGreedyDecision &&
            (this.lexerActionExecutor ? this.lexerActionExecutor.equals(other.lexerActionExecutor) : !other.lexerActionExecutor) &&
            ATNConfig.prototype.equals.call(this, other));
};

LexerATNConfig.prototype.hashCodeForConfigSet = LexerATNConfig.prototype.hashCode;

LexerATNConfig.prototype.equalsForConfigSet = LexerATNConfig.prototype.equals;


LexerATNConfig.prototype.checkNonGreedyDecision = function(source, target) {
    return source.passedThroughNonGreedyDecision ||
        (target instanceof DecisionState) && target.nonGreedy;
};

exports.ATNConfig = ATNConfig;
exports.LexerATNConfig = LexerATNConfig;
},{"../Utils":58,"./ATNState":65,"./SemanticContext":72}],61:[function(require,module,exports){
//
/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

//
// Specialized {@link Set}{@code <}{@link ATNConfig}{@code >} that can track
// info about the set, with support for combining similar configurations using a
// graph-structured stack.
///

var ATN = require('./ATN').ATN;
var Utils = require('./../Utils');
var Hash = Utils.Hash;
var Set = Utils.Set;
var SemanticContext = require('./SemanticContext').SemanticContext;
var merge = require('./../PredictionContext').merge;

function hashATNConfig(c) {
	return c.hashCodeForConfigSet();
}

function equalATNConfigs(a, b) {
	if ( a===b ) {
		return true;
	} else if ( a===null || b===null ) {
		return false;
	} else
       return a.equalsForConfigSet(b);
 }


function ATNConfigSet(fullCtx) {
	//
	// The reason that we need this is because we don't want the hash map to use
	// the standard hash code and equals. We need all configurations with the
	// same
	// {@code (s,i,_,semctx)} to be equal. Unfortunately, this key effectively
	// doubles
	// the number of objects associated with ATNConfigs. The other solution is
	// to
	// use a hash table that lets us specify the equals/hashcode operation.
	// All configs but hashed by (s, i, _, pi) not including context. Wiped out
	// when we go readonly as this set becomes a DFA state.
	this.configLookup = new Set(hashATNConfig, equalATNConfigs);
	// Indicates that this configuration set is part of a full context
	// LL prediction. It will be used to determine how to merge $. With SLL
	// it's a wildcard whereas it is not for LL context merge.
	this.fullCtx = fullCtx === undefined ? true : fullCtx;
	// Indicates that the set of configurations is read-only. Do not
	// allow any code to manipulate the set; DFA states will point at
	// the sets and they must not change. This does not protect the other
	// fields; in particular, conflictingAlts is set after
	// we've made this readonly.
	this.readOnly = false;
	// Track the elements as they are added to the set; supports get(i)///
	this.configs = [];

	// TODO: these fields make me pretty uncomfortable but nice to pack up info
	// together, saves recomputation
	// TODO: can we track conflicts as they are added to save scanning configs
	// later?
	this.uniqueAlt = 0;
	this.conflictingAlts = null;

	// Used in parser and lexer. In lexer, it indicates we hit a pred
	// while computing a closure operation. Don't make a DFA state from this.
	this.hasSemanticContext = false;
	this.dipsIntoOuterContext = false;

	this.cachedHashCode = -1;

	return this;
}

// Adding a new config means merging contexts with existing configs for
// {@code (s, i, pi, _)}, where {@code s} is the
// {@link ATNConfig//state}, {@code i} is the {@link ATNConfig//alt}, and
// {@code pi} is the {@link ATNConfig//semanticContext}. We use
// {@code (s,i,pi)} as key.
//
// <p>This method updates {@link //dipsIntoOuterContext} and
// {@link //hasSemanticContext} when necessary.</p>
// /
ATNConfigSet.prototype.add = function(config, mergeCache) {
	if (mergeCache === undefined) {
		mergeCache = null;
	}
	if (this.readOnly) {
		throw "This set is readonly";
	}
	if (config.semanticContext !== SemanticContext.NONE) {
		this.hasSemanticContext = true;
	}
	if (config.reachesIntoOuterContext > 0) {
		this.dipsIntoOuterContext = true;
	}
	var existing = this.configLookup.add(config);
	if (existing === config) {
		this.cachedHashCode = -1;
		this.configs.push(config); // track order here
		return true;
	}
	// a previous (s,i,pi,_), merge with it and save result
	var rootIsWildcard = !this.fullCtx;
	var merged = merge(existing.context, config.context, rootIsWildcard, mergeCache);
	// no need to check for existing.context, config.context in cache
	// since only way to create new graphs is "call rule" and here. We
	// cache at both places.
	existing.reachesIntoOuterContext = Math.max( existing.reachesIntoOuterContext, config.reachesIntoOuterContext);
	// make sure to preserve the precedence filter suppression during the merge
	if (config.precedenceFilterSuppressed) {
		existing.precedenceFilterSuppressed = true;
	}
	existing.context = merged; // replace context; no need to alt mapping
	return true;
};

ATNConfigSet.prototype.getStates = function() {
	var states = new Set();
	for (var i = 0; i < this.configs.length; i++) {
		states.add(this.configs[i].state);
	}
	return states;
};

ATNConfigSet.prototype.getPredicates = function() {
	var preds = [];
	for (var i = 0; i < this.configs.length; i++) {
		var c = this.configs[i].semanticContext;
		if (c !== SemanticContext.NONE) {
			preds.push(c.semanticContext);
		}
	}
	return preds;
};

Object.defineProperty(ATNConfigSet.prototype, "items", {
	get : function() {
		return this.configs;
	}
});

ATNConfigSet.prototype.optimizeConfigs = function(interpreter) {
	if (this.readOnly) {
		throw "This set is readonly";
	}
	if (this.configLookup.length === 0) {
		return;
	}
	for (var i = 0; i < this.configs.length; i++) {
		var config = this.configs[i];
		config.context = interpreter.getCachedContext(config.context);
	}
};

ATNConfigSet.prototype.addAll = function(coll) {
	for (var i = 0; i < coll.length; i++) {
		this.add(coll[i]);
	}
	return false;
};

ATNConfigSet.prototype.equals = function(other) {
	return this === other ||
		(other instanceof ATNConfigSet &&
		Utils.equalArrays(this.configs, other.configs) &&
		this.fullCtx === other.fullCtx &&
		this.uniqueAlt === other.uniqueAlt &&
		this.conflictingAlts === other.conflictingAlts &&
		this.hasSemanticContext === other.hasSemanticContext &&
		this.dipsIntoOuterContext === other.dipsIntoOuterContext);
};

ATNConfigSet.prototype.hashCode = function() {
    var hash = new Hash();
	hash.update(this.configs);
    return hash.finish();
};


ATNConfigSet.prototype.updateHashCode = function(hash) {
	if (this.readOnly) {
		if (this.cachedHashCode === -1) {
            this.cachedHashCode = this.hashCode();
		}
        hash.update(this.cachedHashCode);
	} else {
        hash.update(this.hashCode());
	}
};


Object.defineProperty(ATNConfigSet.prototype, "length", {
	get : function() {
		return this.configs.length;
	}
});

ATNConfigSet.prototype.isEmpty = function() {
	return this.configs.length === 0;
};

ATNConfigSet.prototype.contains = function(item) {
	if (this.configLookup === null) {
		throw "This method is not implemented for readonly sets.";
	}
	return this.configLookup.contains(item);
};

ATNConfigSet.prototype.containsFast = function(item) {
	if (this.configLookup === null) {
		throw "This method is not implemented for readonly sets.";
	}
	return this.configLookup.containsFast(item);
};

ATNConfigSet.prototype.clear = function() {
	if (this.readOnly) {
		throw "This set is readonly";
	}
	this.configs = [];
	this.cachedHashCode = -1;
	this.configLookup = new Set();
};

ATNConfigSet.prototype.setReadonly = function(readOnly) {
	this.readOnly = readOnly;
	if (readOnly) {
		this.configLookup = null; // can't mod, no need for lookup cache
	}
};

ATNConfigSet.prototype.toString = function() {
	return Utils.arrayToString(this.configs) +
		(this.hasSemanticContext ? ",hasSemanticContext=" + this.hasSemanticContext : "") +
		(this.uniqueAlt !== ATN.INVALID_ALT_NUMBER ? ",uniqueAlt=" + this.uniqueAlt : "") +
		(this.conflictingAlts !== null ? ",conflictingAlts=" + this.conflictingAlts : "") +
		(this.dipsIntoOuterContext ? ",dipsIntoOuterContext" : "");
};

function OrderedATNConfigSet() {
	ATNConfigSet.call(this);
	this.configLookup = new Set();
	return this;
}

OrderedATNConfigSet.prototype = Object.create(ATNConfigSet.prototype);
OrderedATNConfigSet.prototype.constructor = OrderedATNConfigSet;

exports.ATNConfigSet = ATNConfigSet;
exports.OrderedATNConfigSet = OrderedATNConfigSet;

},{"./../PredictionContext":54,"./../Utils":58,"./ATN":59,"./SemanticContext":72}],62:[function(require,module,exports){
/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

function ATNDeserializationOptions(copyFrom) {
	if(copyFrom===undefined) {
		copyFrom = null;
	}
	this.readOnly = false;
    this.verifyATN = copyFrom===null ? true : copyFrom.verifyATN;
    this.generateRuleBypassTransitions = copyFrom===null ? false : copyFrom.generateRuleBypassTransitions;

    return this;
}

ATNDeserializationOptions.defaultOptions = new ATNDeserializationOptions();
ATNDeserializationOptions.defaultOptions.readOnly = true;

//    def __setattr__(self, key, value):
//        if key!="readOnly" and self.readOnly:
//            raise Exception("The object is read only.")
//        super(type(self), self).__setattr__(key,value)

exports.ATNDeserializationOptions = ATNDeserializationOptions;

},{}],63:[function(require,module,exports){
/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

var Token = require('./../Token').Token;
var ATN = require('./ATN').ATN;
var ATNType = require('./ATNType').ATNType;
var ATNStates = require('./ATNState');
var ATNState = ATNStates.ATNState;
var BasicState = ATNStates.BasicState;
var DecisionState = ATNStates.DecisionState;
var BlockStartState = ATNStates.BlockStartState;
var BlockEndState = ATNStates.BlockEndState;
var LoopEndState = ATNStates.LoopEndState;
var RuleStartState = ATNStates.RuleStartState;
var RuleStopState = ATNStates.RuleStopState;
var TokensStartState = ATNStates.TokensStartState;
var PlusLoopbackState = ATNStates.PlusLoopbackState;
var StarLoopbackState = ATNStates.StarLoopbackState;
var StarLoopEntryState = ATNStates.StarLoopEntryState;
var PlusBlockStartState = ATNStates.PlusBlockStartState;
var StarBlockStartState = ATNStates.StarBlockStartState;
var BasicBlockStartState = ATNStates.BasicBlockStartState;
var Transitions = require('./Transition');
var Transition = Transitions.Transition;
var AtomTransition = Transitions.AtomTransition;
var SetTransition = Transitions.SetTransition;
var NotSetTransition = Transitions.NotSetTransition;
var RuleTransition = Transitions.RuleTransition;
var RangeTransition = Transitions.RangeTransition;
var ActionTransition = Transitions.ActionTransition;
var EpsilonTransition = Transitions.EpsilonTransition;
var WildcardTransition = Transitions.WildcardTransition;
var PredicateTransition = Transitions.PredicateTransition;
var PrecedencePredicateTransition = Transitions.PrecedencePredicateTransition;
var IntervalSet = require('./../IntervalSet').IntervalSet;
var Interval = require('./../IntervalSet').Interval;
var ATNDeserializationOptions = require('./ATNDeserializationOptions').ATNDeserializationOptions;
var LexerActions = require('./LexerAction');
var LexerActionType = LexerActions.LexerActionType;
var LexerSkipAction = LexerActions.LexerSkipAction;
var LexerChannelAction = LexerActions.LexerChannelAction;
var LexerCustomAction = LexerActions.LexerCustomAction;
var LexerMoreAction = LexerActions.LexerMoreAction;
var LexerTypeAction = LexerActions.LexerTypeAction;
var LexerPushModeAction = LexerActions.LexerPushModeAction;
var LexerPopModeAction = LexerActions.LexerPopModeAction;
var LexerModeAction = LexerActions.LexerModeAction;
// This is the earliest supported serialized UUID.
// stick to serialized version for now, we don't need a UUID instance
var BASE_SERIALIZED_UUID = "AADB8D7E-AEEF-4415-AD2B-8204D6CF042E";

//
// This UUID indicates the serialized ATN contains two sets of
// IntervalSets, where the second set's values are encoded as
// 32-bit integers to support the full Unicode SMP range up to U+10FFFF.
//
var ADDED_UNICODE_SMP = "59627784-3BE5-417A-B9EB-8131A7286089";

// This list contains all of the currently supported UUIDs, ordered by when
// the feature first appeared in this branch.
var SUPPORTED_UUIDS = [ BASE_SERIALIZED_UUID, ADDED_UNICODE_SMP ];

var SERIALIZED_VERSION = 3;

// This is the current serialized UUID.
var SERIALIZED_UUID = ADDED_UNICODE_SMP;

function initArray( length, value) {
	var tmp = [];
	tmp[length-1] = value;
	return tmp.map(function(i) {return value;});
}

function ATNDeserializer (options) {

    if ( options=== undefined || options === null ) {
        options = ATNDeserializationOptions.defaultOptions;
    }
    this.deserializationOptions = options;
    this.stateFactories = null;
    this.actionFactories = null;

    return this;
}

// Determines if a particular serialized representation of an ATN supports
// a particular feature, identified by the {@link UUID} used for serializing
// the ATN at the time the feature was first introduced.
//
// @param feature The {@link UUID} marking the first time the feature was
// supported in the serialized ATN.
// @param actualUuid The {@link UUID} of the actual serialized ATN which is
// currently being deserialized.
// @return {@code true} if the {@code actualUuid} value represents a
// serialized ATN at or after the feature identified by {@code feature} was
// introduced; otherwise, {@code false}.

ATNDeserializer.prototype.isFeatureSupported = function(feature, actualUuid) {
    var idx1 = SUPPORTED_UUIDS.indexOf(feature);
    if (idx1<0) {
        return false;
    }
    var idx2 = SUPPORTED_UUIDS.indexOf(actualUuid);
    return idx2 >= idx1;
};

ATNDeserializer.prototype.deserialize = function(data) {
    this.reset(data);
    this.checkVersion();
    this.checkUUID();
    var atn = this.readATN();
    this.readStates(atn);
    this.readRules(atn);
    this.readModes(atn);
    var sets = [];
    // First, deserialize sets with 16-bit arguments <= U+FFFF.
    this.readSets(atn, sets, this.readInt.bind(this));
    // Next, if the ATN was serialized with the Unicode SMP feature,
    // deserialize sets with 32-bit arguments <= U+10FFFF.
    if (this.isFeatureSupported(ADDED_UNICODE_SMP, this.uuid)) {
        this.readSets(atn, sets, this.readInt32.bind(this));
    }
    this.readEdges(atn, sets);
    this.readDecisions(atn);
    this.readLexerActions(atn);
    this.markPrecedenceDecisions(atn);
    this.verifyATN(atn);
    if (this.deserializationOptions.generateRuleBypassTransitions && atn.grammarType === ATNType.PARSER ) {
        this.generateRuleBypassTransitions(atn);
        // re-verify after modification
        this.verifyATN(atn);
    }
    return atn;
};

ATNDeserializer.prototype.reset = function(data) {
	var adjust = function(c) {
        var v = c.charCodeAt(0);
        return v>1  ? v-2 : v + 65534;
	};
    var temp = data.split("").map(adjust);
    // don't adjust the first value since that's the version number
    temp[0] = data.charCodeAt(0);
    this.data = temp;
    this.pos = 0;
};

ATNDeserializer.prototype.checkVersion = function() {
    var version = this.readInt();
    if ( version !== SERIALIZED_VERSION ) {
        throw ("Could not deserialize ATN with version " + version + " (expected " + SERIALIZED_VERSION + ").");
    }
};

ATNDeserializer.prototype.checkUUID = function() {
    var uuid = this.readUUID();
    if (SUPPORTED_UUIDS.indexOf(uuid)<0) {
        throw ("Could not deserialize ATN with UUID: " + uuid +
                        " (expected " + SERIALIZED_UUID + " or a legacy UUID).", uuid, SERIALIZED_UUID);
    }
    this.uuid = uuid;
};

ATNDeserializer.prototype.readATN = function() {
    var grammarType = this.readInt();
    var maxTokenType = this.readInt();
    return new ATN(grammarType, maxTokenType);
};

ATNDeserializer.prototype.readStates = function(atn) {
	var j, pair, stateNumber;
    var loopBackStateNumbers = [];
    var endStateNumbers = [];
    var nstates = this.readInt();
    for(var i=0; i<nstates; i++) {
        var stype = this.readInt();
        // ignore bad type of states
        if (stype===ATNState.INVALID_TYPE) {
            atn.addState(null);
            continue;
        }
        var ruleIndex = this.readInt();
        if (ruleIndex === 0xFFFF) {
            ruleIndex = -1;
        }
        var s = this.stateFactory(stype, ruleIndex);
        if (stype === ATNState.LOOP_END) { // special case
            var loopBackStateNumber = this.readInt();
            loopBackStateNumbers.push([s, loopBackStateNumber]);
        } else if(s instanceof BlockStartState) {
            var endStateNumber = this.readInt();
            endStateNumbers.push([s, endStateNumber]);
        }
        atn.addState(s);
    }
    // delay the assignment of loop back and end states until we know all the
	// state instances have been initialized
    for (j=0; j<loopBackStateNumbers.length; j++) {
        pair = loopBackStateNumbers[j];
        pair[0].loopBackState = atn.states[pair[1]];
    }

    for (j=0; j<endStateNumbers.length; j++) {
        pair = endStateNumbers[j];
        pair[0].endState = atn.states[pair[1]];
    }

    var numNonGreedyStates = this.readInt();
    for (j=0; j<numNonGreedyStates; j++) {
        stateNumber = this.readInt();
        atn.states[stateNumber].nonGreedy = true;
    }

    var numPrecedenceStates = this.readInt();
    for (j=0; j<numPrecedenceStates; j++) {
        stateNumber = this.readInt();
        atn.states[stateNumber].isPrecedenceRule = true;
    }
};

ATNDeserializer.prototype.readRules = function(atn) {
    var i;
    var nrules = this.readInt();
    if (atn.grammarType === ATNType.LEXER ) {
        atn.ruleToTokenType = initArray(nrules, 0);
    }
    atn.ruleToStartState = initArray(nrules, 0);
    for (i=0; i<nrules; i++) {
        var s = this.readInt();
        var startState = atn.states[s];
        atn.ruleToStartState[i] = startState;
        if ( atn.grammarType === ATNType.LEXER ) {
            var tokenType = this.readInt();
            if (tokenType === 0xFFFF) {
                tokenType = Token.EOF;
            }
            atn.ruleToTokenType[i] = tokenType;
        }
    }
    atn.ruleToStopState = initArray(nrules, 0);
    for (i=0; i<atn.states.length; i++) {
        var state = atn.states[i];
        if (!(state instanceof RuleStopState)) {
            continue;
        }
        atn.ruleToStopState[state.ruleIndex] = state;
        atn.ruleToStartState[state.ruleIndex].stopState = state;
    }
};

ATNDeserializer.prototype.readModes = function(atn) {
    var nmodes = this.readInt();
    for (var i=0; i<nmodes; i++) {
        var s = this.readInt();
        atn.modeToStartState.push(atn.states[s]);
    }
};

ATNDeserializer.prototype.readSets = function(atn, sets, readUnicode) {
    var m = this.readInt();
    for (var i=0; i<m; i++) {
        var iset = new IntervalSet();
        sets.push(iset);
        var n = this.readInt();
        var containsEof = this.readInt();
        if (containsEof!==0) {
            iset.addOne(-1);
        }
        for (var j=0; j<n; j++) {
            var i1 = readUnicode();
            var i2 = readUnicode();
            iset.addRange(i1, i2);
        }
    }
};

ATNDeserializer.prototype.readEdges = function(atn, sets) {
	var i, j, state, trans, target;
    var nedges = this.readInt();
    for (i=0; i<nedges; i++) {
        var src = this.readInt();
        var trg = this.readInt();
        var ttype = this.readInt();
        var arg1 = this.readInt();
        var arg2 = this.readInt();
        var arg3 = this.readInt();
        trans = this.edgeFactory(atn, ttype, src, trg, arg1, arg2, arg3, sets);
        var srcState = atn.states[src];
        srcState.addTransition(trans);
    }
    // edges for rule stop states can be derived, so they aren't serialized
    for (i=0; i<atn.states.length; i++) {
        state = atn.states[i];
        for (j=0; j<state.transitions.length; j++) {
            var t = state.transitions[j];
            if (!(t instanceof RuleTransition)) {
                continue;
            }
			var outermostPrecedenceReturn = -1;
			if (atn.ruleToStartState[t.target.ruleIndex].isPrecedenceRule) {
				if (t.precedence === 0) {
					outermostPrecedenceReturn = t.target.ruleIndex;
				}
			}

			trans = new EpsilonTransition(t.followState, outermostPrecedenceReturn);
            atn.ruleToStopState[t.target.ruleIndex].addTransition(trans);
        }
    }

    for (i=0; i<atn.states.length; i++) {
        state = atn.states[i];
        if (state instanceof BlockStartState) {
            // we need to know the end state to set its start state
            if (state.endState === null) {
                throw ("IllegalState");
            }
            // block end states can only be associated to a single block start
			// state
            if ( state.endState.startState !== null) {
                throw ("IllegalState");
            }
            state.endState.startState = state;
        }
        if (state instanceof PlusLoopbackState) {
            for (j=0; j<state.transitions.length; j++) {
                target = state.transitions[j].target;
                if (target instanceof PlusBlockStartState) {
                    target.loopBackState = state;
                }
            }
        } else if (state instanceof StarLoopbackState) {
            for (j=0; j<state.transitions.length; j++) {
                target = state.transitions[j].target;
                if (target instanceof StarLoopEntryState) {
                    target.loopBackState = state;
                }
            }
        }
    }
};

ATNDeserializer.prototype.readDecisions = function(atn) {
    var ndecisions = this.readInt();
    for (var i=0; i<ndecisions; i++) {
        var s = this.readInt();
        var decState = atn.states[s];
        atn.decisionToState.push(decState);
        decState.decision = i;
    }
};

ATNDeserializer.prototype.readLexerActions = function(atn) {
    if (atn.grammarType === ATNType.LEXER) {
        var count = this.readInt();
        atn.lexerActions = initArray(count, null);
        for (var i=0; i<count; i++) {
            var actionType = this.readInt();
            var data1 = this.readInt();
            if (data1 === 0xFFFF) {
                data1 = -1;
            }
            var data2 = this.readInt();
            if (data2 === 0xFFFF) {
                data2 = -1;
            }
            var lexerAction = this.lexerActionFactory(actionType, data1, data2);
            atn.lexerActions[i] = lexerAction;
        }
    }
};

ATNDeserializer.prototype.generateRuleBypassTransitions = function(atn) {
	var i;
    var count = atn.ruleToStartState.length;
    for(i=0; i<count; i++) {
        atn.ruleToTokenType[i] = atn.maxTokenType + i + 1;
    }
    for(i=0; i<count; i++) {
        this.generateRuleBypassTransition(atn, i);
    }
};

ATNDeserializer.prototype.generateRuleBypassTransition = function(atn, idx) {
	var i, state;
    var bypassStart = new BasicBlockStartState();
    bypassStart.ruleIndex = idx;
    atn.addState(bypassStart);

    var bypassStop = new BlockEndState();
    bypassStop.ruleIndex = idx;
    atn.addState(bypassStop);

    bypassStart.endState = bypassStop;
    atn.defineDecisionState(bypassStart);

    bypassStop.startState = bypassStart;

    var excludeTransition = null;
    var endState = null;

    if (atn.ruleToStartState[idx].isPrecedenceRule) {
        // wrap from the beginning of the rule to the StarLoopEntryState
        endState = null;
        for(i=0; i<atn.states.length; i++) {
            state = atn.states[i];
            if (this.stateIsEndStateFor(state, idx)) {
                endState = state;
                excludeTransition = state.loopBackState.transitions[0];
                break;
            }
        }
        if (excludeTransition === null) {
            throw ("Couldn't identify final state of the precedence rule prefix section.");
        }
    } else {
        endState = atn.ruleToStopState[idx];
    }

    // all non-excluded transitions that currently target end state need to
	// target blockEnd instead
    for(i=0; i<atn.states.length; i++) {
        state = atn.states[i];
        for(var j=0; j<state.transitions.length; j++) {
            var transition = state.transitions[j];
            if (transition === excludeTransition) {
                continue;
            }
            if (transition.target === endState) {
                transition.target = bypassStop;
            }
        }
    }

    // all transitions leaving the rule start state need to leave blockStart
	// instead
    var ruleToStartState = atn.ruleToStartState[idx];
    var count = ruleToStartState.transitions.length;
    while ( count > 0) {
        bypassStart.addTransition(ruleToStartState.transitions[count-1]);
        ruleToStartState.transitions = ruleToStartState.transitions.slice(-1);
    }
    // link the new states
    atn.ruleToStartState[idx].addTransition(new EpsilonTransition(bypassStart));
    bypassStop.addTransition(new EpsilonTransition(endState));

    var matchState = new BasicState();
    atn.addState(matchState);
    matchState.addTransition(new AtomTransition(bypassStop, atn.ruleToTokenType[idx]));
    bypassStart.addTransition(new EpsilonTransition(matchState));
};

ATNDeserializer.prototype.stateIsEndStateFor = function(state, idx) {
    if ( state.ruleIndex !== idx) {
        return null;
    }
    if (!( state instanceof StarLoopEntryState)) {
        return null;
    }
    var maybeLoopEndState = state.transitions[state.transitions.length - 1].target;
    if (!( maybeLoopEndState instanceof LoopEndState)) {
        return null;
    }
    if (maybeLoopEndState.epsilonOnlyTransitions &&
        (maybeLoopEndState.transitions[0].target instanceof RuleStopState)) {
        return state;
    } else {
        return null;
    }
};

//
// Analyze the {@link StarLoopEntryState} states in the specified ATN to set
// the {@link StarLoopEntryState//isPrecedenceDecision} field to the
// correct value.
//
// @param atn The ATN.
//
ATNDeserializer.prototype.markPrecedenceDecisions = function(atn) {
	for(var i=0; i<atn.states.length; i++) {
		var state = atn.states[i];
		if (!( state instanceof StarLoopEntryState)) {
            continue;
        }
        // We analyze the ATN to determine if this ATN decision state is the
        // decision for the closure block that determines whether a
        // precedence rule should continue or complete.
        //
        if ( atn.ruleToStartState[state.ruleIndex].isPrecedenceRule) {
            var maybeLoopEndState = state.transitions[state.transitions.length - 1].target;
            if (maybeLoopEndState instanceof LoopEndState) {
                if ( maybeLoopEndState.epsilonOnlyTransitions &&
                        (maybeLoopEndState.transitions[0].target instanceof RuleStopState)) {
                    state.isPrecedenceDecision = true;
                }
            }
        }
	}
};

ATNDeserializer.prototype.verifyATN = function(atn) {
    if (!this.deserializationOptions.verifyATN) {
        return;
    }
    // verify assumptions
	for(var i=0; i<atn.states.length; i++) {
        var state = atn.states[i];
        if (state === null) {
            continue;
        }
        this.checkCondition(state.epsilonOnlyTransitions || state.transitions.length <= 1);
        if (state instanceof PlusBlockStartState) {
            this.checkCondition(state.loopBackState !== null);
        } else  if (state instanceof StarLoopEntryState) {
            this.checkCondition(state.loopBackState !== null);
            this.checkCondition(state.transitions.length === 2);
            if (state.transitions[0].target instanceof StarBlockStartState) {
                this.checkCondition(state.transitions[1].target instanceof LoopEndState);
                this.checkCondition(!state.nonGreedy);
            } else if (state.transitions[0].target instanceof LoopEndState) {
                this.checkCondition(state.transitions[1].target instanceof StarBlockStartState);
                this.checkCondition(state.nonGreedy);
            } else {
                throw("IllegalState");
            }
        } else if (state instanceof StarLoopbackState) {
            this.checkCondition(state.transitions.length === 1);
            this.checkCondition(state.transitions[0].target instanceof StarLoopEntryState);
        } else if (state instanceof LoopEndState) {
            this.checkCondition(state.loopBackState !== null);
        } else if (state instanceof RuleStartState) {
            this.checkCondition(state.stopState !== null);
        } else if (state instanceof BlockStartState) {
            this.checkCondition(state.endState !== null);
        } else if (state instanceof BlockEndState) {
            this.checkCondition(state.startState !== null);
        } else if (state instanceof DecisionState) {
            this.checkCondition(state.transitions.length <= 1 || state.decision >= 0);
        } else {
            this.checkCondition(state.transitions.length <= 1 || (state instanceof RuleStopState));
        }
	}
};

ATNDeserializer.prototype.checkCondition = function(condition, message) {
    if (!condition) {
        if (message === undefined || message===null) {
            message = "IllegalState";
        }
        throw (message);
    }
};

ATNDeserializer.prototype.readInt = function() {
    return this.data[this.pos++];
};

ATNDeserializer.prototype.readInt32 = function() {
    var low = this.readInt();
    var high = this.readInt();
    return low | (high << 16);
};

ATNDeserializer.prototype.readLong = function() {
    var low = this.readInt32();
    var high = this.readInt32();
    return (low & 0x00000000FFFFFFFF) | (high << 32);
};

function createByteToHex() {
	var bth = [];
	for (var i = 0; i < 256; i++) {
		bth[i] = (i + 0x100).toString(16).substr(1).toUpperCase();
	}
	return bth;
}

var byteToHex = createByteToHex();

ATNDeserializer.prototype.readUUID = function() {
	var bb = [];
	for(var i=7;i>=0;i--) {
		var int = this.readInt();
		/* jshint bitwise: false */
		bb[(2*i)+1] = int & 0xFF;
		bb[2*i] = (int >> 8) & 0xFF;
	}
    return byteToHex[bb[0]] + byteToHex[bb[1]] +
    byteToHex[bb[2]] + byteToHex[bb[3]] + '-' +
    byteToHex[bb[4]] + byteToHex[bb[5]] + '-' +
    byteToHex[bb[6]] + byteToHex[bb[7]] + '-' +
    byteToHex[bb[8]] + byteToHex[bb[9]] + '-' +
    byteToHex[bb[10]] + byteToHex[bb[11]] +
    byteToHex[bb[12]] + byteToHex[bb[13]] +
    byteToHex[bb[14]] + byteToHex[bb[15]];
};

ATNDeserializer.prototype.edgeFactory = function(atn, type, src, trg, arg1, arg2, arg3, sets) {
    var target = atn.states[trg];
    switch(type) {
    case Transition.EPSILON:
        return new EpsilonTransition(target);
    case Transition.RANGE:
        return arg3 !== 0 ? new RangeTransition(target, Token.EOF, arg2) : new RangeTransition(target, arg1, arg2);
    case Transition.RULE:
        return new RuleTransition(atn.states[arg1], arg2, arg3, target);
    case Transition.PREDICATE:
        return new PredicateTransition(target, arg1, arg2, arg3 !== 0);
    case Transition.PRECEDENCE:
        return new PrecedencePredicateTransition(target, arg1);
    case Transition.ATOM:
        return arg3 !== 0 ? new AtomTransition(target, Token.EOF) : new AtomTransition(target, arg1);
    case Transition.ACTION:
        return new ActionTransition(target, arg1, arg2, arg3 !== 0);
    case Transition.SET:
        return new SetTransition(target, sets[arg1]);
    case Transition.NOT_SET:
        return new NotSetTransition(target, sets[arg1]);
    case Transition.WILDCARD:
        return new WildcardTransition(target);
    default:
        throw "The specified transition type: " + type + " is not valid.";
    }
};

ATNDeserializer.prototype.stateFactory = function(type, ruleIndex) {
    if (this.stateFactories === null) {
        var sf = [];
        sf[ATNState.INVALID_TYPE] = null;
        sf[ATNState.BASIC] = function() { return new BasicState(); };
        sf[ATNState.RULE_START] = function() { return new RuleStartState(); };
        sf[ATNState.BLOCK_START] = function() { return new BasicBlockStartState(); };
        sf[ATNState.PLUS_BLOCK_START] = function() { return new PlusBlockStartState(); };
        sf[ATNState.STAR_BLOCK_START] = function() { return new StarBlockStartState(); };
        sf[ATNState.TOKEN_START] = function() { return new TokensStartState(); };
        sf[ATNState.RULE_STOP] = function() { return new RuleStopState(); };
        sf[ATNState.BLOCK_END] = function() { return new BlockEndState(); };
        sf[ATNState.STAR_LOOP_BACK] = function() { return new StarLoopbackState(); };
        sf[ATNState.STAR_LOOP_ENTRY] = function() { return new StarLoopEntryState(); };
        sf[ATNState.PLUS_LOOP_BACK] = function() { return new PlusLoopbackState(); };
        sf[ATNState.LOOP_END] = function() { return new LoopEndState(); };
        this.stateFactories = sf;
    }
    if (type>this.stateFactories.length || this.stateFactories[type] === null) {
        throw("The specified state type " + type + " is not valid.");
    } else {
        var s = this.stateFactories[type]();
        if (s!==null) {
            s.ruleIndex = ruleIndex;
            return s;
        }
    }
};

ATNDeserializer.prototype.lexerActionFactory = function(type, data1, data2) {
    if (this.actionFactories === null) {
        var af = [];
        af[LexerActionType.CHANNEL] = function(data1, data2) { return new LexerChannelAction(data1); };
        af[LexerActionType.CUSTOM] = function(data1, data2) { return new LexerCustomAction(data1, data2); };
        af[LexerActionType.MODE] = function(data1, data2) { return new LexerModeAction(data1); };
        af[LexerActionType.MORE] = function(data1, data2) { return LexerMoreAction.INSTANCE; };
        af[LexerActionType.POP_MODE] = function(data1, data2) { return LexerPopModeAction.INSTANCE; };
        af[LexerActionType.PUSH_MODE] = function(data1, data2) { return new LexerPushModeAction(data1); };
        af[LexerActionType.SKIP] = function(data1, data2) { return LexerSkipAction.INSTANCE; };
        af[LexerActionType.TYPE] = function(data1, data2) { return new LexerTypeAction(data1); };
        this.actionFactories = af;
    }
    if (type>this.actionFactories.length || this.actionFactories[type] === null) {
        throw("The specified lexer action type " + type + " is not valid.");
    } else {
        return this.actionFactories[type](data1, data2);
    }
};


exports.ATNDeserializer = ATNDeserializer;
},{"./../IntervalSet":49,"./../Token":57,"./ATN":59,"./ATNDeserializationOptions":62,"./ATNState":65,"./ATNType":66,"./LexerAction":68,"./Transition":73}],64:[function(require,module,exports){
//
/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
///

var DFAState = require('./../dfa/DFAState').DFAState;
var ATNConfigSet = require('./ATNConfigSet').ATNConfigSet;
var getCachedPredictionContext = require('./../PredictionContext').getCachedPredictionContext;
var Map = require('./../Utils').Map;

function ATNSimulator(atn, sharedContextCache) {

    // The context cache maps all PredictionContext objects that are ==
    //  to a single cached copy. This cache is shared across all contexts
    //  in all ATNConfigs in all DFA states.  We rebuild each ATNConfigSet
    //  to use only cached nodes/graphs in addDFAState(). We don't want to
    //  fill this during closure() since there are lots of contexts that
    //  pop up but are not used ever again. It also greatly slows down closure().
    //
    //  <p>This cache makes a huge difference in memory and a little bit in speed.
    //  For the Java grammar on java.*, it dropped the memory requirements
    //  at the end from 25M to 16M. We don't store any of the full context
    //  graphs in the DFA because they are limited to local context only,
    //  but apparently there's a lot of repetition there as well. We optimize
    //  the config contexts before storing the config set in the DFA states
    //  by literally rebuilding them with cached subgraphs only.</p>
    //
    //  <p>I tried a cache for use during closure operations, that was
    //  whacked after each adaptivePredict(). It cost a little bit
    //  more time I think and doesn't save on the overall footprint
    //  so it's not worth the complexity.</p>
    ///
    this.atn = atn;
    this.sharedContextCache = sharedContextCache;
    return this;
}

// Must distinguish between missing edge and edge we know leads nowhere///
ATNSimulator.ERROR = new DFAState(0x7FFFFFFF, new ATNConfigSet());


ATNSimulator.prototype.getCachedContext = function(context) {
    if (this.sharedContextCache ===null) {
        return context;
    }
    var visited = new Map();
    return getCachedPredictionContext(context, this.sharedContextCache, visited);
};

exports.ATNSimulator = ATNSimulator;

},{"./../PredictionContext":54,"./../Utils":58,"./../dfa/DFAState":77,"./ATNConfigSet":61}],65:[function(require,module,exports){
//
/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
//

// The following images show the relation of states and
// {@link ATNState//transitions} for various grammar constructs.
//
// <ul>
//
// <li>Solid edges marked with an &//0949; indicate a required
// {@link EpsilonTransition}.</li>
//
// <li>Dashed edges indicate locations where any transition derived from
// {@link Transition} might appear.</li>
//
// <li>Dashed nodes are place holders for either a sequence of linked
// {@link BasicState} states or the inclusion of a block representing a nested
// construct in one of the forms below.</li>
//
// <li>Nodes showing multiple outgoing alternatives with a {@code ...} support
// any number of alternatives (one or more). Nodes without the {@code ...} only
// support the exact number of alternatives shown in the diagram.</li>
//
// </ul>
//
// <h2>Basic Blocks</h2>
//
// <h3>Rule</h3>
//
// <embed src="images/Rule.svg" type="image/svg+xml"/>
//
// <h3>Block of 1 or more alternatives</h3>
//
// <embed src="images/Block.svg" type="image/svg+xml"/>
//
// <h2>Greedy Loops</h2>
//
// <h3>Greedy Closure: {@code (...)*}</h3>
//
// <embed src="images/ClosureGreedy.svg" type="image/svg+xml"/>
//
// <h3>Greedy Positive Closure: {@code (...)+}</h3>
//
// <embed src="images/PositiveClosureGreedy.svg" type="image/svg+xml"/>
//
// <h3>Greedy Optional: {@code (...)?}</h3>
//
// <embed src="images/OptionalGreedy.svg" type="image/svg+xml"/>
//
// <h2>Non-Greedy Loops</h2>
//
// <h3>Non-Greedy Closure: {@code (...)*?}</h3>
//
// <embed src="images/ClosureNonGreedy.svg" type="image/svg+xml"/>
//
// <h3>Non-Greedy Positive Closure: {@code (...)+?}</h3>
//
// <embed src="images/PositiveClosureNonGreedy.svg" type="image/svg+xml"/>
//
// <h3>Non-Greedy Optional: {@code (...)??}</h3>
//
// <embed src="images/OptionalNonGreedy.svg" type="image/svg+xml"/>
//

var INITIAL_NUM_TRANSITIONS = 4;

function ATNState() {
    // Which ATN are we in?
    this.atn = null;
    this.stateNumber = ATNState.INVALID_STATE_NUMBER;
    this.stateType = null;
    this.ruleIndex = 0; // at runtime, we don't have Rule objects
    this.epsilonOnlyTransitions = false;
    // Track the transitions emanating from this ATN state.
    this.transitions = [];
    // Used to cache lookahead during parsing, not used during construction
    this.nextTokenWithinRule = null;
    return this;
}

// constants for serialization
ATNState.INVALID_TYPE = 0;
ATNState.BASIC = 1;
ATNState.RULE_START = 2;
ATNState.BLOCK_START = 3;
ATNState.PLUS_BLOCK_START = 4;
ATNState.STAR_BLOCK_START = 5;
ATNState.TOKEN_START = 6;
ATNState.RULE_STOP = 7;
ATNState.BLOCK_END = 8;
ATNState.STAR_LOOP_BACK = 9;
ATNState.STAR_LOOP_ENTRY = 10;
ATNState.PLUS_LOOP_BACK = 11;
ATNState.LOOP_END = 12;

ATNState.serializationNames = [
            "INVALID",
            "BASIC",
            "RULE_START",
            "BLOCK_START",
            "PLUS_BLOCK_START",
            "STAR_BLOCK_START",
            "TOKEN_START",
            "RULE_STOP",
            "BLOCK_END",
            "STAR_LOOP_BACK",
            "STAR_LOOP_ENTRY",
            "PLUS_LOOP_BACK",
            "LOOP_END" ];

ATNState.INVALID_STATE_NUMBER = -1;

ATNState.prototype.toString = function() {
	return this.stateNumber;
};

ATNState.prototype.equals = function(other) {
    if (other instanceof ATNState) {
        return this.stateNumber===other.stateNumber;
    } else {
        return false;
    }
};

ATNState.prototype.isNonGreedyExitState = function() {
    return false;
};


ATNState.prototype.addTransition = function(trans, index) {
	if(index===undefined) {
		index = -1;
	}
    if (this.transitions.length===0) {
        this.epsilonOnlyTransitions = trans.isEpsilon;
    } else if(this.epsilonOnlyTransitions !== trans.isEpsilon) {
        this.epsilonOnlyTransitions = false;
    }
    if (index===-1) {
        this.transitions.push(trans);
    } else {
        this.transitions.splice(index, 1, trans);
    }
};

function BasicState() {
	ATNState.call(this);
    this.stateType = ATNState.BASIC;
    return this;
}

BasicState.prototype = Object.create(ATNState.prototype);
BasicState.prototype.constructor = BasicState;


function DecisionState() {
	ATNState.call(this);
    this.decision = -1;
    this.nonGreedy = false;
    return this;
}

DecisionState.prototype = Object.create(ATNState.prototype);
DecisionState.prototype.constructor = DecisionState;


//  The start of a regular {@code (...)} block.
function BlockStartState() {
	DecisionState.call(this);
	this.endState = null;
	return this;
}

BlockStartState.prototype = Object.create(DecisionState.prototype);
BlockStartState.prototype.constructor = BlockStartState;


function BasicBlockStartState() {
	BlockStartState.call(this);
	this.stateType = ATNState.BLOCK_START;
	return this;
}

BasicBlockStartState.prototype = Object.create(BlockStartState.prototype);
BasicBlockStartState.prototype.constructor = BasicBlockStartState;


// Terminal node of a simple {@code (a|b|c)} block.
function BlockEndState() {
	ATNState.call(this);
	this.stateType = ATNState.BLOCK_END;
    this.startState = null;
    return this;
}

BlockEndState.prototype = Object.create(ATNState.prototype);
BlockEndState.prototype.constructor = BlockEndState;


// The last node in the ATN for a rule, unless that rule is the start symbol.
//  In that case, there is one transition to EOF. Later, we might encode
//  references to all calls to this rule to compute FOLLOW sets for
//  error handling.
//
function RuleStopState() {
	ATNState.call(this);
    this.stateType = ATNState.RULE_STOP;
    return this;
}

RuleStopState.prototype = Object.create(ATNState.prototype);
RuleStopState.prototype.constructor = RuleStopState;

function RuleStartState() {
	ATNState.call(this);
	this.stateType = ATNState.RULE_START;
	this.stopState = null;
	this.isPrecedenceRule = false;
	return this;
}

RuleStartState.prototype = Object.create(ATNState.prototype);
RuleStartState.prototype.constructor = RuleStartState;

// Decision state for {@code A+} and {@code (A|B)+}.  It has two transitions:
//  one to the loop back to start of the block and one to exit.
//
function PlusLoopbackState() {
	DecisionState.call(this);
	this.stateType = ATNState.PLUS_LOOP_BACK;
	return this;
}

PlusLoopbackState.prototype = Object.create(DecisionState.prototype);
PlusLoopbackState.prototype.constructor = PlusLoopbackState;


// Start of {@code (A|B|...)+} loop. Technically a decision state, but
//  we don't use for code generation; somebody might need it, so I'm defining
//  it for completeness. In reality, the {@link PlusLoopbackState} node is the
//  real decision-making note for {@code A+}.
//
function PlusBlockStartState() {
	BlockStartState.call(this);
	this.stateType = ATNState.PLUS_BLOCK_START;
    this.loopBackState = null;
    return this;
}

PlusBlockStartState.prototype = Object.create(BlockStartState.prototype);
PlusBlockStartState.prototype.constructor = PlusBlockStartState;

// The block that begins a closure loop.
function StarBlockStartState() {
	BlockStartState.call(this);
	this.stateType = ATNState.STAR_BLOCK_START;
	return this;
}

StarBlockStartState.prototype = Object.create(BlockStartState.prototype);
StarBlockStartState.prototype.constructor = StarBlockStartState;


function StarLoopbackState() {
	ATNState.call(this);
	this.stateType = ATNState.STAR_LOOP_BACK;
	return this;
}

StarLoopbackState.prototype = Object.create(ATNState.prototype);
StarLoopbackState.prototype.constructor = StarLoopbackState;


function StarLoopEntryState() {
	DecisionState.call(this);
	this.stateType = ATNState.STAR_LOOP_ENTRY;
    this.loopBackState = null;
    // Indicates whether this state can benefit from a precedence DFA during SLL decision making.
    this.isPrecedenceDecision = null;
    return this;
}

StarLoopEntryState.prototype = Object.create(DecisionState.prototype);
StarLoopEntryState.prototype.constructor = StarLoopEntryState;


// Mark the end of a * or + loop.
function LoopEndState() {
	ATNState.call(this);
	this.stateType = ATNState.LOOP_END;
	this.loopBackState = null;
	return this;
}

LoopEndState.prototype = Object.create(ATNState.prototype);
LoopEndState.prototype.constructor = LoopEndState;


// The Tokens rule start state linking to each lexer rule start state */
function TokensStartState() {
	DecisionState.call(this);
	this.stateType = ATNState.TOKEN_START;
	return this;
}

TokensStartState.prototype = Object.create(DecisionState.prototype);
TokensStartState.prototype.constructor = TokensStartState;

exports.ATNState = ATNState;
exports.BasicState = BasicState;
exports.DecisionState = DecisionState;
exports.BlockStartState = BlockStartState;
exports.BlockEndState = BlockEndState;
exports.LoopEndState = LoopEndState;
exports.RuleStartState = RuleStartState;
exports.RuleStopState = RuleStopState;
exports.TokensStartState = TokensStartState;
exports.PlusLoopbackState = PlusLoopbackState;
exports.StarLoopbackState = StarLoopbackState;
exports.StarLoopEntryState = StarLoopEntryState;
exports.PlusBlockStartState = PlusBlockStartState;
exports.StarBlockStartState = StarBlockStartState;
exports.BasicBlockStartState = BasicBlockStartState;

},{}],66:[function(require,module,exports){
/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
///

// Represents the type of recognizer an ATN applies to.

function ATNType() {

}

ATNType.LEXER = 0;
ATNType.PARSER = 1;

exports.ATNType = ATNType;


},{}],67:[function(require,module,exports){
//
/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
///

// When we hit an accept state in either the DFA or the ATN, we
//  have to notify the character stream to start buffering characters
//  via {@link IntStream//mark} and record the current state. The current sim state
//  includes the current index into the input, the current line,
//  and current character position in that line. Note that the Lexer is
//  tracking the starting line and characterization of the token. These
//  variables track the "state" of the simulator when it hits an accept state.
//
//  <p>We track these variables separately for the DFA and ATN simulation
//  because the DFA simulation often has to fail over to the ATN
//  simulation. If the ATN simulation fails, we need the DFA to fall
//  back to its previously accepted state, if any. If the ATN succeeds,
//  then the ATN does the accept and the DFA simulator that invoked it
//  can simply return the predicted token type.</p>
///

var Token = require('./../Token').Token;
var Lexer = require('./../Lexer').Lexer;
var ATN = require('./ATN').ATN;
var ATNSimulator = require('./ATNSimulator').ATNSimulator;
var DFAState = require('./../dfa/DFAState').DFAState;
var ATNConfigSet = require('./ATNConfigSet').ATNConfigSet;
var OrderedATNConfigSet = require('./ATNConfigSet').OrderedATNConfigSet;
var PredictionContext = require('./../PredictionContext').PredictionContext;
var SingletonPredictionContext = require('./../PredictionContext').SingletonPredictionContext;
var RuleStopState = require('./ATNState').RuleStopState;
var LexerATNConfig = require('./ATNConfig').LexerATNConfig;
var Transition = require('./Transition').Transition;
var LexerActionExecutor = require('./LexerActionExecutor').LexerActionExecutor;
var LexerNoViableAltException = require('./../error/Errors').LexerNoViableAltException;

function resetSimState(sim) {
	sim.index = -1;
	sim.line = 0;
	sim.column = -1;
	sim.dfaState = null;
}

function SimState() {
	resetSimState(this);
	return this;
}

SimState.prototype.reset = function() {
	resetSimState(this);
};

function LexerATNSimulator(recog, atn, decisionToDFA, sharedContextCache) {
	ATNSimulator.call(this, atn, sharedContextCache);
	this.decisionToDFA = decisionToDFA;
	this.recog = recog;
	// The current token's starting index into the character stream.
	// Shared across DFA to ATN simulation in case the ATN fails and the
	// DFA did not have a previous accept state. In this case, we use the
	// ATN-generated exception object.
	this.startIndex = -1;
	// line number 1..n within the input///
	this.line = 1;
	// The index of the character relative to the beginning of the line
	// 0..n-1///
	this.column = 0;
	this.mode = Lexer.DEFAULT_MODE;
	// Used during DFA/ATN exec to record the most recent accept configuration
	// info
	this.prevAccept = new SimState();
	// done
	return this;
}

LexerATNSimulator.prototype = Object.create(ATNSimulator.prototype);
LexerATNSimulator.prototype.constructor = LexerATNSimulator;

LexerATNSimulator.debug = false;
LexerATNSimulator.dfa_debug = false;

LexerATNSimulator.MIN_DFA_EDGE = 0;
LexerATNSimulator.MAX_DFA_EDGE = 127; // forces unicode to stay in ATN

LexerATNSimulator.match_calls = 0;

LexerATNSimulator.prototype.copyState = function(simulator) {
	this.column = simulator.column;
	this.line = simulator.line;
	this.mode = simulator.mode;
	this.startIndex = simulator.startIndex;
};

LexerATNSimulator.prototype.match = function(input, mode) {
	this.match_calls += 1;
	this.mode = mode;
	var mark = input.mark();
	try {
		this.startIndex = input.index;
		this.prevAccept.reset();
		var dfa = this.decisionToDFA[mode];
		if (dfa.s0 === null) {
			return this.matchATN(input);
		} else {
			return this.execATN(input, dfa.s0);
		}
	} finally {
		input.release(mark);
	}
};

LexerATNSimulator.prototype.reset = function() {
	this.prevAccept.reset();
	this.startIndex = -1;
	this.line = 1;
	this.column = 0;
	this.mode = Lexer.DEFAULT_MODE;
};

LexerATNSimulator.prototype.matchATN = function(input) {
	var startState = this.atn.modeToStartState[this.mode];

	if (LexerATNSimulator.debug) {
		console.log("matchATN mode " + this.mode + " start: " + startState);
	}
	var old_mode = this.mode;
	var s0_closure = this.computeStartState(input, startState);
	var suppressEdge = s0_closure.hasSemanticContext;
	s0_closure.hasSemanticContext = false;

	var next = this.addDFAState(s0_closure);
	if (!suppressEdge) {
		this.decisionToDFA[this.mode].s0 = next;
	}

	var predict = this.execATN(input, next);

	if (LexerATNSimulator.debug) {
		console.log("DFA after matchATN: " + this.decisionToDFA[old_mode].toLexerString());
	}
	return predict;
};

LexerATNSimulator.prototype.execATN = function(input, ds0) {
	if (LexerATNSimulator.debug) {
		console.log("start state closure=" + ds0.configs);
	}
	if (ds0.isAcceptState) {
		// allow zero-length tokens
		this.captureSimState(this.prevAccept, input, ds0);
	}
	var t = input.LA(1);
	var s = ds0; // s is current/from DFA state

	while (true) { // while more work
		if (LexerATNSimulator.debug) {
			console.log("execATN loop starting closure: " + s.configs);
		}

		// As we move src->trg, src->trg, we keep track of the previous trg to
		// avoid looking up the DFA state again, which is expensive.
		// If the previous target was already part of the DFA, we might
		// be able to avoid doing a reach operation upon t. If s!=null,
		// it means that semantic predicates didn't prevent us from
		// creating a DFA state. Once we know s!=null, we check to see if
		// the DFA state has an edge already for t. If so, we can just reuse
		// it's configuration set; there's no point in re-computing it.
		// This is kind of like doing DFA simulation within the ATN
		// simulation because DFA simulation is really just a way to avoid
		// computing reach/closure sets. Technically, once we know that
		// we have a previously added DFA state, we could jump over to
		// the DFA simulator. But, that would mean popping back and forth
		// a lot and making things more complicated algorithmically.
		// This optimization makes a lot of sense for loops within DFA.
		// A character will take us back to an existing DFA state
		// that already has lots of edges out of it. e.g., .* in comments.
		// print("Target for:" + str(s) + " and:" + str(t))
		var target = this.getExistingTargetState(s, t);
		// print("Existing:" + str(target))
		if (target === null) {
			target = this.computeTargetState(input, s, t);
			// print("Computed:" + str(target))
		}
		if (target === ATNSimulator.ERROR) {
			break;
		}
		// If this is a consumable input element, make sure to consume before
		// capturing the accept state so the input index, line, and char
		// position accurately reflect the state of the interpreter at the
		// end of the token.
		if (t !== Token.EOF) {
			this.consume(input);
		}
		if (target.isAcceptState) {
			this.captureSimState(this.prevAccept, input, target);
			if (t === Token.EOF) {
				break;
			}
		}
		t = input.LA(1);
		s = target; // flip; current DFA target becomes new src/from state
	}
	return this.failOrAccept(this.prevAccept, input, s.configs, t);
};

// Get an existing target state for an edge in the DFA. If the target state
// for the edge has not yet been computed or is otherwise not available,
// this method returns {@code null}.
//
// @param s The current DFA state
// @param t The next input symbol
// @return The existing target DFA state for the given input symbol
// {@code t}, or {@code null} if the target state for this edge is not
// already cached
LexerATNSimulator.prototype.getExistingTargetState = function(s, t) {
	if (s.edges === null || t < LexerATNSimulator.MIN_DFA_EDGE || t > LexerATNSimulator.MAX_DFA_EDGE) {
		return null;
	}

	var target = s.edges[t - LexerATNSimulator.MIN_DFA_EDGE];
	if(target===undefined) {
		target = null;
	}
	if (LexerATNSimulator.debug && target !== null) {
		console.log("reuse state " + s.stateNumber + " edge to " + target.stateNumber);
	}
	return target;
};

// Compute a target state for an edge in the DFA, and attempt to add the
// computed state and corresponding edge to the DFA.
//
// @param input The input stream
// @param s The current DFA state
// @param t The next input symbol
//
// @return The computed target DFA state for the given input symbol
// {@code t}. If {@code t} does not lead to a valid DFA state, this method
// returns {@link //ERROR}.
LexerATNSimulator.prototype.computeTargetState = function(input, s, t) {
	var reach = new OrderedATNConfigSet();
	// if we don't find an existing DFA state
	// Fill reach starting from closure, following t transitions
	this.getReachableConfigSet(input, s.configs, reach, t);

	if (reach.items.length === 0) { // we got nowhere on t from s
		if (!reach.hasSemanticContext) {
			// we got nowhere on t, don't throw out this knowledge; it'd
			// cause a failover from DFA later.
			this.addDFAEdge(s, t, ATNSimulator.ERROR);
		}
		// stop when we can't match any more char
		return ATNSimulator.ERROR;
	}
	// Add an edge from s to target DFA found/created for reach
	return this.addDFAEdge(s, t, null, reach);
};

LexerATNSimulator.prototype.failOrAccept = function(prevAccept, input, reach, t) {
	if (this.prevAccept.dfaState !== null) {
		var lexerActionExecutor = prevAccept.dfaState.lexerActionExecutor;
		this.accept(input, lexerActionExecutor, this.startIndex,
				prevAccept.index, prevAccept.line, prevAccept.column);
		return prevAccept.dfaState.prediction;
	} else {
		// if no accept and EOF is first char, return EOF
		if (t === Token.EOF && input.index === this.startIndex) {
			return Token.EOF;
		}
		throw new LexerNoViableAltException(this.recog, input, this.startIndex, reach);
	}
};

// Given a starting configuration set, figure out all ATN configurations
// we can reach upon input {@code t}. Parameter {@code reach} is a return
// parameter.
LexerATNSimulator.prototype.getReachableConfigSet = function(input, closure,
		reach, t) {
	// this is used to skip processing for configs which have a lower priority
	// than a config that already reached an accept state for the same rule
	var skipAlt = ATN.INVALID_ALT_NUMBER;
	for (var i = 0; i < closure.items.length; i++) {
		var cfg = closure.items[i];
		var currentAltReachedAcceptState = (cfg.alt === skipAlt);
		if (currentAltReachedAcceptState && cfg.passedThroughNonGreedyDecision) {
			continue;
		}
		if (LexerATNSimulator.debug) {
			console.log("testing %s at %s\n", this.getTokenName(t), cfg
					.toString(this.recog, true));
		}
		for (var j = 0; j < cfg.state.transitions.length; j++) {
			var trans = cfg.state.transitions[j]; // for each transition
			var target = this.getReachableTarget(trans, t);
			if (target !== null) {
				var lexerActionExecutor = cfg.lexerActionExecutor;
				if (lexerActionExecutor !== null) {
					lexerActionExecutor = lexerActionExecutor.fixOffsetBeforeMatch(input.index - this.startIndex);
				}
				var treatEofAsEpsilon = (t === Token.EOF);
				var config = new LexerATNConfig({state:target, lexerActionExecutor:lexerActionExecutor}, cfg);
				if (this.closure(input, config, reach,
						currentAltReachedAcceptState, true, treatEofAsEpsilon)) {
					// any remaining configs for this alt have a lower priority
					// than the one that just reached an accept state.
					skipAlt = cfg.alt;
				}
			}
		}
	}
};

LexerATNSimulator.prototype.accept = function(input, lexerActionExecutor,
		startIndex, index, line, charPos) {
	if (LexerATNSimulator.debug) {
		console.log("ACTION %s\n", lexerActionExecutor);
	}
	// seek to after last char in token
	input.seek(index);
	this.line = line;
	this.column = charPos;
	if (lexerActionExecutor !== null && this.recog !== null) {
		lexerActionExecutor.execute(this.recog, input, startIndex);
	}
};

LexerATNSimulator.prototype.getReachableTarget = function(trans, t) {
	if (trans.matches(t, 0, Lexer.MAX_CHAR_VALUE)) {
		return trans.target;
	} else {
		return null;
	}
};

LexerATNSimulator.prototype.computeStartState = function(input, p) {
	var initialContext = PredictionContext.EMPTY;
	var configs = new OrderedATNConfigSet();
	for (var i = 0; i < p.transitions.length; i++) {
		var target = p.transitions[i].target;
        var cfg = new LexerATNConfig({state:target, alt:i+1, context:initialContext}, null);
		this.closure(input, cfg, configs, false, false, false);
	}
	return configs;
};

// Since the alternatives within any lexer decision are ordered by
// preference, this method stops pursuing the closure as soon as an accept
// state is reached. After the first accept state is reached by depth-first
// search from {@code config}, all other (potentially reachable) states for
// this rule would have a lower priority.
//
// @return {@code true} if an accept state is reached, otherwise
// {@code false}.
LexerATNSimulator.prototype.closure = function(input, config, configs,
		currentAltReachedAcceptState, speculative, treatEofAsEpsilon) {
	var cfg = null;
	if (LexerATNSimulator.debug) {
		console.log("closure(" + config.toString(this.recog, true) + ")");
	}
	if (config.state instanceof RuleStopState) {
		if (LexerATNSimulator.debug) {
			if (this.recog !== null) {
				console.log("closure at %s rule stop %s\n", this.recog.ruleNames[config.state.ruleIndex], config);
			} else {
				console.log("closure at rule stop %s\n", config);
			}
		}
		if (config.context === null || config.context.hasEmptyPath()) {
			if (config.context === null || config.context.isEmpty()) {
				configs.add(config);
				return true;
			} else {
				configs.add(new LexerATNConfig({ state:config.state, context:PredictionContext.EMPTY}, config));
				currentAltReachedAcceptState = true;
			}
		}
		if (config.context !== null && !config.context.isEmpty()) {
			for (var i = 0; i < config.context.length; i++) {
				if (config.context.getReturnState(i) !== PredictionContext.EMPTY_RETURN_STATE) {
					var newContext = config.context.getParent(i); // "pop" return state
					var returnState = this.atn.states[config.context.getReturnState(i)];
					cfg = new LexerATNConfig({ state:returnState, context:newContext }, config);
					currentAltReachedAcceptState = this.closure(input, cfg,
							configs, currentAltReachedAcceptState, speculative,
							treatEofAsEpsilon);
				}
			}
		}
		return currentAltReachedAcceptState;
	}
	// optimization
	if (!config.state.epsilonOnlyTransitions) {
		if (!currentAltReachedAcceptState || !config.passedThroughNonGreedyDecision) {
			configs.add(config);
		}
	}
	for (var j = 0; j < config.state.transitions.length; j++) {
		var trans = config.state.transitions[j];
		cfg = this.getEpsilonTarget(input, config, trans, configs, speculative, treatEofAsEpsilon);
		if (cfg !== null) {
			currentAltReachedAcceptState = this.closure(input, cfg, configs,
					currentAltReachedAcceptState, speculative, treatEofAsEpsilon);
		}
	}
	return currentAltReachedAcceptState;
};

// side-effect: can alter configs.hasSemanticContext
LexerATNSimulator.prototype.getEpsilonTarget = function(input, config, trans,
		configs, speculative, treatEofAsEpsilon) {
	var cfg = null;
	if (trans.serializationType === Transition.RULE) {
		var newContext = SingletonPredictionContext.create(config.context, trans.followState.stateNumber);
		cfg = new LexerATNConfig( { state:trans.target, context:newContext}, config);
	} else if (trans.serializationType === Transition.PRECEDENCE) {
		throw "Precedence predicates are not supported in lexers.";
	} else if (trans.serializationType === Transition.PREDICATE) {
		// Track traversing semantic predicates. If we traverse,
		// we cannot add a DFA state for this "reach" computation
		// because the DFA would not test the predicate again in the
		// future. Rather than creating collections of semantic predicates
		// like v3 and testing them on prediction, v4 will test them on the
		// fly all the time using the ATN not the DFA. This is slower but
		// semantically it's not used that often. One of the key elements to
		// this predicate mechanism is not adding DFA states that see
		// predicates immediately afterwards in the ATN. For example,

		// a : ID {p1}? | ID {p2}? ;

		// should create the start state for rule 'a' (to save start state
		// competition), but should not create target of ID state. The
		// collection of ATN states the following ID references includes
		// states reached by traversing predicates. Since this is when we
		// test them, we cannot cash the DFA state target of ID.

		if (LexerATNSimulator.debug) {
			console.log("EVAL rule " + trans.ruleIndex + ":" + trans.predIndex);
		}
		configs.hasSemanticContext = true;
		if (this.evaluatePredicate(input, trans.ruleIndex, trans.predIndex, speculative)) {
			cfg = new LexerATNConfig({ state:trans.target}, config);
		}
	} else if (trans.serializationType === Transition.ACTION) {
		if (config.context === null || config.context.hasEmptyPath()) {
			// execute actions anywhere in the start rule for a token.
			//
			// TODO: if the entry rule is invoked recursively, some
			// actions may be executed during the recursive call. The
			// problem can appear when hasEmptyPath() is true but
			// isEmpty() is false. In this case, the config needs to be
			// split into two contexts - one with just the empty path
			// and another with everything but the empty path.
			// Unfortunately, the current algorithm does not allow
			// getEpsilonTarget to return two configurations, so
			// additional modifications are needed before we can support
			// the split operation.
			var lexerActionExecutor = LexerActionExecutor.append(config.lexerActionExecutor,
					this.atn.lexerActions[trans.actionIndex]);
			cfg = new LexerATNConfig({ state:trans.target, lexerActionExecutor:lexerActionExecutor }, config);
		} else {
			// ignore actions in referenced rules
			cfg = new LexerATNConfig( { state:trans.target}, config);
		}
	} else if (trans.serializationType === Transition.EPSILON) {
		cfg = new LexerATNConfig({ state:trans.target}, config);
	} else if (trans.serializationType === Transition.ATOM ||
				trans.serializationType === Transition.RANGE ||
				trans.serializationType === Transition.SET) {
		if (treatEofAsEpsilon) {
			if (trans.matches(Token.EOF, 0, Lexer.MAX_CHAR_VALUE)) {
				cfg = new LexerATNConfig( { state:trans.target }, config);
			}
		}
	}
	return cfg;
};

// Evaluate a predicate specified in the lexer.
//
// <p>If {@code speculative} is {@code true}, this method was called before
// {@link //consume} for the matched character. This method should call
// {@link //consume} before evaluating the predicate to ensure position
// sensitive values, including {@link Lexer//getText}, {@link Lexer//getLine},
// and {@link Lexer//getcolumn}, properly reflect the current
// lexer state. This method should restore {@code input} and the simulator
// to the original state before returning (i.e. undo the actions made by the
// call to {@link //consume}.</p>
//
// @param input The input stream.
// @param ruleIndex The rule containing the predicate.
// @param predIndex The index of the predicate within the rule.
// @param speculative {@code true} if the current index in {@code input} is
// one character before the predicate's location.
//
// @return {@code true} if the specified predicate evaluates to
// {@code true}.
// /
LexerATNSimulator.prototype.evaluatePredicate = function(input, ruleIndex,
		predIndex, speculative) {
	// assume true if no recognizer was provided
	if (this.recog === null) {
		return true;
	}
	if (!speculative) {
		return this.recog.sempred(null, ruleIndex, predIndex);
	}
	var savedcolumn = this.column;
	var savedLine = this.line;
	var index = input.index;
	var marker = input.mark();
	try {
		this.consume(input);
		return this.recog.sempred(null, ruleIndex, predIndex);
	} finally {
		this.column = savedcolumn;
		this.line = savedLine;
		input.seek(index);
		input.release(marker);
	}
};

LexerATNSimulator.prototype.captureSimState = function(settings, input, dfaState) {
	settings.index = input.index;
	settings.line = this.line;
	settings.column = this.column;
	settings.dfaState = dfaState;
};

LexerATNSimulator.prototype.addDFAEdge = function(from_, tk, to, cfgs) {
	if (to === undefined) {
		to = null;
	}
	if (cfgs === undefined) {
		cfgs = null;
	}
	if (to === null && cfgs !== null) {
		// leading to this call, ATNConfigSet.hasSemanticContext is used as a
		// marker indicating dynamic predicate evaluation makes this edge
		// dependent on the specific input sequence, so the static edge in the
		// DFA should be omitted. The target DFAState is still created since
		// execATN has the ability to resynchronize with the DFA state cache
		// following the predicate evaluation step.
		//
		// TJP notes: next time through the DFA, we see a pred again and eval.
		// If that gets us to a previously created (but dangling) DFA
		// state, we can continue in pure DFA mode from there.
		// /
		var suppressEdge = cfgs.hasSemanticContext;
		cfgs.hasSemanticContext = false;

		to = this.addDFAState(cfgs);

		if (suppressEdge) {
			return to;
		}
	}
	// add the edge
	if (tk < LexerATNSimulator.MIN_DFA_EDGE || tk > LexerATNSimulator.MAX_DFA_EDGE) {
		// Only track edges within the DFA bounds
		return to;
	}
	if (LexerATNSimulator.debug) {
		console.log("EDGE " + from_ + " -> " + to + " upon " + tk);
	}
	if (from_.edges === null) {
		// make room for tokens 1..n and -1 masquerading as index 0
		from_.edges = [];
	}
	from_.edges[tk - LexerATNSimulator.MIN_DFA_EDGE] = to; // connect

	return to;
};

// Add a new DFA state if there isn't one with this set of
// configurations already. This method also detects the first
// configuration containing an ATN rule stop state. Later, when
// traversing the DFA, we will know which rule to accept.
LexerATNSimulator.prototype.addDFAState = function(configs) {
	var proposed = new DFAState(null, configs);
	var firstConfigWithRuleStopState = null;
	for (var i = 0; i < configs.items.length; i++) {
		var cfg = configs.items[i];
		if (cfg.state instanceof RuleStopState) {
			firstConfigWithRuleStopState = cfg;
			break;
		}
	}
	if (firstConfigWithRuleStopState !== null) {
		proposed.isAcceptState = true;
		proposed.lexerActionExecutor = firstConfigWithRuleStopState.lexerActionExecutor;
		proposed.prediction = this.atn.ruleToTokenType[firstConfigWithRuleStopState.state.ruleIndex];
	}
	var dfa = this.decisionToDFA[this.mode];
	var existing = dfa.states.get(proposed);
	if (existing!==null) {
		return existing;
	}
	var newState = proposed;
	newState.stateNumber = dfa.states.length;
	configs.setReadonly(true);
	newState.configs = configs;
	dfa.states.add(newState);
	return newState;
};

LexerATNSimulator.prototype.getDFA = function(mode) {
	return this.decisionToDFA[mode];
};

// Get the text matched so far for the current token.
LexerATNSimulator.prototype.getText = function(input) {
	// index is first lookahead char, don't include.
	return input.getText(this.startIndex, input.index - 1);
};

LexerATNSimulator.prototype.consume = function(input) {
	var curChar = input.LA(1);
	if (curChar === "\n".charCodeAt(0)) {
		this.line += 1;
		this.column = 0;
	} else {
		this.column += 1;
	}
	input.consume();
};

LexerATNSimulator.prototype.getTokenName = function(tt) {
	if (tt === -1) {
		return "EOF";
	} else {
		return "'" + String.fromCharCode(tt) + "'";
	}
};

exports.LexerATNSimulator = LexerATNSimulator;

},{"./../Lexer":51,"./../PredictionContext":54,"./../Token":57,"./../dfa/DFAState":77,"./../error/Errors":82,"./ATN":59,"./ATNConfig":60,"./ATNConfigSet":61,"./ATNSimulator":64,"./ATNState":65,"./LexerActionExecutor":69,"./Transition":73}],68:[function(require,module,exports){
//
/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
 //

function LexerActionType() {
}

LexerActionType.CHANNEL = 0;     //The type of a {@link LexerChannelAction} action.
LexerActionType.CUSTOM = 1;      //The type of a {@link LexerCustomAction} action.
LexerActionType.MODE = 2;        //The type of a {@link LexerModeAction} action.
LexerActionType.MORE = 3;        //The type of a {@link LexerMoreAction} action.
LexerActionType.POP_MODE = 4;    //The type of a {@link LexerPopModeAction} action.
LexerActionType.PUSH_MODE = 5;   //The type of a {@link LexerPushModeAction} action.
LexerActionType.SKIP = 6;        //The type of a {@link LexerSkipAction} action.
LexerActionType.TYPE = 7;        //The type of a {@link LexerTypeAction} action.

function LexerAction(action) {
    this.actionType = action;
    this.isPositionDependent = false;
    return this;
}

LexerAction.prototype.hashCode = function() {
    var hash = new Hash();
    this.updateHashCode(hash);
    return hash.finish()
};

LexerAction.prototype.updateHashCode = function(hash) {
    hash.update(this.actionType);
};

LexerAction.prototype.equals = function(other) {
    return this === other;
};



//
// Implements the {@code skip} lexer action by calling {@link Lexer//skip}.
//
// <p>The {@code skip} command does not have any parameters, so this action is
// implemented as a singleton instance exposed by {@link //INSTANCE}.</p>
function LexerSkipAction() {
	LexerAction.call(this, LexerActionType.SKIP);
	return this;
}

LexerSkipAction.prototype = Object.create(LexerAction.prototype);
LexerSkipAction.prototype.constructor = LexerSkipAction;

// Provides a singleton instance of this parameterless lexer action.
LexerSkipAction.INSTANCE = new LexerSkipAction();

LexerSkipAction.prototype.execute = function(lexer) {
    lexer.skip();
};

LexerSkipAction.prototype.toString = function() {
	return "skip";
};

//  Implements the {@code type} lexer action by calling {@link Lexer//setType}
// with the assigned type.
function LexerTypeAction(type) {
	LexerAction.call(this, LexerActionType.TYPE);
	this.type = type;
	return this;
}

LexerTypeAction.prototype = Object.create(LexerAction.prototype);
LexerTypeAction.prototype.constructor = LexerTypeAction;

LexerTypeAction.prototype.execute = function(lexer) {
    lexer.type = this.type;
};

LexerTypeAction.prototype.updateHashCode = function(hash) {
    hash.update(this.actionType, this.type);
};


LexerTypeAction.prototype.equals = function(other) {
    if(this === other) {
        return true;
    } else if (! (other instanceof LexerTypeAction)) {
        return false;
    } else {
        return this.type === other.type;
    }
};

LexerTypeAction.prototype.toString = function() {
    return "type(" + this.type + ")";
};

// Implements the {@code pushMode} lexer action by calling
// {@link Lexer//pushMode} with the assigned mode.
function LexerPushModeAction(mode) {
	LexerAction.call(this, LexerActionType.PUSH_MODE);
    this.mode = mode;
    return this;
}

LexerPushModeAction.prototype = Object.create(LexerAction.prototype);
LexerPushModeAction.prototype.constructor = LexerPushModeAction;

// <p>This action is implemented by calling {@link Lexer//pushMode} with the
// value provided by {@link //getMode}.</p>
LexerPushModeAction.prototype.execute = function(lexer) {
    lexer.pushMode(this.mode);
};

LexerPushModeAction.prototype.updateHashCode = function(hash) {
    hash.update(this.actionType, this.mode);
};

LexerPushModeAction.prototype.equals = function(other) {
    if (this === other) {
        return true;
    } else if (! (other instanceof LexerPushModeAction)) {
        return false;
    } else {
        return this.mode === other.mode;
    }
};

LexerPushModeAction.prototype.toString = function() {
	return "pushMode(" + this.mode + ")";
};


// Implements the {@code popMode} lexer action by calling {@link Lexer//popMode}.
//
// <p>The {@code popMode} command does not have any parameters, so this action is
// implemented as a singleton instance exposed by {@link //INSTANCE}.</p>
function LexerPopModeAction() {
	LexerAction.call(this,LexerActionType.POP_MODE);
	return this;
}

LexerPopModeAction.prototype = Object.create(LexerAction.prototype);
LexerPopModeAction.prototype.constructor = LexerPopModeAction;

LexerPopModeAction.INSTANCE = new LexerPopModeAction();

// <p>This action is implemented by calling {@link Lexer//popMode}.</p>
LexerPopModeAction.prototype.execute = function(lexer) {
    lexer.popMode();
};

LexerPopModeAction.prototype.toString = function() {
	return "popMode";
};

// Implements the {@code more} lexer action by calling {@link Lexer//more}.
//
// <p>The {@code more} command does not have any parameters, so this action is
// implemented as a singleton instance exposed by {@link //INSTANCE}.</p>
function LexerMoreAction() {
	LexerAction.call(this, LexerActionType.MORE);
	return this;
}

LexerMoreAction.prototype = Object.create(LexerAction.prototype);
LexerMoreAction.prototype.constructor = LexerMoreAction;

LexerMoreAction.INSTANCE = new LexerMoreAction();

// <p>This action is implemented by calling {@link Lexer//popMode}.</p>
LexerMoreAction.prototype.execute = function(lexer) {
    lexer.more();
};

LexerMoreAction.prototype.toString = function() {
    return "more";
};


// Implements the {@code mode} lexer action by calling {@link Lexer//mode} with
// the assigned mode.
function LexerModeAction(mode) {
	LexerAction.call(this, LexerActionType.MODE);
    this.mode = mode;
    return this;
}

LexerModeAction.prototype = Object.create(LexerAction.prototype);
LexerModeAction.prototype.constructor = LexerModeAction;

// <p>This action is implemented by calling {@link Lexer//mode} with the
// value provided by {@link //getMode}.</p>
LexerModeAction.prototype.execute = function(lexer) {
    lexer.mode(this.mode);
};

LexerModeAction.prototype.updateHashCode = function(hash) {
    hash.update(this.actionType, this.mode);
};

LexerModeAction.prototype.equals = function(other) {
    if (this === other) {
        return true;
    } else if (! (other instanceof LexerModeAction)) {
        return false;
    } else {
        return this.mode === other.mode;
    }
};

LexerModeAction.prototype.toString = function() {
    return "mode(" + this.mode + ")";
};

// Executes a custom lexer action by calling {@link Recognizer//action} with the
// rule and action indexes assigned to the custom action. The implementation of
// a custom action is added to the generated code for the lexer in an override
// of {@link Recognizer//action} when the grammar is compiled.
//
// <p>This class may represent embedded actions created with the <code>{...}</code>
// syntax in ANTLR 4, as well as actions created for lexer commands where the
// command argument could not be evaluated when the grammar was compiled.</p>


    // Constructs a custom lexer action with the specified rule and action
    // indexes.
    //
    // @param ruleIndex The rule index to use for calls to
    // {@link Recognizer//action}.
    // @param actionIndex The action index to use for calls to
    // {@link Recognizer//action}.

function LexerCustomAction(ruleIndex, actionIndex) {
	LexerAction.call(this, LexerActionType.CUSTOM);
    this.ruleIndex = ruleIndex;
    this.actionIndex = actionIndex;
    this.isPositionDependent = true;
    return this;
}

LexerCustomAction.prototype = Object.create(LexerAction.prototype);
LexerCustomAction.prototype.constructor = LexerCustomAction;

// <p>Custom actions are implemented by calling {@link Lexer//action} with the
// appropriate rule and action indexes.</p>
LexerCustomAction.prototype.execute = function(lexer) {
    lexer.action(null, this.ruleIndex, this.actionIndex);
};

LexerCustomAction.prototype.updateHashCode = function(hash) {
    hash.update(this.actionType, this.ruleIndex, this.actionIndex);
};

LexerCustomAction.prototype.equals = function(other) {
    if (this === other) {
        return true;
    } else if (! (other instanceof LexerCustomAction)) {
        return false;
    } else {
        return this.ruleIndex === other.ruleIndex && this.actionIndex === other.actionIndex;
    }
};

// Implements the {@code channel} lexer action by calling
// {@link Lexer//setChannel} with the assigned channel.
// Constructs a new {@code channel} action with the specified channel value.
// @param channel The channel value to pass to {@link Lexer//setChannel}.
function LexerChannelAction(channel) {
	LexerAction.call(this, LexerActionType.CHANNEL);
    this.channel = channel;
    return this;
}

LexerChannelAction.prototype = Object.create(LexerAction.prototype);
LexerChannelAction.prototype.constructor = LexerChannelAction;

// <p>This action is implemented by calling {@link Lexer//setChannel} with the
// value provided by {@link //getChannel}.</p>
LexerChannelAction.prototype.execute = function(lexer) {
    lexer._channel = this.channel;
};

LexerChannelAction.prototype.updateHashCode = function(hash) {
    hash.update(this.actionType, this.channel);
};

LexerChannelAction.prototype.equals = function(other) {
    if (this === other) {
        return true;
    } else if (! (other instanceof LexerChannelAction)) {
        return false;
    } else {
        return this.channel === other.channel;
    }
};

LexerChannelAction.prototype.toString = function() {
    return "channel(" + this.channel + ")";
};

// This implementation of {@link LexerAction} is used for tracking input offsets
// for position-dependent actions within a {@link LexerActionExecutor}.
//
// <p>This action is not serialized as part of the ATN, and is only required for
// position-dependent lexer actions which appear at a location other than the
// end of a rule. For more information about DFA optimizations employed for
// lexer actions, see {@link LexerActionExecutor//append} and
// {@link LexerActionExecutor//fixOffsetBeforeMatch}.</p>

// Constructs a new indexed custom action by associating a character offset
// with a {@link LexerAction}.
//
// <p>Note: This class is only required for lexer actions for which
// {@link LexerAction//isPositionDependent} returns {@code true}.</p>
//
// @param offset The offset into the input {@link CharStream}, relative to
// the token start index, at which the specified lexer action should be
// executed.
// @param action The lexer action to execute at a particular offset in the
// input {@link CharStream}.
function LexerIndexedCustomAction(offset, action) {
	LexerAction.call(this, action.actionType);
    this.offset = offset;
    this.action = action;
    this.isPositionDependent = true;
    return this;
}

LexerIndexedCustomAction.prototype = Object.create(LexerAction.prototype);
LexerIndexedCustomAction.prototype.constructor = LexerIndexedCustomAction;

// <p>This method calls {@link //execute} on the result of {@link //getAction}
// using the provided {@code lexer}.</p>
LexerIndexedCustomAction.prototype.execute = function(lexer) {
    // assume the input stream position was properly set by the calling code
    this.action.execute(lexer);
};

LexerIndexedCustomAction.prototype.updateHashCode = function(hash) {
    hash.update(this.actionType, this.offset, this.action);
};

LexerIndexedCustomAction.prototype.equals = function(other) {
    if (this === other) {
        return true;
    } else if (! (other instanceof LexerIndexedCustomAction)) {
        return false;
    } else {
        return this.offset === other.offset && this.action === other.action;
    }
};


exports.LexerActionType = LexerActionType;
exports.LexerSkipAction = LexerSkipAction;
exports.LexerChannelAction = LexerChannelAction;
exports.LexerCustomAction = LexerCustomAction;
exports.LexerIndexedCustomAction = LexerIndexedCustomAction;
exports.LexerMoreAction = LexerMoreAction;
exports.LexerTypeAction = LexerTypeAction;
exports.LexerPushModeAction = LexerPushModeAction;
exports.LexerPopModeAction = LexerPopModeAction;
exports.LexerModeAction = LexerModeAction;
},{}],69:[function(require,module,exports){
//
/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
///

// Represents an executor for a sequence of lexer actions which traversed during
// the matching operation of a lexer rule (token).
//
// <p>The executor tracks position information for position-dependent lexer actions
// efficiently, ensuring that actions appearing only at the end of the rule do
// not cause bloating of the {@link DFA} created for the lexer.</p>

var hashStuff = require("../Utils").hashStuff;
var LexerIndexedCustomAction = require('./LexerAction').LexerIndexedCustomAction;

function LexerActionExecutor(lexerActions) {
	this.lexerActions = lexerActions === null ? [] : lexerActions;
	// Caches the result of {@link //hashCode} since the hash code is an element
	// of the performance-critical {@link LexerATNConfig//hashCode} operation.
	this.cachedHashCode = hashStuff(lexerActions); // "".join([str(la) for la in
	// lexerActions]))
	return this;
}

// Creates a {@link LexerActionExecutor} which executes the actions for
// the input {@code lexerActionExecutor} followed by a specified
// {@code lexerAction}.
//
// @param lexerActionExecutor The executor for actions already traversed by
// the lexer while matching a token within a particular
// {@link LexerATNConfig}. If this is {@code null}, the method behaves as
// though it were an empty executor.
// @param lexerAction The lexer action to execute after the actions
// specified in {@code lexerActionExecutor}.
//
// @return A {@link LexerActionExecutor} for executing the combine actions
// of {@code lexerActionExecutor} and {@code lexerAction}.
LexerActionExecutor.append = function(lexerActionExecutor, lexerAction) {
	if (lexerActionExecutor === null) {
		return new LexerActionExecutor([ lexerAction ]);
	}
	var lexerActions = lexerActionExecutor.lexerActions.concat([ lexerAction ]);
	return new LexerActionExecutor(lexerActions);
};

// Creates a {@link LexerActionExecutor} which encodes the current offset
// for position-dependent lexer actions.
//
// <p>Normally, when the executor encounters lexer actions where
// {@link LexerAction//isPositionDependent} returns {@code true}, it calls
// {@link IntStream//seek} on the input {@link CharStream} to set the input
// position to the <em>end</em> of the current token. This behavior provides
// for efficient DFA representation of lexer actions which appear at the end
// of a lexer rule, even when the lexer rule matches a variable number of
// characters.</p>
//
// <p>Prior to traversing a match transition in the ATN, the current offset
// from the token start index is assigned to all position-dependent lexer
// actions which have not already been assigned a fixed offset. By storing
// the offsets relative to the token start index, the DFA representation of
// lexer actions which appear in the middle of tokens remains efficient due
// to sharing among tokens of the same length, regardless of their absolute
// position in the input stream.</p>
//
// <p>If the current executor already has offsets assigned to all
// position-dependent lexer actions, the method returns {@code this}.</p>
//
// @param offset The current offset to assign to all position-dependent
// lexer actions which do not already have offsets assigned.
//
// @return A {@link LexerActionExecutor} which stores input stream offsets
// for all position-dependent lexer actions.
// /
LexerActionExecutor.prototype.fixOffsetBeforeMatch = function(offset) {
	var updatedLexerActions = null;
	for (var i = 0; i < this.lexerActions.length; i++) {
		if (this.lexerActions[i].isPositionDependent &&
				!(this.lexerActions[i] instanceof LexerIndexedCustomAction)) {
			if (updatedLexerActions === null) {
				updatedLexerActions = this.lexerActions.concat([]);
			}
			updatedLexerActions[i] = new LexerIndexedCustomAction(offset,
					this.lexerActions[i]);
		}
	}
	if (updatedLexerActions === null) {
		return this;
	} else {
		return new LexerActionExecutor(updatedLexerActions);
	}
};

// Execute the actions encapsulated by this executor within the context of a
// particular {@link Lexer}.
//
// <p>This method calls {@link IntStream//seek} to set the position of the
// {@code input} {@link CharStream} prior to calling
// {@link LexerAction//execute} on a position-dependent action. Before the
// method returns, the input position will be restored to the same position
// it was in when the method was invoked.</p>
//
// @param lexer The lexer instance.
// @param input The input stream which is the source for the current token.
// When this method is called, the current {@link IntStream//index} for
// {@code input} should be the start of the following token, i.e. 1
// character past the end of the current token.
// @param startIndex The token start index. This value may be passed to
// {@link IntStream//seek} to set the {@code input} position to the beginning
// of the token.
// /
LexerActionExecutor.prototype.execute = function(lexer, input, startIndex) {
	var requiresSeek = false;
	var stopIndex = input.index;
	try {
		for (var i = 0; i < this.lexerActions.length; i++) {
			var lexerAction = this.lexerActions[i];
			if (lexerAction instanceof LexerIndexedCustomAction) {
				var offset = lexerAction.offset;
				input.seek(startIndex + offset);
				lexerAction = lexerAction.action;
				requiresSeek = (startIndex + offset) !== stopIndex;
			} else if (lexerAction.isPositionDependent) {
				input.seek(stopIndex);
				requiresSeek = false;
			}
			lexerAction.execute(lexer);
		}
	} finally {
		if (requiresSeek) {
			input.seek(stopIndex);
		}
	}
};

LexerActionExecutor.prototype.hashCode = function() {
	return this.cachedHashCode;
};

LexerActionExecutor.prototype.updateHashCode = function(hash) {
    hash.update(this.cachedHashCode);
};


LexerActionExecutor.prototype.equals = function(other) {
	if (this === other) {
		return true;
	} else if (!(other instanceof LexerActionExecutor)) {
		return false;
	} else if (this.cachedHashCode != other.cachedHashCode) {
		return false;
	} else if (this.lexerActions.length != other.lexerActions.length) {
		return false;
	} else {
		var numActions = this.lexerActions.length
		for (var idx = 0; idx < numActions; ++idx) {
			if (!this.lexerActions[idx].equals(other.lexerActions[idx])) {
				return false;
			}
		}
		return true;
	}
};

exports.LexerActionExecutor = LexerActionExecutor;

},{"../Utils":58,"./LexerAction":68}],70:[function(require,module,exports){
//
/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
//

//
// The embodiment of the adaptive LL(*), ALL(*), parsing strategy.
//
// <p>
// The basic complexity of the adaptive strategy makes it harder to understand.
// We begin with ATN simulation to build paths in a DFA. Subsequent prediction
// requests go through the DFA first. If they reach a state without an edge for
// the current symbol, the algorithm fails over to the ATN simulation to
// complete the DFA path for the current input (until it finds a conflict state
// or uniquely predicting state).</p>
//
// <p>
// All of that is done without using the outer context because we want to create
// a DFA that is not dependent upon the rule invocation stack when we do a
// prediction. One DFA works in all contexts. We avoid using context not
// necessarily because it's slower, although it can be, but because of the DFA
// caching problem. The closure routine only considers the rule invocation stack
// created during prediction beginning in the decision rule. For example, if
// prediction occurs without invoking another rule's ATN, there are no context
// stacks in the configurations. When lack of context leads to a conflict, we
// don't know if it's an ambiguity or a weakness in the strong LL(*) parsing
// strategy (versus full LL(*)).</p>
//
// <p>
// When SLL yields a configuration set with conflict, we rewind the input and
// retry the ATN simulation, this time using full outer context without adding
// to the DFA. Configuration context stacks will be the full invocation stacks
// from the start rule. If we get a conflict using full context, then we can
// definitively say we have a true ambiguity for that input sequence. If we
// don't get a conflict, it implies that the decision is sensitive to the outer
// context. (It is not context-sensitive in the sense of context-sensitive
// grammars.)</p>
//
// <p>
// The next time we reach this DFA state with an SLL conflict, through DFA
// simulation, we will again retry the ATN simulation using full context mode.
// This is slow because we can't save the results and have to "interpret" the
// ATN each time we get that input.</p>
//
// <p>
// <strong>CACHING FULL CONTEXT PREDICTIONS</strong></p>
//
// <p>
// We could cache results from full context to predicted alternative easily and
// that saves a lot of time but doesn't work in presence of predicates. The set
// of visible predicates from the ATN start state changes depending on the
// context, because closure can fall off the end of a rule. I tried to cache
// tuples (stack context, semantic context, predicted alt) but it was slower
// than interpreting and much more complicated. Also required a huge amount of
// memory. The goal is not to create the world's fastest parser anyway. I'd like
// to keep this algorithm simple. By launching multiple threads, we can improve
// the speed of parsing across a large number of files.</p>
//
// <p>
// There is no strict ordering between the amount of input used by SLL vs LL,
// which makes it really hard to build a cache for full context. Let's say that
// we have input A B C that leads to an SLL conflict with full context X. That
// implies that using X we might only use A B but we could also use A B C D to
// resolve conflict. Input A B C D could predict alternative 1 in one position
// in the input and A B C E could predict alternative 2 in another position in
// input. The conflicting SLL configurations could still be non-unique in the
// full context prediction, which would lead us to requiring more input than the
// original A B C.	To make a	prediction cache work, we have to track	the exact
// input	used during the previous prediction. That amounts to a cache that maps
// X to a specific DFA for that context.</p>
//
// <p>
// Something should be done for left-recursive expression predictions. They are
// likely LL(1) + pred eval. Easier to do the whole SLL unless error and retry
// with full LL thing Sam does.</p>
//
// <p>
// <strong>AVOIDING FULL CONTEXT PREDICTION</strong></p>
//
// <p>
// We avoid doing full context retry when the outer context is empty, we did not
// dip into the outer context by falling off the end of the decision state rule,
// or when we force SLL mode.</p>
//
// <p>
// As an example of the not dip into outer context case, consider as super
// constructor calls versus function calls. One grammar might look like
// this:</p>
//
// <pre>
// ctorBody
//   : '{' superCall? stat* '}'
//   ;
// </pre>
//
// <p>
// Or, you might see something like</p>
//
// <pre>
// stat
//   : superCall ';'
//   | expression ';'
//   | ...
//   ;
// </pre>
//
// <p>
// In both cases I believe that no closure operations will dip into the outer
// context. In the first case ctorBody in the worst case will stop at the '}'.
// In the 2nd case it should stop at the ';'. Both cases should stay within the
// entry rule and not dip into the outer context.</p>
//
// <p>
// <strong>PREDICATES</strong></p>
//
// <p>
// Predicates are always evaluated if present in either SLL or LL both. SLL and
// LL simulation deals with predicates differently. SLL collects predicates as
// it performs closure operations like ANTLR v3 did. It delays predicate
// evaluation until it reaches and accept state. This allows us to cache the SLL
// ATN simulation whereas, if we had evaluated predicates on-the-fly during
// closure, the DFA state configuration sets would be different and we couldn't
// build up a suitable DFA.</p>
//
// <p>
// When building a DFA accept state during ATN simulation, we evaluate any
// predicates and return the sole semantically valid alternative. If there is
// more than 1 alternative, we report an ambiguity. If there are 0 alternatives,
// we throw an exception. Alternatives without predicates act like they have
// true predicates. The simple way to think about it is to strip away all
// alternatives with false predicates and choose the minimum alternative that
// remains.</p>
//
// <p>
// When we start in the DFA and reach an accept state that's predicated, we test
// those and return the minimum semantically viable alternative. If no
// alternatives are viable, we throw an exception.</p>
//
// <p>
// During full LL ATN simulation, closure always evaluates predicates and
// on-the-fly. This is crucial to reducing the configuration set size during
// closure. It hits a landmine when parsing with the Java grammar, for example,
// without this on-the-fly evaluation.</p>
//
// <p>
// <strong>SHARING DFA</strong></p>
//
// <p>
// All instances of the same parser share the same decision DFAs through a
// static field. Each instance gets its own ATN simulator but they share the
// same {@link //decisionToDFA} field. They also share a
// {@link PredictionContextCache} object that makes sure that all
// {@link PredictionContext} objects are shared among the DFA states. This makes
// a big size difference.</p>
//
// <p>
// <strong>THREAD SAFETY</strong></p>
//
// <p>
// The {@link ParserATNSimulator} locks on the {@link //decisionToDFA} field when
// it adds a new DFA object to that array. {@link //addDFAEdge}
// locks on the DFA for the current decision when setting the
// {@link DFAState//edges} field. {@link //addDFAState} locks on
// the DFA for the current decision when looking up a DFA state to see if it
// already exists. We must make sure that all requests to add DFA states that
// are equivalent result in the same shared DFA object. This is because lots of
// threads will be trying to update the DFA at once. The
// {@link //addDFAState} method also locks inside the DFA lock
// but this time on the shared context cache when it rebuilds the
// configurations' {@link PredictionContext} objects using cached
// subgraphs/nodes. No other locking occurs, even during DFA simulation. This is
// safe as long as we can guarantee that all threads referencing
// {@code s.edge[t]} get the same physical target {@link DFAState}, or
// {@code null}. Once into the DFA, the DFA simulation does not reference the
// {@link DFA//states} map. It follows the {@link DFAState//edges} field to new
// targets. The DFA simulator will either find {@link DFAState//edges} to be
// {@code null}, to be non-{@code null} and {@code dfa.edges[t]} null, or
// {@code dfa.edges[t]} to be non-null. The
// {@link //addDFAEdge} method could be racing to set the field
// but in either case the DFA simulator works; if {@code null}, and requests ATN
// simulation. It could also race trying to get {@code dfa.edges[t]}, but either
// way it will work because it's not doing a test and set operation.</p>
//
// <p>
// <strong>Starting with SLL then failing to combined SLL/LL (Two-Stage
// Parsing)</strong></p>
//
// <p>
// Sam pointed out that if SLL does not give a syntax error, then there is no
// point in doing full LL, which is slower. We only have to try LL if we get a
// syntax error. For maximum speed, Sam starts the parser set to pure SLL
// mode with the {@link BailErrorStrategy}:</p>
//
// <pre>
// parser.{@link Parser//getInterpreter() getInterpreter()}.{@link //setPredictionMode setPredictionMode}{@code (}{@link PredictionMode//SLL}{@code )};
// parser.{@link Parser//setErrorHandler setErrorHandler}(new {@link BailErrorStrategy}());
// </pre>
//
// <p>
// If it does not get a syntax error, then we're done. If it does get a syntax
// error, we need to retry with the combined SLL/LL strategy.</p>
//
// <p>
// The reason this works is as follows. If there are no SLL conflicts, then the
// grammar is SLL (at least for that input set). If there is an SLL conflict,
// the full LL analysis must yield a set of viable alternatives which is a
// subset of the alternatives reported by SLL. If the LL set is a singleton,
// then the grammar is LL but not SLL. If the LL set is the same size as the SLL
// set, the decision is SLL. If the LL set has size &gt; 1, then that decision
// is truly ambiguous on the current input. If the LL set is smaller, then the
// SLL conflict resolution might choose an alternative that the full LL would
// rule out as a possibility based upon better context information. If that's
// the case, then the SLL parse will definitely get an error because the full LL
// analysis says it's not viable. If SLL conflict resolution chooses an
// alternative within the LL set, them both SLL and LL would choose the same
// alternative because they both choose the minimum of multiple conflicting
// alternatives.</p>
//
// <p>
// Let's say we have a set of SLL conflicting alternatives {@code {1, 2, 3}} and
// a smaller LL set called <em>s</em>. If <em>s</em> is {@code {2, 3}}, then SLL
// parsing will get an error because SLL will pursue alternative 1. If
// <em>s</em> is {@code {1, 2}} or {@code {1, 3}} then both SLL and LL will
// choose the same alternative because alternative one is the minimum of either
// set. If <em>s</em> is {@code {2}} or {@code {3}} then SLL will get a syntax
// error. If <em>s</em> is {@code {1}} then SLL will succeed.</p>
//
// <p>
// Of course, if the input is invalid, then we will get an error for sure in
// both SLL and LL parsing. Erroneous input will therefore require 2 passes over
// the input.</p>
//

var Utils = require('./../Utils');
var Set = Utils.Set;
var BitSet = Utils.BitSet;
var DoubleDict = Utils.DoubleDict;
var ATN = require('./ATN').ATN;
var ATNState = require('./ATNState').ATNState;
var ATNConfig = require('./ATNConfig').ATNConfig;
var ATNConfigSet = require('./ATNConfigSet').ATNConfigSet;
var Token = require('./../Token').Token;
var DFAState = require('./../dfa/DFAState').DFAState;
var PredPrediction = require('./../dfa/DFAState').PredPrediction;
var ATNSimulator = require('./ATNSimulator').ATNSimulator;
var PredictionMode = require('./PredictionMode').PredictionMode;
var RuleContext = require('./../RuleContext').RuleContext;
var ParserRuleContext = require('./../ParserRuleContext').ParserRuleContext;
var SemanticContext = require('./SemanticContext').SemanticContext;
var StarLoopEntryState = require('./ATNState').StarLoopEntryState;
var RuleStopState = require('./ATNState').RuleStopState;
var PredictionContext = require('./../PredictionContext').PredictionContext;
var Interval = require('./../IntervalSet').Interval;
var Transitions = require('./Transition');
var Transition = Transitions.Transition;
var SetTransition = Transitions.SetTransition;
var NotSetTransition = Transitions.NotSetTransition;
var RuleTransition = Transitions.RuleTransition;
var ActionTransition = Transitions.ActionTransition;
var NoViableAltException = require('./../error/Errors').NoViableAltException;

var SingletonPredictionContext = require('./../PredictionContext').SingletonPredictionContext;
var predictionContextFromRuleContext = require('./../PredictionContext').predictionContextFromRuleContext;

function ParserATNSimulator(parser, atn, decisionToDFA, sharedContextCache) {
	ATNSimulator.call(this, atn, sharedContextCache);
    this.parser = parser;
    this.decisionToDFA = decisionToDFA;
    // SLL, LL, or LL + exact ambig detection?//
    this.predictionMode = PredictionMode.LL;
    // LAME globals to avoid parameters!!!!! I need these down deep in predTransition
    this._input = null;
    this._startIndex = 0;
    this._outerContext = null;
    this._dfa = null;
    // Each prediction operation uses a cache for merge of prediction contexts.
    //  Don't keep around as it wastes huge amounts of memory. DoubleKeyMap
    //  isn't synchronized but we're ok since two threads shouldn't reuse same
    //  parser/atnsim object because it can only handle one input at a time.
    //  This maps graphs a and b to merged result c. (a,b)&rarr;c. We can avoid
    //  the merge if we ever see a and b again.  Note that (b,a)&rarr;c should
    //  also be examined during cache lookup.
    //
    this.mergeCache = null;
    return this;
}

ParserATNSimulator.prototype = Object.create(ATNSimulator.prototype);
ParserATNSimulator.prototype.constructor = ParserATNSimulator;

ParserATNSimulator.prototype.debug = false;
ParserATNSimulator.prototype.debug_closure = false;
ParserATNSimulator.prototype.debug_add = false;
ParserATNSimulator.prototype.debug_list_atn_decisions = false;
ParserATNSimulator.prototype.dfa_debug = false;
ParserATNSimulator.prototype.retry_debug = false;


ParserATNSimulator.prototype.reset = function() {
};

ParserATNSimulator.prototype.adaptivePredict = function(input, decision, outerContext) {
    if (this.debug || this.debug_list_atn_decisions) {
        console.log("adaptivePredict decision " + decision +
                               " exec LA(1)==" + this.getLookaheadName(input) +
                               " line " + input.LT(1).line + ":" +
                               input.LT(1).column);
    }
    this._input = input;
    this._startIndex = input.index;
    this._outerContext = outerContext;

    var dfa = this.decisionToDFA[decision];
    this._dfa = dfa;
    var m = input.mark();
    var index = input.index;

    // Now we are certain to have a specific decision's DFA
    // But, do we still need an initial state?
    try {
        var s0;
        if (dfa.precedenceDfa) {
            // the start state for a precedence DFA depends on the current
            // parser precedence, and is provided by a DFA method.
            s0 = dfa.getPrecedenceStartState(this.parser.getPrecedence());
        } else {
            // the start state for a "regular" DFA is just s0
            s0 = dfa.s0;
        }
        if (s0===null) {
            if (outerContext===null) {
                outerContext = RuleContext.EMPTY;
            }
            if (this.debug || this.debug_list_atn_decisions) {
                console.log("predictATN decision " + dfa.decision +
                                   " exec LA(1)==" + this.getLookaheadName(input) +
                                   ", outerContext=" + outerContext.toString(this.parser.ruleNames));
            }

            var fullCtx = false;
            var s0_closure = this.computeStartState(dfa.atnStartState, RuleContext.EMPTY, fullCtx);

            if( dfa.precedenceDfa) {
                // If this is a precedence DFA, we use applyPrecedenceFilter
                // to convert the computed start state to a precedence start
                // state. We then use DFA.setPrecedenceStartState to set the
                // appropriate start state for the precedence level rather
                // than simply setting DFA.s0.
                //
                dfa.s0.configs = s0_closure; // not used for prediction but useful to know start configs anyway
                s0_closure = this.applyPrecedenceFilter(s0_closure);
                s0 = this.addDFAState(dfa, new DFAState(null, s0_closure));
                dfa.setPrecedenceStartState(this.parser.getPrecedence(), s0);
            } else {
                s0 = this.addDFAState(dfa, new DFAState(null, s0_closure));
                dfa.s0 = s0;
            }
        }
        var alt = this.execATN(dfa, s0, input, index, outerContext);
        if (this.debug) {
            console.log("DFA after predictATN: " + dfa.toString(this.parser.literalNames));
        }
        return alt;
    } finally {
        this._dfa = null;
        this.mergeCache = null; // wack cache after each prediction
        input.seek(index);
        input.release(m);
    }
};
// Performs ATN simulation to compute a predicted alternative based
//  upon the remaining input, but also updates the DFA cache to avoid
//  having to traverse the ATN again for the same input sequence.

// There are some key conditions we're looking for after computing a new
// set of ATN configs (proposed DFA state):
      // if the set is empty, there is no viable alternative for current symbol
      // does the state uniquely predict an alternative?
      // does the state have a conflict that would prevent us from
      //   putting it on the work list?

// We also have some key operations to do:
      // add an edge from previous DFA state to potentially new DFA state, D,
      //   upon current symbol but only if adding to work list, which means in all
      //   cases except no viable alternative (and possibly non-greedy decisions?)
      // collecting predicates and adding semantic context to DFA accept states
      // adding rule context to context-sensitive DFA accept states
      // consuming an input symbol
      // reporting a conflict
      // reporting an ambiguity
      // reporting a context sensitivity
      // reporting insufficient predicates

// cover these cases:
//    dead end
//    single alt
//    single alt + preds
//    conflict
//    conflict + preds
//
ParserATNSimulator.prototype.execATN = function(dfa, s0, input, startIndex, outerContext ) {
    if (this.debug || this.debug_list_atn_decisions) {
        console.log("execATN decision " + dfa.decision +
                " exec LA(1)==" + this.getLookaheadName(input) +
                " line " + input.LT(1).line + ":" + input.LT(1).column);
    }
    var alt;
    var previousD = s0;

    if (this.debug) {
        console.log("s0 = " + s0);
    }
    var t = input.LA(1);
    while(true) { // while more work
        var D = this.getExistingTargetState(previousD, t);
        if(D===null) {
            D = this.computeTargetState(dfa, previousD, t);
        }
        if(D===ATNSimulator.ERROR) {
            // if any configs in previous dipped into outer context, that
            // means that input up to t actually finished entry rule
            // at least for SLL decision. Full LL doesn't dip into outer
            // so don't need special case.
            // We will get an error no matter what so delay until after
            // decision; better error message. Also, no reachable target
            // ATN states in SLL implies LL will also get nowhere.
            // If conflict in states that dip out, choose min since we
            // will get error no matter what.
            var e = this.noViableAlt(input, outerContext, previousD.configs, startIndex);
            input.seek(startIndex);
            alt = this.getSynValidOrSemInvalidAltThatFinishedDecisionEntryRule(previousD.configs, outerContext);
            if(alt!==ATN.INVALID_ALT_NUMBER) {
                return alt;
            } else {
                throw e;
            }
        }
        if(D.requiresFullContext && this.predictionMode !== PredictionMode.SLL) {
            // IF PREDS, MIGHT RESOLVE TO SINGLE ALT => SLL (or syntax error)
            var conflictingAlts = null;
            if (D.predicates!==null) {
                if (this.debug) {
                    console.log("DFA state has preds in DFA sim LL failover");
                }
                var conflictIndex = input.index;
                if(conflictIndex !== startIndex) {
                    input.seek(startIndex);
                }
                conflictingAlts = this.evalSemanticContext(D.predicates, outerContext, true);
                if (conflictingAlts.length===1) {
                    if(this.debug) {
                        console.log("Full LL avoided");
                    }
                    return conflictingAlts.minValue();
                }
                if (conflictIndex !== startIndex) {
                    // restore the index so reporting the fallback to full
                    // context occurs with the index at the correct spot
                    input.seek(conflictIndex);
                }
            }
            if (this.dfa_debug) {
                console.log("ctx sensitive state " + outerContext +" in " + D);
            }
            var fullCtx = true;
            var s0_closure = this.computeStartState(dfa.atnStartState, outerContext, fullCtx);
            this.reportAttemptingFullContext(dfa, conflictingAlts, D.configs, startIndex, input.index);
            alt = this.execATNWithFullContext(dfa, D, s0_closure, input, startIndex, outerContext);
            return alt;
        }
        if (D.isAcceptState) {
            if (D.predicates===null) {
                return D.prediction;
            }
            var stopIndex = input.index;
            input.seek(startIndex);
            var alts = this.evalSemanticContext(D.predicates, outerContext, true);
            if (alts.length===0) {
                throw this.noViableAlt(input, outerContext, D.configs, startIndex);
            } else if (alts.length===1) {
                return alts.minValue();
            } else {
                // report ambiguity after predicate evaluation to make sure the correct set of ambig alts is reported.
                this.reportAmbiguity(dfa, D, startIndex, stopIndex, false, alts, D.configs);
                return alts.minValue();
            }
        }
        previousD = D;

        if (t !== Token.EOF) {
            input.consume();
            t = input.LA(1);
        }
    }
};
//
// Get an existing target state for an edge in the DFA. If the target state
// for the edge has not yet been computed or is otherwise not available,
// this method returns {@code null}.
//
// @param previousD The current DFA state
// @param t The next input symbol
// @return The existing target DFA state for the given input symbol
// {@code t}, or {@code null} if the target state for this edge is not
// already cached
//
ParserATNSimulator.prototype.getExistingTargetState = function(previousD, t) {
    var edges = previousD.edges;
    if (edges===null) {
        return null;
    } else {
        return edges[t + 1] || null;
    }
};
//
// Compute a target state for an edge in the DFA, and attempt to add the
// computed state and corresponding edge to the DFA.
//
// @param dfa The DFA
// @param previousD The current DFA state
// @param t The next input symbol
//
// @return The computed target DFA state for the given input symbol
// {@code t}. If {@code t} does not lead to a valid DFA state, this method
// returns {@link //ERROR}.
//
ParserATNSimulator.prototype.computeTargetState = function(dfa, previousD, t) {
   var reach = this.computeReachSet(previousD.configs, t, false);
    if(reach===null) {
        this.addDFAEdge(dfa, previousD, t, ATNSimulator.ERROR);
        return ATNSimulator.ERROR;
    }
    // create new target state; we'll add to DFA after it's complete
    var D = new DFAState(null, reach);

    var predictedAlt = this.getUniqueAlt(reach);

    if (this.debug) {
        var altSubSets = PredictionMode.getConflictingAltSubsets(reach);
        console.log("SLL altSubSets=" + Utils.arrayToString(altSubSets) +
                    ", previous=" + previousD.configs +
                    ", configs=" + reach +
                    ", predict=" + predictedAlt +
                    ", allSubsetsConflict=" +
                    PredictionMode.allSubsetsConflict(altSubSets) + ", conflictingAlts=" +
                    this.getConflictingAlts(reach));
    }
    if (predictedAlt!==ATN.INVALID_ALT_NUMBER) {
        // NO CONFLICT, UNIQUELY PREDICTED ALT
        D.isAcceptState = true;
        D.configs.uniqueAlt = predictedAlt;
        D.prediction = predictedAlt;
    } else if (PredictionMode.hasSLLConflictTerminatingPrediction(this.predictionMode, reach)) {
        // MORE THAN ONE VIABLE ALTERNATIVE
        D.configs.conflictingAlts = this.getConflictingAlts(reach);
        D.requiresFullContext = true;
        // in SLL-only mode, we will stop at this state and return the minimum alt
        D.isAcceptState = true;
        D.prediction = D.configs.conflictingAlts.minValue();
    }
    if (D.isAcceptState && D.configs.hasSemanticContext) {
        this.predicateDFAState(D, this.atn.getDecisionState(dfa.decision));
        if( D.predicates!==null) {
            D.prediction = ATN.INVALID_ALT_NUMBER;
        }
    }
    // all adds to dfa are done after we've created full D state
    D = this.addDFAEdge(dfa, previousD, t, D);
    return D;
};

ParserATNSimulator.prototype.predicateDFAState = function(dfaState, decisionState) {
    // We need to test all predicates, even in DFA states that
    // uniquely predict alternative.
    var nalts = decisionState.transitions.length;
    // Update DFA so reach becomes accept state with (predicate,alt)
    // pairs if preds found for conflicting alts
    var altsToCollectPredsFrom = this.getConflictingAltsOrUniqueAlt(dfaState.configs);
    var altToPred = this.getPredsForAmbigAlts(altsToCollectPredsFrom, dfaState.configs, nalts);
    if (altToPred!==null) {
        dfaState.predicates = this.getPredicatePredictions(altsToCollectPredsFrom, altToPred);
        dfaState.prediction = ATN.INVALID_ALT_NUMBER; // make sure we use preds
    } else {
        // There are preds in configs but they might go away
        // when OR'd together like {p}? || NONE == NONE. If neither
        // alt has preds, resolve to min alt
        dfaState.prediction = altsToCollectPredsFrom.minValue();
    }
};

// comes back with reach.uniqueAlt set to a valid alt
ParserATNSimulator.prototype.execATNWithFullContext = function(dfa, D, // how far we got before failing over
                                     s0,
                                     input,
                                     startIndex,
                                     outerContext) {
    if (this.debug || this.debug_list_atn_decisions) {
        console.log("execATNWithFullContext "+s0);
    }
    var fullCtx = true;
    var foundExactAmbig = false;
    var reach = null;
    var previous = s0;
    input.seek(startIndex);
    var t = input.LA(1);
    var predictedAlt = -1;
    while (true) { // while more work
        reach = this.computeReachSet(previous, t, fullCtx);
        if (reach===null) {
            // if any configs in previous dipped into outer context, that
            // means that input up to t actually finished entry rule
            // at least for LL decision. Full LL doesn't dip into outer
            // so don't need special case.
            // We will get an error no matter what so delay until after
            // decision; better error message. Also, no reachable target
            // ATN states in SLL implies LL will also get nowhere.
            // If conflict in states that dip out, choose min since we
            // will get error no matter what.
            var e = this.noViableAlt(input, outerContext, previous, startIndex);
            input.seek(startIndex);
            var alt = this.getSynValidOrSemInvalidAltThatFinishedDecisionEntryRule(previous, outerContext);
            if(alt!==ATN.INVALID_ALT_NUMBER) {
                return alt;
            } else {
                throw e;
            }
        }
        var altSubSets = PredictionMode.getConflictingAltSubsets(reach);
        if(this.debug) {
            console.log("LL altSubSets=" + altSubSets + ", predict=" +
                  PredictionMode.getUniqueAlt(altSubSets) + ", resolvesToJustOneViableAlt=" +
                  PredictionMode.resolvesToJustOneViableAlt(altSubSets));
        }
        reach.uniqueAlt = this.getUniqueAlt(reach);
        // unique prediction?
        if(reach.uniqueAlt!==ATN.INVALID_ALT_NUMBER) {
            predictedAlt = reach.uniqueAlt;
            break;
        } else if (this.predictionMode !== PredictionMode.LL_EXACT_AMBIG_DETECTION) {
            predictedAlt = PredictionMode.resolvesToJustOneViableAlt(altSubSets);
            if(predictedAlt !== ATN.INVALID_ALT_NUMBER) {
                break;
            }
        } else {
            // In exact ambiguity mode, we never try to terminate early.
            // Just keeps scarfing until we know what the conflict is
            if (PredictionMode.allSubsetsConflict(altSubSets) && PredictionMode.allSubsetsEqual(altSubSets)) {
                foundExactAmbig = true;
                predictedAlt = PredictionMode.getSingleViableAlt(altSubSets);
                break;
            }
            // else there are multiple non-conflicting subsets or
            // we're not sure what the ambiguity is yet.
            // So, keep going.
        }
        previous = reach;
        if( t !== Token.EOF) {
            input.consume();
            t = input.LA(1);
        }
    }
    // If the configuration set uniquely predicts an alternative,
    // without conflict, then we know that it's a full LL decision
    // not SLL.
    if (reach.uniqueAlt !== ATN.INVALID_ALT_NUMBER ) {
        this.reportContextSensitivity(dfa, predictedAlt, reach, startIndex, input.index);
        return predictedAlt;
    }
    // We do not check predicates here because we have checked them
    // on-the-fly when doing full context prediction.

    //
    // In non-exact ambiguity detection mode, we might	actually be able to
    // detect an exact ambiguity, but I'm not going to spend the cycles
    // needed to check. We only emit ambiguity warnings in exact ambiguity
    // mode.
    //
    // For example, we might know that we have conflicting configurations.
    // But, that does not mean that there is no way forward without a
    // conflict. It's possible to have nonconflicting alt subsets as in:

    // altSubSets=[{1, 2}, {1, 2}, {1}, {1, 2}]

    // from
    //
    //    [(17,1,[5 $]), (13,1,[5 10 $]), (21,1,[5 10 $]), (11,1,[$]),
    //     (13,2,[5 10 $]), (21,2,[5 10 $]), (11,2,[$])]
    //
    // In this case, (17,1,[5 $]) indicates there is some next sequence that
    // would resolve this without conflict to alternative 1. Any other viable
    // next sequence, however, is associated with a conflict.  We stop
    // looking for input because no amount of further lookahead will alter
    // the fact that we should predict alternative 1.  We just can't say for
    // sure that there is an ambiguity without looking further.

    this.reportAmbiguity(dfa, D, startIndex, input.index, foundExactAmbig, null, reach);

    return predictedAlt;
};

ParserATNSimulator.prototype.computeReachSet = function(closure, t, fullCtx) {
    if (this.debug) {
        console.log("in computeReachSet, starting closure: " + closure);
    }
    if( this.mergeCache===null) {
        this.mergeCache = new DoubleDict();
    }
    var intermediate = new ATNConfigSet(fullCtx);

    // Configurations already in a rule stop state indicate reaching the end
    // of the decision rule (local context) or end of the start rule (full
    // context). Once reached, these configurations are never updated by a
    // closure operation, so they are handled separately for the performance
    // advantage of having a smaller intermediate set when calling closure.
    //
    // For full-context reach operations, separate handling is required to
    // ensure that the alternative matching the longest overall sequence is
    // chosen when multiple such configurations can match the input.

    var skippedStopStates = null;

    // First figure out where we can reach on input t
    for (var i=0; i<closure.items.length;i++) {
        var c = closure.items[i];
        if(this.debug_add) {
            console.log("testing " + this.getTokenName(t) + " at " + c);
        }
        if (c.state instanceof RuleStopState) {
            if (fullCtx || t === Token.EOF) {
                if (skippedStopStates===null) {
                    skippedStopStates = [];
                }
                skippedStopStates.push(c);
                if(this.debug_add) {
                    console.log("added " + c + " to skippedStopStates");
                }
            }
            continue;
        }
        for(var j=0;j<c.state.transitions.length;j++) {
            var trans = c.state.transitions[j];
            var target = this.getReachableTarget(trans, t);
            if (target!==null) {
                var cfg = new ATNConfig({state:target}, c);
                intermediate.add(cfg, this.mergeCache);
                if(this.debug_add) {
                    console.log("added " + cfg + " to intermediate");
                }
            }
        }
    }
    // Now figure out where the reach operation can take us...
    var reach = null;

    // This block optimizes the reach operation for intermediate sets which
    // trivially indicate a termination state for the overall
    // adaptivePredict operation.
    //
    // The conditions assume that intermediate
    // contains all configurations relevant to the reach set, but this
    // condition is not true when one or more configurations have been
    // withheld in skippedStopStates, or when the current symbol is EOF.
    //
    if (skippedStopStates===null && t!==Token.EOF) {
        if (intermediate.items.length===1) {
            // Don't pursue the closure if there is just one state.
            // It can only have one alternative; just add to result
            // Also don't pursue the closure if there is unique alternative
            // among the configurations.
            reach = intermediate;
        } else if (this.getUniqueAlt(intermediate)!==ATN.INVALID_ALT_NUMBER) {
            // Also don't pursue the closure if there is unique alternative
            // among the configurations.
            reach = intermediate;
        }
    }
    // If the reach set could not be trivially determined, perform a closure
    // operation on the intermediate set to compute its initial value.
    //
    if (reach===null) {
        reach = new ATNConfigSet(fullCtx);
        var closureBusy = new Set();
        var treatEofAsEpsilon = t === Token.EOF;
        for (var k=0; k<intermediate.items.length;k++) {
            this.closure(intermediate.items[k], reach, closureBusy, false, fullCtx, treatEofAsEpsilon);
        }
    }
    if (t === Token.EOF) {
        // After consuming EOF no additional input is possible, so we are
        // only interested in configurations which reached the end of the
        // decision rule (local context) or end of the start rule (full
        // context). Update reach to contain only these configurations. This
        // handles both explicit EOF transitions in the grammar and implicit
        // EOF transitions following the end of the decision or start rule.
        //
        // When reach==intermediate, no closure operation was performed. In
        // this case, removeAllConfigsNotInRuleStopState needs to check for
        // reachable rule stop states as well as configurations already in
        // a rule stop state.
        //
        // This is handled before the configurations in skippedStopStates,
        // because any configurations potentially added from that list are
        // already guaranteed to meet this condition whether or not it's
        // required.
        //
        reach = this.removeAllConfigsNotInRuleStopState(reach, reach === intermediate);
    }
    // If skippedStopStates!==null, then it contains at least one
    // configuration. For full-context reach operations, these
    // configurations reached the end of the start rule, in which case we
    // only add them back to reach if no configuration during the current
    // closure operation reached such a state. This ensures adaptivePredict
    // chooses an alternative matching the longest overall sequence when
    // multiple alternatives are viable.
    //
    if (skippedStopStates!==null && ( (! fullCtx) || (! PredictionMode.hasConfigInRuleStopState(reach)))) {
        for (var l=0; l<skippedStopStates.length;l++) {
            reach.add(skippedStopStates[l], this.mergeCache);
        }
    }
    if (reach.items.length===0) {
        return null;
    } else {
        return reach;
    }
};
//
// Return a configuration set containing only the configurations from
// {@code configs} which are in a {@link RuleStopState}. If all
// configurations in {@code configs} are already in a rule stop state, this
// method simply returns {@code configs}.
//
// <p>When {@code lookToEndOfRule} is true, this method uses
// {@link ATN//nextTokens} for each configuration in {@code configs} which is
// not already in a rule stop state to see if a rule stop state is reachable
// from the configuration via epsilon-only transitions.</p>
//
// @param configs the configuration set to update
// @param lookToEndOfRule when true, this method checks for rule stop states
// reachable by epsilon-only transitions from each configuration in
// {@code configs}.
//
// @return {@code configs} if all configurations in {@code configs} are in a
// rule stop state, otherwise return a new configuration set containing only
// the configurations from {@code configs} which are in a rule stop state
//
ParserATNSimulator.prototype.removeAllConfigsNotInRuleStopState = function(configs, lookToEndOfRule) {
    if (PredictionMode.allConfigsInRuleStopStates(configs)) {
        return configs;
    }
    var result = new ATNConfigSet(configs.fullCtx);
    for(var i=0; i<configs.items.length;i++) {
        var config = configs.items[i];
        if (config.state instanceof RuleStopState) {
            result.add(config, this.mergeCache);
            continue;
        }
        if (lookToEndOfRule && config.state.epsilonOnlyTransitions) {
            var nextTokens = this.atn.nextTokens(config.state);
            if (nextTokens.contains(Token.EPSILON)) {
                var endOfRuleState = this.atn.ruleToStopState[config.state.ruleIndex];
                result.add(new ATNConfig({state:endOfRuleState}, config), this.mergeCache);
            }
        }
    }
    return result;
};

ParserATNSimulator.prototype.computeStartState = function(p, ctx, fullCtx) {
    // always at least the implicit call to start rule
    var initialContext = predictionContextFromRuleContext(this.atn, ctx);
    var configs = new ATNConfigSet(fullCtx);
    for(var i=0;i<p.transitions.length;i++) {
        var target = p.transitions[i].target;
        var c = new ATNConfig({ state:target, alt:i+1, context:initialContext }, null);
        var closureBusy = new Set();
        this.closure(c, configs, closureBusy, true, fullCtx, false);
    }
    return configs;
};

//
// This method transforms the start state computed by
// {@link //computeStartState} to the special start state used by a
// precedence DFA for a particular precedence value. The transformation
// process applies the following changes to the start state's configuration
// set.
//
// <ol>
// <li>Evaluate the precedence predicates for each configuration using
// {@link SemanticContext//evalPrecedence}.</li>
// <li>Remove all configurations which predict an alternative greater than
// 1, for which another configuration that predicts alternative 1 is in the
// same ATN state with the same prediction context. This transformation is
// valid for the following reasons:
// <ul>
// <li>The closure block cannot contain any epsilon transitions which bypass
// the body of the closure, so all states reachable via alternative 1 are
// part of the precedence alternatives of the transformed left-recursive
// rule.</li>
// <li>The "primary" portion of a left recursive rule cannot contain an
// epsilon transition, so the only way an alternative other than 1 can exist
// in a state that is also reachable via alternative 1 is by nesting calls
// to the left-recursive rule, with the outer calls not being at the
// preferred precedence level.</li>
// </ul>
// </li>
// </ol>
//
// <p>
// The prediction context must be considered by this filter to address
// situations like the following.
// </p>
// <code>
// <pre>
// grammar TA;
// prog: statement* EOF;
// statement: letterA | statement letterA 'b' ;
// letterA: 'a';
// </pre>
// </code>
// <p>
// If the above grammar, the ATN state immediately before the token
// reference {@code 'a'} in {@code letterA} is reachable from the left edge
// of both the primary and closure blocks of the left-recursive rule
// {@code statement}. The prediction context associated with each of these
// configurations distinguishes between them, and prevents the alternative
// which stepped out to {@code prog} (and then back in to {@code statement}
// from being eliminated by the filter.
// </p>
//
// @param configs The configuration set computed by
// {@link //computeStartState} as the start state for the DFA.
// @return The transformed configuration set representing the start state
// for a precedence DFA at a particular precedence level (determined by
// calling {@link Parser//getPrecedence}).
//
ParserATNSimulator.prototype.applyPrecedenceFilter = function(configs) {
	var config;
	var statesFromAlt1 = [];
    var configSet = new ATNConfigSet(configs.fullCtx);
    for(var i=0; i<configs.items.length; i++) {
        config = configs.items[i];
        // handle alt 1 first
        if (config.alt !== 1) {
            continue;
        }
        var updatedContext = config.semanticContext.evalPrecedence(this.parser, this._outerContext);
        if (updatedContext===null) {
            // the configuration was eliminated
            continue;
        }
        statesFromAlt1[config.state.stateNumber] = config.context;
        if (updatedContext !== config.semanticContext) {
            configSet.add(new ATNConfig({semanticContext:updatedContext}, config), this.mergeCache);
        } else {
            configSet.add(config, this.mergeCache);
        }
    }
    for(i=0; i<configs.items.length; i++) {
        config = configs.items[i];
        if (config.alt === 1) {
            // already handled
            continue;
        }
        // In the future, this elimination step could be updated to also
        // filter the prediction context for alternatives predicting alt>1
        // (basically a graph subtraction algorithm).
		if (!config.precedenceFilterSuppressed) {
            var context = statesFromAlt1[config.state.stateNumber] || null;
            if (context!==null && context.equals(config.context)) {
                // eliminated
                continue;
            }
		}
        configSet.add(config, this.mergeCache);
    }
    return configSet;
};

ParserATNSimulator.prototype.getReachableTarget = function(trans, ttype) {
    if (trans.matches(ttype, 0, this.atn.maxTokenType)) {
        return trans.target;
    } else {
        return null;
    }
};

ParserATNSimulator.prototype.getPredsForAmbigAlts = function(ambigAlts, configs, nalts) {
    // REACH=[1|1|[]|0:0, 1|2|[]|0:1]
    // altToPred starts as an array of all null contexts. The entry at index i
    // corresponds to alternative i. altToPred[i] may have one of three values:
    //   1. null: no ATNConfig c is found such that c.alt==i
    //   2. SemanticContext.NONE: At least one ATNConfig c exists such that
    //      c.alt==i and c.semanticContext==SemanticContext.NONE. In other words,
    //      alt i has at least one unpredicated config.
    //   3. Non-NONE Semantic Context: There exists at least one, and for all
    //      ATNConfig c such that c.alt==i, c.semanticContext!=SemanticContext.NONE.
    //
    // From this, it is clear that NONE||anything==NONE.
    //
    var altToPred = [];
    for(var i=0;i<configs.items.length;i++) {
        var c = configs.items[i];
        if(ambigAlts.contains( c.alt )) {
            altToPred[c.alt] = SemanticContext.orContext(altToPred[c.alt] || null, c.semanticContext);
        }
    }
    var nPredAlts = 0;
    for (i =1;i< nalts+1;i++) {
        var pred = altToPred[i] || null;
        if (pred===null) {
            altToPred[i] = SemanticContext.NONE;
        } else if (pred !== SemanticContext.NONE) {
            nPredAlts += 1;
        }
    }
    // nonambig alts are null in altToPred
    if (nPredAlts===0) {
        altToPred = null;
    }
    if (this.debug) {
        console.log("getPredsForAmbigAlts result " + Utils.arrayToString(altToPred));
    }
    return altToPred;
};

ParserATNSimulator.prototype.getPredicatePredictions = function(ambigAlts, altToPred) {
    var pairs = [];
    var containsPredicate = false;
    for (var i=1; i<altToPred.length;i++) {
        var pred = altToPred[i];
        // unpredicated is indicated by SemanticContext.NONE
        if( ambigAlts!==null && ambigAlts.contains( i )) {
            pairs.push(new PredPrediction(pred, i));
        }
        if (pred !== SemanticContext.NONE) {
            containsPredicate = true;
        }
    }
    if (! containsPredicate) {
        return null;
    }
    return pairs;
};

//
// This method is used to improve the localization of error messages by
// choosing an alternative rather than throwing a
// {@link NoViableAltException} in particular prediction scenarios where the
// {@link //ERROR} state was reached during ATN simulation.
//
// <p>
// The default implementation of this method uses the following
// algorithm to identify an ATN configuration which successfully parsed the
// decision entry rule. Choosing such an alternative ensures that the
// {@link ParserRuleContext} returned by the calling rule will be complete
// and valid, and the syntax error will be reported later at a more
// localized location.</p>
//
// <ul>
// <li>If a syntactically valid path or paths reach the end of the decision rule and
// they are semantically valid if predicated, return the min associated alt.</li>
// <li>Else, if a semantically invalid but syntactically valid path exist
// or paths exist, return the minimum associated alt.
// </li>
// <li>Otherwise, return {@link ATN//INVALID_ALT_NUMBER}.</li>
// </ul>
//
// <p>
// In some scenarios, the algorithm described above could predict an
// alternative which will result in a {@link FailedPredicateException} in
// the parser. Specifically, this could occur if the <em>only</em> configuration
// capable of successfully parsing to the end of the decision rule is
// blocked by a semantic predicate. By choosing this alternative within
// {@link //adaptivePredict} instead of throwing a
// {@link NoViableAltException}, the resulting
// {@link FailedPredicateException} in the parser will identify the specific
// predicate which is preventing the parser from successfully parsing the
// decision rule, which helps developers identify and correct logic errors
// in semantic predicates.
// </p>
//
// @param configs The ATN configurations which were valid immediately before
// the {@link //ERROR} state was reached
// @param outerContext The is the \gamma_0 initial parser context from the paper
// or the parser stack at the instant before prediction commences.
//
// @return The value to return from {@link //adaptivePredict}, or
// {@link ATN//INVALID_ALT_NUMBER} if a suitable alternative was not
// identified and {@link //adaptivePredict} should report an error instead.
//
ParserATNSimulator.prototype.getSynValidOrSemInvalidAltThatFinishedDecisionEntryRule = function(configs, outerContext) {
    var cfgs = this.splitAccordingToSemanticValidity(configs, outerContext);
    var semValidConfigs = cfgs[0];
    var semInvalidConfigs = cfgs[1];
    var alt = this.getAltThatFinishedDecisionEntryRule(semValidConfigs);
    if (alt!==ATN.INVALID_ALT_NUMBER) { // semantically/syntactically viable path exists
        return alt;
    }
    // Is there a syntactically valid path with a failed pred?
    if (semInvalidConfigs.items.length>0) {
        alt = this.getAltThatFinishedDecisionEntryRule(semInvalidConfigs);
        if (alt!==ATN.INVALID_ALT_NUMBER) { // syntactically viable path exists
            return alt;
        }
    }
    return ATN.INVALID_ALT_NUMBER;
};

ParserATNSimulator.prototype.getAltThatFinishedDecisionEntryRule = function(configs) {
    var alts = [];
    for(var i=0;i<configs.items.length; i++) {
        var c = configs.items[i];
        if (c.reachesIntoOuterContext>0 || ((c.state instanceof RuleStopState) && c.context.hasEmptyPath())) {
            if(alts.indexOf(c.alt)<0) {
                alts.push(c.alt);
            }
        }
    }
    if (alts.length===0) {
        return ATN.INVALID_ALT_NUMBER;
    } else {
        return Math.min.apply(null, alts);
    }
};
// Walk the list of configurations and split them according to
//  those that have preds evaluating to true/false.  If no pred, assume
//  true pred and include in succeeded set.  Returns Pair of sets.
//
//  Create a new set so as not to alter the incoming parameter.
//
//  Assumption: the input stream has been restored to the starting point
//  prediction, which is where predicates need to evaluate.
//
ParserATNSimulator.prototype.splitAccordingToSemanticValidity = function( configs, outerContext) {
    var succeeded = new ATNConfigSet(configs.fullCtx);
    var failed = new ATNConfigSet(configs.fullCtx);
    for(var i=0;i<configs.items.length; i++) {
        var c = configs.items[i];
        if (c.semanticContext !== SemanticContext.NONE) {
            var predicateEvaluationResult = c.semanticContext.evaluate(this.parser, outerContext);
            if (predicateEvaluationResult) {
                succeeded.add(c);
            } else {
                failed.add(c);
            }
        } else {
            succeeded.add(c);
        }
    }
    return [succeeded, failed];
};

// Look through a list of predicate/alt pairs, returning alts for the
//  pairs that win. A {@code NONE} predicate indicates an alt containing an
//  unpredicated config which behaves as "always true." If !complete
//  then we stop at the first predicate that evaluates to true. This
//  includes pairs with null predicates.
//
ParserATNSimulator.prototype.evalSemanticContext = function(predPredictions, outerContext, complete) {
    var predictions = new BitSet();
    for(var i=0;i<predPredictions.length;i++) {
    	var pair = predPredictions[i];
        if (pair.pred === SemanticContext.NONE) {
            predictions.add(pair.alt);
            if (! complete) {
                break;
            }
            continue;
        }
        var predicateEvaluationResult = pair.pred.evaluate(this.parser, outerContext);
        if (this.debug || this.dfa_debug) {
            console.log("eval pred " + pair + "=" + predicateEvaluationResult);
        }
        if (predicateEvaluationResult) {
            if (this.debug || this.dfa_debug) {
                console.log("PREDICT " + pair.alt);
            }
            predictions.add(pair.alt);
            if (! complete) {
                break;
            }
        }
    }
    return predictions;
};

// TODO: If we are doing predicates, there is no point in pursuing
//     closure operations if we reach a DFA state that uniquely predicts
//     alternative. We will not be caching that DFA state and it is a
//     waste to pursue the closure. Might have to advance when we do
//     ambig detection thought :(
//

ParserATNSimulator.prototype.closure = function(config, configs, closureBusy, collectPredicates, fullCtx, treatEofAsEpsilon) {
    var initialDepth = 0;
    this.closureCheckingStopState(config, configs, closureBusy, collectPredicates,
                             fullCtx, initialDepth, treatEofAsEpsilon);
};


ParserATNSimulator.prototype.closureCheckingStopState = function(config, configs, closureBusy, collectPredicates, fullCtx, depth, treatEofAsEpsilon) {
    if (this.debug || this.debug_closure) {
        console.log("closure(" + config.toString(this.parser,true) + ")");
        // console.log("configs(" + configs.toString() + ")");
        if(config.reachesIntoOuterContext>50) {
            throw "problem";
        }
    }
    if (config.state instanceof RuleStopState) {
        // We hit rule end. If we have context info, use it
        // run thru all possible stack tops in ctx
        if (! config.context.isEmpty()) {
            for ( var i =0; i<config.context.length; i++) {
                if (config.context.getReturnState(i) === PredictionContext.EMPTY_RETURN_STATE) {
                    if (fullCtx) {
                        configs.add(new ATNConfig({state:config.state, context:PredictionContext.EMPTY}, config), this.mergeCache);
                        continue;
                    } else {
                        // we have no context info, just chase follow links (if greedy)
                        if (this.debug) {
                            console.log("FALLING off rule " + this.getRuleName(config.state.ruleIndex));
                        }
                        this.closure_(config, configs, closureBusy, collectPredicates,
                                 fullCtx, depth, treatEofAsEpsilon);
                    }
                    continue;
                }
                var returnState = this.atn.states[config.context.getReturnState(i)];
                var newContext = config.context.getParent(i); // "pop" return state
                var parms = {state:returnState, alt:config.alt, context:newContext, semanticContext:config.semanticContext};
                var c = new ATNConfig(parms, null);
                // While we have context to pop back from, we may have
                // gotten that context AFTER having falling off a rule.
                // Make sure we track that we are now out of context.
                c.reachesIntoOuterContext = config.reachesIntoOuterContext;
                this.closureCheckingStopState(c, configs, closureBusy, collectPredicates, fullCtx, depth - 1, treatEofAsEpsilon);
            }
            return;
        } else if( fullCtx) {
            // reached end of start rule
            configs.add(config, this.mergeCache);
            return;
        } else {
            // else if we have no context info, just chase follow links (if greedy)
            if (this.debug) {
                console.log("FALLING off rule " + this.getRuleName(config.state.ruleIndex));
            }
        }
    }
    this.closure_(config, configs, closureBusy, collectPredicates, fullCtx, depth, treatEofAsEpsilon);
};


// Do the actual work of walking epsilon edges//
ParserATNSimulator.prototype.closure_ = function(config, configs, closureBusy, collectPredicates, fullCtx, depth, treatEofAsEpsilon) {
    var p = config.state;
    // optimization
    if (! p.epsilonOnlyTransitions) {
        configs.add(config, this.mergeCache);
        // make sure to not return here, because EOF transitions can act as
        // both epsilon transitions and non-epsilon transitions.
    }
    for(var i = 0;i<p.transitions.length; i++) {
        if(i==0 && this.canDropLoopEntryEdgeInLeftRecursiveRule(config))
            continue;

        var t = p.transitions[i];
        var continueCollecting = collectPredicates && !(t instanceof ActionTransition);
        var c = this.getEpsilonTarget(config, t, continueCollecting, depth === 0, fullCtx, treatEofAsEpsilon);
        if (c!==null) {
            var newDepth = depth;
            if ( config.state instanceof RuleStopState) {
                // target fell off end of rule; mark resulting c as having dipped into outer context
                // We can't get here if incoming config was rule stop and we had context
                // track how far we dip into outer context.  Might
                // come in handy and we avoid evaluating context dependent
                // preds if this is > 0.
				if (this._dfa !== null && this._dfa.precedenceDfa) {
					if (t.outermostPrecedenceReturn === this._dfa.atnStartState.ruleIndex) {
						c.precedenceFilterSuppressed = true;
					}
				}

                c.reachesIntoOuterContext += 1;
                if (closureBusy.add(c)!==c) {
                    // avoid infinite recursion for right-recursive rules
                    continue;
                }
                configs.dipsIntoOuterContext = true; // TODO: can remove? only care when we add to set per middle of this method
                newDepth -= 1;
                if (this.debug) {
                    console.log("dips into outer ctx: " + c);
                }
            } else {
                if (!t.isEpsilon && closureBusy.add(c)!==c){
                    // avoid infinite recursion for EOF* and EOF+
                    continue;
                }
                if (t instanceof RuleTransition) {
                    // latch when newDepth goes negative - once we step out of the entry context we can't return
                    if (newDepth >= 0) {
                        newDepth += 1;
                    }
                }
            }
            this.closureCheckingStopState(c, configs, closureBusy, continueCollecting, fullCtx, newDepth, treatEofAsEpsilon);
        }
    }
};


ParserATNSimulator.prototype.canDropLoopEntryEdgeInLeftRecursiveRule = function(config) {
    // return False
    var p = config.state;
    // First check to see if we are in StarLoopEntryState generated during
    // left-recursion elimination. For efficiency, also check if
    // the context has an empty stack case. If so, it would mean
    // global FOLLOW so we can't perform optimization
    // Are we the special loop entry/exit state? or SLL wildcard
    if(p.stateType != ATNState.STAR_LOOP_ENTRY)
        return false;
    if(p.stateType != ATNState.STAR_LOOP_ENTRY || !p.isPrecedenceDecision ||
           config.context.isEmpty() || config.context.hasEmptyPath())
        return false;

    // Require all return states to return back to the same rule that p is in.
    var numCtxs = config.context.length;
    for(var i=0; i<numCtxs; i++) { // for each stack context
        var returnState = this.atn.states[config.context.getReturnState(i)];
        if (returnState.ruleIndex != p.ruleIndex)
            return false;
    }

    var decisionStartState = p.transitions[0].target;
    var blockEndStateNum = decisionStartState.endState.stateNumber;
    var blockEndState = this.atn.states[blockEndStateNum];

    // Verify that the top of each stack context leads to loop entry/exit
    // state through epsilon edges and w/o leaving rule.
    for(var i=0; i<numCtxs; i++) { // for each stack context
        var returnStateNumber = config.context.getReturnState(i);
        var returnState = this.atn.states[returnStateNumber];
        // all states must have single outgoing epsilon edge
        if (returnState.transitions.length != 1 || !returnState.transitions[0].isEpsilon)
            return false;

        // Look for prefix op case like 'not expr', (' type ')' expr
        var returnStateTarget = returnState.transitions[0].target;
        if ( returnState.stateType == ATNState.BLOCK_END && returnStateTarget == p )
            continue;

        // Look for 'expr op expr' or case where expr's return state is block end
        // of (...)* internal block; the block end points to loop back
        // which points to p but we don't need to check that
        if ( returnState == blockEndState )
            continue;

        // Look for ternary expr ? expr : expr. The return state points at block end,
        // which points at loop entry state
        if ( returnStateTarget == blockEndState )
            continue;

        // Look for complex prefix 'between expr and expr' case where 2nd expr's
        // return state points at block end state of (...)* internal block
        if (returnStateTarget.stateType == ATNState.BLOCK_END && returnStateTarget.transitions.length == 1
                && returnStateTarget.transitions[0].isEpsilon && returnStateTarget.transitions[0].target == p)
            continue;

        // anything else ain't conforming
        return false;
    }
    return true;
};


ParserATNSimulator.prototype.getRuleName = function( index) {
    if (this.parser!==null && index>=0) {
        return this.parser.ruleNames[index];
    } else {
        return "<rule " + index + ">";
    }
};

ParserATNSimulator.prototype.getEpsilonTarget = function(config, t, collectPredicates, inContext, fullCtx, treatEofAsEpsilon) {
    switch(t.serializationType) {
    case Transition.RULE:
        return this.ruleTransition(config, t);
    case Transition.PRECEDENCE:
        return this.precedenceTransition(config, t, collectPredicates, inContext, fullCtx);
    case Transition.PREDICATE:
        return this.predTransition(config, t, collectPredicates, inContext, fullCtx);
    case Transition.ACTION:
        return this.actionTransition(config, t);
    case Transition.EPSILON:
        return new ATNConfig({state:t.target}, config);
    case Transition.ATOM:
    case Transition.RANGE:
    case Transition.SET:
        // EOF transitions act like epsilon transitions after the first EOF
        // transition is traversed
        if (treatEofAsEpsilon) {
            if (t.matches(Token.EOF, 0, 1)) {
                return new ATNConfig({state: t.target}, config);
            }
        }
        return null;
    default:
    	return null;
    }
};

ParserATNSimulator.prototype.actionTransition = function(config, t) {
    if (this.debug) {
        var index = t.actionIndex==-1 ? 65535 : t.actionIndex;
        console.log("ACTION edge " + t.ruleIndex + ":" + index);
    }
    return new ATNConfig({state:t.target}, config);
};

ParserATNSimulator.prototype.precedenceTransition = function(config, pt,  collectPredicates, inContext, fullCtx) {
    if (this.debug) {
        console.log("PRED (collectPredicates=" + collectPredicates + ") " +
                pt.precedence + ">=_p, ctx dependent=true");
        if (this.parser!==null) {
        	console.log("context surrounding pred is " + Utils.arrayToString(this.parser.getRuleInvocationStack()));
        }
    }
    var c = null;
    if (collectPredicates && inContext) {
        if (fullCtx) {
            // In full context mode, we can evaluate predicates on-the-fly
            // during closure, which dramatically reduces the size of
            // the config sets. It also obviates the need to test predicates
            // later during conflict resolution.
            var currentPosition = this._input.index;
            this._input.seek(this._startIndex);
            var predSucceeds = pt.getPredicate().evaluate(this.parser, this._outerContext);
            this._input.seek(currentPosition);
            if (predSucceeds) {
                c = new ATNConfig({state:pt.target}, config); // no pred context
            }
        } else {
            var newSemCtx = SemanticContext.andContext(config.semanticContext, pt.getPredicate());
            c = new ATNConfig({state:pt.target, semanticContext:newSemCtx}, config);
        }
    } else {
        c = new ATNConfig({state:pt.target}, config);
    }
    if (this.debug) {
        console.log("config from pred transition=" + c);
    }
    return c;
};

ParserATNSimulator.prototype.predTransition = function(config, pt, collectPredicates, inContext, fullCtx) {
    if (this.debug) {
        console.log("PRED (collectPredicates=" + collectPredicates + ") " + pt.ruleIndex +
                ":" + pt.predIndex + ", ctx dependent=" + pt.isCtxDependent);
        if (this.parser!==null) {
            console.log("context surrounding pred is " + Utils.arrayToString(this.parser.getRuleInvocationStack()));
        }
    }
    var c = null;
    if (collectPredicates && ((pt.isCtxDependent && inContext) || ! pt.isCtxDependent)) {
        if (fullCtx) {
            // In full context mode, we can evaluate predicates on-the-fly
            // during closure, which dramatically reduces the size of
            // the config sets. It also obviates the need to test predicates
            // later during conflict resolution.
            var currentPosition = this._input.index;
            this._input.seek(this._startIndex);
            var predSucceeds = pt.getPredicate().evaluate(this.parser, this._outerContext);
            this._input.seek(currentPosition);
            if (predSucceeds) {
                c = new ATNConfig({state:pt.target}, config); // no pred context
            }
        } else {
            var newSemCtx = SemanticContext.andContext(config.semanticContext, pt.getPredicate());
            c = new ATNConfig({state:pt.target, semanticContext:newSemCtx}, config);
        }
    } else {
        c = new ATNConfig({state:pt.target}, config);
    }
    if (this.debug) {
        console.log("config from pred transition=" + c);
    }
    return c;
};

ParserATNSimulator.prototype.ruleTransition = function(config, t) {
    if (this.debug) {
        console.log("CALL rule " + this.getRuleName(t.target.ruleIndex) + ", ctx=" + config.context);
    }
    var returnState = t.followState;
    var newContext = SingletonPredictionContext.create(config.context, returnState.stateNumber);
    return new ATNConfig({state:t.target, context:newContext}, config );
};

ParserATNSimulator.prototype.getConflictingAlts = function(configs) {
    var altsets = PredictionMode.getConflictingAltSubsets(configs);
    return PredictionMode.getAlts(altsets);
};

 // Sam pointed out a problem with the previous definition, v3, of
 // ambiguous states. If we have another state associated with conflicting
 // alternatives, we should keep going. For example, the following grammar
 //
 // s : (ID | ID ID?) ';' ;
 //
 // When the ATN simulation reaches the state before ';', it has a DFA
 // state that looks like: [12|1|[], 6|2|[], 12|2|[]]. Naturally
 // 12|1|[] and 12|2|[] conflict, but we cannot stop processing this node
 // because alternative to has another way to continue, via [6|2|[]].
 // The key is that we have a single state that has config's only associated
 // with a single alternative, 2, and crucially the state transitions
 // among the configurations are all non-epsilon transitions. That means
 // we don't consider any conflicts that include alternative 2. So, we
 // ignore the conflict between alts 1 and 2. We ignore a set of
 // conflicting alts when there is an intersection with an alternative
 // associated with a single alt state in the state&rarr;config-list map.
 //
 // It's also the case that we might have two conflicting configurations but
 // also a 3rd nonconflicting configuration for a different alternative:
 // [1|1|[], 1|2|[], 8|3|[]]. This can come about from grammar:
 //
 // a : A | A | A B ;
 //
 // After matching input A, we reach the stop state for rule A, state 1.
 // State 8 is the state right before B. Clearly alternatives 1 and 2
 // conflict and no amount of further lookahead will separate the two.
 // However, alternative 3 will be able to continue and so we do not
 // stop working on this state. In the previous example, we're concerned
 // with states associated with the conflicting alternatives. Here alt
 // 3 is not associated with the conflicting configs, but since we can continue
 // looking for input reasonably, I don't declare the state done. We
 // ignore a set of conflicting alts when we have an alternative
 // that we still need to pursue.
//

ParserATNSimulator.prototype.getConflictingAltsOrUniqueAlt = function(configs) {
    var conflictingAlts = null;
    if (configs.uniqueAlt!== ATN.INVALID_ALT_NUMBER) {
        conflictingAlts = new BitSet();
        conflictingAlts.add(configs.uniqueAlt);
    } else {
        conflictingAlts = configs.conflictingAlts;
    }
    return conflictingAlts;
};

ParserATNSimulator.prototype.getTokenName = function( t) {
    if (t===Token.EOF) {
        return "EOF";
    }
    if( this.parser!==null && this.parser.literalNames!==null) {
        if (t >= this.parser.literalNames.length && t >= this.parser.symbolicNames.length) {
            console.log("" + t + " ttype out of range: " + this.parser.literalNames);
            console.log("" + this.parser.getInputStream().getTokens());
        } else {
            var name = this.parser.literalNames[t] || this.parser.symbolicNames[t];
            return name + "<" + t + ">";
        }
    }
    return "" + t;
};

ParserATNSimulator.prototype.getLookaheadName = function(input) {
    return this.getTokenName(input.LA(1));
};

// Used for debugging in adaptivePredict around execATN but I cut
//  it out for clarity now that alg. works well. We can leave this
//  "dead" code for a bit.
//
ParserATNSimulator.prototype.dumpDeadEndConfigs = function(nvae) {
    console.log("dead end configs: ");
    var decs = nvae.getDeadEndConfigs();
    for(var i=0; i<decs.length; i++) {
    	var c = decs[i];
        var trans = "no edges";
        if (c.state.transitions.length>0) {
            var t = c.state.transitions[0];
            if (t instanceof AtomTransition) {
                trans = "Atom "+ this.getTokenName(t.label);
            } else if (t instanceof SetTransition) {
                var neg = (t instanceof NotSetTransition);
                trans = (neg ? "~" : "") + "Set " + t.set;
            }
        }
        console.error(c.toString(this.parser, true) + ":" + trans);
    }
};

ParserATNSimulator.prototype.noViableAlt = function(input, outerContext, configs, startIndex) {
    return new NoViableAltException(this.parser, input, input.get(startIndex), input.LT(1), configs, outerContext);
};

ParserATNSimulator.prototype.getUniqueAlt = function(configs) {
    var alt = ATN.INVALID_ALT_NUMBER;
    for(var i=0;i<configs.items.length;i++) {
    	var c = configs.items[i];
        if (alt === ATN.INVALID_ALT_NUMBER) {
            alt = c.alt // found first alt
        } else if( c.alt!==alt) {
            return ATN.INVALID_ALT_NUMBER;
        }
    }
    return alt;
};

//
// Add an edge to the DFA, if possible. This method calls
// {@link //addDFAState} to ensure the {@code to} state is present in the
// DFA. If {@code from} is {@code null}, or if {@code t} is outside the
// range of edges that can be represented in the DFA tables, this method
// returns without adding the edge to the DFA.
//
// <p>If {@code to} is {@code null}, this method returns {@code null}.
// Otherwise, this method returns the {@link DFAState} returned by calling
// {@link //addDFAState} for the {@code to} state.</p>
//
// @param dfa The DFA
// @param from The source state for the edge
// @param t The input symbol
// @param to The target state for the edge
//
// @return If {@code to} is {@code null}, this method returns {@code null};
// otherwise this method returns the result of calling {@link //addDFAState}
// on {@code to}
//
ParserATNSimulator.prototype.addDFAEdge = function(dfa, from_, t, to) {
    if( this.debug) {
        console.log("EDGE " + from_ + " -> " + to + " upon " + this.getTokenName(t));
    }
    if (to===null) {
        return null;
    }
    to = this.addDFAState(dfa, to); // used existing if possible not incoming
    if (from_===null || t < -1 || t > this.atn.maxTokenType) {
        return to;
    }
    if (from_.edges===null) {
        from_.edges = [];
    }
    from_.edges[t+1] = to; // connect

    if (this.debug) {
        var literalNames = this.parser===null ? null : this.parser.literalNames;
        var symbolicNames = this.parser===null ? null : this.parser.symbolicNames;
        console.log("DFA=\n" + dfa.toString(literalNames, symbolicNames));
    }
    return to;
};
//
// Add state {@code D} to the DFA if it is not already present, and return
// the actual instance stored in the DFA. If a state equivalent to {@code D}
// is already in the DFA, the existing state is returned. Otherwise this
// method returns {@code D} after adding it to the DFA.
//
// <p>If {@code D} is {@link //ERROR}, this method returns {@link //ERROR} and
// does not change the DFA.</p>
//
// @param dfa The dfa
// @param D The DFA state to add
// @return The state stored in the DFA. This will be either the existing
// state if {@code D} is already in the DFA, or {@code D} itself if the
// state was not already present.
//
ParserATNSimulator.prototype.addDFAState = function(dfa, D) {
    if (D == ATNSimulator.ERROR) {
        return D;
    }
    var existing = dfa.states.get(D);
    if(existing!==null) {
        return existing;
    }
    D.stateNumber = dfa.states.length;
    if (! D.configs.readOnly) {
        D.configs.optimizeConfigs(this);
        D.configs.setReadonly(true);
    }
    dfa.states.add(D);
    if (this.debug) {
        console.log("adding new DFA state: " + D);
    }
    return D;
};

ParserATNSimulator.prototype.reportAttemptingFullContext = function(dfa, conflictingAlts, configs, startIndex, stopIndex) {
    if (this.debug || this.retry_debug) {
        var interval = new Interval(startIndex, stopIndex + 1);
        console.log("reportAttemptingFullContext decision=" + dfa.decision + ":" + configs +
                           ", input=" + this.parser.getTokenStream().getText(interval));
    }
    if (this.parser!==null) {
        this.parser.getErrorListenerDispatch().reportAttemptingFullContext(this.parser, dfa, startIndex, stopIndex, conflictingAlts, configs);
    }
};

ParserATNSimulator.prototype.reportContextSensitivity = function(dfa, prediction, configs, startIndex, stopIndex) {
    if (this.debug || this.retry_debug) {
        var interval = new Interval(startIndex, stopIndex + 1);
        console.log("reportContextSensitivity decision=" + dfa.decision + ":" + configs +
                           ", input=" + this.parser.getTokenStream().getText(interval));
    }
    if (this.parser!==null) {
        this.parser.getErrorListenerDispatch().reportContextSensitivity(this.parser, dfa, startIndex, stopIndex, prediction, configs);
    }
};

// If context sensitive parsing, we know it's ambiguity not conflict//
ParserATNSimulator.prototype.reportAmbiguity = function(dfa, D, startIndex, stopIndex,
                               exact, ambigAlts, configs ) {
    if (this.debug || this.retry_debug) {
        var interval = new Interval(startIndex, stopIndex + 1);
        console.log("reportAmbiguity " + ambigAlts + ":" + configs +
                           ", input=" + this.parser.getTokenStream().getText(interval));
    }
    if (this.parser!==null) {
        this.parser.getErrorListenerDispatch().reportAmbiguity(this.parser, dfa, startIndex, stopIndex, exact, ambigAlts, configs);
    }
};

exports.ParserATNSimulator = ParserATNSimulator;
},{"./../IntervalSet":49,"./../ParserRuleContext":53,"./../PredictionContext":54,"./../RuleContext":56,"./../Token":57,"./../Utils":58,"./../dfa/DFAState":77,"./../error/Errors":82,"./ATN":59,"./ATNConfig":60,"./ATNConfigSet":61,"./ATNSimulator":64,"./ATNState":65,"./PredictionMode":71,"./SemanticContext":72,"./Transition":73}],71:[function(require,module,exports){
//
/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
//
//
// This enumeration defines the prediction modes available in ANTLR 4 along with
// utility methods for analyzing configuration sets for conflicts and/or
// ambiguities.

var Set = require('./../Utils').Set;
var Map = require('./../Utils').Map;
var BitSet = require('./../Utils').BitSet;
var AltDict = require('./../Utils').AltDict;
var ATN = require('./ATN').ATN;
var RuleStopState = require('./ATNState').RuleStopState;
var ATNConfigSet = require('./ATNConfigSet').ATNConfigSet;
var ATNConfig = require('./ATNConfig').ATNConfig;
var SemanticContext = require('./SemanticContext').SemanticContext;
var Hash = require("../Utils").Hash;
var hashStuff = require('./../Utils').hashStuff;
var equalArrays = require('./../Utils').equalArrays;

function PredictionMode() {
	return this;
}

//
// The SLL(*) prediction mode. This prediction mode ignores the current
// parser context when making predictions. This is the fastest prediction
// mode, and provides correct results for many grammars. This prediction
// mode is more powerful than the prediction mode provided by ANTLR 3, but
// may result in syntax errors for grammar and input combinations which are
// not SLL.
//
// <p>
// When using this prediction mode, the parser will either return a correct
// parse tree (i.e. the same parse tree that would be returned with the
// {@link //LL} prediction mode), or it will report a syntax error. If a
// syntax error is encountered when using the {@link //SLL} prediction mode,
// it may be due to either an actual syntax error in the input or indicate
// that the particular combination of grammar and input requires the more
// powerful {@link //LL} prediction abilities to complete successfully.</p>
//
// <p>
// This prediction mode does not provide any guarantees for prediction
// behavior for syntactically-incorrect inputs.</p>
//
PredictionMode.SLL = 0;
//
// The LL(*) prediction mode. This prediction mode allows the current parser
// context to be used for resolving SLL conflicts that occur during
// prediction. This is the fastest prediction mode that guarantees correct
// parse results for all combinations of grammars with syntactically correct
// inputs.
//
// <p>
// When using this prediction mode, the parser will make correct decisions
// for all syntactically-correct grammar and input combinations. However, in
// cases where the grammar is truly ambiguous this prediction mode might not
// report a precise answer for <em>exactly which</em> alternatives are
// ambiguous.</p>
//
// <p>
// This prediction mode does not provide any guarantees for prediction
// behavior for syntactically-incorrect inputs.</p>
//
PredictionMode.LL = 1;
//
// The LL(*) prediction mode with exact ambiguity detection. In addition to
// the correctness guarantees provided by the {@link //LL} prediction mode,
// this prediction mode instructs the prediction algorithm to determine the
// complete and exact set of ambiguous alternatives for every ambiguous
// decision encountered while parsing.
//
// <p>
// This prediction mode may be used for diagnosing ambiguities during
// grammar development. Due to the performance overhead of calculating sets
// of ambiguous alternatives, this prediction mode should be avoided when
// the exact results are not necessary.</p>
//
// <p>
// This prediction mode does not provide any guarantees for prediction
// behavior for syntactically-incorrect inputs.</p>
//
PredictionMode.LL_EXACT_AMBIG_DETECTION = 2;


//
// Computes the SLL prediction termination condition.
//
// <p>
// This method computes the SLL prediction termination condition for both of
// the following cases.</p>
//
// <ul>
// <li>The usual SLL+LL fallback upon SLL conflict</li>
// <li>Pure SLL without LL fallback</li>
// </ul>
//
// <p><strong>COMBINED SLL+LL PARSING</strong></p>
//
// <p>When LL-fallback is enabled upon SLL conflict, correct predictions are
// ensured regardless of how the termination condition is computed by this
// method. Due to the substantially higher cost of LL prediction, the
// prediction should only fall back to LL when the additional lookahead
// cannot lead to a unique SLL prediction.</p>
//
// <p>Assuming combined SLL+LL parsing, an SLL configuration set with only
// conflicting subsets should fall back to full LL, even if the
// configuration sets don't resolve to the same alternative (e.g.
// {@code {1,2}} and {@code {3,4}}. If there is at least one non-conflicting
// configuration, SLL could continue with the hopes that more lookahead will
// resolve via one of those non-conflicting configurations.</p>
//
// <p>Here's the prediction termination rule them: SLL (for SLL+LL parsing)
// stops when it sees only conflicting configuration subsets. In contrast,
// full LL keeps going when there is uncertainty.</p>
//
// <p><strong>HEURISTIC</strong></p>
//
// <p>As a heuristic, we stop prediction when we see any conflicting subset
// unless we see a state that only has one alternative associated with it.
// The single-alt-state thing lets prediction continue upon rules like
// (otherwise, it would admit defeat too soon):</p>
//
// <p>{@code [12|1|[], 6|2|[], 12|2|[]]. s : (ID | ID ID?) ';' ;}</p>
//
// <p>When the ATN simulation reaches the state before {@code ';'}, it has a
// DFA state that looks like: {@code [12|1|[], 6|2|[], 12|2|[]]}. Naturally
// {@code 12|1|[]} and {@code 12|2|[]} conflict, but we cannot stop
// processing this node because alternative to has another way to continue,
// via {@code [6|2|[]]}.</p>
//
// <p>It also let's us continue for this rule:</p>
//
// <p>{@code [1|1|[], 1|2|[], 8|3|[]] a : A | A | A B ;}</p>
//
// <p>After matching input A, we reach the stop state for rule A, state 1.
// State 8 is the state right before B. Clearly alternatives 1 and 2
// conflict and no amount of further lookahead will separate the two.
// However, alternative 3 will be able to continue and so we do not stop
// working on this state. In the previous example, we're concerned with
// states associated with the conflicting alternatives. Here alt 3 is not
// associated with the conflicting configs, but since we can continue
// looking for input reasonably, don't declare the state done.</p>
//
// <p><strong>PURE SLL PARSING</strong></p>
//
// <p>To handle pure SLL parsing, all we have to do is make sure that we
// combine stack contexts for configurations that differ only by semantic
// predicate. From there, we can do the usual SLL termination heuristic.</p>
//
// <p><strong>PREDICATES IN SLL+LL PARSING</strong></p>
//
// <p>SLL decisions don't evaluate predicates until after they reach DFA stop
// states because they need to create the DFA cache that works in all
// semantic situations. In contrast, full LL evaluates predicates collected
// during start state computation so it can ignore predicates thereafter.
// This means that SLL termination detection can totally ignore semantic
// predicates.</p>
//
// <p>Implementation-wise, {@link ATNConfigSet} combines stack contexts but not
// semantic predicate contexts so we might see two configurations like the
// following.</p>
//
// <p>{@code (s, 1, x, {}), (s, 1, x', {p})}</p>
//
// <p>Before testing these configurations against others, we have to merge
// {@code x} and {@code x'} (without modifying the existing configurations).
// For example, we test {@code (x+x')==x''} when looking for conflicts in
// the following configurations.</p>
//
// <p>{@code (s, 1, x, {}), (s, 1, x', {p}), (s, 2, x'', {})}</p>
//
// <p>If the configuration set has predicates (as indicated by
// {@link ATNConfigSet//hasSemanticContext}), this algorithm makes a copy of
// the configurations to strip out all of the predicates so that a standard
// {@link ATNConfigSet} will merge everything ignoring predicates.</p>
//
PredictionMode.hasSLLConflictTerminatingPrediction = function( mode, configs) {
    // Configs in rule stop states indicate reaching the end of the decision
    // rule (local context) or end of start rule (full context). If all
    // configs meet this condition, then none of the configurations is able
    // to match additional input so we terminate prediction.
    //
    if (PredictionMode.allConfigsInRuleStopStates(configs)) {
        return true;
    }
    // pure SLL mode parsing
    if (mode === PredictionMode.SLL) {
        // Don't bother with combining configs from different semantic
        // contexts if we can fail over to full LL; costs more time
        // since we'll often fail over anyway.
        if (configs.hasSemanticContext) {
            // dup configs, tossing out semantic predicates
            var dup = new ATNConfigSet();
            for(var i=0;i<configs.items.length;i++) {
            	var c = configs.items[i];
                c = new ATNConfig({semanticContext:SemanticContext.NONE}, c);
                dup.add(c);
            }
            configs = dup;
        }
        // now we have combined contexts for configs with dissimilar preds
    }
    // pure SLL or combined SLL+LL mode parsing
    var altsets = PredictionMode.getConflictingAltSubsets(configs);
    return PredictionMode.hasConflictingAltSet(altsets) && !PredictionMode.hasStateAssociatedWithOneAlt(configs);
};

// Checks if any configuration in {@code configs} is in a
// {@link RuleStopState}. Configurations meeting this condition have reached
// the end of the decision rule (local context) or end of start rule (full
// context).
//
// @param configs the configuration set to test
// @return {@code true} if any configuration in {@code configs} is in a
// {@link RuleStopState}, otherwise {@code false}
PredictionMode.hasConfigInRuleStopState = function(configs) {
	for(var i=0;i<configs.items.length;i++) {
		var c = configs.items[i];
        if (c.state instanceof RuleStopState) {
            return true;
        }
	}
    return false;
};

// Checks if all configurations in {@code configs} are in a
// {@link RuleStopState}. Configurations meeting this condition have reached
// the end of the decision rule (local context) or end of start rule (full
// context).
//
// @param configs the configuration set to test
// @return {@code true} if all configurations in {@code configs} are in a
// {@link RuleStopState}, otherwise {@code false}
PredictionMode.allConfigsInRuleStopStates = function(configs) {
	for(var i=0;i<configs.items.length;i++) {
		var c = configs.items[i];
        if (!(c.state instanceof RuleStopState)) {
            return false;
        }
	}
    return true;
};

//
// Full LL prediction termination.
//
// <p>Can we stop looking ahead during ATN simulation or is there some
// uncertainty as to which alternative we will ultimately pick, after
// consuming more input? Even if there are partial conflicts, we might know
// that everything is going to resolve to the same minimum alternative. That
// means we can stop since no more lookahead will change that fact. On the
// other hand, there might be multiple conflicts that resolve to different
// minimums. That means we need more look ahead to decide which of those
// alternatives we should predict.</p>
//
// <p>The basic idea is to split the set of configurations {@code C}, into
// conflicting subsets {@code (s, _, ctx, _)} and singleton subsets with
// non-conflicting configurations. Two configurations conflict if they have
// identical {@link ATNConfig//state} and {@link ATNConfig//context} values
// but different {@link ATNConfig//alt} value, e.g. {@code (s, i, ctx, _)}
// and {@code (s, j, ctx, _)} for {@code i!=j}.</p>
//
// <p>Reduce these configuration subsets to the set of possible alternatives.
// You can compute the alternative subsets in one pass as follows:</p>
//
// <p>{@code A_s,ctx = {i | (s, i, ctx, _)}} for each configuration in
// {@code C} holding {@code s} and {@code ctx} fixed.</p>
//
// <p>Or in pseudo-code, for each configuration {@code c} in {@code C}:</p>
//
// <pre>
// map[c] U= c.{@link ATNConfig//alt alt} // map hash/equals uses s and x, not
// alt and not pred
// </pre>
//
// <p>The values in {@code map} are the set of {@code A_s,ctx} sets.</p>
//
// <p>If {@code |A_s,ctx|=1} then there is no conflict associated with
// {@code s} and {@code ctx}.</p>
//
// <p>Reduce the subsets to singletons by choosing a minimum of each subset. If
// the union of these alternative subsets is a singleton, then no amount of
// more lookahead will help us. We will always pick that alternative. If,
// however, there is more than one alternative, then we are uncertain which
// alternative to predict and must continue looking for resolution. We may
// or may not discover an ambiguity in the future, even if there are no
// conflicting subsets this round.</p>
//
// <p>The biggest sin is to terminate early because it means we've made a
// decision but were uncertain as to the eventual outcome. We haven't used
// enough lookahead. On the other hand, announcing a conflict too late is no
// big deal; you will still have the conflict. It's just inefficient. It
// might even look until the end of file.</p>
//
// <p>No special consideration for semantic predicates is required because
// predicates are evaluated on-the-fly for full LL prediction, ensuring that
// no configuration contains a semantic context during the termination
// check.</p>
//
// <p><strong>CONFLICTING CONFIGS</strong></p>
//
// <p>Two configurations {@code (s, i, x)} and {@code (s, j, x')}, conflict
// when {@code i!=j} but {@code x=x'}. Because we merge all
// {@code (s, i, _)} configurations together, that means that there are at
// most {@code n} configurations associated with state {@code s} for
// {@code n} possible alternatives in the decision. The merged stacks
// complicate the comparison of configuration contexts {@code x} and
// {@code x'}. Sam checks to see if one is a subset of the other by calling
// merge and checking to see if the merged result is either {@code x} or
// {@code x'}. If the {@code x} associated with lowest alternative {@code i}
// is the superset, then {@code i} is the only possible prediction since the
// others resolve to {@code min(i)} as well. However, if {@code x} is
// associated with {@code j>i} then at least one stack configuration for
// {@code j} is not in conflict with alternative {@code i}. The algorithm
// should keep going, looking for more lookahead due to the uncertainty.</p>
//
// <p>For simplicity, I'm doing a equality check between {@code x} and
// {@code x'} that lets the algorithm continue to consume lookahead longer
// than necessary. The reason I like the equality is of course the
// simplicity but also because that is the test you need to detect the
// alternatives that are actually in conflict.</p>
//
// <p><strong>CONTINUE/STOP RULE</strong></p>
//
// <p>Continue if union of resolved alternative sets from non-conflicting and
// conflicting alternative subsets has more than one alternative. We are
// uncertain about which alternative to predict.</p>
//
// <p>The complete set of alternatives, {@code [i for (_,i,_)]}, tells us which
// alternatives are still in the running for the amount of input we've
// consumed at this point. The conflicting sets let us to strip away
// configurations that won't lead to more states because we resolve
// conflicts to the configuration with a minimum alternate for the
// conflicting set.</p>
//
// <p><strong>CASES</strong></p>
//
// <ul>
//
// <li>no conflicts and more than 1 alternative in set =&gt; continue</li>
//
// <li> {@code (s, 1, x)}, {@code (s, 2, x)}, {@code (s, 3, z)},
// {@code (s', 1, y)}, {@code (s', 2, y)} yields non-conflicting set
// {@code {3}} U conflicting sets {@code min({1,2})} U {@code min({1,2})} =
// {@code {1,3}} =&gt; continue
// </li>
//
// <li>{@code (s, 1, x)}, {@code (s, 2, x)}, {@code (s', 1, y)},
// {@code (s', 2, y)}, {@code (s'', 1, z)} yields non-conflicting set
// {@code {1}} U conflicting sets {@code min({1,2})} U {@code min({1,2})} =
// {@code {1}} =&gt; stop and predict 1</li>
//
// <li>{@code (s, 1, x)}, {@code (s, 2, x)}, {@code (s', 1, y)},
// {@code (s', 2, y)} yields conflicting, reduced sets {@code {1}} U
// {@code {1}} = {@code {1}} =&gt; stop and predict 1, can announce
// ambiguity {@code {1,2}}</li>
//
// <li>{@code (s, 1, x)}, {@code (s, 2, x)}, {@code (s', 2, y)},
// {@code (s', 3, y)} yields conflicting, reduced sets {@code {1}} U
// {@code {2}} = {@code {1,2}} =&gt; continue</li>
//
// <li>{@code (s, 1, x)}, {@code (s, 2, x)}, {@code (s', 3, y)},
// {@code (s', 4, y)} yields conflicting, reduced sets {@code {1}} U
// {@code {3}} = {@code {1,3}} =&gt; continue</li>
//
// </ul>
//
// <p><strong>EXACT AMBIGUITY DETECTION</strong></p>
//
// <p>If all states report the same conflicting set of alternatives, then we
// know we have the exact ambiguity set.</p>
//
// <p><code>|A_<em>i</em>|&gt;1</code> and
// <code>A_<em>i</em> = A_<em>j</em></code> for all <em>i</em>, <em>j</em>.</p>
//
// <p>In other words, we continue examining lookahead until all {@code A_i}
// have more than one alternative and all {@code A_i} are the same. If
// {@code A={{1,2}, {1,3}}}, then regular LL prediction would terminate
// because the resolved set is {@code {1}}. To determine what the real
// ambiguity is, we have to know whether the ambiguity is between one and
// two or one and three so we keep going. We can only stop prediction when
// we need exact ambiguity detection when the sets look like
// {@code A={{1,2}}} or {@code {{1,2},{1,2}}}, etc...</p>
//
PredictionMode.resolvesToJustOneViableAlt = function(altsets) {
    return PredictionMode.getSingleViableAlt(altsets);
};

//
// Determines if every alternative subset in {@code altsets} contains more
// than one alternative.
//
// @param altsets a collection of alternative subsets
// @return {@code true} if every {@link BitSet} in {@code altsets} has
// {@link BitSet//cardinality cardinality} &gt; 1, otherwise {@code false}
//
PredictionMode.allSubsetsConflict = function(altsets) {
    return ! PredictionMode.hasNonConflictingAltSet(altsets);
};
//
// Determines if any single alternative subset in {@code altsets} contains
// exactly one alternative.
//
// @param altsets a collection of alternative subsets
// @return {@code true} if {@code altsets} contains a {@link BitSet} with
// {@link BitSet//cardinality cardinality} 1, otherwise {@code false}
//
PredictionMode.hasNonConflictingAltSet = function(altsets) {
	for(var i=0;i<altsets.length;i++) {
		var alts = altsets[i];
        if (alts.length===1) {
            return true;
        }
	}
    return false;
};

//
// Determines if any single alternative subset in {@code altsets} contains
// more than one alternative.
//
// @param altsets a collection of alternative subsets
// @return {@code true} if {@code altsets} contains a {@link BitSet} with
// {@link BitSet//cardinality cardinality} &gt; 1, otherwise {@code false}
//
PredictionMode.hasConflictingAltSet = function(altsets) {
	for(var i=0;i<altsets.length;i++) {
		var alts = altsets[i];
        if (alts.length>1) {
            return true;
        }
	}
    return false;
};

//
// Determines if every alternative subset in {@code altsets} is equivalent.
//
// @param altsets a collection of alternative subsets
// @return {@code true} if every member of {@code altsets} is equal to the
// others, otherwise {@code false}
//
PredictionMode.allSubsetsEqual = function(altsets) {
    var first = null;
	for(var i=0;i<altsets.length;i++) {
		var alts = altsets[i];
        if (first === null) {
            first = alts;
        } else if (alts!==first) {
            return false;
        }
	}
    return true;
};

//
// Returns the unique alternative predicted by all alternative subsets in
// {@code altsets}. If no such alternative exists, this method returns
// {@link ATN//INVALID_ALT_NUMBER}.
//
// @param altsets a collection of alternative subsets
//
PredictionMode.getUniqueAlt = function(altsets) {
    var all = PredictionMode.getAlts(altsets);
    if (all.length===1) {
        return all.minValue();
    } else {
        return ATN.INVALID_ALT_NUMBER;
    }
};

// Gets the complete set of represented alternatives for a collection of
// alternative subsets. This method returns the union of each {@link BitSet}
// in {@code altsets}.
//
// @param altsets a collection of alternative subsets
// @return the set of represented alternatives in {@code altsets}
//
PredictionMode.getAlts = function(altsets) {
    var all = new BitSet();
    altsets.map( function(alts) { all.or(alts); });
    return all;
};

//
// This function gets the conflicting alt subsets from a configuration set.
// For each configuration {@code c} in {@code configs}:
//
// <pre>
// map[c] U= c.{@link ATNConfig//alt alt} // map hash/equals uses s and x, not
// alt and not pred
// </pre>

PredictionMode.getConflictingAltSubsets = function(configs) {
    var configToAlts = new Map();
    configToAlts.hashFunction = function(cfg) { hashStuff(cfg.state.stateNumber, cfg.context); };
    configToAlts.equalsFunction = function(c1, c2) { return c1.state.stateNumber==c2.state.stateNumber && c1.context.equals(c2.context);}
    configs.items.map(function(cfg) {
        var alts = configToAlts.get(cfg);
        if (alts === null) {
            alts = new BitSet();
            configToAlts.put(cfg, alts);
        }
        alts.add(cfg.alt);
	});
    return configToAlts.getValues();
};

//
// Get a map from state to alt subset from a configuration set. For each
// configuration {@code c} in {@code configs}:
//
// <pre>
// map[c.{@link ATNConfig//state state}] U= c.{@link ATNConfig//alt alt}
// </pre>
//
PredictionMode.getStateToAltMap = function(configs) {
    var m = new AltDict();
    configs.items.map(function(c) {
        var alts = m.get(c.state);
        if (alts === null) {
            alts = new BitSet();
            m.put(c.state, alts);
        }
        alts.add(c.alt);
    });
    return m;
};

PredictionMode.hasStateAssociatedWithOneAlt = function(configs) {
    var values = PredictionMode.getStateToAltMap(configs).values();
    for(var i=0;i<values.length;i++) {
        if (values[i].length===1) {
            return true;
        }
    }
    return false;
};

PredictionMode.getSingleViableAlt = function(altsets) {
    var result = null;
	for(var i=0;i<altsets.length;i++) {
		var alts = altsets[i];
        var minAlt = alts.minValue();
        if(result===null) {
            result = minAlt;
        } else if(result!==minAlt) { // more than 1 viable alt
            return ATN.INVALID_ALT_NUMBER;
        }
	}
    return result;
};

exports.PredictionMode = PredictionMode;

},{"../Utils":58,"./../Utils":58,"./ATN":59,"./ATNConfig":60,"./ATNConfigSet":61,"./ATNState":65,"./SemanticContext":72}],72:[function(require,module,exports){
//
/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
//

// A tree structure used to record the semantic context in which
//  an ATN configuration is valid.  It's either a single predicate,
//  a conjunction {@code p1&&p2}, or a sum of products {@code p1||p2}.
//
//  <p>I have scoped the {@link AND}, {@link OR}, and {@link Predicate} subclasses of
//  {@link SemanticContext} within the scope of this outer class.</p>
//

var Set = require('./../Utils').Set;
var Hash = require('./../Utils').Hash;

function SemanticContext() {
	return this;
}

SemanticContext.prototype.hashCode = function() {
    var hash = new Hash();
    this.updateHashCode(hash);
    return hash.finish();
};

// For context independent predicates, we evaluate them without a local
// context (i.e., null context). That way, we can evaluate them without
// having to create proper rule-specific context during prediction (as
// opposed to the parser, which creates them naturally). In a practical
// sense, this avoids a cast exception from RuleContext to myruleContext.
//
// <p>For context dependent predicates, we must pass in a local context so that
// references such as $arg evaluate properly as _localctx.arg. We only
// capture context dependent predicates in the context in which we begin
// prediction, so we passed in the outer context here in case of context
// dependent predicate evaluation.</p>
//
SemanticContext.prototype.evaluate = function(parser, outerContext) {
};

//
// Evaluate the precedence predicates for the context and reduce the result.
//
// @param parser The parser instance.
// @param outerContext The current parser context object.
// @return The simplified semantic context after precedence predicates are
// evaluated, which will be one of the following values.
// <ul>
// <li>{@link //NONE}: if the predicate simplifies to {@code true} after
// precedence predicates are evaluated.</li>
// <li>{@code null}: if the predicate simplifies to {@code false} after
// precedence predicates are evaluated.</li>
// <li>{@code this}: if the semantic context is not changed as a result of
// precedence predicate evaluation.</li>
// <li>A non-{@code null} {@link SemanticContext}: the new simplified
// semantic context after precedence predicates are evaluated.</li>
// </ul>
//
SemanticContext.prototype.evalPrecedence = function(parser, outerContext) {
	return this;
};

SemanticContext.andContext = function(a, b) {
	if (a === null || a === SemanticContext.NONE) {
		return b;
	}
	if (b === null || b === SemanticContext.NONE) {
		return a;
	}
	var result = new AND(a, b);
	if (result.opnds.length === 1) {
		return result.opnds[0];
	} else {
		return result;
	}
};

SemanticContext.orContext = function(a, b) {
	if (a === null) {
		return b;
	}
	if (b === null) {
		return a;
	}
	if (a === SemanticContext.NONE || b === SemanticContext.NONE) {
		return SemanticContext.NONE;
	}
	var result = new OR(a, b);
	if (result.opnds.length === 1) {
		return result.opnds[0];
	} else {
		return result;
	}
};

function Predicate(ruleIndex, predIndex, isCtxDependent) {
	SemanticContext.call(this);
	this.ruleIndex = ruleIndex === undefined ? -1 : ruleIndex;
	this.predIndex = predIndex === undefined ? -1 : predIndex;
	this.isCtxDependent = isCtxDependent === undefined ? false : isCtxDependent; // e.g., $i ref in pred
	return this;
}

Predicate.prototype = Object.create(SemanticContext.prototype);
Predicate.prototype.constructor = Predicate;

//The default {@link SemanticContext}, which is semantically equivalent to
//a predicate of the form {@code {true}?}.
//
SemanticContext.NONE = new Predicate();


Predicate.prototype.evaluate = function(parser, outerContext) {
	var localctx = this.isCtxDependent ? outerContext : null;
	return parser.sempred(localctx, this.ruleIndex, this.predIndex);
};

Predicate.prototype.updateHashCode = function(hash) {
	hash.update(this.ruleIndex, this.predIndex, this.isCtxDependent);
};

Predicate.prototype.equals = function(other) {
	if (this === other) {
		return true;
	} else if (!(other instanceof Predicate)) {
		return false;
	} else {
		return this.ruleIndex === other.ruleIndex &&
				this.predIndex === other.predIndex &&
				this.isCtxDependent === other.isCtxDependent;
	}
};

Predicate.prototype.toString = function() {
	return "{" + this.ruleIndex + ":" + this.predIndex + "}?";
};

function PrecedencePredicate(precedence) {
	SemanticContext.call(this);
	this.precedence = precedence === undefined ? 0 : precedence;
}

PrecedencePredicate.prototype = Object.create(SemanticContext.prototype);
PrecedencePredicate.prototype.constructor = PrecedencePredicate;

PrecedencePredicate.prototype.evaluate = function(parser, outerContext) {
	return parser.precpred(outerContext, this.precedence);
};

PrecedencePredicate.prototype.evalPrecedence = function(parser, outerContext) {
	if (parser.precpred(outerContext, this.precedence)) {
		return SemanticContext.NONE;
	} else {
		return null;
	}
};

PrecedencePredicate.prototype.compareTo = function(other) {
	return this.precedence - other.precedence;
};

PrecedencePredicate.prototype.updateHashCode = function(hash) {
    hash.update(31);
};

PrecedencePredicate.prototype.equals = function(other) {
	if (this === other) {
		return true;
	} else if (!(other instanceof PrecedencePredicate)) {
		return false;
	} else {
		return this.precedence === other.precedence;
	}
};

PrecedencePredicate.prototype.toString = function() {
	return "{"+this.precedence+">=prec}?";
};



PrecedencePredicate.filterPrecedencePredicates = function(set) {
	var result = [];
	set.values().map( function(context) {
		if (context instanceof PrecedencePredicate) {
			result.push(context);
		}
	});
	return result;
};


// A semantic context which is true whenever none of the contained contexts
// is false.
//
function AND(a, b) {
	SemanticContext.call(this);
	var operands = new Set();
	if (a instanceof AND) {
		a.opnds.map(function(o) {
			operands.add(o);
		});
	} else {
		operands.add(a);
	}
	if (b instanceof AND) {
		b.opnds.map(function(o) {
			operands.add(o);
		});
	} else {
		operands.add(b);
	}
	var precedencePredicates = PrecedencePredicate.filterPrecedencePredicates(operands);
	if (precedencePredicates.length > 0) {
		// interested in the transition with the lowest precedence
		var reduced = null;
		precedencePredicates.map( function(p) {
			if(reduced===null || p.precedence<reduced.precedence) {
				reduced = p;
			}
		});
		operands.add(reduced);
	}
	this.opnds = operands.values();
	return this;
}

AND.prototype = Object.create(SemanticContext.prototype);
AND.prototype.constructor = AND;

AND.prototype.equals = function(other) {
	if (this === other) {
		return true;
	} else if (!(other instanceof AND)) {
		return false;
	} else {
		return this.opnds === other.opnds;
	}
};

AND.prototype.updateHashCode = function(hash) {
    hash.update(this.opnds, "AND");
};
//
// {@inheritDoc}
//
// <p>
// The evaluation of predicates by this context is short-circuiting, but
// unordered.</p>
//
AND.prototype.evaluate = function(parser, outerContext) {
	for (var i = 0; i < this.opnds.length; i++) {
		if (!this.opnds[i].evaluate(parser, outerContext)) {
			return false;
		}
	}
	return true;
};

AND.prototype.evalPrecedence = function(parser, outerContext) {
	var differs = false;
	var operands = [];
	for (var i = 0; i < this.opnds.length; i++) {
		var context = this.opnds[i];
		var evaluated = context.evalPrecedence(parser, outerContext);
		differs |= (evaluated !== context);
		if (evaluated === null) {
			// The AND context is false if any element is false
			return null;
		} else if (evaluated !== SemanticContext.NONE) {
			// Reduce the result by skipping true elements
			operands.push(evaluated);
		}
	}
	if (!differs) {
		return this;
	}
	if (operands.length === 0) {
		// all elements were true, so the AND context is true
		return SemanticContext.NONE;
	}
	var result = null;
	operands.map(function(o) {
		result = result === null ? o : SemanticContext.andContext(result, o);
	});
	return result;
};

AND.prototype.toString = function() {
	var s = "";
	this.opnds.map(function(o) {
		s += "&& " + o.toString();
	});
	return s.length > 3 ? s.slice(3) : s;
};

//
// A semantic context which is true whenever at least one of the contained
// contexts is true.
//
function OR(a, b) {
	SemanticContext.call(this);
	var operands = new Set();
	if (a instanceof OR) {
		a.opnds.map(function(o) {
			operands.add(o);
		});
	} else {
		operands.add(a);
	}
	if (b instanceof OR) {
		b.opnds.map(function(o) {
			operands.add(o);
		});
	} else {
		operands.add(b);
	}

	var precedencePredicates = PrecedencePredicate.filterPrecedencePredicates(operands);
	if (precedencePredicates.length > 0) {
		// interested in the transition with the highest precedence
		var s = precedencePredicates.sort(function(a, b) {
			return a.compareTo(b);
		});
		var reduced = s[s.length-1];
		operands.add(reduced);
	}
	this.opnds = operands.values();
	return this;
}

OR.prototype = Object.create(SemanticContext.prototype);
OR.prototype.constructor = OR;

OR.prototype.constructor = function(other) {
	if (this === other) {
		return true;
	} else if (!(other instanceof OR)) {
		return false;
	} else {
		return this.opnds === other.opnds;
	}
};

OR.prototype.updateHashCode = function(hash) {
    hash.update(this.opnds, "OR");
};

// <p>
// The evaluation of predicates by this context is short-circuiting, but
// unordered.</p>
//
OR.prototype.evaluate = function(parser, outerContext) {
	for (var i = 0; i < this.opnds.length; i++) {
		if (this.opnds[i].evaluate(parser, outerContext)) {
			return true;
		}
	}
	return false;
};

OR.prototype.evalPrecedence = function(parser, outerContext) {
	var differs = false;
	var operands = [];
	for (var i = 0; i < this.opnds.length; i++) {
		var context = this.opnds[i];
		var evaluated = context.evalPrecedence(parser, outerContext);
		differs |= (evaluated !== context);
		if (evaluated === SemanticContext.NONE) {
			// The OR context is true if any element is true
			return SemanticContext.NONE;
		} else if (evaluated !== null) {
			// Reduce the result by skipping false elements
			operands.push(evaluated);
		}
	}
	if (!differs) {
		return this;
	}
	if (operands.length === 0) {
		// all elements were false, so the OR context is false
		return null;
	}
	var result = null;
	operands.map(function(o) {
		return result === null ? o : SemanticContext.orContext(result, o);
	});
	return result;
};

OR.prototype.toString = function() {
	var s = "";
	this.opnds.map(function(o) {
		s += "|| " + o.toString();
	});
	return s.length > 3 ? s.slice(3) : s;
};

exports.SemanticContext = SemanticContext;
exports.PrecedencePredicate = PrecedencePredicate;
exports.Predicate = Predicate;

},{"./../Utils":58}],73:[function(require,module,exports){
/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
//

//  An ATN transition between any two ATN states.  Subclasses define
//  atom, set, epsilon, action, predicate, rule transitions.
//
//  <p>This is a one way link.  It emanates from a state (usually via a list of
//  transitions) and has a target state.</p>
//
//  <p>Since we never have to change the ATN transitions once we construct it,
//  we can fix these transitions as specific classes. The DFA transitions
//  on the other hand need to update the labels as it adds transitions to
//  the states. We'll use the term Edge for the DFA to distinguish them from
//  ATN transitions.</p>

var Token = require('./../Token').Token;
var Interval = require('./../IntervalSet').Interval;
var IntervalSet = require('./../IntervalSet').IntervalSet;
var Predicate = require('./SemanticContext').Predicate;
var PrecedencePredicate = require('./SemanticContext').PrecedencePredicate;

function Transition (target) {
    // The target of this transition.
    if (target===undefined || target===null) {
        throw "target cannot be null.";
    }
    this.target = target;
    // Are we epsilon, action, sempred?
    this.isEpsilon = false;
    this.label = null;
    return this;
}
    // constants for serialization
Transition.EPSILON = 1;
Transition.RANGE = 2;
Transition.RULE = 3;
Transition.PREDICATE = 4; // e.g., {isType(input.LT(1))}?
Transition.ATOM = 5;
Transition.ACTION = 6;
Transition.SET = 7; // ~(A|B) or ~atom, wildcard, which convert to next 2
Transition.NOT_SET = 8;
Transition.WILDCARD = 9;
Transition.PRECEDENCE = 10;

Transition.serializationNames = [
            "INVALID",
            "EPSILON",
            "RANGE",
            "RULE",
            "PREDICATE",
            "ATOM",
            "ACTION",
            "SET",
            "NOT_SET",
            "WILDCARD",
            "PRECEDENCE"
        ];

Transition.serializationTypes = {
        EpsilonTransition: Transition.EPSILON,
        RangeTransition: Transition.RANGE,
        RuleTransition: Transition.RULE,
        PredicateTransition: Transition.PREDICATE,
        AtomTransition: Transition.ATOM,
        ActionTransition: Transition.ACTION,
        SetTransition: Transition.SET,
        NotSetTransition: Transition.NOT_SET,
        WildcardTransition: Transition.WILDCARD,
        PrecedencePredicateTransition: Transition.PRECEDENCE
    };


// TODO: make all transitions sets? no, should remove set edges
function AtomTransition(target, label) {
	Transition.call(this, target);
	this.label_ = label; // The token type or character value; or, signifies special label.
    this.label = this.makeLabel();
    this.serializationType = Transition.ATOM;
    return this;
}

AtomTransition.prototype = Object.create(Transition.prototype);
AtomTransition.prototype.constructor = AtomTransition;

AtomTransition.prototype.makeLabel = function() {
	var s = new IntervalSet();
    s.addOne(this.label_);
    return s;
};

AtomTransition.prototype.matches = function( symbol, minVocabSymbol,  maxVocabSymbol) {
    return this.label_ === symbol;
};

AtomTransition.prototype.toString = function() {
	return this.label_;
};

function RuleTransition(ruleStart, ruleIndex, precedence, followState) {
	Transition.call(this, ruleStart);
    this.ruleIndex = ruleIndex; // ptr to the rule definition object for this rule ref
    this.precedence = precedence;
    this.followState = followState; // what node to begin computations following ref to rule
    this.serializationType = Transition.RULE;
    this.isEpsilon = true;
    return this;
}

RuleTransition.prototype = Object.create(Transition.prototype);
RuleTransition.prototype.constructor = RuleTransition;

RuleTransition.prototype.matches = function(symbol, minVocabSymbol,  maxVocabSymbol) {
	return false;
};


function EpsilonTransition(target, outermostPrecedenceReturn) {
	Transition.call(this, target);
    this.serializationType = Transition.EPSILON;
    this.isEpsilon = true;
    this.outermostPrecedenceReturn = outermostPrecedenceReturn;
    return this;
}

EpsilonTransition.prototype = Object.create(Transition.prototype);
EpsilonTransition.prototype.constructor = EpsilonTransition;

EpsilonTransition.prototype.matches = function( symbol, minVocabSymbol,  maxVocabSymbol) {
	return false;
};

EpsilonTransition.prototype.toString = function() {
	return "epsilon";
};

function RangeTransition(target, start, stop) {
	Transition.call(this, target);
	this.serializationType = Transition.RANGE;
    this.start = start;
    this.stop = stop;
    this.label = this.makeLabel();
    return this;
}

RangeTransition.prototype = Object.create(Transition.prototype);
RangeTransition.prototype.constructor = RangeTransition;

RangeTransition.prototype.makeLabel = function() {
    var s = new IntervalSet();
    s.addRange(this.start, this.stop);
    return s;
};

RangeTransition.prototype.matches = function(symbol, minVocabSymbol,  maxVocabSymbol) {
	return symbol >= this.start && symbol <= this.stop;
};

RangeTransition.prototype.toString = function() {
	return "'" + String.fromCharCode(this.start) + "'..'" + String.fromCharCode(this.stop) + "'";
};

function AbstractPredicateTransition(target) {
	Transition.call(this, target);
	return this;
}

AbstractPredicateTransition.prototype = Object.create(Transition.prototype);
AbstractPredicateTransition.prototype.constructor = AbstractPredicateTransition;

function PredicateTransition(target, ruleIndex, predIndex, isCtxDependent) {
	AbstractPredicateTransition.call(this, target);
    this.serializationType = Transition.PREDICATE;
    this.ruleIndex = ruleIndex;
    this.predIndex = predIndex;
    this.isCtxDependent = isCtxDependent; // e.g., $i ref in pred
    this.isEpsilon = true;
    return this;
}

PredicateTransition.prototype = Object.create(AbstractPredicateTransition.prototype);
PredicateTransition.prototype.constructor = PredicateTransition;

PredicateTransition.prototype.matches = function(symbol, minVocabSymbol,  maxVocabSymbol) {
	return false;
};

PredicateTransition.prototype.getPredicate = function() {
	return new Predicate(this.ruleIndex, this.predIndex, this.isCtxDependent);
};

PredicateTransition.prototype.toString = function() {
	return "pred_" + this.ruleIndex + ":" + this.predIndex;
};

function ActionTransition(target, ruleIndex, actionIndex, isCtxDependent) {
	Transition.call(this, target);
    this.serializationType = Transition.ACTION;
    this.ruleIndex = ruleIndex;
    this.actionIndex = actionIndex===undefined ? -1 : actionIndex;
    this.isCtxDependent = isCtxDependent===undefined ? false : isCtxDependent; // e.g., $i ref in pred
    this.isEpsilon = true;
    return this;
}

ActionTransition.prototype = Object.create(Transition.prototype);
ActionTransition.prototype.constructor = ActionTransition;


ActionTransition.prototype.matches = function(symbol, minVocabSymbol,  maxVocabSymbol) {
	return false;
};

ActionTransition.prototype.toString = function() {
	return "action_" + this.ruleIndex + ":" + this.actionIndex;
};


// A transition containing a set of values.
function SetTransition(target, set) {
	Transition.call(this, target);
	this.serializationType = Transition.SET;
    if (set !==undefined && set !==null) {
        this.label = set;
    } else {
        this.label = new IntervalSet();
        this.label.addOne(Token.INVALID_TYPE);
    }
    return this;
}

SetTransition.prototype = Object.create(Transition.prototype);
SetTransition.prototype.constructor = SetTransition;

SetTransition.prototype.matches = function(symbol, minVocabSymbol,  maxVocabSymbol) {
	return this.label.contains(symbol);
};


SetTransition.prototype.toString = function() {
	return this.label.toString();
};

function NotSetTransition(target, set) {
	SetTransition.call(this, target, set);
	this.serializationType = Transition.NOT_SET;
	return this;
}

NotSetTransition.prototype = Object.create(SetTransition.prototype);
NotSetTransition.prototype.constructor = NotSetTransition;

NotSetTransition.prototype.matches = function(symbol, minVocabSymbol,  maxVocabSymbol) {
	return symbol >= minVocabSymbol && symbol <= maxVocabSymbol &&
			!SetTransition.prototype.matches.call(this, symbol, minVocabSymbol, maxVocabSymbol);
};

NotSetTransition.prototype.toString = function() {
	return '~' + SetTransition.prototype.toString.call(this);
};

function WildcardTransition(target) {
	Transition.call(this, target);
	this.serializationType = Transition.WILDCARD;
	return this;
}

WildcardTransition.prototype = Object.create(Transition.prototype);
WildcardTransition.prototype.constructor = WildcardTransition;


WildcardTransition.prototype.matches = function(symbol, minVocabSymbol,  maxVocabSymbol) {
	return symbol >= minVocabSymbol && symbol <= maxVocabSymbol;
};

WildcardTransition.prototype.toString = function() {
	return ".";
};

function PrecedencePredicateTransition(target, precedence) {
	AbstractPredicateTransition.call(this, target);
    this.serializationType = Transition.PRECEDENCE;
    this.precedence = precedence;
    this.isEpsilon = true;
    return this;
}

PrecedencePredicateTransition.prototype = Object.create(AbstractPredicateTransition.prototype);
PrecedencePredicateTransition.prototype.constructor = PrecedencePredicateTransition;

PrecedencePredicateTransition.prototype.matches = function(symbol, minVocabSymbol,  maxVocabSymbol) {
	return false;
};

PrecedencePredicateTransition.prototype.getPredicate = function() {
	return new PrecedencePredicate(this.precedence);
};

PrecedencePredicateTransition.prototype.toString = function() {
	return this.precedence + " >= _p";
};

exports.Transition = Transition;
exports.AtomTransition = AtomTransition;
exports.SetTransition = SetTransition;
exports.NotSetTransition = NotSetTransition;
exports.RuleTransition = RuleTransition;
exports.ActionTransition = ActionTransition;
exports.EpsilonTransition = EpsilonTransition;
exports.RangeTransition = RangeTransition;
exports.WildcardTransition = WildcardTransition;
exports.PredicateTransition = PredicateTransition;
exports.PrecedencePredicateTransition = PrecedencePredicateTransition;
exports.AbstractPredicateTransition = AbstractPredicateTransition;
},{"./../IntervalSet":49,"./../Token":57,"./SemanticContext":72}],74:[function(require,module,exports){
/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

exports.ATN = require('./ATN').ATN;
exports.ATNDeserializer = require('./ATNDeserializer').ATNDeserializer;
exports.LexerATNSimulator = require('./LexerATNSimulator').LexerATNSimulator;
exports.ParserATNSimulator = require('./ParserATNSimulator').ParserATNSimulator;
exports.PredictionMode = require('./PredictionMode').PredictionMode;

},{"./ATN":59,"./ATNDeserializer":63,"./LexerATNSimulator":67,"./ParserATNSimulator":70,"./PredictionMode":71}],75:[function(require,module,exports){
//
/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

var Set = require("../Utils").Set;
var DFAState = require('./DFAState').DFAState;
var StarLoopEntryState = require('../atn/ATNState').StarLoopEntryState;
var ATNConfigSet = require('./../atn/ATNConfigSet').ATNConfigSet;
var DFASerializer = require('./DFASerializer').DFASerializer;
var LexerDFASerializer = require('./DFASerializer').LexerDFASerializer;



function DFA(atnStartState, decision) {
	if (decision === undefined) {
		decision = 0;
	}
	// From which ATN state did we create this DFA?
	this.atnStartState = atnStartState;
	this.decision = decision;
	// A set of all DFA states. Use {@link Map} so we can get old state back
	// ({@link Set} only allows you to see if it's there).
	this._states = new Set();
	this.s0 = null;
	// {@code true} if this DFA is for a precedence decision; otherwise,
	// {@code false}. This is the backing field for {@link //isPrecedenceDfa},
	// {@link //setPrecedenceDfa}.
	this.precedenceDfa = false;
    if (atnStartState instanceof StarLoopEntryState)
    {
        if (atnStartState.isPrecedenceDecision) {
            this.precedenceDfa = true;
            var precedenceState = new DFAState(null, new ATNConfigSet());
            precedenceState.edges = [];
            precedenceState.isAcceptState = false;
            precedenceState.requiresFullContext = false;
            this.s0 = precedenceState;
        }
    }
	return this;
}

// Get the start state for a specific precedence value.
//
// @param precedence The current precedence.
// @return The start state corresponding to the specified precedence, or
// {@code null} if no start state exists for the specified precedence.
//
// @throws IllegalStateException if this is not a precedence DFA.
// @see //isPrecedenceDfa()

DFA.prototype.getPrecedenceStartState = function(precedence) {
	if (!(this.precedenceDfa)) {
		throw ("Only precedence DFAs may contain a precedence start state.");
	}
	// s0.edges is never null for a precedence DFA
	if (precedence < 0 || precedence >= this.s0.edges.length) {
		return null;
	}
	return this.s0.edges[precedence] || null;
};

// Set the start state for a specific precedence value.
//
// @param precedence The current precedence.
// @param startState The start state corresponding to the specified
// precedence.
//
// @throws IllegalStateException if this is not a precedence DFA.
// @see //isPrecedenceDfa()
//
DFA.prototype.setPrecedenceStartState = function(precedence, startState) {
	if (!(this.precedenceDfa)) {
		throw ("Only precedence DFAs may contain a precedence start state.");
	}
	if (precedence < 0) {
		return;
	}

	// synchronization on s0 here is ok. when the DFA is turned into a
	// precedence DFA, s0 will be initialized once and not updated again
	// s0.edges is never null for a precedence DFA
	this.s0.edges[precedence] = startState;
};

//
// Sets whether this is a precedence DFA. If the specified value differs
// from the current DFA configuration, the following actions are taken;
// otherwise no changes are made to the current DFA.
//
// <ul>
// <li>The {@link //states} map is cleared</li>
// <li>If {@code precedenceDfa} is {@code false}, the initial state
// {@link //s0} is set to {@code null}; otherwise, it is initialized to a new
// {@link DFAState} with an empty outgoing {@link DFAState//edges} array to
// store the start states for individual precedence values.</li>
// <li>The {@link //precedenceDfa} field is updated</li>
// </ul>
//
// @param precedenceDfa {@code true} if this is a precedence DFA; otherwise,
// {@code false}

DFA.prototype.setPrecedenceDfa = function(precedenceDfa) {
	if (this.precedenceDfa!==precedenceDfa) {
		this._states = new DFAStatesSet();
		if (precedenceDfa) {
			var precedenceState = new DFAState(null, new ATNConfigSet());
			precedenceState.edges = [];
			precedenceState.isAcceptState = false;
			precedenceState.requiresFullContext = false;
			this.s0 = precedenceState;
		} else {
			this.s0 = null;
		}
		this.precedenceDfa = precedenceDfa;
	}
};

Object.defineProperty(DFA.prototype, "states", {
	get : function() {
		return this._states;
	}
});

// Return a list of all states in this DFA, ordered by state number.
DFA.prototype.sortedStates = function() {
	var list = this._states.values();
	return list.sort(function(a, b) {
		return a.stateNumber - b.stateNumber;
	});
};

DFA.prototype.toString = function(literalNames, symbolicNames) {
	literalNames = literalNames || null;
	symbolicNames = symbolicNames || null;
	if (this.s0 === null) {
		return "";
	}
	var serializer = new DFASerializer(this, literalNames, symbolicNames);
	return serializer.toString();
};

DFA.prototype.toLexerString = function() {
	if (this.s0 === null) {
		return "";
	}
	var serializer = new LexerDFASerializer(this);
	return serializer.toString();
};

exports.DFA = DFA;

},{"../Utils":58,"../atn/ATNState":65,"./../atn/ATNConfigSet":61,"./DFASerializer":76,"./DFAState":77}],76:[function(require,module,exports){
/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

// A DFA walker that knows how to dump them to serialized strings.#/


function DFASerializer(dfa, literalNames, symbolicNames) {
	this.dfa = dfa;
	this.literalNames = literalNames || [];
	this.symbolicNames = symbolicNames || [];
	return this;
}

DFASerializer.prototype.toString = function() {
   if(this.dfa.s0 === null) {
       return null;
   }
   var buf = "";
   var states = this.dfa.sortedStates();
   for(var i=0;i<states.length;i++) {
       var s = states[i];
       if(s.edges!==null) {
            var n = s.edges.length;
            for(var j=0;j<n;j++) {
                var t = s.edges[j] || null;
                if(t!==null && t.stateNumber !== 0x7FFFFFFF) {
                    buf = buf.concat(this.getStateString(s));
                    buf = buf.concat("-");
                    buf = buf.concat(this.getEdgeLabel(j));
                    buf = buf.concat("->");
                    buf = buf.concat(this.getStateString(t));
                    buf = buf.concat('\n');
                }
            }
       }
   }
   return buf.length===0 ? null : buf;
};

DFASerializer.prototype.getEdgeLabel = function(i) {
    if (i===0) {
        return "EOF";
    } else if(this.literalNames !==null || this.symbolicNames!==null) {
        return this.literalNames[i-1] || this.symbolicNames[i-1];
    } else {
        return String.fromCharCode(i-1);
    }
};

DFASerializer.prototype.getStateString = function(s) {
    var baseStateStr = ( s.isAcceptState ? ":" : "") + "s" + s.stateNumber + ( s.requiresFullContext ? "^" : "");
    if(s.isAcceptState) {
        if (s.predicates !== null) {
            return baseStateStr + "=>" + s.predicates.toString();
        } else {
            return baseStateStr + "=>" + s.prediction.toString();
        }
    } else {
        return baseStateStr;
    }
};

function LexerDFASerializer(dfa) {
	DFASerializer.call(this, dfa, null);
	return this;
}

LexerDFASerializer.prototype = Object.create(DFASerializer.prototype);
LexerDFASerializer.prototype.constructor = LexerDFASerializer;

LexerDFASerializer.prototype.getEdgeLabel = function(i) {
	return "'" + String.fromCharCode(i) + "'";
};

exports.DFASerializer = DFASerializer;
exports.LexerDFASerializer = LexerDFASerializer;


},{}],77:[function(require,module,exports){
//
/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
///

var ATNConfigSet = require('./../atn/ATNConfigSet').ATNConfigSet;
var Utils = require('./../Utils');
var Hash = Utils.Hash;
var Set = Utils.Set;

// Map a predicate to a predicted alternative.///

function PredPrediction(pred, alt) {
	this.alt = alt;
	this.pred = pred;
	return this;
}

PredPrediction.prototype.toString = function() {
	return "(" + this.pred + ", " + this.alt + ")";
};

// A DFA state represents a set of possible ATN configurations.
// As Aho, Sethi, Ullman p. 117 says "The DFA uses its state
// to keep track of all possible states the ATN can be in after
// reading each input symbol. That is to say, after reading
// input a1a2..an, the DFA is in a state that represents the
// subset T of the states of the ATN that are reachable from the
// ATN's start state along some path labeled a1a2..an."
// In conventional NFA&rarr;DFA conversion, therefore, the subset T
// would be a bitset representing the set of states the
// ATN could be in. We need to track the alt predicted by each
// state as well, however. More importantly, we need to maintain
// a stack of states, tracking the closure operations as they
// jump from rule to rule, emulating rule invocations (method calls).
// I have to add a stack to simulate the proper lookahead sequences for
// the underlying LL grammar from which the ATN was derived.
//
// <p>I use a set of ATNConfig objects not simple states. An ATNConfig
// is both a state (ala normal conversion) and a RuleContext describing
// the chain of rules (if any) followed to arrive at that state.</p>
//
// <p>A DFA state may have multiple references to a particular state,
// but with different ATN contexts (with same or different alts)
// meaning that state was reached via a different set of rule invocations.</p>
// /

function DFAState(stateNumber, configs) {
	if (stateNumber === null) {
		stateNumber = -1;
	}
	if (configs === null) {
		configs = new ATNConfigSet();
	}
	this.stateNumber = stateNumber;
	this.configs = configs;
	// {@code edges[symbol]} points to target of symbol. Shift up by 1 so (-1)
	// {@link Token//EOF} maps to {@code edges[0]}.
	this.edges = null;
	this.isAcceptState = false;
	// if accept state, what ttype do we match or alt do we predict?
	// This is set to {@link ATN//INVALID_ALT_NUMBER} when {@link
	// //predicates}{@code !=null} or
	// {@link //requiresFullContext}.
	this.prediction = 0;
	this.lexerActionExecutor = null;
	// Indicates that this state was created during SLL prediction that
	// discovered a conflict between the configurations in the state. Future
	// {@link ParserATNSimulator//execATN} invocations immediately jumped doing
	// full context prediction if this field is true.
	this.requiresFullContext = false;
	// During SLL parsing, this is a list of predicates associated with the
	// ATN configurations of the DFA state. When we have predicates,
	// {@link //requiresFullContext} is {@code false} since full context
	// prediction evaluates predicates
	// on-the-fly. If this is not null, then {@link //prediction} is
	// {@link ATN//INVALID_ALT_NUMBER}.
	//
	// <p>We only use these for non-{@link //requiresFullContext} but
	// conflicting states. That
	// means we know from the context (it's $ or we don't dip into outer
	// context) that it's an ambiguity not a conflict.</p>
	//
	// <p>This list is computed by {@link
	// ParserATNSimulator//predicateDFAState}.</p>
	this.predicates = null;
	return this;
}

// Get the set of all alts mentioned by all ATN configurations in this
// DFA state.
DFAState.prototype.getAltSet = function() {
	var alts = new Set();
	if (this.configs !== null) {
		for (var i = 0; i < this.configs.length; i++) {
			var c = this.configs[i];
			alts.add(c.alt);
		}
	}
	if (alts.length === 0) {
		return null;
	} else {
		return alts;
	}
};

// Two {@link DFAState} instances are equal if their ATN configuration sets
// are the same. This method is used to see if a state already exists.
//
// <p>Because the number of alternatives and number of ATN configurations are
// finite, there is a finite number of DFA states that can be processed.
// This is necessary to show that the algorithm terminates.</p>
//
// <p>Cannot test the DFA state numbers here because in
// {@link ParserATNSimulator//addDFAState} we need to know if any other state
// exists that has this exact set of ATN configurations. The
// {@link //stateNumber} is irrelevant.</p>
DFAState.prototype.equals = function(other) {
	// compare set of ATN configurations in this set with other
	return this === other ||
			(other instanceof DFAState &&
				this.configs.equals(other.configs));
};

DFAState.prototype.toString = function() {
	var s = "" + this.stateNumber + ":" + this.configs;
	if(this.isAcceptState) {
        s = s + "=>";
        if (this.predicates !== null)
            s = s + this.predicates;
        else
            s = s + this.prediction;
    }
	return s;
};

DFAState.prototype.hashCode = function() {
	var hash = new Hash();
	hash.update(this.configs);
    return hash.finish();
};

exports.DFAState = DFAState;
exports.PredPrediction = PredPrediction;

},{"./../Utils":58,"./../atn/ATNConfigSet":61}],78:[function(require,module,exports){
/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

exports.DFA = require('./DFA').DFA;
exports.DFASerializer = require('./DFASerializer').DFASerializer;
exports.LexerDFASerializer = require('./DFASerializer').LexerDFASerializer;
exports.PredPrediction = require('./DFAState').PredPrediction;

},{"./DFA":75,"./DFASerializer":76,"./DFAState":77}],79:[function(require,module,exports){
//
/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
//

//
// This implementation of {@link ANTLRErrorListener} can be used to identify
// certain potential correctness and performance problems in grammars. "Reports"
// are made by calling {@link Parser//notifyErrorListeners} with the appropriate
// message.
//
// <ul>
// <li><b>Ambiguities</b>: These are cases where more than one path through the
// grammar can match the input.</li>
// <li><b>Weak context sensitivity</b>: These are cases where full-context
// prediction resolved an SLL conflict to a unique alternative which equaled the
// minimum alternative of the SLL conflict.</li>
// <li><b>Strong (forced) context sensitivity</b>: These are cases where the
// full-context prediction resolved an SLL conflict to a unique alternative,
// <em>and</em> the minimum alternative of the SLL conflict was found to not be
// a truly viable alternative. Two-stage parsing cannot be used for inputs where
// this situation occurs.</li>
// </ul>

var BitSet = require('./../Utils').BitSet;
var ErrorListener = require('./ErrorListener').ErrorListener;
var Interval = require('./../IntervalSet').Interval;

function DiagnosticErrorListener(exactOnly) {
	ErrorListener.call(this);
	exactOnly = exactOnly || true;
	// whether all ambiguities or only exact ambiguities are reported.
	this.exactOnly = exactOnly;
	return this;
}

DiagnosticErrorListener.prototype = Object.create(ErrorListener.prototype);
DiagnosticErrorListener.prototype.constructor = DiagnosticErrorListener;

DiagnosticErrorListener.prototype.reportAmbiguity = function(recognizer, dfa,
		startIndex, stopIndex, exact, ambigAlts, configs) {
	if (this.exactOnly && !exact) {
		return;
	}
	var msg = "reportAmbiguity d=" +
			this.getDecisionDescription(recognizer, dfa) +
			": ambigAlts=" +
			this.getConflictingAlts(ambigAlts, configs) +
			", input='" +
			recognizer.getTokenStream().getText(new Interval(startIndex, stopIndex)) + "'";
	recognizer.notifyErrorListeners(msg);
};

DiagnosticErrorListener.prototype.reportAttemptingFullContext = function(
		recognizer, dfa, startIndex, stopIndex, conflictingAlts, configs) {
	var msg = "reportAttemptingFullContext d=" +
			this.getDecisionDescription(recognizer, dfa) +
			", input='" +
			recognizer.getTokenStream().getText(new Interval(startIndex, stopIndex)) + "'";
	recognizer.notifyErrorListeners(msg);
};

DiagnosticErrorListener.prototype.reportContextSensitivity = function(
		recognizer, dfa, startIndex, stopIndex, prediction, configs) {
	var msg = "reportContextSensitivity d=" +
			this.getDecisionDescription(recognizer, dfa) +
			", input='" +
			recognizer.getTokenStream().getText(new Interval(startIndex, stopIndex)) + "'";
	recognizer.notifyErrorListeners(msg);
};

DiagnosticErrorListener.prototype.getDecisionDescription = function(recognizer, dfa) {
	var decision = dfa.decision;
	var ruleIndex = dfa.atnStartState.ruleIndex;

	var ruleNames = recognizer.ruleNames;
	if (ruleIndex < 0 || ruleIndex >= ruleNames.length) {
		return "" + decision;
	}
	var ruleName = ruleNames[ruleIndex] || null;
	if (ruleName === null || ruleName.length === 0) {
		return "" + decision;
	}
	return "" + decision + " (" + ruleName + ")";
};

//
// Computes the set of conflicting or ambiguous alternatives from a
// configuration set, if that information was not already provided by the
// parser.
//
// @param reportedAlts The set of conflicting or ambiguous alternatives, as
// reported by the parser.
// @param configs The conflicting or ambiguous configuration set.
// @return Returns {@code reportedAlts} if it is not {@code null}, otherwise
// returns the set of alternatives represented in {@code configs}.
//
DiagnosticErrorListener.prototype.getConflictingAlts = function(reportedAlts, configs) {
	if (reportedAlts !== null) {
		return reportedAlts;
	}
	var result = new BitSet();
	for (var i = 0; i < configs.items.length; i++) {
		result.add(configs.items[i].alt);
	}
	return "{" + result.values().join(", ") + "}";
};

exports.DiagnosticErrorListener = DiagnosticErrorListener;
},{"./../IntervalSet":49,"./../Utils":58,"./ErrorListener":80}],80:[function(require,module,exports){
//
/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

// Provides an empty default implementation of {@link ANTLRErrorListener}. The
// default implementation of each method does nothing, but can be overridden as
// necessary.

function ErrorListener() {
	return this;
}

ErrorListener.prototype.syntaxError = function(recognizer, offendingSymbol, line, column, msg, e) {
};

ErrorListener.prototype.reportAmbiguity = function(recognizer, dfa, startIndex, stopIndex, exact, ambigAlts, configs) {
};

ErrorListener.prototype.reportAttemptingFullContext = function(recognizer, dfa, startIndex, stopIndex, conflictingAlts, configs) {
};

ErrorListener.prototype.reportContextSensitivity = function(recognizer, dfa, startIndex, stopIndex, prediction, configs) {
};

function ConsoleErrorListener() {
	ErrorListener.call(this);
	return this;
}

ConsoleErrorListener.prototype = Object.create(ErrorListener.prototype);
ConsoleErrorListener.prototype.constructor = ConsoleErrorListener;

//
// Provides a default instance of {@link ConsoleErrorListener}.
//
ConsoleErrorListener.INSTANCE = new ConsoleErrorListener();

//
// {@inheritDoc}
//
// <p>
// This implementation prints messages to {@link System//err} containing the
// values of {@code line}, {@code charPositionInLine}, and {@code msg} using
// the following format.</p>
//
// <pre>
// line <em>line</em>:<em>charPositionInLine</em> <em>msg</em>
// </pre>
//
ConsoleErrorListener.prototype.syntaxError = function(recognizer, offendingSymbol, line, column, msg, e) {
    console.error("line " + line + ":" + column + " " + msg);
};

function ProxyErrorListener(delegates) {
	ErrorListener.call(this);
    if (delegates===null) {
        throw "delegates";
    }
    this.delegates = delegates;
	return this;
}

ProxyErrorListener.prototype = Object.create(ErrorListener.prototype);
ProxyErrorListener.prototype.constructor = ProxyErrorListener;

ProxyErrorListener.prototype.syntaxError = function(recognizer, offendingSymbol, line, column, msg, e) {
    this.delegates.map(function(d) { d.syntaxError(recognizer, offendingSymbol, line, column, msg, e); });
};

ProxyErrorListener.prototype.reportAmbiguity = function(recognizer, dfa, startIndex, stopIndex, exact, ambigAlts, configs) {
    this.delegates.map(function(d) { d.reportAmbiguity(recognizer, dfa, startIndex, stopIndex, exact, ambigAlts, configs); });
};

ProxyErrorListener.prototype.reportAttemptingFullContext = function(recognizer, dfa, startIndex, stopIndex, conflictingAlts, configs) {
	this.delegates.map(function(d) { d.reportAttemptingFullContext(recognizer, dfa, startIndex, stopIndex, conflictingAlts, configs); });
};

ProxyErrorListener.prototype.reportContextSensitivity = function(recognizer, dfa, startIndex, stopIndex, prediction, configs) {
	this.delegates.map(function(d) { d.reportContextSensitivity(recognizer, dfa, startIndex, stopIndex, prediction, configs); });
};

exports.ErrorListener = ErrorListener;
exports.ConsoleErrorListener = ConsoleErrorListener;
exports.ProxyErrorListener = ProxyErrorListener;


},{}],81:[function(require,module,exports){
//
/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
//

var Token = require('./../Token').Token;
var Errors = require('./Errors');
var NoViableAltException = Errors.NoViableAltException;
var InputMismatchException = Errors.InputMismatchException;
var FailedPredicateException = Errors.FailedPredicateException;
var ParseCancellationException = Errors.ParseCancellationException;
var ATNState = require('./../atn/ATNState').ATNState;
var Interval = require('./../IntervalSet').Interval;
var IntervalSet = require('./../IntervalSet').IntervalSet;

function ErrorStrategy() {

}

ErrorStrategy.prototype.reset = function(recognizer){
};

ErrorStrategy.prototype.recoverInline = function(recognizer){
};

ErrorStrategy.prototype.recover = function(recognizer, e){
};

ErrorStrategy.prototype.sync = function(recognizer){
};

ErrorStrategy.prototype.inErrorRecoveryMode = function(recognizer){
};

ErrorStrategy.prototype.reportError = function(recognizer){
};



// This is the default implementation of {@link ANTLRErrorStrategy} used for
// error reporting and recovery in ANTLR parsers.
//
function DefaultErrorStrategy() {
	ErrorStrategy.call(this);
    // Indicates whether the error strategy is currently "recovering from an
    // error". This is used to suppress reporting multiple error messages while
    // attempting to recover from a detected syntax error.
    //
    // @see //inErrorRecoveryMode
    //
    this.errorRecoveryMode = false;

    // The index into the input stream where the last error occurred.
    // This is used to prevent infinite loops where an error is found
    // but no token is consumed during recovery...another error is found,
    // ad nauseum. This is a failsafe mechanism to guarantee that at least
    // one token/tree node is consumed for two errors.
    //
    this.lastErrorIndex = -1;
    this.lastErrorStates = null;
    return this;
}

DefaultErrorStrategy.prototype = Object.create(ErrorStrategy.prototype);
DefaultErrorStrategy.prototype.constructor = DefaultErrorStrategy;

// <p>The default implementation simply calls {@link //endErrorCondition} to
// ensure that the handler is not in error recovery mode.</p>
DefaultErrorStrategy.prototype.reset = function(recognizer) {
    this.endErrorCondition(recognizer);
};

//
// This method is called to enter error recovery mode when a recognition
// exception is reported.
//
// @param recognizer the parser instance
//
DefaultErrorStrategy.prototype.beginErrorCondition = function(recognizer) {
    this.errorRecoveryMode = true;
};

DefaultErrorStrategy.prototype.inErrorRecoveryMode = function(recognizer) {
    return this.errorRecoveryMode;
};

//
// This method is called to leave error recovery mode after recovering from
// a recognition exception.
//
// @param recognizer
//
DefaultErrorStrategy.prototype.endErrorCondition = function(recognizer) {
    this.errorRecoveryMode = false;
    this.lastErrorStates = null;
    this.lastErrorIndex = -1;
};

//
// {@inheritDoc}
//
// <p>The default implementation simply calls {@link //endErrorCondition}.</p>
//
DefaultErrorStrategy.prototype.reportMatch = function(recognizer) {
    this.endErrorCondition(recognizer);
};

//
// {@inheritDoc}
//
// <p>The default implementation returns immediately if the handler is already
// in error recovery mode. Otherwise, it calls {@link //beginErrorCondition}
// and dispatches the reporting task based on the runtime type of {@code e}
// according to the following table.</p>
//
// <ul>
// <li>{@link NoViableAltException}: Dispatches the call to
// {@link //reportNoViableAlternative}</li>
// <li>{@link InputMismatchException}: Dispatches the call to
// {@link //reportInputMismatch}</li>
// <li>{@link FailedPredicateException}: Dispatches the call to
// {@link //reportFailedPredicate}</li>
// <li>All other types: calls {@link Parser//notifyErrorListeners} to report
// the exception</li>
// </ul>
//
DefaultErrorStrategy.prototype.reportError = function(recognizer, e) {
   // if we've already reported an error and have not matched a token
   // yet successfully, don't report any errors.
    if(this.inErrorRecoveryMode(recognizer)) {
        return; // don't report spurious errors
    }
    this.beginErrorCondition(recognizer);
    if ( e instanceof NoViableAltException ) {
        this.reportNoViableAlternative(recognizer, e);
    } else if ( e instanceof InputMismatchException ) {
        this.reportInputMismatch(recognizer, e);
    } else if ( e instanceof FailedPredicateException ) {
        this.reportFailedPredicate(recognizer, e);
    } else {
        console.log("unknown recognition error type: " + e.constructor.name);
        console.log(e.stack);
        recognizer.notifyErrorListeners(e.getOffendingToken(), e.getMessage(), e);
    }
};
//
// {@inheritDoc}
//
// <p>The default implementation resynchronizes the parser by consuming tokens
// until we find one in the resynchronization set--loosely the set of tokens
// that can follow the current rule.</p>
//
DefaultErrorStrategy.prototype.recover = function(recognizer, e) {
    if (this.lastErrorIndex===recognizer.getInputStream().index &&
        this.lastErrorStates !== null && this.lastErrorStates.indexOf(recognizer.state)>=0) {
		// uh oh, another error at same token index and previously-visited
		// state in ATN; must be a case where LT(1) is in the recovery
		// token set so nothing got consumed. Consume a single token
		// at least to prevent an infinite loop; this is a failsafe.
		recognizer.consume();
    }
    this.lastErrorIndex = recognizer._input.index;
    if (this.lastErrorStates === null) {
        this.lastErrorStates = [];
    }
    this.lastErrorStates.push(recognizer.state);
    var followSet = this.getErrorRecoverySet(recognizer);
    this.consumeUntil(recognizer, followSet);
};

// The default implementation of {@link ANTLRErrorStrategy//sync} makes sure
// that the current lookahead symbol is consistent with what were expecting
// at this point in the ATN. You can call this anytime but ANTLR only
// generates code to check before subrules/loops and each iteration.
//
// <p>Implements Jim Idle's magic sync mechanism in closures and optional
// subrules. E.g.,</p>
//
// <pre>
// a : sync ( stuff sync )* ;
// sync : {consume to what can follow sync} ;
// </pre>
//
// At the start of a sub rule upon error, {@link //sync} performs single
// token deletion, if possible. If it can't do that, it bails on the current
// rule and uses the default error recovery, which consumes until the
// resynchronization set of the current rule.
//
// <p>If the sub rule is optional ({@code (...)?}, {@code (...)*}, or block
// with an empty alternative), then the expected set includes what follows
// the subrule.</p>
//
// <p>During loop iteration, it consumes until it sees a token that can start a
// sub rule or what follows loop. Yes, that is pretty aggressive. We opt to
// stay in the loop as long as possible.</p>
//
// <p><strong>ORIGINS</strong></p>
//
// <p>Previous versions of ANTLR did a poor job of their recovery within loops.
// A single mismatch token or missing token would force the parser to bail
// out of the entire rules surrounding the loop. So, for rule</p>
//
// <pre>
// classDef : 'class' ID '{' member* '}'
// </pre>
//
// input with an extra token between members would force the parser to
// consume until it found the next class definition rather than the next
// member definition of the current class.
//
// <p>This functionality cost a little bit of effort because the parser has to
// compare token set at the start of the loop and at each iteration. If for
// some reason speed is suffering for you, you can turn off this
// functionality by simply overriding this method as a blank { }.</p>
//
DefaultErrorStrategy.prototype.sync = function(recognizer) {
    // If already recovering, don't try to sync
    if (this.inErrorRecoveryMode(recognizer)) {
        return;
    }
    var s = recognizer._interp.atn.states[recognizer.state];
    var la = recognizer.getTokenStream().LA(1);
    // try cheaper subset first; might get lucky. seems to shave a wee bit off
    var nextTokens = recognizer.atn.nextTokens(s);
    if (nextTokens.contains(Token.EPSILON) || nextTokens.contains(la)) {
        return;
    }
    switch (s.stateType) {
    case ATNState.BLOCK_START:
    case ATNState.STAR_BLOCK_START:
    case ATNState.PLUS_BLOCK_START:
    case ATNState.STAR_LOOP_ENTRY:
       // report error and recover if possible
        if( this.singleTokenDeletion(recognizer) !== null) {
            return;
        } else {
            throw new InputMismatchException(recognizer);
        }
        break;
    case ATNState.PLUS_LOOP_BACK:
    case ATNState.STAR_LOOP_BACK:
        this.reportUnwantedToken(recognizer);
        var expecting = new IntervalSet();
        expecting.addSet(recognizer.getExpectedTokens());
        var whatFollowsLoopIterationOrRule = expecting.addSet(this.getErrorRecoverySet(recognizer));
        this.consumeUntil(recognizer, whatFollowsLoopIterationOrRule);
        break;
    default:
        // do nothing if we can't identify the exact kind of ATN state
    }
};

// This is called by {@link //reportError} when the exception is a
// {@link NoViableAltException}.
//
// @see //reportError
//
// @param recognizer the parser instance
// @param e the recognition exception
//
DefaultErrorStrategy.prototype.reportNoViableAlternative = function(recognizer, e) {
    var tokens = recognizer.getTokenStream();
    var input;
    if(tokens !== null) {
        if (e.startToken.type===Token.EOF) {
            input = "<EOF>";
        } else {
            input = tokens.getText(new Interval(e.startToken.tokenIndex, e.offendingToken.tokenIndex));
        }
    } else {
        input = "<unknown input>";
    }
    var msg = "no viable alternative at input " + this.escapeWSAndQuote(input);
    recognizer.notifyErrorListeners(msg, e.offendingToken, e);
};

//
// This is called by {@link //reportError} when the exception is an
// {@link InputMismatchException}.
//
// @see //reportError
//
// @param recognizer the parser instance
// @param e the recognition exception
//
DefaultErrorStrategy.prototype.reportInputMismatch = function(recognizer, e) {
    var msg = "mismatched input " + this.getTokenErrorDisplay(e.offendingToken) +
          " expecting " + e.getExpectedTokens().toString(recognizer.literalNames, recognizer.symbolicNames);
    recognizer.notifyErrorListeners(msg, e.offendingToken, e);
};

//
// This is called by {@link //reportError} when the exception is a
// {@link FailedPredicateException}.
//
// @see //reportError
//
// @param recognizer the parser instance
// @param e the recognition exception
//
DefaultErrorStrategy.prototype.reportFailedPredicate = function(recognizer, e) {
    var ruleName = recognizer.ruleNames[recognizer._ctx.ruleIndex];
    var msg = "rule " + ruleName + " " + e.message;
    recognizer.notifyErrorListeners(msg, e.offendingToken, e);
};

// This method is called to report a syntax error which requires the removal
// of a token from the input stream. At the time this method is called, the
// erroneous symbol is current {@code LT(1)} symbol and has not yet been
// removed from the input stream. When this method returns,
// {@code recognizer} is in error recovery mode.
//
// <p>This method is called when {@link //singleTokenDeletion} identifies
// single-token deletion as a viable recovery strategy for a mismatched
// input error.</p>
//
// <p>The default implementation simply returns if the handler is already in
// error recovery mode. Otherwise, it calls {@link //beginErrorCondition} to
// enter error recovery mode, followed by calling
// {@link Parser//notifyErrorListeners}.</p>
//
// @param recognizer the parser instance
//
DefaultErrorStrategy.prototype.reportUnwantedToken = function(recognizer) {
    if (this.inErrorRecoveryMode(recognizer)) {
        return;
    }
    this.beginErrorCondition(recognizer);
    var t = recognizer.getCurrentToken();
    var tokenName = this.getTokenErrorDisplay(t);
    var expecting = this.getExpectedTokens(recognizer);
    var msg = "extraneous input " + tokenName + " expecting " +
        expecting.toString(recognizer.literalNames, recognizer.symbolicNames);
    recognizer.notifyErrorListeners(msg, t, null);
};
// This method is called to report a syntax error which requires the
// insertion of a missing token into the input stream. At the time this
// method is called, the missing token has not yet been inserted. When this
// method returns, {@code recognizer} is in error recovery mode.
//
// <p>This method is called when {@link //singleTokenInsertion} identifies
// single-token insertion as a viable recovery strategy for a mismatched
// input error.</p>
//
// <p>The default implementation simply returns if the handler is already in
// error recovery mode. Otherwise, it calls {@link //beginErrorCondition} to
// enter error recovery mode, followed by calling
// {@link Parser//notifyErrorListeners}.</p>
//
// @param recognizer the parser instance
//
DefaultErrorStrategy.prototype.reportMissingToken = function(recognizer) {
    if ( this.inErrorRecoveryMode(recognizer)) {
        return;
    }
    this.beginErrorCondition(recognizer);
    var t = recognizer.getCurrentToken();
    var expecting = this.getExpectedTokens(recognizer);
    var msg = "missing " + expecting.toString(recognizer.literalNames, recognizer.symbolicNames) +
          " at " + this.getTokenErrorDisplay(t);
    recognizer.notifyErrorListeners(msg, t, null);
};

// <p>The default implementation attempts to recover from the mismatched input
// by using single token insertion and deletion as described below. If the
// recovery attempt fails, this method throws an
// {@link InputMismatchException}.</p>
//
// <p><strong>EXTRA TOKEN</strong> (single token deletion)</p>
//
// <p>{@code LA(1)} is not what we are looking for. If {@code LA(2)} has the
// right token, however, then assume {@code LA(1)} is some extra spurious
// token and delete it. Then consume and return the next token (which was
// the {@code LA(2)} token) as the successful result of the match operation.</p>
//
// <p>This recovery strategy is implemented by {@link
// //singleTokenDeletion}.</p>
//
// <p><strong>MISSING TOKEN</strong> (single token insertion)</p>
//
// <p>If current token (at {@code LA(1)}) is consistent with what could come
// after the expected {@code LA(1)} token, then assume the token is missing
// and use the parser's {@link TokenFactory} to create it on the fly. The
// "insertion" is performed by returning the created token as the successful
// result of the match operation.</p>
//
// <p>This recovery strategy is implemented by {@link
// //singleTokenInsertion}.</p>
//
// <p><strong>EXAMPLE</strong></p>
//
// <p>For example, Input {@code i=(3;} is clearly missing the {@code ')'}. When
// the parser returns from the nested call to {@code expr}, it will have
// call chain:</p>
//
// <pre>
// stat &rarr; expr &rarr; atom
// </pre>
//
// and it will be trying to match the {@code ')'} at this point in the
// derivation:
//
// <pre>
// =&gt; ID '=' '(' INT ')' ('+' atom)* ';'
// ^
// </pre>
//
// The attempt to match {@code ')'} will fail when it sees {@code ';'} and
// call {@link //recoverInline}. To recover, it sees that {@code LA(1)==';'}
// is in the set of tokens that can follow the {@code ')'} token reference
// in rule {@code atom}. It can assume that you forgot the {@code ')'}.
//
DefaultErrorStrategy.prototype.recoverInline = function(recognizer) {
    // SINGLE TOKEN DELETION
    var matchedSymbol = this.singleTokenDeletion(recognizer);
    if (matchedSymbol !== null) {
        // we have deleted the extra token.
        // now, move past ttype token as if all were ok
        recognizer.consume();
        return matchedSymbol;
    }
    // SINGLE TOKEN INSERTION
    if (this.singleTokenInsertion(recognizer)) {
        return this.getMissingSymbol(recognizer);
    }
    // even that didn't work; must throw the exception
    throw new InputMismatchException(recognizer);
};

//
// This method implements the single-token insertion inline error recovery
// strategy. It is called by {@link //recoverInline} if the single-token
// deletion strategy fails to recover from the mismatched input. If this
// method returns {@code true}, {@code recognizer} will be in error recovery
// mode.
//
// <p>This method determines whether or not single-token insertion is viable by
// checking if the {@code LA(1)} input symbol could be successfully matched
// if it were instead the {@code LA(2)} symbol. If this method returns
// {@code true}, the caller is responsible for creating and inserting a
// token with the correct type to produce this behavior.</p>
//
// @param recognizer the parser instance
// @return {@code true} if single-token insertion is a viable recovery
// strategy for the current mismatched input, otherwise {@code false}
//
DefaultErrorStrategy.prototype.singleTokenInsertion = function(recognizer) {
    var currentSymbolType = recognizer.getTokenStream().LA(1);
    // if current token is consistent with what could come after current
    // ATN state, then we know we're missing a token; error recovery
    // is free to conjure up and insert the missing token
    var atn = recognizer._interp.atn;
    var currentState = atn.states[recognizer.state];
    var next = currentState.transitions[0].target;
    var expectingAtLL2 = atn.nextTokens(next, recognizer._ctx);
    if (expectingAtLL2.contains(currentSymbolType) ){
        this.reportMissingToken(recognizer);
        return true;
    } else {
        return false;
    }
};

// This method implements the single-token deletion inline error recovery
// strategy. It is called by {@link //recoverInline} to attempt to recover
// from mismatched input. If this method returns null, the parser and error
// handler state will not have changed. If this method returns non-null,
// {@code recognizer} will <em>not</em> be in error recovery mode since the
// returned token was a successful match.
//
// <p>If the single-token deletion is successful, this method calls
// {@link //reportUnwantedToken} to report the error, followed by
// {@link Parser//consume} to actually "delete" the extraneous token. Then,
// before returning {@link //reportMatch} is called to signal a successful
// match.</p>
//
// @param recognizer the parser instance
// @return the successfully matched {@link Token} instance if single-token
// deletion successfully recovers from the mismatched input, otherwise
// {@code null}
//
DefaultErrorStrategy.prototype.singleTokenDeletion = function(recognizer) {
    var nextTokenType = recognizer.getTokenStream().LA(2);
    var expecting = this.getExpectedTokens(recognizer);
    if (expecting.contains(nextTokenType)) {
        this.reportUnwantedToken(recognizer);
        // print("recoverFromMismatchedToken deleting " \
        // + str(recognizer.getTokenStream().LT(1)) \
        // + " since " + str(recognizer.getTokenStream().LT(2)) \
        // + " is what we want", file=sys.stderr)
        recognizer.consume(); // simply delete extra token
        // we want to return the token we're actually matching
        var matchedSymbol = recognizer.getCurrentToken();
        this.reportMatch(recognizer); // we know current token is correct
        return matchedSymbol;
    } else {
        return null;
    }
};

// Conjure up a missing token during error recovery.
//
// The recognizer attempts to recover from single missing
// symbols. But, actions might refer to that missing symbol.
// For example, x=ID {f($x);}. The action clearly assumes
// that there has been an identifier matched previously and that
// $x points at that token. If that token is missing, but
// the next token in the stream is what we want we assume that
// this token is missing and we keep going. Because we
// have to return some token to replace the missing token,
// we have to conjure one up. This method gives the user control
// over the tokens returned for missing tokens. Mostly,
// you will want to create something special for identifier
// tokens. For literals such as '{' and ',', the default
// action in the parser or tree parser works. It simply creates
// a CommonToken of the appropriate type. The text will be the token.
// If you change what tokens must be created by the lexer,
// override this method to create the appropriate tokens.
//
DefaultErrorStrategy.prototype.getMissingSymbol = function(recognizer) {
    var currentSymbol = recognizer.getCurrentToken();
    var expecting = this.getExpectedTokens(recognizer);
    var expectedTokenType = expecting.first(); // get any element
    var tokenText;
    if (expectedTokenType===Token.EOF) {
        tokenText = "<missing EOF>";
    } else {
        tokenText = "<missing " + recognizer.literalNames[expectedTokenType] + ">";
    }
    var current = currentSymbol;
    var lookback = recognizer.getTokenStream().LT(-1);
    if (current.type===Token.EOF && lookback !== null) {
        current = lookback;
    }
    return recognizer.getTokenFactory().create(current.source,
        expectedTokenType, tokenText, Token.DEFAULT_CHANNEL,
        -1, -1, current.line, current.column);
};

DefaultErrorStrategy.prototype.getExpectedTokens = function(recognizer) {
    return recognizer.getExpectedTokens();
};

// How should a token be displayed in an error message? The default
// is to display just the text, but during development you might
// want to have a lot of information spit out. Override in that case
// to use t.toString() (which, for CommonToken, dumps everything about
// the token). This is better than forcing you to override a method in
// your token objects because you don't have to go modify your lexer
// so that it creates a new Java type.
//
DefaultErrorStrategy.prototype.getTokenErrorDisplay = function(t) {
    if (t === null) {
        return "<no token>";
    }
    var s = t.text;
    if (s === null) {
        if (t.type===Token.EOF) {
            s = "<EOF>";
        } else {
            s = "<" + t.type + ">";
        }
    }
    return this.escapeWSAndQuote(s);
};

DefaultErrorStrategy.prototype.escapeWSAndQuote = function(s) {
    s = s.replace(/\n/g,"\\n");
    s = s.replace(/\r/g,"\\r");
    s = s.replace(/\t/g,"\\t");
    return "'" + s + "'";
};

// Compute the error recovery set for the current rule. During
// rule invocation, the parser pushes the set of tokens that can
// follow that rule reference on the stack; this amounts to
// computing FIRST of what follows the rule reference in the
// enclosing rule. See LinearApproximator.FIRST().
// This local follow set only includes tokens
// from within the rule; i.e., the FIRST computation done by
// ANTLR stops at the end of a rule.
//
// EXAMPLE
//
// When you find a "no viable alt exception", the input is not
// consistent with any of the alternatives for rule r. The best
// thing to do is to consume tokens until you see something that
// can legally follow a call to r//or* any rule that called r.
// You don't want the exact set of viable next tokens because the
// input might just be missing a token--you might consume the
// rest of the input looking for one of the missing tokens.
//
// Consider grammar:
//
// a : '[' b ']'
// | '(' b ')'
// ;
// b : c '^' INT ;
// c : ID
// | INT
// ;
//
// At each rule invocation, the set of tokens that could follow
// that rule is pushed on a stack. Here are the various
// context-sensitive follow sets:
//
// FOLLOW(b1_in_a) = FIRST(']') = ']'
// FOLLOW(b2_in_a) = FIRST(')') = ')'
// FOLLOW(c_in_b) = FIRST('^') = '^'
//
// Upon erroneous input "[]", the call chain is
//
// a -> b -> c
//
// and, hence, the follow context stack is:
//
// depth follow set start of rule execution
// 0 <EOF> a (from main())
// 1 ']' b
// 2 '^' c
//
// Notice that ')' is not included, because b would have to have
// been called from a different context in rule a for ')' to be
// included.
//
// For error recovery, we cannot consider FOLLOW(c)
// (context-sensitive or otherwise). We need the combined set of
// all context-sensitive FOLLOW sets--the set of all tokens that
// could follow any reference in the call chain. We need to
// resync to one of those tokens. Note that FOLLOW(c)='^' and if
// we resync'd to that token, we'd consume until EOF. We need to
// sync to context-sensitive FOLLOWs for a, b, and c: {']','^'}.
// In this case, for input "[]", LA(1) is ']' and in the set, so we would
// not consume anything. After printing an error, rule c would
// return normally. Rule b would not find the required '^' though.
// At this point, it gets a mismatched token error and throws an
// exception (since LA(1) is not in the viable following token
// set). The rule exception handler tries to recover, but finds
// the same recovery set and doesn't consume anything. Rule b
// exits normally returning to rule a. Now it finds the ']' (and
// with the successful match exits errorRecovery mode).
//
// So, you can see that the parser walks up the call chain looking
// for the token that was a member of the recovery set.
//
// Errors are not generated in errorRecovery mode.
//
// ANTLR's error recovery mechanism is based upon original ideas:
//
// "Algorithms + Data Structures = Programs" by Niklaus Wirth
//
// and
//
// "A note on error recovery in recursive descent parsers":
// http://portal.acm.org/citation.cfm?id=947902.947905
//
// Later, Josef Grosch had some good ideas:
//
// "Efficient and Comfortable Error Recovery in Recursive Descent
// Parsers":
// ftp://www.cocolab.com/products/cocktail/doca4.ps/ell.ps.zip
//
// Like Grosch I implement context-sensitive FOLLOW sets that are combined
// at run-time upon error to avoid overhead during parsing.
//
DefaultErrorStrategy.prototype.getErrorRecoverySet = function(recognizer) {
    var atn = recognizer._interp.atn;
    var ctx = recognizer._ctx;
    var recoverSet = new IntervalSet();
    while (ctx !== null && ctx.invokingState>=0) {
        // compute what follows who invoked us
        var invokingState = atn.states[ctx.invokingState];
        var rt = invokingState.transitions[0];
        var follow = atn.nextTokens(rt.followState);
        recoverSet.addSet(follow);
        ctx = ctx.parentCtx;
    }
    recoverSet.removeOne(Token.EPSILON);
    return recoverSet;
};

// Consume tokens until one matches the given token set.//
DefaultErrorStrategy.prototype.consumeUntil = function(recognizer, set) {
    var ttype = recognizer.getTokenStream().LA(1);
    while( ttype !== Token.EOF && !set.contains(ttype)) {
        recognizer.consume();
        ttype = recognizer.getTokenStream().LA(1);
    }
};

//
// This implementation of {@link ANTLRErrorStrategy} responds to syntax errors
// by immediately canceling the parse operation with a
// {@link ParseCancellationException}. The implementation ensures that the
// {@link ParserRuleContext//exception} field is set for all parse tree nodes
// that were not completed prior to encountering the error.
//
// <p>
// This error strategy is useful in the following scenarios.</p>
//
// <ul>
// <li><strong>Two-stage parsing:</strong> This error strategy allows the first
// stage of two-stage parsing to immediately terminate if an error is
// encountered, and immediately fall back to the second stage. In addition to
// avoiding wasted work by attempting to recover from errors here, the empty
// implementation of {@link BailErrorStrategy//sync} improves the performance of
// the first stage.</li>
// <li><strong>Silent validation:</strong> When syntax errors are not being
// reported or logged, and the parse result is simply ignored if errors occur,
// the {@link BailErrorStrategy} avoids wasting work on recovering from errors
// when the result will be ignored either way.</li>
// </ul>
//
// <p>
// {@code myparser.setErrorHandler(new BailErrorStrategy());}</p>
//
// @see Parser//setErrorHandler(ANTLRErrorStrategy)
//
function BailErrorStrategy() {
	DefaultErrorStrategy.call(this);
	return this;
}

BailErrorStrategy.prototype = Object.create(DefaultErrorStrategy.prototype);
BailErrorStrategy.prototype.constructor = BailErrorStrategy;

// Instead of recovering from exception {@code e}, re-throw it wrapped
// in a {@link ParseCancellationException} so it is not caught by the
// rule function catches. Use {@link Exception//getCause()} to get the
// original {@link RecognitionException}.
//
BailErrorStrategy.prototype.recover = function(recognizer, e) {
    var context = recognizer._ctx;
    while (context !== null) {
        context.exception = e;
        context = context.parentCtx;
    }
    throw new ParseCancellationException(e);
};

// Make sure we don't attempt to recover inline; if the parser
// successfully recovers, it won't throw an exception.
//
BailErrorStrategy.prototype.recoverInline = function(recognizer) {
    this.recover(recognizer, new InputMismatchException(recognizer));
};

// Make sure we don't attempt to recover from problems in subrules.//
BailErrorStrategy.prototype.sync = function(recognizer) {
    // pass
};

exports.BailErrorStrategy = BailErrorStrategy;
exports.DefaultErrorStrategy = DefaultErrorStrategy;

},{"./../IntervalSet":49,"./../Token":57,"./../atn/ATNState":65,"./Errors":82}],82:[function(require,module,exports){
/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

// The root of the ANTLR exception hierarchy. In general, ANTLR tracks just
//  3 kinds of errors: prediction errors, failed predicate errors, and
//  mismatched input errors. In each case, the parser knows where it is
//  in the input, where it is in the ATN, the rule invocation stack,
//  and what kind of problem occurred.

var PredicateTransition = require('./../atn/Transition').PredicateTransition;

function RecognitionException(params) {
	Error.call(this);
	if (!!Error.captureStackTrace) {
        Error.captureStackTrace(this, RecognitionException);
	} else {
		var stack = new Error().stack;
	}
	this.message = params.message;
    this.recognizer = params.recognizer;
    this.input = params.input;
    this.ctx = params.ctx;
    // The current {@link Token} when an error occurred. Since not all streams
    // support accessing symbols by index, we have to track the {@link Token}
    // instance itself.
    this.offendingToken = null;
    // Get the ATN state number the parser was in at the time the error
    // occurred. For {@link NoViableAltException} and
    // {@link LexerNoViableAltException} exceptions, this is the
    // {@link DecisionState} number. For others, it is the state whose outgoing
    // edge we couldn't match.
    this.offendingState = -1;
    if (this.recognizer!==null) {
        this.offendingState = this.recognizer.state;
    }
    return this;
}

RecognitionException.prototype = Object.create(Error.prototype);
RecognitionException.prototype.constructor = RecognitionException;

// <p>If the state number is not known, this method returns -1.</p>

//
// Gets the set of input symbols which could potentially follow the
// previously matched symbol at the time this exception was thrown.
//
// <p>If the set of expected tokens is not known and could not be computed,
// this method returns {@code null}.</p>
//
// @return The set of token types that could potentially follow the current
// state in the ATN, or {@code null} if the information is not available.
// /
RecognitionException.prototype.getExpectedTokens = function() {
    if (this.recognizer!==null) {
        return this.recognizer.atn.getExpectedTokens(this.offendingState, this.ctx);
    } else {
        return null;
    }
};

RecognitionException.prototype.toString = function() {
    return this.message;
};

function LexerNoViableAltException(lexer, input, startIndex, deadEndConfigs) {
	RecognitionException.call(this, {message:"", recognizer:lexer, input:input, ctx:null});
    this.startIndex = startIndex;
    this.deadEndConfigs = deadEndConfigs;
    return this;
}

LexerNoViableAltException.prototype = Object.create(RecognitionException.prototype);
LexerNoViableAltException.prototype.constructor = LexerNoViableAltException;

LexerNoViableAltException.prototype.toString = function() {
    var symbol = "";
    if (this.startIndex >= 0 && this.startIndex < this.input.size) {
        symbol = this.input.getText((this.startIndex,this.startIndex));
    }
    return "LexerNoViableAltException" + symbol;
};

// Indicates that the parser could not decide which of two or more paths
// to take based upon the remaining input. It tracks the starting token
// of the offending input and also knows where the parser was
// in the various paths when the error. Reported by reportNoViableAlternative()
//
function NoViableAltException(recognizer, input, startToken, offendingToken, deadEndConfigs, ctx) {
	ctx = ctx || recognizer._ctx;
	offendingToken = offendingToken || recognizer.getCurrentToken();
	startToken = startToken || recognizer.getCurrentToken();
	input = input || recognizer.getInputStream();
	RecognitionException.call(this, {message:"", recognizer:recognizer, input:input, ctx:ctx});
    // Which configurations did we try at input.index() that couldn't match
	// input.LT(1)?//
    this.deadEndConfigs = deadEndConfigs;
    // The token object at the start index; the input stream might
    // not be buffering tokens so get a reference to it. (At the
    // time the error occurred, of course the stream needs to keep a
    // buffer all of the tokens but later we might not have access to those.)
    this.startToken = startToken;
    this.offendingToken = offendingToken;
}

NoViableAltException.prototype = Object.create(RecognitionException.prototype);
NoViableAltException.prototype.constructor = NoViableAltException;

// This signifies any kind of mismatched input exceptions such as
// when the current input does not match the expected token.
//
function InputMismatchException(recognizer) {
	RecognitionException.call(this, {message:"", recognizer:recognizer, input:recognizer.getInputStream(), ctx:recognizer._ctx});
    this.offendingToken = recognizer.getCurrentToken();
}

InputMismatchException.prototype = Object.create(RecognitionException.prototype);
InputMismatchException.prototype.constructor = InputMismatchException;

// A semantic predicate failed during validation. Validation of predicates
// occurs when normally parsing the alternative just like matching a token.
// Disambiguating predicate evaluation occurs when we test a predicate during
// prediction.

function FailedPredicateException(recognizer, predicate, message) {
	RecognitionException.call(this, {message:this.formatMessage(predicate,message || null), recognizer:recognizer,
                         input:recognizer.getInputStream(), ctx:recognizer._ctx});
    var s = recognizer._interp.atn.states[recognizer.state];
    var trans = s.transitions[0];
    if (trans instanceof PredicateTransition) {
        this.ruleIndex = trans.ruleIndex;
        this.predicateIndex = trans.predIndex;
    } else {
        this.ruleIndex = 0;
        this.predicateIndex = 0;
    }
    this.predicate = predicate;
    this.offendingToken = recognizer.getCurrentToken();
    return this;
}

FailedPredicateException.prototype = Object.create(RecognitionException.prototype);
FailedPredicateException.prototype.constructor = FailedPredicateException;

FailedPredicateException.prototype.formatMessage = function(predicate, message) {
    if (message !==null) {
        return message;
    } else {
        return "failed predicate: {" + predicate + "}?";
    }
};

function ParseCancellationException() {
	Error.call(this);
	Error.captureStackTrace(this, ParseCancellationException);
	return this;
}

ParseCancellationException.prototype = Object.create(Error.prototype);
ParseCancellationException.prototype.constructor = ParseCancellationException;

exports.RecognitionException = RecognitionException;
exports.NoViableAltException = NoViableAltException;
exports.LexerNoViableAltException = LexerNoViableAltException;
exports.InputMismatchException = InputMismatchException;
exports.FailedPredicateException = FailedPredicateException;
exports.ParseCancellationException = ParseCancellationException;

},{"./../atn/Transition":73}],83:[function(require,module,exports){
/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

exports.RecognitionException = require('./Errors').RecognitionException;
exports.NoViableAltException = require('./Errors').NoViableAltException;
exports.LexerNoViableAltException = require('./Errors').LexerNoViableAltException;
exports.InputMismatchException = require('./Errors').InputMismatchException;
exports.FailedPredicateException = require('./Errors').FailedPredicateException;
exports.DiagnosticErrorListener = require('./DiagnosticErrorListener').DiagnosticErrorListener;
exports.BailErrorStrategy = require('./ErrorStrategy').BailErrorStrategy;
exports.ErrorListener = require('./ErrorListener').ErrorListener;

},{"./DiagnosticErrorListener":79,"./ErrorListener":80,"./ErrorStrategy":81,"./Errors":82}],84:[function(require,module,exports){
/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
exports.atn = require('./atn/index');
exports.codepointat = require('./polyfills/codepointat');
exports.dfa = require('./dfa/index');
exports.fromcodepoint = require('./polyfills/fromcodepoint');
exports.tree = require('./tree/index');
exports.error = require('./error/index');
exports.Token = require('./Token').Token;
exports.CharStreams = require('./CharStreams').CharStreams;
exports.CommonToken = require('./Token').CommonToken;
exports.InputStream = require('./InputStream').InputStream;
exports.FileStream = require('./FileStream').FileStream;
exports.CommonTokenStream = require('./CommonTokenStream').CommonTokenStream;
exports.Lexer = require('./Lexer').Lexer;
exports.Parser = require('./Parser').Parser;
var pc = require('./PredictionContext');
exports.PredictionContextCache = pc.PredictionContextCache;
exports.ParserRuleContext = require('./ParserRuleContext').ParserRuleContext;
exports.Interval = require('./IntervalSet').Interval;
exports.Utils = require('./Utils');

},{"./CharStreams":44,"./CommonTokenStream":46,"./FileStream":47,"./InputStream":48,"./IntervalSet":49,"./Lexer":51,"./Parser":52,"./ParserRuleContext":53,"./PredictionContext":54,"./Token":57,"./Utils":58,"./atn/index":74,"./dfa/index":78,"./error/index":83,"./polyfills/codepointat":85,"./polyfills/fromcodepoint":86,"./tree/index":89}],85:[function(require,module,exports){
/*! https://mths.be/codepointat v0.2.0 by @mathias */
if (!String.prototype.codePointAt) {
	(function() {
		'use strict'; // needed to support `apply`/`call` with `undefined`/`null`
		var defineProperty = (function() {
			// IE 8 only supports `Object.defineProperty` on DOM elements
			try {
				var object = {};
				var $defineProperty = Object.defineProperty;
				var result = $defineProperty(object, object, object) && $defineProperty;
			} catch(error) {}
			return result;
		}());
		var codePointAt = function(position) {
			if (this == null) {
				throw TypeError();
			}
			var string = String(this);
			var size = string.length;
			// `ToInteger`
			var index = position ? Number(position) : 0;
			if (index != index) { // better `isNaN`
				index = 0;
			}
			// Account for out-of-bounds indices:
			if (index < 0 || index >= size) {
				return undefined;
			}
			// Get the first code unit
			var first = string.charCodeAt(index);
			var second;
			if ( // check if its the start of a surrogate pair
				first >= 0xD800 && first <= 0xDBFF && // high surrogate
				size > index + 1 // there is a next code unit
			) {
				second = string.charCodeAt(index + 1);
				if (second >= 0xDC00 && second <= 0xDFFF) { // low surrogate
					// https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
					return (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
				}
			}
			return first;
		};
		if (defineProperty) {
			defineProperty(String.prototype, 'codePointAt', {
				'value': codePointAt,
				'configurable': true,
				'writable': true
			});
		} else {
			String.prototype.codePointAt = codePointAt;
		}
	}());
}

},{}],86:[function(require,module,exports){
/*! https://mths.be/fromcodepoint v0.2.1 by @mathias */
if (!String.fromCodePoint) {
	(function() {
		var defineProperty = (function() {
			// IE 8 only supports `Object.defineProperty` on DOM elements
			try {
				var object = {};
				var $defineProperty = Object.defineProperty;
				var result = $defineProperty(object, object, object) && $defineProperty;
			} catch(error) {}
			return result;
		}());
		var stringFromCharCode = String.fromCharCode;
		var floor = Math.floor;
		var fromCodePoint = function(_) {
			var MAX_SIZE = 0x4000;
			var codeUnits = [];
			var highSurrogate;
			var lowSurrogate;
			var index = -1;
			var length = arguments.length;
			if (!length) {
				return '';
			}
			var result = '';
			while (++index < length) {
				var codePoint = Number(arguments[index]);
				if (
					!isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`
					codePoint < 0 || // not a valid Unicode code point
					codePoint > 0x10FFFF || // not a valid Unicode code point
					floor(codePoint) != codePoint // not an integer
				) {
					throw RangeError('Invalid code point: ' + codePoint);
				}
				if (codePoint <= 0xFFFF) { // BMP code point
					codeUnits.push(codePoint);
				} else { // Astral code point; split in surrogate halves
					// https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
					codePoint -= 0x10000;
					highSurrogate = (codePoint >> 10) + 0xD800;
					lowSurrogate = (codePoint % 0x400) + 0xDC00;
					codeUnits.push(highSurrogate, lowSurrogate);
				}
				if (index + 1 == length || codeUnits.length > MAX_SIZE) {
					result += stringFromCharCode.apply(null, codeUnits);
					codeUnits.length = 0;
				}
			}
			return result;
		};
		if (defineProperty) {
			defineProperty(String, 'fromCodePoint', {
				'value': fromCodePoint,
				'configurable': true,
				'writable': true
			});
		} else {
			String.fromCodePoint = fromCodePoint;
		}
	}());
}

},{}],87:[function(require,module,exports){
/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
///

// The basic notion of a tree has a parent, a payload, and a list of children.
//  It is the most abstract interface for all the trees used by ANTLR.
///

var Token = require('./../Token').Token;
var Interval = require('./../IntervalSet').Interval;
var INVALID_INTERVAL = new Interval(-1, -2);
var Utils = require('../Utils.js');


function Tree() {
	return this;
}

function SyntaxTree() {
	Tree.call(this);
	return this;
}

SyntaxTree.prototype = Object.create(Tree.prototype);
SyntaxTree.prototype.constructor = SyntaxTree;

function ParseTree() {
	SyntaxTree.call(this);
	return this;
}

ParseTree.prototype = Object.create(SyntaxTree.prototype);
ParseTree.prototype.constructor = ParseTree;

function RuleNode() {
	ParseTree.call(this);
	return this;
}

RuleNode.prototype = Object.create(ParseTree.prototype);
RuleNode.prototype.constructor = RuleNode;

function TerminalNode() {
	ParseTree.call(this);
	return this;
}

TerminalNode.prototype = Object.create(ParseTree.prototype);
TerminalNode.prototype.constructor = TerminalNode;

function ErrorNode() {
	TerminalNode.call(this);
	return this;
}

ErrorNode.prototype = Object.create(TerminalNode.prototype);
ErrorNode.prototype.constructor = ErrorNode;

function ParseTreeVisitor() {
	return this;
}

ParseTreeVisitor.prototype.visit = function(ctx) {
 	if (Array.isArray(ctx)) {
		return ctx.map(function(child) {
            return child.accept(this);
        }, this);
	} else {
		return ctx.accept(this);
	}
};

ParseTreeVisitor.prototype.visitChildren = function(ctx) {
	if (ctx.children) {
		return this.visit(ctx.children);
	} else {
		return null;
	}
}

ParseTreeVisitor.prototype.visitTerminal = function(node) {
};

ParseTreeVisitor.prototype.visitErrorNode = function(node) {
};


function ParseTreeListener() {
	return this;
}

ParseTreeListener.prototype.visitTerminal = function(node) {
};

ParseTreeListener.prototype.visitErrorNode = function(node) {
};

ParseTreeListener.prototype.enterEveryRule = function(node) {
};

ParseTreeListener.prototype.exitEveryRule = function(node) {
};

function TerminalNodeImpl(symbol) {
	TerminalNode.call(this);
	this.parentCtx = null;
	this.symbol = symbol;
	return this;
}

TerminalNodeImpl.prototype = Object.create(TerminalNode.prototype);
TerminalNodeImpl.prototype.constructor = TerminalNodeImpl;

TerminalNodeImpl.prototype.getChild = function(i) {
	return null;
};

TerminalNodeImpl.prototype.getSymbol = function() {
	return this.symbol;
};

TerminalNodeImpl.prototype.getParent = function() {
	return this.parentCtx;
};

TerminalNodeImpl.prototype.getPayload = function() {
	return this.symbol;
};

TerminalNodeImpl.prototype.getSourceInterval = function() {
	if (this.symbol === null) {
		return INVALID_INTERVAL;
	}
	var tokenIndex = this.symbol.tokenIndex;
	return new Interval(tokenIndex, tokenIndex);
};

TerminalNodeImpl.prototype.getChildCount = function() {
	return 0;
};

TerminalNodeImpl.prototype.accept = function(visitor) {
	return visitor.visitTerminal(this);
};

TerminalNodeImpl.prototype.getText = function() {
	return this.symbol.text;
};

TerminalNodeImpl.prototype.toString = function() {
	if (this.symbol.type === Token.EOF) {
		return "<EOF>";
	} else {
		return this.symbol.text;
	}
};

// Represents a token that was consumed during resynchronization
// rather than during a valid match operation. For example,
// we will create this kind of a node during single token insertion
// and deletion as well as during "consume until error recovery set"
// upon no viable alternative exceptions.

function ErrorNodeImpl(token) {
	TerminalNodeImpl.call(this, token);
	return this;
}

ErrorNodeImpl.prototype = Object.create(TerminalNodeImpl.prototype);
ErrorNodeImpl.prototype.constructor = ErrorNodeImpl;

ErrorNodeImpl.prototype.isErrorNode = function() {
	return true;
};

ErrorNodeImpl.prototype.accept = function(visitor) {
	return visitor.visitErrorNode(this);
};

function ParseTreeWalker() {
	return this;
}

ParseTreeWalker.prototype.walk = function(listener, t) {
	var errorNode = t instanceof ErrorNode ||
			(t.isErrorNode !== undefined && t.isErrorNode());
	if (errorNode) {
		listener.visitErrorNode(t);
	} else if (t instanceof TerminalNode) {
		listener.visitTerminal(t);
	} else {
		this.enterRule(listener, t);
		for (var i = 0; i < t.getChildCount(); i++) {
			var child = t.getChild(i);
			this.walk(listener, child);
		}
		this.exitRule(listener, t);
	}
};
//
// The discovery of a rule node, involves sending two events: the generic
// {@link ParseTreeListener//enterEveryRule} and a
// {@link RuleContext}-specific event. First we trigger the generic and then
// the rule specific. We to them in reverse order upon finishing the node.
//
ParseTreeWalker.prototype.enterRule = function(listener, r) {
	var ctx = r.getRuleContext();
	listener.enterEveryRule(ctx);
	ctx.enterRule(listener);
};

ParseTreeWalker.prototype.exitRule = function(listener, r) {
	var ctx = r.getRuleContext();
	ctx.exitRule(listener);
	listener.exitEveryRule(ctx);
};

ParseTreeWalker.DEFAULT = new ParseTreeWalker();

exports.RuleNode = RuleNode;
exports.ErrorNode = ErrorNode;
exports.TerminalNode = TerminalNode;
exports.ErrorNodeImpl = ErrorNodeImpl;
exports.TerminalNodeImpl = TerminalNodeImpl;
exports.ParseTreeListener = ParseTreeListener;
exports.ParseTreeVisitor = ParseTreeVisitor;
exports.ParseTreeWalker = ParseTreeWalker;
exports.INVALID_INTERVAL = INVALID_INTERVAL;

},{"../Utils.js":58,"./../IntervalSet":49,"./../Token":57}],88:[function(require,module,exports){
/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

var Utils = require('./../Utils');
var Token = require('./../Token').Token;
var RuleNode = require('./Tree').RuleNode;
var ErrorNode = require('./Tree').ErrorNode;
var TerminalNode = require('./Tree').TerminalNode;
var ParserRuleContext = require('./../ParserRuleContext').ParserRuleContext;
var RuleContext = require('./../RuleContext').RuleContext;
var INVALID_ALT_NUMBER = require('./../atn/ATN').INVALID_ALT_NUMBER;


/** A set of utility routines useful for all kinds of ANTLR trees. */
function Trees() {
}

// Print out a whole tree in LISP form. {@link //getNodeText} is used on the
//  node payloads to get the text for the nodes.  Detect
//  parse trees and extract data appropriately.
Trees.toStringTree = function(tree, ruleNames, recog) {
	ruleNames = ruleNames || null;
	recog = recog || null;
    if(recog!==null) {
       ruleNames = recog.ruleNames;
    }
    var s = Trees.getNodeText(tree, ruleNames);
    s = Utils.escapeWhitespace(s, false);
    var c = tree.getChildCount();
    if(c===0) {
        return s;
    }
    var res = "(" + s + ' ';
    if(c>0) {
        s = Trees.toStringTree(tree.getChild(0), ruleNames);
        res = res.concat(s);
    }
    for(var i=1;i<c;i++) {
        s = Trees.toStringTree(tree.getChild(i), ruleNames);
        res = res.concat(' ' + s);
    }
    res = res.concat(")");
    return res;
};

Trees.getNodeText = function(t, ruleNames, recog) {
	ruleNames = ruleNames || null;
	recog = recog || null;
    if(recog!==null) {
        ruleNames = recog.ruleNames;
    }
    if(ruleNames!==null) {
       if (t instanceof RuleContext) {
           var altNumber = t.getAltNumber();
           if ( altNumber!=INVALID_ALT_NUMBER ) {
               return ruleNames[t.ruleIndex]+":"+altNumber;
           }
           return ruleNames[t.ruleIndex];
       } else if ( t instanceof ErrorNode) {
           return t.toString();
       } else if(t instanceof TerminalNode) {
           if(t.symbol!==null) {
               return t.symbol.text;
           }
       }
    }
    // no recog for rule names
    var payload = t.getPayload();
    if (payload instanceof Token ) {
       return payload.text;
    }
    return t.getPayload().toString();
};


// Return ordered list of all children of this node
Trees.getChildren = function(t) {
	var list = [];
	for(var i=0;i<t.getChildCount();i++) {
		list.push(t.getChild(i));
	}
	return list;
};

// Return a list of all ancestors of this node.  The first node of
//  list is the root and the last is the parent of this node.
//
Trees.getAncestors = function(t) {
    var ancestors = [];
    t = t.getParent();
    while(t!==null) {
        ancestors = [t].concat(ancestors);
        t = t.getParent();
    }
    return ancestors;
};

Trees.findAllTokenNodes = function(t, ttype) {
    return Trees.findAllNodes(t, ttype, true);
};

Trees.findAllRuleNodes = function(t, ruleIndex) {
	return Trees.findAllNodes(t, ruleIndex, false);
};

Trees.findAllNodes = function(t, index, findTokens) {
	var nodes = [];
	Trees._findAllNodes(t, index, findTokens, nodes);
	return nodes;
};

Trees._findAllNodes = function(t, index, findTokens, nodes) {
	// check this node (the root) first
	if(findTokens && (t instanceof TerminalNode)) {
		if(t.symbol.type===index) {
			nodes.push(t);
		}
	} else if(!findTokens && (t instanceof ParserRuleContext)) {
		if(t.ruleIndex===index) {
			nodes.push(t);
		}
	}
	// check children
	for(var i=0;i<t.getChildCount();i++) {
		Trees._findAllNodes(t.getChild(i), index, findTokens, nodes);
	}
};

Trees.descendants = function(t) {
	var nodes = [t];
    for(var i=0;i<t.getChildCount();i++) {
        nodes = nodes.concat(Trees.descendants(t.getChild(i)));
    }
    return nodes;
};


exports.Trees = Trees;
},{"./../ParserRuleContext":53,"./../RuleContext":56,"./../Token":57,"./../Utils":58,"./../atn/ATN":59,"./Tree":87}],89:[function(require,module,exports){
/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

var Tree = require('./Tree');
exports.Trees = require('./Trees').Trees;
exports.RuleNode = Tree.RuleNode;
exports.ParseTreeListener = Tree.ParseTreeListener;
exports.ParseTreeVisitor = Tree.ParseTreeVisitor;
exports.ParseTreeWalker = Tree.ParseTreeWalker;

},{"./Tree":87,"./Trees":88}],90:[function(require,module,exports){

},{}],91:[function(require,module,exports){
// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

// Open simple dialogs on top of an editor. Relies on dialog.css.

(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    mod(require("../../lib/codemirror"));
  else if (typeof define == "function" && define.amd) // AMD
    define(["../../lib/codemirror"], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function(CodeMirror) {
  function dialogDiv(cm, template, bottom) {
    var wrap = cm.getWrapperElement();
    var dialog;
    dialog = wrap.appendChild(document.createElement("div"));
    if (bottom)
      dialog.className = "CodeMirror-dialog CodeMirror-dialog-bottom";
    else
      dialog.className = "CodeMirror-dialog CodeMirror-dialog-top";

    if (typeof template == "string") {
      dialog.innerHTML = template;
    } else { // Assuming it's a detached DOM element.
      dialog.appendChild(template);
    }
    CodeMirror.addClass(wrap, 'dialog-opened');
    return dialog;
  }

  function closeNotification(cm, newVal) {
    if (cm.state.currentNotificationClose)
      cm.state.currentNotificationClose();
    cm.state.currentNotificationClose = newVal;
  }

  CodeMirror.defineExtension("openDialog", function(template, callback, options) {
    if (!options) options = {};

    closeNotification(this, null);

    var dialog = dialogDiv(this, template, options.bottom);
    var closed = false, me = this;
    function close(newVal) {
      if (typeof newVal == 'string') {
        inp.value = newVal;
      } else {
        if (closed) return;
        closed = true;
        CodeMirror.rmClass(dialog.parentNode, 'dialog-opened');
        dialog.parentNode.removeChild(dialog);
        me.focus();

        if (options.onClose) options.onClose(dialog);
      }
    }

    var inp = dialog.getElementsByTagName("input")[0], button;
    if (inp) {
      inp.focus();

      if (options.value) {
        inp.value = options.value;
        if (options.selectValueOnOpen !== false) {
          inp.select();
        }
      }

      if (options.onInput)
        CodeMirror.on(inp, "input", function(e) { options.onInput(e, inp.value, close);});
      if (options.onKeyUp)
        CodeMirror.on(inp, "keyup", function(e) {options.onKeyUp(e, inp.value, close);});

      CodeMirror.on(inp, "keydown", function(e) {
        if (options && options.onKeyDown && options.onKeyDown(e, inp.value, close)) { return; }
        if (e.keyCode == 27 || (options.closeOnEnter !== false && e.keyCode == 13)) {
          inp.blur();
          CodeMirror.e_stop(e);
          close();
        }
        if (e.keyCode == 13) callback(inp.value, e);
      });

      if (options.closeOnBlur !== false) CodeMirror.on(dialog, "focusout", function (evt) {
        if (evt.relatedTarget !== null) close();
      });
    } else if (button = dialog.getElementsByTagName("button")[0]) {
      CodeMirror.on(button, "click", function() {
        close();
        me.focus();
      });

      if (options.closeOnBlur !== false) CodeMirror.on(button, "blur", close);

      button.focus();
    }
    return close;
  });

  CodeMirror.defineExtension("openConfirm", function(template, callbacks, options) {
    closeNotification(this, null);
    var dialog = dialogDiv(this, template, options && options.bottom);
    var buttons = dialog.getElementsByTagName("button");
    var closed = false, me = this, blurring = 1;
    function close() {
      if (closed) return;
      closed = true;
      CodeMirror.rmClass(dialog.parentNode, 'dialog-opened');
      dialog.parentNode.removeChild(dialog);
      me.focus();
    }
    buttons[0].focus();
    for (var i = 0; i < buttons.length; ++i) {
      var b = buttons[i];
      (function(callback) {
        CodeMirror.on(b, "click", function(e) {
          CodeMirror.e_preventDefault(e);
          close();
          if (callback) callback(me);
        });
      })(callbacks[i]);
      CodeMirror.on(b, "blur", function() {
        --blurring;
        setTimeout(function() { if (blurring <= 0) close(); }, 200);
      });
      CodeMirror.on(b, "focus", function() { ++blurring; });
    }
  });

  /*
   * openNotification
   * Opens a notification, that can be closed with an optional timer
   * (default 5000ms timer) and always closes on click.
   *
   * If a notification is opened while another is opened, it will close the
   * currently opened one and open the new one immediately.
   */
  CodeMirror.defineExtension("openNotification", function(template, options) {
    closeNotification(this, close);
    var dialog = dialogDiv(this, template, options && options.bottom);
    var closed = false, doneTimer;
    var duration = options && typeof options.duration !== "undefined" ? options.duration : 5000;

    function close() {
      if (closed) return;
      closed = true;
      clearTimeout(doneTimer);
      CodeMirror.rmClass(dialog.parentNode, 'dialog-opened');
      dialog.parentNode.removeChild(dialog);
    }

    CodeMirror.on(dialog, 'click', function(e) {
      CodeMirror.e_preventDefault(e);
      close();
    });

    if (duration)
      doneTimer = setTimeout(close, duration);

    return close;
  });
});

},{"../../lib/codemirror":101}],92:[function(require,module,exports){
// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    mod(require("../../lib/codemirror"))
  else if (typeof define == "function" && define.amd) // AMD
    define(["../../lib/codemirror"], mod)
  else // Plain browser env
    mod(CodeMirror)
})(function(CodeMirror) {
  "use strict"

  CodeMirror.defineOption("autoRefresh", false, function(cm, val) {
    if (cm.state.autoRefresh) {
      stopListening(cm, cm.state.autoRefresh)
      cm.state.autoRefresh = null
    }
    if (val && cm.display.wrapper.offsetHeight == 0)
      startListening(cm, cm.state.autoRefresh = {delay: val.delay || 250})
  })

  function startListening(cm, state) {
    function check() {
      if (cm.display.wrapper.offsetHeight) {
        stopListening(cm, state)
        if (cm.display.lastWrapHeight != cm.display.wrapper.clientHeight)
          cm.refresh()
      } else {
        state.timeout = setTimeout(check, state.delay)
      }
    }
    state.timeout = setTimeout(check, state.delay)
    state.hurry = function() {
      clearTimeout(state.timeout)
      state.timeout = setTimeout(check, 50)
    }
    CodeMirror.on(window, "mouseup", state.hurry)
    CodeMirror.on(window, "keyup", state.hurry)
  }

  function stopListening(_cm, state) {
    clearTimeout(state.timeout)
    CodeMirror.off(window, "mouseup", state.hurry)
    CodeMirror.off(window, "keyup", state.hurry)
  }
});

},{"../../lib/codemirror":101}],93:[function(require,module,exports){
// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    mod(require("../../lib/codemirror"));
  else if (typeof define == "function" && define.amd) // AMD
    define(["../../lib/codemirror"], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function(CodeMirror) {
  CodeMirror.defineOption("placeholder", "", function(cm, val, old) {
    var prev = old && old != CodeMirror.Init;
    if (val && !prev) {
      cm.on("blur", onBlur);
      cm.on("change", onChange);
      cm.on("swapDoc", onChange);
      CodeMirror.on(cm.getInputField(), "compositionupdate", cm.state.placeholderCompose = function() { onComposition(cm) })
      onChange(cm);
    } else if (!val && prev) {
      cm.off("blur", onBlur);
      cm.off("change", onChange);
      cm.off("swapDoc", onChange);
      CodeMirror.off(cm.getInputField(), "compositionupdate", cm.state.placeholderCompose)
      clearPlaceholder(cm);
      var wrapper = cm.getWrapperElement();
      wrapper.className = wrapper.className.replace(" CodeMirror-empty", "");
    }

    if (val && !cm.hasFocus()) onBlur(cm);
  });

  function clearPlaceholder(cm) {
    if (cm.state.placeholder) {
      cm.state.placeholder.parentNode.removeChild(cm.state.placeholder);
      cm.state.placeholder = null;
    }
  }
  function setPlaceholder(cm) {
    clearPlaceholder(cm);
    var elt = cm.state.placeholder = document.createElement("pre");
    elt.style.cssText = "height: 0; overflow: visible";
    elt.style.direction = cm.getOption("direction");
    elt.className = "CodeMirror-placeholder CodeMirror-line-like";
    var placeHolder = cm.getOption("placeholder")
    if (typeof placeHolder == "string") placeHolder = document.createTextNode(placeHolder)
    elt.appendChild(placeHolder)
    cm.display.lineSpace.insertBefore(elt, cm.display.lineSpace.firstChild);
  }

  function onComposition(cm) {
    setTimeout(function() {
      var empty = false, input = cm.getInputField()
      if (input.nodeName == "TEXTAREA")
        empty = !input.value
      else if (cm.lineCount() == 1)
        empty = !/[^\u200b]/.test(input.querySelector(".CodeMirror-line").textContent)
      if (empty) setPlaceholder(cm)
      else clearPlaceholder(cm)
    }, 20)
  }

  function onBlur(cm) {
    if (isEmpty(cm)) setPlaceholder(cm);
  }
  function onChange(cm) {
    var wrapper = cm.getWrapperElement(), empty = isEmpty(cm);
    wrapper.className = wrapper.className.replace(" CodeMirror-empty", "") + (empty ? " CodeMirror-empty" : "");

    if (empty) setPlaceholder(cm);
    else clearPlaceholder(cm);
  }

  function isEmpty(cm) {
    return (cm.lineCount() === 1) && (cm.getLine(0) === "");
  }
});

},{"../../lib/codemirror":101}],94:[function(require,module,exports){
// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    mod(require("../../lib/codemirror"));
  else if (typeof define == "function" && define.amd) // AMD
    define(["../../lib/codemirror"], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function(CodeMirror) {
  var defaults = {
    pairs: "()[]{}''\"\"",
    closeBefore: ")]}'\":;>",
    triples: "",
    explode: "[]{}"
  };

  var Pos = CodeMirror.Pos;

  CodeMirror.defineOption("autoCloseBrackets", false, function(cm, val, old) {
    if (old && old != CodeMirror.Init) {
      cm.removeKeyMap(keyMap);
      cm.state.closeBrackets = null;
    }
    if (val) {
      ensureBound(getOption(val, "pairs"))
      cm.state.closeBrackets = val;
      cm.addKeyMap(keyMap);
    }
  });

  function getOption(conf, name) {
    if (name == "pairs" && typeof conf == "string") return conf;
    if (typeof conf == "object" && conf[name] != null) return conf[name];
    return defaults[name];
  }

  var keyMap = {Backspace: handleBackspace, Enter: handleEnter};
  function ensureBound(chars) {
    for (var i = 0; i < chars.length; i++) {
      var ch = chars.charAt(i), key = "'" + ch + "'"
      if (!keyMap[key]) keyMap[key] = handler(ch)
    }
  }
  ensureBound(defaults.pairs + "`")

  function handler(ch) {
    return function(cm) { return handleChar(cm, ch); };
  }

  function getConfig(cm) {
    var deflt = cm.state.closeBrackets;
    if (!deflt || deflt.override) return deflt;
    var mode = cm.getModeAt(cm.getCursor());
    return mode.closeBrackets || deflt;
  }

  function handleBackspace(cm) {
    var conf = getConfig(cm);
    if (!conf || cm.getOption("disableInput")) return CodeMirror.Pass;

    var pairs = getOption(conf, "pairs");
    var ranges = cm.listSelections();
    for (var i = 0; i < ranges.length; i++) {
      if (!ranges[i].empty()) return CodeMirror.Pass;
      var around = charsAround(cm, ranges[i].head);
      if (!around || pairs.indexOf(around) % 2 != 0) return CodeMirror.Pass;
    }
    for (var i = ranges.length - 1; i >= 0; i--) {
      var cur = ranges[i].head;
      cm.replaceRange("", Pos(cur.line, cur.ch - 1), Pos(cur.line, cur.ch + 1), "+delete");
    }
  }

  function handleEnter(cm) {
    var conf = getConfig(cm);
    var explode = conf && getOption(conf, "explode");
    if (!explode || cm.getOption("disableInput")) return CodeMirror.Pass;

    var ranges = cm.listSelections();
    for (var i = 0; i < ranges.length; i++) {
      if (!ranges[i].empty()) return CodeMirror.Pass;
      var around = charsAround(cm, ranges[i].head);
      if (!around || explode.indexOf(around) % 2 != 0) return CodeMirror.Pass;
    }
    cm.operation(function() {
      var linesep = cm.lineSeparator() || "\n";
      cm.replaceSelection(linesep + linesep, null);
      cm.execCommand("goCharLeft");
      ranges = cm.listSelections();
      for (var i = 0; i < ranges.length; i++) {
        var line = ranges[i].head.line;
        cm.indentLine(line, null, true);
        cm.indentLine(line + 1, null, true);
      }
    });
  }

  function contractSelection(sel) {
    var inverted = CodeMirror.cmpPos(sel.anchor, sel.head) > 0;
    return {anchor: new Pos(sel.anchor.line, sel.anchor.ch + (inverted ? -1 : 1)),
            head: new Pos(sel.head.line, sel.head.ch + (inverted ? 1 : -1))};
  }

  function handleChar(cm, ch) {
    var conf = getConfig(cm);
    if (!conf || cm.getOption("disableInput")) return CodeMirror.Pass;

    var pairs = getOption(conf, "pairs");
    var pos = pairs.indexOf(ch);
    if (pos == -1) return CodeMirror.Pass;

    var closeBefore = getOption(conf,"closeBefore");

    var triples = getOption(conf, "triples");

    var identical = pairs.charAt(pos + 1) == ch;
    var ranges = cm.listSelections();
    var opening = pos % 2 == 0;

    var type;
    for (var i = 0; i < ranges.length; i++) {
      var range = ranges[i], cur = range.head, curType;
      var next = cm.getRange(cur, Pos(cur.line, cur.ch + 1));
      if (opening && !range.empty()) {
        curType = "surround";
      } else if ((identical || !opening) && next == ch) {
        if (identical && stringStartsAfter(cm, cur))
          curType = "both";
        else if (triples.indexOf(ch) >= 0 && cm.getRange(cur, Pos(cur.line, cur.ch + 3)) == ch + ch + ch)
          curType = "skipThree";
        else
          curType = "skip";
      } else if (identical && cur.ch > 1 && triples.indexOf(ch) >= 0 &&
                 cm.getRange(Pos(cur.line, cur.ch - 2), cur) == ch + ch) {
        if (cur.ch > 2 && /\bstring/.test(cm.getTokenTypeAt(Pos(cur.line, cur.ch - 2)))) return CodeMirror.Pass;
        curType = "addFour";
      } else if (identical) {
        var prev = cur.ch == 0 ? " " : cm.getRange(Pos(cur.line, cur.ch - 1), cur)
        if (!CodeMirror.isWordChar(next) && prev != ch && !CodeMirror.isWordChar(prev)) curType = "both";
        else return CodeMirror.Pass;
      } else if (opening && (next.length === 0 || /\s/.test(next) || closeBefore.indexOf(next) > -1)) {
        curType = "both";
      } else {
        return CodeMirror.Pass;
      }
      if (!type) type = curType;
      else if (type != curType) return CodeMirror.Pass;
    }

    var left = pos % 2 ? pairs.charAt(pos - 1) : ch;
    var right = pos % 2 ? ch : pairs.charAt(pos + 1);
    cm.operation(function() {
      if (type == "skip") {
        cm.execCommand("goCharRight");
      } else if (type == "skipThree") {
        for (var i = 0; i < 3; i++)
          cm.execCommand("goCharRight");
      } else if (type == "surround") {
        var sels = cm.getSelections();
        for (var i = 0; i < sels.length; i++)
          sels[i] = left + sels[i] + right;
        cm.replaceSelections(sels, "around");
        sels = cm.listSelections().slice();
        for (var i = 0; i < sels.length; i++)
          sels[i] = contractSelection(sels[i]);
        cm.setSelections(sels);
      } else if (type == "both") {
        cm.replaceSelection(left + right, null);
        cm.triggerElectric(left + right);
        cm.execCommand("goCharLeft");
      } else if (type == "addFour") {
        cm.replaceSelection(left + left + left + left, "before");
        cm.execCommand("goCharRight");
      }
    });
  }

  function charsAround(cm, pos) {
    var str = cm.getRange(Pos(pos.line, pos.ch - 1),
                          Pos(pos.line, pos.ch + 1));
    return str.length == 2 ? str : null;
  }

  function stringStartsAfter(cm, pos) {
    var token = cm.getTokenAt(Pos(pos.line, pos.ch + 1))
    return /\bstring/.test(token.type) && token.start == pos.ch &&
      (pos.ch == 0 || !/\bstring/.test(cm.getTokenTypeAt(pos)))
  }
});

},{"../../lib/codemirror":101}],95:[function(require,module,exports){
// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    mod(require("../../lib/codemirror"));
  else if (typeof define == "function" && define.amd) // AMD
    define(["../../lib/codemirror"], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function(CodeMirror) {
  var ie_lt8 = /MSIE \d/.test(navigator.userAgent) &&
    (document.documentMode == null || document.documentMode < 8);

  var Pos = CodeMirror.Pos;

  var matching = {"(": ")>", ")": "(<", "[": "]>", "]": "[<", "{": "}>", "}": "{<", "<": ">>", ">": "<<"};

  function bracketRegex(config) {
    return config && config.bracketRegex || /[(){}[\]]/
  }

  function findMatchingBracket(cm, where, config) {
    var line = cm.getLineHandle(where.line), pos = where.ch - 1;
    var afterCursor = config && config.afterCursor
    if (afterCursor == null)
      afterCursor = /(^| )cm-fat-cursor($| )/.test(cm.getWrapperElement().className)
    var re = bracketRegex(config)

    // A cursor is defined as between two characters, but in in vim command mode
    // (i.e. not insert mode), the cursor is visually represented as a
    // highlighted box on top of the 2nd character. Otherwise, we allow matches
    // from before or after the cursor.
    var match = (!afterCursor && pos >= 0 && re.test(line.text.charAt(pos)) && matching[line.text.charAt(pos)]) ||
        re.test(line.text.charAt(pos + 1)) && matching[line.text.charAt(++pos)];
    if (!match) return null;
    var dir = match.charAt(1) == ">" ? 1 : -1;
    if (config && config.strict && (dir > 0) != (pos == where.ch)) return null;
    var style = cm.getTokenTypeAt(Pos(where.line, pos + 1));

    var found = scanForBracket(cm, Pos(where.line, pos + (dir > 0 ? 1 : 0)), dir, style || null, config);
    if (found == null) return null;
    return {from: Pos(where.line, pos), to: found && found.pos,
            match: found && found.ch == match.charAt(0), forward: dir > 0};
  }

  // bracketRegex is used to specify which type of bracket to scan
  // should be a regexp, e.g. /[[\]]/
  //
  // Note: If "where" is on an open bracket, then this bracket is ignored.
  //
  // Returns false when no bracket was found, null when it reached
  // maxScanLines and gave up
  function scanForBracket(cm, where, dir, style, config) {
    var maxScanLen = (config && config.maxScanLineLength) || 10000;
    var maxScanLines = (config && config.maxScanLines) || 1000;

    var stack = [];
    var re = bracketRegex(config)
    var lineEnd = dir > 0 ? Math.min(where.line + maxScanLines, cm.lastLine() + 1)
                          : Math.max(cm.firstLine() - 1, where.line - maxScanLines);
    for (var lineNo = where.line; lineNo != lineEnd; lineNo += dir) {
      var line = cm.getLine(lineNo);
      if (!line) continue;
      var pos = dir > 0 ? 0 : line.length - 1, end = dir > 0 ? line.length : -1;
      if (line.length > maxScanLen) continue;
      if (lineNo == where.line) pos = where.ch - (dir < 0 ? 1 : 0);
      for (; pos != end; pos += dir) {
        var ch = line.charAt(pos);
        if (re.test(ch) && (style === undefined || cm.getTokenTypeAt(Pos(lineNo, pos + 1)) == style)) {
          var match = matching[ch];
          if (match && (match.charAt(1) == ">") == (dir > 0)) stack.push(ch);
          else if (!stack.length) return {pos: Pos(lineNo, pos), ch: ch};
          else stack.pop();
        }
      }
    }
    return lineNo - dir == (dir > 0 ? cm.lastLine() : cm.firstLine()) ? false : null;
  }

  function matchBrackets(cm, autoclear, config) {
    // Disable brace matching in long lines, since it'll cause hugely slow updates
    var maxHighlightLen = cm.state.matchBrackets.maxHighlightLineLength || 1000;
    var marks = [], ranges = cm.listSelections();
    for (var i = 0; i < ranges.length; i++) {
      var match = ranges[i].empty() && findMatchingBracket(cm, ranges[i].head, config);
      if (match && cm.getLine(match.from.line).length <= maxHighlightLen) {
        var style = match.match ? "CodeMirror-matchingbracket" : "CodeMirror-nonmatchingbracket";
        marks.push(cm.markText(match.from, Pos(match.from.line, match.from.ch + 1), {className: style}));
        if (match.to && cm.getLine(match.to.line).length <= maxHighlightLen)
          marks.push(cm.markText(match.to, Pos(match.to.line, match.to.ch + 1), {className: style}));
      }
    }

    if (marks.length) {
      // Kludge to work around the IE bug from issue #1193, where text
      // input stops going to the textare whever this fires.
      if (ie_lt8 && cm.state.focused) cm.focus();

      var clear = function() {
        cm.operation(function() {
          for (var i = 0; i < marks.length; i++) marks[i].clear();
        });
      };
      if (autoclear) setTimeout(clear, 800);
      else return clear;
    }
  }

  function doMatchBrackets(cm) {
    cm.operation(function() {
      if (cm.state.matchBrackets.currentlyHighlighted) {
        cm.state.matchBrackets.currentlyHighlighted();
        cm.state.matchBrackets.currentlyHighlighted = null;
      }
      cm.state.matchBrackets.currentlyHighlighted = matchBrackets(cm, false, cm.state.matchBrackets);
    });
  }

  CodeMirror.defineOption("matchBrackets", false, function(cm, val, old) {
    function clear(cm) {
      if (cm.state.matchBrackets && cm.state.matchBrackets.currentlyHighlighted) {
        cm.state.matchBrackets.currentlyHighlighted();
        cm.state.matchBrackets.currentlyHighlighted = null;
      }
    }

    if (old && old != CodeMirror.Init) {
      cm.off("cursorActivity", doMatchBrackets);
      cm.off("focus", doMatchBrackets)
      cm.off("blur", clear)
      clear(cm);
    }
    if (val) {
      cm.state.matchBrackets = typeof val == "object" ? val : {};
      cm.on("cursorActivity", doMatchBrackets);
      cm.on("focus", doMatchBrackets)
      cm.on("blur", clear)
    }
  });

  CodeMirror.defineExtension("matchBrackets", function() {matchBrackets(this, true);});
  CodeMirror.defineExtension("findMatchingBracket", function(pos, config, oldConfig){
    // Backwards-compatibility kludge
    if (oldConfig || typeof config == "boolean") {
      if (!oldConfig) {
        config = config ? {strict: true} : null
      } else {
        oldConfig.strict = config
        config = oldConfig
      }
    }
    return findMatchingBracket(this, pos, config)
  });
  CodeMirror.defineExtension("scanForBracket", function(pos, dir, style, config){
    return scanForBracket(this, pos, dir, style, config);
  });
});

},{"../../lib/codemirror":101}],96:[function(require,module,exports){
// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    mod(require("../../lib/codemirror"));
  else if (typeof define == "function" && define.amd) // AMD
    define(["../../lib/codemirror"], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function(CodeMirror) {
  "use strict";
  var GUTTER_ID = "CodeMirror-lint-markers";

  function showTooltip(cm, e, content) {
    var tt = document.createElement("div");
    tt.className = "CodeMirror-lint-tooltip cm-s-" + cm.options.theme;
    tt.appendChild(content.cloneNode(true));
    if (cm.state.lint.options.selfContain)
      cm.getWrapperElement().appendChild(tt);
    else
      document.body.appendChild(tt);

    function position(e) {
      if (!tt.parentNode) return CodeMirror.off(document, "mousemove", position);
      tt.style.top = Math.max(0, e.clientY - tt.offsetHeight - 5) + "px";
      tt.style.left = (e.clientX + 5) + "px";
    }
    CodeMirror.on(document, "mousemove", position);
    position(e);
    if (tt.style.opacity != null) tt.style.opacity = 1;
    return tt;
  }
  function rm(elt) {
    if (elt.parentNode) elt.parentNode.removeChild(elt);
  }
  function hideTooltip(tt) {
    if (!tt.parentNode) return;
    if (tt.style.opacity == null) rm(tt);
    tt.style.opacity = 0;
    setTimeout(function() { rm(tt); }, 600);
  }

  function showTooltipFor(cm, e, content, node) {
    var tooltip = showTooltip(cm, e, content);
    function hide() {
      CodeMirror.off(node, "mouseout", hide);
      if (tooltip) { hideTooltip(tooltip); tooltip = null; }
    }
    var poll = setInterval(function() {
      if (tooltip) for (var n = node;; n = n.parentNode) {
        if (n && n.nodeType == 11) n = n.host;
        if (n == document.body) return;
        if (!n) { hide(); break; }
      }
      if (!tooltip) return clearInterval(poll);
    }, 400);
    CodeMirror.on(node, "mouseout", hide);
  }

  function LintState(cm, options, hasGutter) {
    this.marked = [];
    this.options = options;
    this.timeout = null;
    this.hasGutter = hasGutter;
    this.onMouseOver = function(e) { onMouseOver(cm, e); };
    this.waitingFor = 0
  }

  function parseOptions(_cm, options) {
    if (options instanceof Function) return {getAnnotations: options};
    if (!options || options === true) options = {};
    return options;
  }

  function clearMarks(cm) {
    var state = cm.state.lint;
    if (state.hasGutter) cm.clearGutter(GUTTER_ID);
    for (var i = 0; i < state.marked.length; ++i)
      state.marked[i].clear();
    state.marked.length = 0;
  }

  function makeMarker(cm, labels, severity, multiple, tooltips) {
    var marker = document.createElement("div"), inner = marker;
    marker.className = "CodeMirror-lint-marker CodeMirror-lint-marker-" + severity;
    if (multiple) {
      inner = marker.appendChild(document.createElement("div"));
      inner.className = "CodeMirror-lint-marker CodeMirror-lint-marker-multiple";
    }

    if (tooltips != false) CodeMirror.on(inner, "mouseover", function(e) {
      showTooltipFor(cm, e, labels, inner);
    });

    return marker;
  }

  function getMaxSeverity(a, b) {
    if (a == "error") return a;
    else return b;
  }

  function groupByLine(annotations) {
    var lines = [];
    for (var i = 0; i < annotations.length; ++i) {
      var ann = annotations[i], line = ann.from.line;
      (lines[line] || (lines[line] = [])).push(ann);
    }
    return lines;
  }

  function annotationTooltip(ann) {
    var severity = ann.severity;
    if (!severity) severity = "error";
    var tip = document.createElement("div");
    tip.className = "CodeMirror-lint-message CodeMirror-lint-message-" + severity;
    if (typeof ann.messageHTML != 'undefined') {
      tip.innerHTML = ann.messageHTML;
    } else {
      tip.appendChild(document.createTextNode(ann.message));
    }
    return tip;
  }

  function lintAsync(cm, getAnnotations, passOptions) {
    var state = cm.state.lint
    var id = ++state.waitingFor
    function abort() {
      id = -1
      cm.off("change", abort)
    }
    cm.on("change", abort)
    getAnnotations(cm.getValue(), function(annotations, arg2) {
      cm.off("change", abort)
      if (state.waitingFor != id) return
      if (arg2 && annotations instanceof CodeMirror) annotations = arg2
      cm.operation(function() {updateLinting(cm, annotations)})
    }, passOptions, cm);
  }

  function startLinting(cm) {
    var state = cm.state.lint, options = state.options;
    /*
     * Passing rules in `options` property prevents JSHint (and other linters) from complaining
     * about unrecognized rules like `onUpdateLinting`, `delay`, `lintOnChange`, etc.
     */
    var passOptions = options.options || options;
    var getAnnotations = options.getAnnotations || cm.getHelper(CodeMirror.Pos(0, 0), "lint");
    if (!getAnnotations) return;
    if (options.async || getAnnotations.async) {
      lintAsync(cm, getAnnotations, passOptions)
    } else {
      var annotations = getAnnotations(cm.getValue(), passOptions, cm);
      if (!annotations) return;
      if (annotations.then) annotations.then(function(issues) {
        cm.operation(function() {updateLinting(cm, issues)})
      });
      else cm.operation(function() {updateLinting(cm, annotations)})
    }
  }

  function updateLinting(cm, annotationsNotSorted) {
    clearMarks(cm);
    var state = cm.state.lint, options = state.options;

    var annotations = groupByLine(annotationsNotSorted);

    for (var line = 0; line < annotations.length; ++line) {
      var anns = annotations[line];
      if (!anns) continue;

      var maxSeverity = null;
      var tipLabel = state.hasGutter && document.createDocumentFragment();

      for (var i = 0; i < anns.length; ++i) {
        var ann = anns[i];
        var severity = ann.severity;
        if (!severity) severity = "error";
        maxSeverity = getMaxSeverity(maxSeverity, severity);

        if (options.formatAnnotation) ann = options.formatAnnotation(ann);
        if (state.hasGutter) tipLabel.appendChild(annotationTooltip(ann));

        if (ann.to) state.marked.push(cm.markText(ann.from, ann.to, {
          className: "CodeMirror-lint-mark CodeMirror-lint-mark-" + severity,
          __annotation: ann
        }));
      }

      if (state.hasGutter)
        cm.setGutterMarker(line, GUTTER_ID, makeMarker(cm, tipLabel, maxSeverity, anns.length > 1,
                                                       state.options.tooltips));
    }
    if (options.onUpdateLinting) options.onUpdateLinting(annotationsNotSorted, annotations, cm);
  }

  function onChange(cm) {
    var state = cm.state.lint;
    if (!state) return;
    clearTimeout(state.timeout);
    state.timeout = setTimeout(function(){startLinting(cm);}, state.options.delay || 500);
  }

  function popupTooltips(cm, annotations, e) {
    var target = e.target || e.srcElement;
    var tooltip = document.createDocumentFragment();
    for (var i = 0; i < annotations.length; i++) {
      var ann = annotations[i];
      tooltip.appendChild(annotationTooltip(ann));
    }
    showTooltipFor(cm, e, tooltip, target);
  }

  function onMouseOver(cm, e) {
    var target = e.target || e.srcElement;
    if (!/\bCodeMirror-lint-mark-/.test(target.className)) return;
    var box = target.getBoundingClientRect(), x = (box.left + box.right) / 2, y = (box.top + box.bottom) / 2;
    var spans = cm.findMarksAt(cm.coordsChar({left: x, top: y}, "client"));

    var annotations = [];
    for (var i = 0; i < spans.length; ++i) {
      var ann = spans[i].__annotation;
      if (ann) annotations.push(ann);
    }
    if (annotations.length) popupTooltips(cm, annotations, e);
  }

  CodeMirror.defineOption("lint", false, function(cm, val, old) {
    if (old && old != CodeMirror.Init) {
      clearMarks(cm);
      if (cm.state.lint.options.lintOnChange !== false)
        cm.off("change", onChange);
      CodeMirror.off(cm.getWrapperElement(), "mouseover", cm.state.lint.onMouseOver);
      clearTimeout(cm.state.lint.timeout);
      delete cm.state.lint;
    }

    if (val) {
      var gutters = cm.getOption("gutters"), hasLintGutter = false;
      for (var i = 0; i < gutters.length; ++i) if (gutters[i] == GUTTER_ID) hasLintGutter = true;
      var state = cm.state.lint = new LintState(cm, parseOptions(cm, val), hasLintGutter);
      if (state.options.lintOnChange !== false)
        cm.on("change", onChange);
      if (state.options.tooltips != false && state.options.tooltips != "gutter")
        CodeMirror.on(cm.getWrapperElement(), "mouseover", state.onMouseOver);

      startLinting(cm);
    }
  });

  CodeMirror.defineExtension("performLint", function() {
    if (this.state.lint) startLinting(this);
  });
});

},{"../../lib/codemirror":101}],97:[function(require,module,exports){
// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    mod(require("../../lib/codemirror"));
  else if (typeof define == "function" && define.amd) // AMD
    define(["../../lib/codemirror"], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function(CodeMirror) {
"use strict";

CodeMirror.runMode = function(string, modespec, callback, options) {
  var mode = CodeMirror.getMode(CodeMirror.defaults, modespec);
  var tabSize = (options && options.tabSize) || CodeMirror.defaults.tabSize;

  // Create a tokenizing callback function if passed-in callback is a DOM element.
  if (callback.appendChild) {
    var ie = /MSIE \d/.test(navigator.userAgent);
    var ie_lt9 = ie && (document.documentMode == null || document.documentMode < 9);
    var node = callback, col = 0;
    node.innerHTML = "";
    callback = function(text, style) {
      if (text == "\n") {
        // Emitting LF or CRLF on IE8 or earlier results in an incorrect display.
        // Emitting a carriage return makes everything ok.
        node.appendChild(document.createTextNode(ie_lt9 ? '\r' : text));
        col = 0;
        return;
      }
      var content = "";
      // replace tabs
      for (var pos = 0;;) {
        var idx = text.indexOf("\t", pos);
        if (idx == -1) {
          content += text.slice(pos);
          col += text.length - pos;
          break;
        } else {
          col += idx - pos;
          content += text.slice(pos, idx);
          var size = tabSize - col % tabSize;
          col += size;
          for (var i = 0; i < size; ++i) content += " ";
          pos = idx + 1;
        }
      }
      // Create a node with token style and append it to the callback DOM element.
      if (style) {
        var sp = node.appendChild(document.createElement("span"));
        sp.className = "cm-" + style.replace(/ +/g, " cm-");
        sp.appendChild(document.createTextNode(content));
      } else {
        node.appendChild(document.createTextNode(content));
      }
    };
  }

  var lines = CodeMirror.splitLines(string), state = (options && options.state) || CodeMirror.startState(mode);
  for (var i = 0, e = lines.length; i < e; ++i) {
    if (i) callback("\n");
    var stream = new CodeMirror.StringStream(lines[i], null, {
      lookAhead: function(n) { return lines[i + n] },
      baseToken: function() {}
    });
    if (!stream.string && mode.blankLine) mode.blankLine(state);
    while (!stream.eol()) {
      var style = mode.token(stream, state);
      callback(stream.current(), style, i, stream.start, state);
      stream.start = stream.pos;
    }
  }
};

});

},{"../../lib/codemirror":101}],98:[function(require,module,exports){
// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    mod(require("../../lib/codemirror"))
  else if (typeof define == "function" && define.amd) // AMD
    define(["../../lib/codemirror"], mod)
  else // Plain browser env
    mod(CodeMirror)
})(function(CodeMirror) {
  "use strict"
  var Pos = CodeMirror.Pos

  function regexpFlags(regexp) {
    var flags = regexp.flags
    return flags != null ? flags : (regexp.ignoreCase ? "i" : "")
      + (regexp.global ? "g" : "")
      + (regexp.multiline ? "m" : "")
  }

  function ensureFlags(regexp, flags) {
    var current = regexpFlags(regexp), target = current
    for (var i = 0; i < flags.length; i++) if (target.indexOf(flags.charAt(i)) == -1)
      target += flags.charAt(i)
    return current == target ? regexp : new RegExp(regexp.source, target)
  }

  function maybeMultiline(regexp) {
    return /\\s|\\n|\n|\\W|\\D|\[\^/.test(regexp.source)
  }

  function searchRegexpForward(doc, regexp, start) {
    regexp = ensureFlags(regexp, "g")
    for (var line = start.line, ch = start.ch, last = doc.lastLine(); line <= last; line++, ch = 0) {
      regexp.lastIndex = ch
      var string = doc.getLine(line), match = regexp.exec(string)
      if (match)
        return {from: Pos(line, match.index),
                to: Pos(line, match.index + match[0].length),
                match: match}
    }
  }

  function searchRegexpForwardMultiline(doc, regexp, start) {
    if (!maybeMultiline(regexp)) return searchRegexpForward(doc, regexp, start)

    regexp = ensureFlags(regexp, "gm")
    var string, chunk = 1
    for (var line = start.line, last = doc.lastLine(); line <= last;) {
      // This grows the search buffer in exponentially-sized chunks
      // between matches, so that nearby matches are fast and don't
      // require concatenating the whole document (in case we're
      // searching for something that has tons of matches), but at the
      // same time, the amount of retries is limited.
      for (var i = 0; i < chunk; i++) {
        if (line > last) break
        var curLine = doc.getLine(line++)
        string = string == null ? curLine : string + "\n" + curLine
      }
      chunk = chunk * 2
      regexp.lastIndex = start.ch
      var match = regexp.exec(string)
      if (match) {
        var before = string.slice(0, match.index).split("\n"), inside = match[0].split("\n")
        var startLine = start.line + before.length - 1, startCh = before[before.length - 1].length
        return {from: Pos(startLine, startCh),
                to: Pos(startLine + inside.length - 1,
                        inside.length == 1 ? startCh + inside[0].length : inside[inside.length - 1].length),
                match: match}
      }
    }
  }

  function lastMatchIn(string, regexp, endMargin) {
    var match, from = 0
    while (from <= string.length) {
      regexp.lastIndex = from
      var newMatch = regexp.exec(string)
      if (!newMatch) break
      var end = newMatch.index + newMatch[0].length
      if (end > string.length - endMargin) break
      if (!match || end > match.index + match[0].length)
        match = newMatch
      from = newMatch.index + 1
    }
    return match
  }

  function searchRegexpBackward(doc, regexp, start) {
    regexp = ensureFlags(regexp, "g")
    for (var line = start.line, ch = start.ch, first = doc.firstLine(); line >= first; line--, ch = -1) {
      var string = doc.getLine(line)
      var match = lastMatchIn(string, regexp, ch < 0 ? 0 : string.length - ch)
      if (match)
        return {from: Pos(line, match.index),
                to: Pos(line, match.index + match[0].length),
                match: match}
    }
  }

  function searchRegexpBackwardMultiline(doc, regexp, start) {
    if (!maybeMultiline(regexp)) return searchRegexpBackward(doc, regexp, start)
    regexp = ensureFlags(regexp, "gm")
    var string, chunkSize = 1, endMargin = doc.getLine(start.line).length - start.ch
    for (var line = start.line, first = doc.firstLine(); line >= first;) {
      for (var i = 0; i < chunkSize && line >= first; i++) {
        var curLine = doc.getLine(line--)
        string = string == null ? curLine : curLine + "\n" + string
      }
      chunkSize *= 2

      var match = lastMatchIn(string, regexp, endMargin)
      if (match) {
        var before = string.slice(0, match.index).split("\n"), inside = match[0].split("\n")
        var startLine = line + before.length, startCh = before[before.length - 1].length
        return {from: Pos(startLine, startCh),
                to: Pos(startLine + inside.length - 1,
                        inside.length == 1 ? startCh + inside[0].length : inside[inside.length - 1].length),
                match: match}
      }
    }
  }

  var doFold, noFold
  if (String.prototype.normalize) {
    doFold = function(str) { return str.normalize("NFD").toLowerCase() }
    noFold = function(str) { return str.normalize("NFD") }
  } else {
    doFold = function(str) { return str.toLowerCase() }
    noFold = function(str) { return str }
  }

  // Maps a position in a case-folded line back to a position in the original line
  // (compensating for codepoints increasing in number during folding)
  function adjustPos(orig, folded, pos, foldFunc) {
    if (orig.length == folded.length) return pos
    for (var min = 0, max = pos + Math.max(0, orig.length - folded.length);;) {
      if (min == max) return min
      var mid = (min + max) >> 1
      var len = foldFunc(orig.slice(0, mid)).length
      if (len == pos) return mid
      else if (len > pos) max = mid
      else min = mid + 1
    }
  }

  function searchStringForward(doc, query, start, caseFold) {
    // Empty string would match anything and never progress, so we
    // define it to match nothing instead.
    if (!query.length) return null
    var fold = caseFold ? doFold : noFold
    var lines = fold(query).split(/\r|\n\r?/)

    search: for (var line = start.line, ch = start.ch, last = doc.lastLine() + 1 - lines.length; line <= last; line++, ch = 0) {
      var orig = doc.getLine(line).slice(ch), string = fold(orig)
      if (lines.length == 1) {
        var found = string.indexOf(lines[0])
        if (found == -1) continue search
        var start = adjustPos(orig, string, found, fold) + ch
        return {from: Pos(line, adjustPos(orig, string, found, fold) + ch),
                to: Pos(line, adjustPos(orig, string, found + lines[0].length, fold) + ch)}
      } else {
        var cutFrom = string.length - lines[0].length
        if (string.slice(cutFrom) != lines[0]) continue search
        for (var i = 1; i < lines.length - 1; i++)
          if (fold(doc.getLine(line + i)) != lines[i]) continue search
        var end = doc.getLine(line + lines.length - 1), endString = fold(end), lastLine = lines[lines.length - 1]
        if (endString.slice(0, lastLine.length) != lastLine) continue search
        return {from: Pos(line, adjustPos(orig, string, cutFrom, fold) + ch),
                to: Pos(line + lines.length - 1, adjustPos(end, endString, lastLine.length, fold))}
      }
    }
  }

  function searchStringBackward(doc, query, start, caseFold) {
    if (!query.length) return null
    var fold = caseFold ? doFold : noFold
    var lines = fold(query).split(/\r|\n\r?/)

    search: for (var line = start.line, ch = start.ch, first = doc.firstLine() - 1 + lines.length; line >= first; line--, ch = -1) {
      var orig = doc.getLine(line)
      if (ch > -1) orig = orig.slice(0, ch)
      var string = fold(orig)
      if (lines.length == 1) {
        var found = string.lastIndexOf(lines[0])
        if (found == -1) continue search
        return {from: Pos(line, adjustPos(orig, string, found, fold)),
                to: Pos(line, adjustPos(orig, string, found + lines[0].length, fold))}
      } else {
        var lastLine = lines[lines.length - 1]
        if (string.slice(0, lastLine.length) != lastLine) continue search
        for (var i = 1, start = line - lines.length + 1; i < lines.length - 1; i++)
          if (fold(doc.getLine(start + i)) != lines[i]) continue search
        var top = doc.getLine(line + 1 - lines.length), topString = fold(top)
        if (topString.slice(topString.length - lines[0].length) != lines[0]) continue search
        return {from: Pos(line + 1 - lines.length, adjustPos(top, topString, top.length - lines[0].length, fold)),
                to: Pos(line, adjustPos(orig, string, lastLine.length, fold))}
      }
    }
  }

  function SearchCursor(doc, query, pos, options) {
    this.atOccurrence = false
    this.doc = doc
    pos = pos ? doc.clipPos(pos) : Pos(0, 0)
    this.pos = {from: pos, to: pos}

    var caseFold
    if (typeof options == "object") {
      caseFold = options.caseFold
    } else { // Backwards compat for when caseFold was the 4th argument
      caseFold = options
      options = null
    }

    if (typeof query == "string") {
      if (caseFold == null) caseFold = false
      this.matches = function(reverse, pos) {
        return (reverse ? searchStringBackward : searchStringForward)(doc, query, pos, caseFold)
      }
    } else {
      query = ensureFlags(query, "gm")
      if (!options || options.multiline !== false)
        this.matches = function(reverse, pos) {
          return (reverse ? searchRegexpBackwardMultiline : searchRegexpForwardMultiline)(doc, query, pos)
        }
      else
        this.matches = function(reverse, pos) {
          return (reverse ? searchRegexpBackward : searchRegexpForward)(doc, query, pos)
        }
    }
  }

  SearchCursor.prototype = {
    findNext: function() {return this.find(false)},
    findPrevious: function() {return this.find(true)},

    find: function(reverse) {
      var result = this.matches(reverse, this.doc.clipPos(reverse ? this.pos.from : this.pos.to))

      // Implements weird auto-growing behavior on null-matches for
      // backwards-compatibility with the vim code (unfortunately)
      while (result && CodeMirror.cmpPos(result.from, result.to) == 0) {
        if (reverse) {
          if (result.from.ch) result.from = Pos(result.from.line, result.from.ch - 1)
          else if (result.from.line == this.doc.firstLine()) result = null
          else result = this.matches(reverse, this.doc.clipPos(Pos(result.from.line - 1)))
        } else {
          if (result.to.ch < this.doc.getLine(result.to.line).length) result.to = Pos(result.to.line, result.to.ch + 1)
          else if (result.to.line == this.doc.lastLine()) result = null
          else result = this.matches(reverse, Pos(result.to.line + 1, 0))
        }
      }

      if (result) {
        this.pos = result
        this.atOccurrence = true
        return this.pos.match || true
      } else {
        var end = Pos(reverse ? this.doc.firstLine() : this.doc.lastLine() + 1, 0)
        this.pos = {from: end, to: end}
        return this.atOccurrence = false
      }
    },

    from: function() {if (this.atOccurrence) return this.pos.from},
    to: function() {if (this.atOccurrence) return this.pos.to},

    replace: function(newText, origin) {
      if (!this.atOccurrence) return
      var lines = CodeMirror.splitLines(newText)
      this.doc.replaceRange(lines, this.pos.from, this.pos.to, origin)
      this.pos.to = Pos(this.pos.from.line + lines.length - 1,
                        lines[lines.length - 1].length + (lines.length == 1 ? this.pos.from.ch : 0))
    }
  }

  CodeMirror.defineExtension("getSearchCursor", function(query, pos, caseFold) {
    return new SearchCursor(this.doc, query, pos, caseFold)
  })
  CodeMirror.defineDocExtension("getSearchCursor", function(query, pos, caseFold) {
    return new SearchCursor(this, query, pos, caseFold)
  })

  CodeMirror.defineExtension("selectMatches", function(query, caseFold) {
    var ranges = []
    var cur = this.getSearchCursor(query, this.getCursor("from"), caseFold)
    while (cur.findNext()) {
      if (CodeMirror.cmpPos(cur.to(), this.getCursor("to")) > 0) break
      ranges.push({anchor: cur.from(), head: cur.to()})
    }
    if (ranges.length)
      this.setSelections(ranges, 0)
  })
});

},{"../../lib/codemirror":101}],99:[function(require,module,exports){
// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    mod(require("../../lib/codemirror"));
  else if (typeof define == "function" && define.amd) // AMD
    define(["../../lib/codemirror"], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function(CodeMirror) {
  "use strict";
  var WRAP_CLASS = "CodeMirror-activeline";
  var BACK_CLASS = "CodeMirror-activeline-background";
  var GUTT_CLASS = "CodeMirror-activeline-gutter";

  CodeMirror.defineOption("styleActiveLine", false, function(cm, val, old) {
    var prev = old == CodeMirror.Init ? false : old;
    if (val == prev) return
    if (prev) {
      cm.off("beforeSelectionChange", selectionChange);
      clearActiveLines(cm);
      delete cm.state.activeLines;
    }
    if (val) {
      cm.state.activeLines = [];
      updateActiveLines(cm, cm.listSelections());
      cm.on("beforeSelectionChange", selectionChange);
    }
  });

  function clearActiveLines(cm) {
    for (var i = 0; i < cm.state.activeLines.length; i++) {
      cm.removeLineClass(cm.state.activeLines[i], "wrap", WRAP_CLASS);
      cm.removeLineClass(cm.state.activeLines[i], "background", BACK_CLASS);
      cm.removeLineClass(cm.state.activeLines[i], "gutter", GUTT_CLASS);
    }
  }

  function sameArray(a, b) {
    if (a.length != b.length) return false;
    for (var i = 0; i < a.length; i++)
      if (a[i] != b[i]) return false;
    return true;
  }

  function updateActiveLines(cm, ranges) {
    var active = [];
    for (var i = 0; i < ranges.length; i++) {
      var range = ranges[i];
      var option = cm.getOption("styleActiveLine");
      if (typeof option == "object" && option.nonEmpty ? range.anchor.line != range.head.line : !range.empty())
        continue
      var line = cm.getLineHandleVisualStart(range.head.line);
      if (active[active.length - 1] != line) active.push(line);
    }
    if (sameArray(cm.state.activeLines, active)) return;
    cm.operation(function() {
      clearActiveLines(cm);
      for (var i = 0; i < active.length; i++) {
        cm.addLineClass(active[i], "wrap", WRAP_CLASS);
        cm.addLineClass(active[i], "background", BACK_CLASS);
        cm.addLineClass(active[i], "gutter", GUTT_CLASS);
      }
      cm.state.activeLines = active;
    });
  }

  function selectionChange(cm, sel) {
    updateActiveLines(cm, sel.ranges);
  }
});

},{"../../lib/codemirror":101}],100:[function(require,module,exports){
// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

/**
 * Supported keybindings:
 *   Too many to list. Refer to defaultKeymap below.
 *
 * Supported Ex commands:
 *   Refer to defaultExCommandMap below.
 *
 * Registers: unnamed, -, ., :, /, _, a-z, A-Z, 0-9
 *   (Does not respect the special case for number registers when delete
 *    operator is made with these commands: %, (, ),  , /, ?, n, N, {, } )
 *   TODO: Implement the remaining registers.
 *
 * Marks: a-z, A-Z, and 0-9
 *   TODO: Implement the remaining special marks. They have more complex
 *       behavior.
 *
 * Events:
 *  'vim-mode-change' - raised on the editor anytime the current mode changes,
 *                      Event object: {mode: "visual", subMode: "linewise"}
 *
 * Code structure:
 *  1. Default keymap
 *  2. Variable declarations and short basic helpers
 *  3. Instance (External API) implementation
 *  4. Internal state tracking objects (input state, counter) implementation
 *     and instantiation
 *  5. Key handler (the main command dispatcher) implementation
 *  6. Motion, operator, and action implementations
 *  7. Helper functions for the key handler, motions, operators, and actions
 *  8. Set up Vim to work as a keymap for CodeMirror.
 *  9. Ex command implementations.
 */

(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    mod(require("../lib/codemirror"), require("../addon/search/searchcursor"), require("../addon/dialog/dialog"), require("../addon/edit/matchbrackets.js"));
  else if (typeof define == "function" && define.amd) // AMD
    define(["../lib/codemirror", "../addon/search/searchcursor", "../addon/dialog/dialog", "../addon/edit/matchbrackets"], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function(CodeMirror) {
  'use strict';

  var defaultKeymap = [
    // Key to key mapping. This goes first to make it possible to override
    // existing mappings.
    { keys: '<Left>', type: 'keyToKey', toKeys: 'h' },
    { keys: '<Right>', type: 'keyToKey', toKeys: 'l' },
    { keys: '<Up>', type: 'keyToKey', toKeys: 'k' },
    { keys: '<Down>', type: 'keyToKey', toKeys: 'j' },
    { keys: '<Space>', type: 'keyToKey', toKeys: 'l' },
    { keys: '<BS>', type: 'keyToKey', toKeys: 'h', context: 'normal'},
    { keys: '<Del>', type: 'keyToKey', toKeys: 'x', context: 'normal'},
    { keys: '<C-Space>', type: 'keyToKey', toKeys: 'W' },
    { keys: '<C-BS>', type: 'keyToKey', toKeys: 'B', context: 'normal' },
    { keys: '<S-Space>', type: 'keyToKey', toKeys: 'w' },
    { keys: '<S-BS>', type: 'keyToKey', toKeys: 'b', context: 'normal' },
    { keys: '<C-n>', type: 'keyToKey', toKeys: 'j' },
    { keys: '<C-p>', type: 'keyToKey', toKeys: 'k' },
    { keys: '<C-[>', type: 'keyToKey', toKeys: '<Esc>' },
    { keys: '<C-c>', type: 'keyToKey', toKeys: '<Esc>' },
    { keys: '<C-[>', type: 'keyToKey', toKeys: '<Esc>', context: 'insert' },
    { keys: '<C-c>', type: 'keyToKey', toKeys: '<Esc>', context: 'insert' },
    { keys: 's', type: 'keyToKey', toKeys: 'cl', context: 'normal' },
    { keys: 's', type: 'keyToKey', toKeys: 'c', context: 'visual'},
    { keys: 'S', type: 'keyToKey', toKeys: 'cc', context: 'normal' },
    { keys: 'S', type: 'keyToKey', toKeys: 'VdO', context: 'visual' },
    { keys: '<Home>', type: 'keyToKey', toKeys: '0' },
    { keys: '<End>', type: 'keyToKey', toKeys: '$' },
    { keys: '<PageUp>', type: 'keyToKey', toKeys: '<C-b>' },
    { keys: '<PageDown>', type: 'keyToKey', toKeys: '<C-f>' },
    { keys: '<CR>', type: 'keyToKey', toKeys: 'j^', context: 'normal' },
    { keys: '<Ins>', type: 'action', action: 'toggleOverwrite', context: 'insert' },
    // Motions
    { keys: 'H', type: 'motion', motion: 'moveToTopLine', motionArgs: { linewise: true, toJumplist: true }},
    { keys: 'M', type: 'motion', motion: 'moveToMiddleLine', motionArgs: { linewise: true, toJumplist: true }},
    { keys: 'L', type: 'motion', motion: 'moveToBottomLine', motionArgs: { linewise: true, toJumplist: true }},
    { keys: 'h', type: 'motion', motion: 'moveByCharacters', motionArgs: { forward: false }},
    { keys: 'l', type: 'motion', motion: 'moveByCharacters', motionArgs: { forward: true }},
    { keys: 'j', type: 'motion', motion: 'moveByLines', motionArgs: { forward: true, linewise: true }},
    { keys: 'k', type: 'motion', motion: 'moveByLines', motionArgs: { forward: false, linewise: true }},
    { keys: 'gj', type: 'motion', motion: 'moveByDisplayLines', motionArgs: { forward: true }},
    { keys: 'gk', type: 'motion', motion: 'moveByDisplayLines', motionArgs: { forward: false }},
    { keys: 'w', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: false }},
    { keys: 'W', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: false, bigWord: true }},
    { keys: 'e', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: true, inclusive: true }},
    { keys: 'E', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: true, bigWord: true, inclusive: true }},
    { keys: 'b', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: false }},
    { keys: 'B', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: false, bigWord: true }},
    { keys: 'ge', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: true, inclusive: true }},
    { keys: 'gE', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: true, bigWord: true, inclusive: true }},
    { keys: '{', type: 'motion', motion: 'moveByParagraph', motionArgs: { forward: false, toJumplist: true }},
    { keys: '}', type: 'motion', motion: 'moveByParagraph', motionArgs: { forward: true, toJumplist: true }},
    { keys: '(', type: 'motion', motion: 'moveBySentence', motionArgs: { forward: false }},
    { keys: ')', type: 'motion', motion: 'moveBySentence', motionArgs: { forward: true }},
    { keys: '<C-f>', type: 'motion', motion: 'moveByPage', motionArgs: { forward: true }},
    { keys: '<C-b>', type: 'motion', motion: 'moveByPage', motionArgs: { forward: false }},
    { keys: '<C-d>', type: 'motion', motion: 'moveByScroll', motionArgs: { forward: true, explicitRepeat: true }},
    { keys: '<C-u>', type: 'motion', motion: 'moveByScroll', motionArgs: { forward: false, explicitRepeat: true }},
    { keys: 'gg', type: 'motion', motion: 'moveToLineOrEdgeOfDocument', motionArgs: { forward: false, explicitRepeat: true, linewise: true, toJumplist: true }},
    { keys: 'G', type: 'motion', motion: 'moveToLineOrEdgeOfDocument', motionArgs: { forward: true, explicitRepeat: true, linewise: true, toJumplist: true }},
    { keys: '0', type: 'motion', motion: 'moveToStartOfLine' },
    { keys: '^', type: 'motion', motion: 'moveToFirstNonWhiteSpaceCharacter' },
    { keys: '+', type: 'motion', motion: 'moveByLines', motionArgs: { forward: true, toFirstChar:true }},
    { keys: '-', type: 'motion', motion: 'moveByLines', motionArgs: { forward: false, toFirstChar:true }},
    { keys: '_', type: 'motion', motion: 'moveByLines', motionArgs: { forward: true, toFirstChar:true, repeatOffset:-1 }},
    { keys: '$', type: 'motion', motion: 'moveToEol', motionArgs: { inclusive: true }},
    { keys: '%', type: 'motion', motion: 'moveToMatchedSymbol', motionArgs: { inclusive: true, toJumplist: true }},
    { keys: 'f<character>', type: 'motion', motion: 'moveToCharacter', motionArgs: { forward: true , inclusive: true }},
    { keys: 'F<character>', type: 'motion', motion: 'moveToCharacter', motionArgs: { forward: false }},
    { keys: 't<character>', type: 'motion', motion: 'moveTillCharacter', motionArgs: { forward: true, inclusive: true }},
    { keys: 'T<character>', type: 'motion', motion: 'moveTillCharacter', motionArgs: { forward: false }},
    { keys: ';', type: 'motion', motion: 'repeatLastCharacterSearch', motionArgs: { forward: true }},
    { keys: ',', type: 'motion', motion: 'repeatLastCharacterSearch', motionArgs: { forward: false }},
    { keys: '\'<character>', type: 'motion', motion: 'goToMark', motionArgs: {toJumplist: true, linewise: true}},
    { keys: '`<character>', type: 'motion', motion: 'goToMark', motionArgs: {toJumplist: true}},
    { keys: ']`', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: true } },
    { keys: '[`', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: false } },
    { keys: ']\'', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: true, linewise: true } },
    { keys: '[\'', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: false, linewise: true } },
    // the next two aren't motions but must come before more general motion declarations
    { keys: ']p', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: true, isEdit: true, matchIndent: true}},
    { keys: '[p', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: false, isEdit: true, matchIndent: true}},
    { keys: ']<character>', type: 'motion', motion: 'moveToSymbol', motionArgs: { forward: true, toJumplist: true}},
    { keys: '[<character>', type: 'motion', motion: 'moveToSymbol', motionArgs: { forward: false, toJumplist: true}},
    { keys: '|', type: 'motion', motion: 'moveToColumn'},
    { keys: 'o', type: 'motion', motion: 'moveToOtherHighlightedEnd', context:'visual'},
    { keys: 'O', type: 'motion', motion: 'moveToOtherHighlightedEnd', motionArgs: {sameLine: true}, context:'visual'},
    // Operators
    { keys: 'd', type: 'operator', operator: 'delete' },
    { keys: 'y', type: 'operator', operator: 'yank' },
    { keys: 'c', type: 'operator', operator: 'change' },
    { keys: '=', type: 'operator', operator: 'indentAuto' },
    { keys: '>', type: 'operator', operator: 'indent', operatorArgs: { indentRight: true }},
    { keys: '<', type: 'operator', operator: 'indent', operatorArgs: { indentRight: false }},
    { keys: 'g~', type: 'operator', operator: 'changeCase' },
    { keys: 'gu', type: 'operator', operator: 'changeCase', operatorArgs: {toLower: true}, isEdit: true },
    { keys: 'gU', type: 'operator', operator: 'changeCase', operatorArgs: {toLower: false}, isEdit: true },
    { keys: 'n', type: 'motion', motion: 'findNext', motionArgs: { forward: true, toJumplist: true }},
    { keys: 'N', type: 'motion', motion: 'findNext', motionArgs: { forward: false, toJumplist: true }},
    { keys: 'gn', type: 'motion', motion: 'findAndSelectNextInclusive', motionArgs: { forward: true }},
    { keys: 'gN', type: 'motion', motion: 'findAndSelectNextInclusive', motionArgs: { forward: false }},
    // Operator-Motion dual commands
    { keys: 'x', type: 'operatorMotion', operator: 'delete', motion: 'moveByCharacters', motionArgs: { forward: true }, operatorMotionArgs: { visualLine: false }},
    { keys: 'X', type: 'operatorMotion', operator: 'delete', motion: 'moveByCharacters', motionArgs: { forward: false }, operatorMotionArgs: { visualLine: true }},
    { keys: 'D', type: 'operatorMotion', operator: 'delete', motion: 'moveToEol', motionArgs: { inclusive: true }, context: 'normal'},
    { keys: 'D', type: 'operator', operator: 'delete', operatorArgs: { linewise: true }, context: 'visual'},
    { keys: 'Y', type: 'operatorMotion', operator: 'yank', motion: 'expandToLine', motionArgs: { linewise: true }, context: 'normal'},
    { keys: 'Y', type: 'operator', operator: 'yank', operatorArgs: { linewise: true }, context: 'visual'},
    { keys: 'C', type: 'operatorMotion', operator: 'change', motion: 'moveToEol', motionArgs: { inclusive: true }, context: 'normal'},
    { keys: 'C', type: 'operator', operator: 'change', operatorArgs: { linewise: true }, context: 'visual'},
    { keys: '~', type: 'operatorMotion', operator: 'changeCase', motion: 'moveByCharacters', motionArgs: { forward: true }, operatorArgs: { shouldMoveCursor: true }, context: 'normal'},
    { keys: '~', type: 'operator', operator: 'changeCase', context: 'visual'},
    { keys: '<C-w>', type: 'operatorMotion', operator: 'delete', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: false }, context: 'insert' },
    //ignore C-w in normal mode
    { keys: '<C-w>', type: 'idle', context: 'normal' },
    // Actions
    { keys: '<C-i>', type: 'action', action: 'jumpListWalk', actionArgs: { forward: true }},
    { keys: '<C-o>', type: 'action', action: 'jumpListWalk', actionArgs: { forward: false }},
    { keys: '<C-e>', type: 'action', action: 'scroll', actionArgs: { forward: true, linewise: true }},
    { keys: '<C-y>', type: 'action', action: 'scroll', actionArgs: { forward: false, linewise: true }},
    { keys: 'a', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'charAfter' }, context: 'normal' },
    { keys: 'A', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'eol' }, context: 'normal' },
    { keys: 'A', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'endOfSelectedArea' }, context: 'visual' },
    { keys: 'i', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'inplace' }, context: 'normal' },
    { keys: 'gi', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'lastEdit' }, context: 'normal' },
    { keys: 'I', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'firstNonBlank'}, context: 'normal' },
    { keys: 'gI', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'bol'}, context: 'normal' },
    { keys: 'I', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'startOfSelectedArea' }, context: 'visual' },
    { keys: 'o', type: 'action', action: 'newLineAndEnterInsertMode', isEdit: true, interlaceInsertRepeat: true, actionArgs: { after: true }, context: 'normal' },
    { keys: 'O', type: 'action', action: 'newLineAndEnterInsertMode', isEdit: true, interlaceInsertRepeat: true, actionArgs: { after: false }, context: 'normal' },
    { keys: 'v', type: 'action', action: 'toggleVisualMode' },
    { keys: 'V', type: 'action', action: 'toggleVisualMode', actionArgs: { linewise: true }},
    { keys: '<C-v>', type: 'action', action: 'toggleVisualMode', actionArgs: { blockwise: true }},
    { keys: '<C-q>', type: 'action', action: 'toggleVisualMode', actionArgs: { blockwise: true }},
    { keys: 'gv', type: 'action', action: 'reselectLastSelection' },
    { keys: 'J', type: 'action', action: 'joinLines', isEdit: true },
    { keys: 'gJ', type: 'action', action: 'joinLines', actionArgs: { keepSpaces: true }, isEdit: true },
    { keys: 'p', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: true, isEdit: true }},
    { keys: 'P', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: false, isEdit: true }},
    { keys: 'r<character>', type: 'action', action: 'replace', isEdit: true },
    { keys: '@<character>', type: 'action', action: 'replayMacro' },
    { keys: 'q<character>', type: 'action', action: 'enterMacroRecordMode' },
    // Handle Replace-mode as a special case of insert mode.
    { keys: 'R', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { replace: true }, context: 'normal'},
    { keys: 'R', type: 'operator', operator: 'change', operatorArgs: { linewise: true, fullLine: true }, context: 'visual', exitVisualBlock: true},
    { keys: 'u', type: 'action', action: 'undo', context: 'normal' },
    { keys: 'u', type: 'operator', operator: 'changeCase', operatorArgs: {toLower: true}, context: 'visual', isEdit: true },
    { keys: 'U', type: 'operator', operator: 'changeCase', operatorArgs: {toLower: false}, context: 'visual', isEdit: true },
    { keys: '<C-r>', type: 'action', action: 'redo' },
    { keys: 'm<character>', type: 'action', action: 'setMark' },
    { keys: '"<character>', type: 'action', action: 'setRegister' },
    { keys: 'zz', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'center' }},
    { keys: 'z.', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'center' }, motion: 'moveToFirstNonWhiteSpaceCharacter' },
    { keys: 'zt', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'top' }},
    { keys: 'z<CR>', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'top' }, motion: 'moveToFirstNonWhiteSpaceCharacter' },
    { keys: 'z-', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'bottom' }},
    { keys: 'zb', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'bottom' }, motion: 'moveToFirstNonWhiteSpaceCharacter' },
    { keys: '.', type: 'action', action: 'repeatLastEdit' },
    { keys: '<C-a>', type: 'action', action: 'incrementNumberToken', isEdit: true, actionArgs: {increase: true, backtrack: false}},
    { keys: '<C-x>', type: 'action', action: 'incrementNumberToken', isEdit: true, actionArgs: {increase: false, backtrack: false}},
    { keys: '<C-t>', type: 'action', action: 'indent', actionArgs: { indentRight: true }, context: 'insert' },
    { keys: '<C-d>', type: 'action', action: 'indent', actionArgs: { indentRight: false }, context: 'insert' },
    // Text object motions
    { keys: 'a<character>', type: 'motion', motion: 'textObjectManipulation' },
    { keys: 'i<character>', type: 'motion', motion: 'textObjectManipulation', motionArgs: { textObjectInner: true }},
    // Search
    { keys: '/', type: 'search', searchArgs: { forward: true, querySrc: 'prompt', toJumplist: true }},
    { keys: '?', type: 'search', searchArgs: { forward: false, querySrc: 'prompt', toJumplist: true }},
    { keys: '*', type: 'search', searchArgs: { forward: true, querySrc: 'wordUnderCursor', wholeWordOnly: true, toJumplist: true }},
    { keys: '#', type: 'search', searchArgs: { forward: false, querySrc: 'wordUnderCursor', wholeWordOnly: true, toJumplist: true }},
    { keys: 'g*', type: 'search', searchArgs: { forward: true, querySrc: 'wordUnderCursor', toJumplist: true }},
    { keys: 'g#', type: 'search', searchArgs: { forward: false, querySrc: 'wordUnderCursor', toJumplist: true }},
    // Ex command
    { keys: ':', type: 'ex' }
  ];
  var defaultKeymapLength = defaultKeymap.length;

  /**
   * Ex commands
   * Care must be taken when adding to the default Ex command map. For any
   * pair of commands that have a shared prefix, at least one of their
   * shortNames must not match the prefix of the other command.
   */
  var defaultExCommandMap = [
    { name: 'colorscheme', shortName: 'colo' },
    { name: 'map' },
    { name: 'imap', shortName: 'im' },
    { name: 'nmap', shortName: 'nm' },
    { name: 'vmap', shortName: 'vm' },
    { name: 'unmap' },
    { name: 'write', shortName: 'w' },
    { name: 'undo', shortName: 'u' },
    { name: 'redo', shortName: 'red' },
    { name: 'set', shortName: 'se' },
    { name: 'setlocal', shortName: 'setl' },
    { name: 'setglobal', shortName: 'setg' },
    { name: 'sort', shortName: 'sor' },
    { name: 'substitute', shortName: 's', possiblyAsync: true },
    { name: 'nohlsearch', shortName: 'noh' },
    { name: 'yank', shortName: 'y' },
    { name: 'delmarks', shortName: 'delm' },
    { name: 'registers', shortName: 'reg', excludeFromCommandHistory: true },
    { name: 'global', shortName: 'g' }
  ];

  var Pos = CodeMirror.Pos;

  var Vim = function() {
    function enterVimMode(cm) {
      cm.setOption('disableInput', true);
      cm.setOption('showCursorWhenSelecting', false);
      CodeMirror.signal(cm, "vim-mode-change", {mode: "normal"});
      cm.on('cursorActivity', onCursorActivity);
      maybeInitVimState(cm);
      CodeMirror.on(cm.getInputField(), 'paste', getOnPasteFn(cm));
    }

    function leaveVimMode(cm) {
      cm.setOption('disableInput', false);
      cm.off('cursorActivity', onCursorActivity);
      CodeMirror.off(cm.getInputField(), 'paste', getOnPasteFn(cm));
      cm.state.vim = null;
    }

    function detachVimMap(cm, next) {
      if (this == CodeMirror.keyMap.vim) {
        CodeMirror.rmClass(cm.getWrapperElement(), "cm-fat-cursor");
        if (cm.getOption("inputStyle") == "contenteditable" && document.body.style.caretColor != null) {
          disableFatCursorMark(cm);
          cm.getInputField().style.caretColor = "";
        }
      }

      if (!next || next.attach != attachVimMap)
        leaveVimMode(cm);
    }
    function attachVimMap(cm, prev) {
      if (this == CodeMirror.keyMap.vim) {
        CodeMirror.addClass(cm.getWrapperElement(), "cm-fat-cursor");
        if (cm.getOption("inputStyle") == "contenteditable" && document.body.style.caretColor != null) {
          enableFatCursorMark(cm);
          cm.getInputField().style.caretColor = "transparent";
        }
      }

      if (!prev || prev.attach != attachVimMap)
        enterVimMode(cm);
    }

    function updateFatCursorMark(cm) {
      if (!cm.state.fatCursorMarks) return;
      clearFatCursorMark(cm);
      var ranges = cm.listSelections(), result = []
      for (var i = 0; i < ranges.length; i++) {
        var range = ranges[i];
        if (range.empty()) {
          var lineLength = cm.getLine(range.anchor.line).length;
          if (range.anchor.ch < lineLength) {
            result.push(cm.markText(range.anchor, Pos(range.anchor.line, range.anchor.ch + 1),
                                    {className: "cm-fat-cursor-mark"}));
          } else {
            result.push(cm.markText(Pos(range.anchor.line, lineLength - 1),
                                    Pos(range.anchor.line, lineLength),
                                    {className: "cm-fat-cursor-mark"}));
          }
        }
      }
      cm.state.fatCursorMarks = result;
    }

    function clearFatCursorMark(cm) {
      var marks = cm.state.fatCursorMarks;
      if (marks) for (var i = 0; i < marks.length; i++) marks[i].clear();
    }

    function enableFatCursorMark(cm) {
      cm.state.fatCursorMarks = [];
      updateFatCursorMark(cm)
      cm.on("cursorActivity", updateFatCursorMark)
    }

    function disableFatCursorMark(cm) {
      clearFatCursorMark(cm);
      cm.off("cursorActivity", updateFatCursorMark);
      // explicitly set fatCursorMarks to null because event listener above
      // can be invoke after removing it, if off is called from operation
      cm.state.fatCursorMarks = null;
    }

    // Deprecated, simply setting the keymap works again.
    CodeMirror.defineOption('vimMode', false, function(cm, val, prev) {
      if (val && cm.getOption("keyMap") != "vim")
        cm.setOption("keyMap", "vim");
      else if (!val && prev != CodeMirror.Init && /^vim/.test(cm.getOption("keyMap")))
        cm.setOption("keyMap", "default");
    });

    function cmKey(key, cm) {
      if (!cm) { return undefined; }
      if (this[key]) { return this[key]; }
      var vimKey = cmKeyToVimKey(key);
      if (!vimKey) {
        return false;
      }
      var cmd = CodeMirror.Vim.findKey(cm, vimKey);
      if (typeof cmd == 'function') {
        CodeMirror.signal(cm, 'vim-keypress', vimKey);
      }
      return cmd;
    }

    var modifiers = {'Shift': 'S', 'Ctrl': 'C', 'Alt': 'A', 'Cmd': 'D', 'Mod': 'A'};
    var specialKeys = {Enter:'CR',Backspace:'BS',Delete:'Del',Insert:'Ins'};
    function cmKeyToVimKey(key) {
      if (key.charAt(0) == '\'') {
        // Keypress character binding of format "'a'"
        return key.charAt(1);
      }
      var pieces = key.split(/-(?!$)/);
      var lastPiece = pieces[pieces.length - 1];
      if (pieces.length == 1 && pieces[0].length == 1) {
        // No-modifier bindings use literal character bindings above. Skip.
        return false;
      } else if (pieces.length == 2 && pieces[0] == 'Shift' && lastPiece.length == 1) {
        // Ignore Shift+char bindings as they should be handled by literal character.
        return false;
      }
      var hasCharacter = false;
      for (var i = 0; i < pieces.length; i++) {
        var piece = pieces[i];
        if (piece in modifiers) { pieces[i] = modifiers[piece]; }
        else { hasCharacter = true; }
        if (piece in specialKeys) { pieces[i] = specialKeys[piece]; }
      }
      if (!hasCharacter) {
        // Vim does not support modifier only keys.
        return false;
      }
      // TODO: Current bindings expect the character to be lower case, but
      // it looks like vim key notation uses upper case.
      if (isUpperCase(lastPiece)) {
        pieces[pieces.length - 1] = lastPiece.toLowerCase();
      }
      return '<' + pieces.join('-') + '>';
    }

    function getOnPasteFn(cm) {
      var vim = cm.state.vim;
      if (!vim.onPasteFn) {
        vim.onPasteFn = function() {
          if (!vim.insertMode) {
            cm.setCursor(offsetCursor(cm.getCursor(), 0, 1));
            actions.enterInsertMode(cm, {}, vim);
          }
        };
      }
      return vim.onPasteFn;
    }

    var numberRegex = /[\d]/;
    var wordCharTest = [CodeMirror.isWordChar, function(ch) {
      return ch && !CodeMirror.isWordChar(ch) && !/\s/.test(ch);
    }], bigWordCharTest = [function(ch) {
      return /\S/.test(ch);
    }];
    function makeKeyRange(start, size) {
      var keys = [];
      for (var i = start; i < start + size; i++) {
        keys.push(String.fromCharCode(i));
      }
      return keys;
    }
    var upperCaseAlphabet = makeKeyRange(65, 26);
    var lowerCaseAlphabet = makeKeyRange(97, 26);
    var numbers = makeKeyRange(48, 10);
    var validMarks = [].concat(upperCaseAlphabet, lowerCaseAlphabet, numbers, ['<', '>']);
    var validRegisters = [].concat(upperCaseAlphabet, lowerCaseAlphabet, numbers, ['-', '"', '.', ':', '_', '/']);

    function isLine(cm, line) {
      return line >= cm.firstLine() && line <= cm.lastLine();
    }
    function isLowerCase(k) {
      return (/^[a-z]$/).test(k);
    }
    function isMatchableSymbol(k) {
      return '()[]{}'.indexOf(k) != -1;
    }
    function isNumber(k) {
      return numberRegex.test(k);
    }
    function isUpperCase(k) {
      return (/^[A-Z]$/).test(k);
    }
    function isWhiteSpaceString(k) {
      return (/^\s*$/).test(k);
    }
    function isEndOfSentenceSymbol(k) {
      return '.?!'.indexOf(k) != -1;
    }
    function inArray(val, arr) {
      for (var i = 0; i < arr.length; i++) {
        if (arr[i] == val) {
          return true;
        }
      }
      return false;
    }

    var options = {};
    function defineOption(name, defaultValue, type, aliases, callback) {
      if (defaultValue === undefined && !callback) {
        throw Error('defaultValue is required unless callback is provided');
      }
      if (!type) { type = 'string'; }
      options[name] = {
        type: type,
        defaultValue: defaultValue,
        callback: callback
      };
      if (aliases) {
        for (var i = 0; i < aliases.length; i++) {
          options[aliases[i]] = options[name];
        }
      }
      if (defaultValue) {
        setOption(name, defaultValue);
      }
    }

    function setOption(name, value, cm, cfg) {
      var option = options[name];
      cfg = cfg || {};
      var scope = cfg.scope;
      if (!option) {
        return new Error('Unknown option: ' + name);
      }
      if (option.type == 'boolean') {
        if (value && value !== true) {
          return new Error('Invalid argument: ' + name + '=' + value);
        } else if (value !== false) {
          // Boolean options are set to true if value is not defined.
          value = true;
        }
      }
      if (option.callback) {
        if (scope !== 'local') {
          option.callback(value, undefined);
        }
        if (scope !== 'global' && cm) {
          option.callback(value, cm);
        }
      } else {
        if (scope !== 'local') {
          option.value = option.type == 'boolean' ? !!value : value;
        }
        if (scope !== 'global' && cm) {
          cm.state.vim.options[name] = {value: value};
        }
      }
    }

    function getOption(name, cm, cfg) {
      var option = options[name];
      cfg = cfg || {};
      var scope = cfg.scope;
      if (!option) {
        return new Error('Unknown option: ' + name);
      }
      if (option.callback) {
        var local = cm && option.callback(undefined, cm);
        if (scope !== 'global' && local !== undefined) {
          return local;
        }
        if (scope !== 'local') {
          return option.callback();
        }
        return;
      } else {
        var local = (scope !== 'global') && (cm && cm.state.vim.options[name]);
        return (local || (scope !== 'local') && option || {}).value;
      }
    }

    defineOption('filetype', undefined, 'string', ['ft'], function(name, cm) {
      // Option is local. Do nothing for global.
      if (cm === undefined) {
        return;
      }
      // The 'filetype' option proxies to the CodeMirror 'mode' option.
      if (name === undefined) {
        var mode = cm.getOption('mode');
        return mode == 'null' ? '' : mode;
      } else {
        var mode = name == '' ? 'null' : name;
        cm.setOption('mode', mode);
      }
    });

    var createCircularJumpList = function() {
      var size = 100;
      var pointer = -1;
      var head = 0;
      var tail = 0;
      var buffer = new Array(size);
      function add(cm, oldCur, newCur) {
        var current = pointer % size;
        var curMark = buffer[current];
        function useNextSlot(cursor) {
          var next = ++pointer % size;
          var trashMark = buffer[next];
          if (trashMark) {
            trashMark.clear();
          }
          buffer[next] = cm.setBookmark(cursor);
        }
        if (curMark) {
          var markPos = curMark.find();
          // avoid recording redundant cursor position
          if (markPos && !cursorEqual(markPos, oldCur)) {
            useNextSlot(oldCur);
          }
        } else {
          useNextSlot(oldCur);
        }
        useNextSlot(newCur);
        head = pointer;
        tail = pointer - size + 1;
        if (tail < 0) {
          tail = 0;
        }
      }
      function move(cm, offset) {
        pointer += offset;
        if (pointer > head) {
          pointer = head;
        } else if (pointer < tail) {
          pointer = tail;
        }
        var mark = buffer[(size + pointer) % size];
        // skip marks that are temporarily removed from text buffer
        if (mark && !mark.find()) {
          var inc = offset > 0 ? 1 : -1;
          var newCur;
          var oldCur = cm.getCursor();
          do {
            pointer += inc;
            mark = buffer[(size + pointer) % size];
            // skip marks that are the same as current position
            if (mark &&
                (newCur = mark.find()) &&
                !cursorEqual(oldCur, newCur)) {
              break;
            }
          } while (pointer < head && pointer > tail);
        }
        return mark;
      }
      function find(cm, offset) {
        var oldPointer = pointer;
        var mark = move(cm, offset);
        pointer = oldPointer;
        return mark && mark.find();
      }
      return {
        cachedCursor: undefined, //used for # and * jumps
        add: add,
        find: find,
        move: move
      };
    };

    // Returns an object to track the changes associated insert mode.  It
    // clones the object that is passed in, or creates an empty object one if
    // none is provided.
    var createInsertModeChanges = function(c) {
      if (c) {
        // Copy construction
        return {
          changes: c.changes,
          expectCursorActivityForChange: c.expectCursorActivityForChange
        };
      }
      return {
        // Change list
        changes: [],
        // Set to true on change, false on cursorActivity.
        expectCursorActivityForChange: false
      };
    };

    function MacroModeState() {
      this.latestRegister = undefined;
      this.isPlaying = false;
      this.isRecording = false;
      this.replaySearchQueries = [];
      this.onRecordingDone = undefined;
      this.lastInsertModeChanges = createInsertModeChanges();
    }
    MacroModeState.prototype = {
      exitMacroRecordMode: function() {
        var macroModeState = vimGlobalState.macroModeState;
        if (macroModeState.onRecordingDone) {
          macroModeState.onRecordingDone(); // close dialog
        }
        macroModeState.onRecordingDone = undefined;
        macroModeState.isRecording = false;
      },
      enterMacroRecordMode: function(cm, registerName) {
        var register =
            vimGlobalState.registerController.getRegister(registerName);
        if (register) {
          register.clear();
          this.latestRegister = registerName;
          if (cm.openDialog) {
            this.onRecordingDone = cm.openDialog(
                '(recording)['+registerName+']', null, {bottom:true});
          }
          this.isRecording = true;
        }
      }
    };

    function maybeInitVimState(cm) {
      if (!cm.state.vim) {
        // Store instance state in the CodeMirror object.
        cm.state.vim = {
          inputState: new InputState(),
          // Vim's input state that triggered the last edit, used to repeat
          // motions and operators with '.'.
          lastEditInputState: undefined,
          // Vim's action command before the last edit, used to repeat actions
          // with '.' and insert mode repeat.
          lastEditActionCommand: undefined,
          // When using jk for navigation, if you move from a longer line to a
          // shorter line, the cursor may clip to the end of the shorter line.
          // If j is pressed again and cursor goes to the next line, the
          // cursor should go back to its horizontal position on the longer
          // line if it can. This is to keep track of the horizontal position.
          lastHPos: -1,
          // Doing the same with screen-position for gj/gk
          lastHSPos: -1,
          // The last motion command run. Cleared if a non-motion command gets
          // executed in between.
          lastMotion: null,
          marks: {},
          // Mark for rendering fake cursor for visual mode.
          fakeCursor: null,
          insertMode: false,
          // Repeat count for changes made in insert mode, triggered by key
          // sequences like 3,i. Only exists when insertMode is true.
          insertModeRepeat: undefined,
          visualMode: false,
          // If we are in visual line mode. No effect if visualMode is false.
          visualLine: false,
          visualBlock: false,
          lastSelection: null,
          lastPastedText: null,
          sel: {},
          // Buffer-local/window-local values of vim options.
          options: {}
        };
      }
      return cm.state.vim;
    }
    var vimGlobalState;
    function resetVimGlobalState() {
      vimGlobalState = {
        // The current search query.
        searchQuery: null,
        // Whether we are searching backwards.
        searchIsReversed: false,
        // Replace part of the last substituted pattern
        lastSubstituteReplacePart: undefined,
        jumpList: createCircularJumpList(),
        macroModeState: new MacroModeState,
        // Recording latest f, t, F or T motion command.
        lastCharacterSearch: {increment:0, forward:true, selectedCharacter:''},
        registerController: new RegisterController({}),
        // search history buffer
        searchHistoryController: new HistoryController(),
        // ex Command history buffer
        exCommandHistoryController : new HistoryController()
      };
      for (var optionName in options) {
        var option = options[optionName];
        option.value = option.defaultValue;
      }
    }

    var lastInsertModeKeyTimer;
    var vimApi= {
      buildKeyMap: function() {
        // TODO: Convert keymap into dictionary format for fast lookup.
      },
      // Testing hook, though it might be useful to expose the register
      // controller anyways.
      getRegisterController: function() {
        return vimGlobalState.registerController;
      },
      // Testing hook.
      resetVimGlobalState_: resetVimGlobalState,

      // Testing hook.
      getVimGlobalState_: function() {
        return vimGlobalState;
      },

      // Testing hook.
      maybeInitVimState_: maybeInitVimState,

      suppressErrorLogging: false,

      InsertModeKey: InsertModeKey,
      map: function(lhs, rhs, ctx) {
        // Add user defined key bindings.
        exCommandDispatcher.map(lhs, rhs, ctx);
      },
      unmap: function(lhs, ctx) {
        exCommandDispatcher.unmap(lhs, ctx);
      },
      // Non-recursive map function.
      // NOTE: This will not create mappings to key maps that aren't present
      // in the default key map. See TODO at bottom of function.
      noremap: function(lhs, rhs, ctx) {
        function toCtxArray(ctx) {
          return ctx ? [ctx] : ['normal', 'insert', 'visual'];
        }
        var ctxsToMap = toCtxArray(ctx);
        // Look through all actual defaults to find a map candidate.
        var actualLength = defaultKeymap.length, origLength = defaultKeymapLength;
        for (var i = actualLength - origLength;
             i < actualLength && ctxsToMap.length;
             i++) {
          var mapping = defaultKeymap[i];
          // Omit mappings that operate in the wrong context(s) and those of invalid type.
          if (mapping.keys == rhs &&
              (!ctx || !mapping.context || mapping.context === ctx) &&
              mapping.type.substr(0, 2) !== 'ex' &&
              mapping.type.substr(0, 3) !== 'key') {
            // Make a shallow copy of the original keymap entry.
            var newMapping = {};
            for (var key in mapping) {
              newMapping[key] = mapping[key];
            }
            // Modify it point to the new mapping with the proper context.
            newMapping.keys = lhs;
            if (ctx && !newMapping.context) {
              newMapping.context = ctx;
            }
            // Add it to the keymap with a higher priority than the original.
            this._mapCommand(newMapping);
            // Record the mapped contexts as complete.
            var mappedCtxs = toCtxArray(mapping.context);
            ctxsToMap = ctxsToMap.filter(function(el) { return mappedCtxs.indexOf(el) === -1; });
          }
        }
        // TODO: Create non-recursive keyToKey mappings for the unmapped contexts once those exist.
      },
      // Remove all user-defined mappings for the provided context.
      mapclear: function(ctx) {
        // Partition the existing keymap into user-defined and true defaults.
        var actualLength = defaultKeymap.length,
            origLength = defaultKeymapLength;
        var userKeymap = defaultKeymap.slice(0, actualLength - origLength);
        defaultKeymap = defaultKeymap.slice(actualLength - origLength);
        if (ctx) {
          // If a specific context is being cleared, we need to keep mappings
          // from all other contexts.
          for (var i = userKeymap.length - 1; i >= 0; i--) {
            var mapping = userKeymap[i];
            if (ctx !== mapping.context) {
              if (mapping.context) {
                this._mapCommand(mapping);
              } else {
                // `mapping` applies to all contexts so create keymap copies
                // for each context except the one being cleared.
                var contexts = ['normal', 'insert', 'visual'];
                for (var j in contexts) {
                  if (contexts[j] !== ctx) {
                    var newMapping = {};
                    for (var key in mapping) {
                      newMapping[key] = mapping[key];
                    }
                    newMapping.context = contexts[j];
                    this._mapCommand(newMapping);
                  }
                }
              }
            }
          }
        }
      },
      // TODO: Expose setOption and getOption as instance methods. Need to decide how to namespace
      // them, or somehow make them work with the existing CodeMirror setOption/getOption API.
      setOption: setOption,
      getOption: getOption,
      defineOption: defineOption,
      defineEx: function(name, prefix, func){
        if (!prefix) {
          prefix = name;
        } else if (name.indexOf(prefix) !== 0) {
          throw new Error('(Vim.defineEx) "'+prefix+'" is not a prefix of "'+name+'", command not registered');
        }
        exCommands[name]=func;
        exCommandDispatcher.commandMap_[prefix]={name:name, shortName:prefix, type:'api'};
      },
      handleKey: function (cm, key, origin) {
        var command = this.findKey(cm, key, origin);
        if (typeof command === 'function') {
          return command();
        }
      },
      /**
       * This is the outermost function called by CodeMirror, after keys have
       * been mapped to their Vim equivalents.
       *
       * Finds a command based on the key (and cached keys if there is a
       * multi-key sequence). Returns `undefined` if no key is matched, a noop
       * function if a partial match is found (multi-key), and a function to
       * execute the bound command if a a key is matched. The function always
       * returns true.
       */
      findKey: function(cm, key, origin) {
        var vim = maybeInitVimState(cm);
        function handleMacroRecording() {
          var macroModeState = vimGlobalState.macroModeState;
          if (macroModeState.isRecording) {
            if (key == 'q') {
              macroModeState.exitMacroRecordMode();
              clearInputState(cm);
              return true;
            }
            if (origin != 'mapping') {
              logKey(macroModeState, key);
            }
          }
        }
        function handleEsc() {
          if (key == '<Esc>') {
            // Clear input state and get back to normal mode.
            clearInputState(cm);
            if (vim.visualMode) {
              exitVisualMode(cm);
            } else if (vim.insertMode) {
              exitInsertMode(cm);
            }
            return true;
          }
        }
        function doKeyToKey(keys) {
          // TODO: prevent infinite recursion.
          var match;
          while (keys) {
            // Pull off one command key, which is either a single character
            // or a special sequence wrapped in '<' and '>', e.g. '<Space>'.
            match = (/<\w+-.+?>|<\w+>|./).exec(keys);
            key = match[0];
            keys = keys.substring(match.index + key.length);
            CodeMirror.Vim.handleKey(cm, key, 'mapping');
          }
        }

        function handleKeyInsertMode() {
          if (handleEsc()) { return true; }
          var keys = vim.inputState.keyBuffer = vim.inputState.keyBuffer + key;
          var keysAreChars = key.length == 1;
          var match = commandDispatcher.matchCommand(keys, defaultKeymap, vim.inputState, 'insert');
          // Need to check all key substrings in insert mode.
          while (keys.length > 1 && match.type != 'full') {
            var keys = vim.inputState.keyBuffer = keys.slice(1);
            var thisMatch = commandDispatcher.matchCommand(keys, defaultKeymap, vim.inputState, 'insert');
            if (thisMatch.type != 'none') { match = thisMatch; }
          }
          if (match.type == 'none') { clearInputState(cm); return false; }
          else if (match.type == 'partial') {
            if (lastInsertModeKeyTimer) { window.clearTimeout(lastInsertModeKeyTimer); }
            lastInsertModeKeyTimer = window.setTimeout(
              function() { if (vim.insertMode && vim.inputState.keyBuffer) { clearInputState(cm); } },
              getOption('insertModeEscKeysTimeout'));
            return !keysAreChars;
          }

          if (lastInsertModeKeyTimer) { window.clearTimeout(lastInsertModeKeyTimer); }
          if (keysAreChars) {
            var selections = cm.listSelections();
            for (var i = 0; i < selections.length; i++) {
              var here = selections[i].head;
              cm.replaceRange('', offsetCursor(here, 0, -(keys.length - 1)), here, '+input');
            }
            vimGlobalState.macroModeState.lastInsertModeChanges.changes.pop();
          }
          clearInputState(cm);
          return match.command;
        }

        function handleKeyNonInsertMode() {
          if (handleMacroRecording() || handleEsc()) { return true; }

          var keys = vim.inputState.keyBuffer = vim.inputState.keyBuffer + key;
          if (/^[1-9]\d*$/.test(keys)) { return true; }

          var keysMatcher = /^(\d*)(.*)$/.exec(keys);
          if (!keysMatcher) { clearInputState(cm); return false; }
          var context = vim.visualMode ? 'visual' :
                                         'normal';
          var match = commandDispatcher.matchCommand(keysMatcher[2] || keysMatcher[1], defaultKeymap, vim.inputState, context);
          if (match.type == 'none') { clearInputState(cm); return false; }
          else if (match.type == 'partial') { return true; }

          vim.inputState.keyBuffer = '';
          var keysMatcher = /^(\d*)(.*)$/.exec(keys);
          if (keysMatcher[1] && keysMatcher[1] != '0') {
            vim.inputState.pushRepeatDigit(keysMatcher[1]);
          }
          return match.command;
        }

        var command;
        if (vim.insertMode) { command = handleKeyInsertMode(); }
        else { command = handleKeyNonInsertMode(); }
        if (command === false) {
          return !vim.insertMode && key.length === 1 ? function() { return true; } : undefined;
        } else if (command === true) {
          // TODO: Look into using CodeMirror's multi-key handling.
          // Return no-op since we are caching the key. Counts as handled, but
          // don't want act on it just yet.
          return function() { return true; };
        } else {
          return function() {
            return cm.operation(function() {
              cm.curOp.isVimOp = true;
              try {
                if (command.type == 'keyToKey') {
                  doKeyToKey(command.toKeys);
                } else {
                  commandDispatcher.processCommand(cm, vim, command);
                }
              } catch (e) {
                // clear VIM state in case it's in a bad state.
                cm.state.vim = undefined;
                maybeInitVimState(cm);
                if (!CodeMirror.Vim.suppressErrorLogging) {
                  console['log'](e);
                }
                throw e;
              }
              return true;
            });
          };
        }
      },
      handleEx: function(cm, input) {
        exCommandDispatcher.processCommand(cm, input);
      },

      defineMotion: defineMotion,
      defineAction: defineAction,
      defineOperator: defineOperator,
      mapCommand: mapCommand,
      _mapCommand: _mapCommand,

      defineRegister: defineRegister,

      exitVisualMode: exitVisualMode,
      exitInsertMode: exitInsertMode
    };

    // Represents the current input state.
    function InputState() {
      this.prefixRepeat = [];
      this.motionRepeat = [];

      this.operator = null;
      this.operatorArgs = null;
      this.motion = null;
      this.motionArgs = null;
      this.keyBuffer = []; // For matching multi-key commands.
      this.registerName = null; // Defaults to the unnamed register.
    }
    InputState.prototype.pushRepeatDigit = function(n) {
      if (!this.operator) {
        this.prefixRepeat = this.prefixRepeat.concat(n);
      } else {
        this.motionRepeat = this.motionRepeat.concat(n);
      }
    };
    InputState.prototype.getRepeat = function() {
      var repeat = 0;
      if (this.prefixRepeat.length > 0 || this.motionRepeat.length > 0) {
        repeat = 1;
        if (this.prefixRepeat.length > 0) {
          repeat *= parseInt(this.prefixRepeat.join(''), 10);
        }
        if (this.motionRepeat.length > 0) {
          repeat *= parseInt(this.motionRepeat.join(''), 10);
        }
      }
      return repeat;
    };

    function clearInputState(cm, reason) {
      cm.state.vim.inputState = new InputState();
      CodeMirror.signal(cm, 'vim-command-done', reason);
    }

    /*
     * Register stores information about copy and paste registers.  Besides
     * text, a register must store whether it is linewise (i.e., when it is
     * pasted, should it insert itself into a new line, or should the text be
     * inserted at the cursor position.)
     */
    function Register(text, linewise, blockwise) {
      this.clear();
      this.keyBuffer = [text || ''];
      this.insertModeChanges = [];
      this.searchQueries = [];
      this.linewise = !!linewise;
      this.blockwise = !!blockwise;
    }
    Register.prototype = {
      setText: function(text, linewise, blockwise) {
        this.keyBuffer = [text || ''];
        this.linewise = !!linewise;
        this.blockwise = !!blockwise;
      },
      pushText: function(text, linewise) {
        // if this register has ever been set to linewise, use linewise.
        if (linewise) {
          if (!this.linewise) {
            this.keyBuffer.push('\n');
          }
          this.linewise = true;
        }
        this.keyBuffer.push(text);
      },
      pushInsertModeChanges: function(changes) {
        this.insertModeChanges.push(createInsertModeChanges(changes));
      },
      pushSearchQuery: function(query) {
        this.searchQueries.push(query);
      },
      clear: function() {
        this.keyBuffer = [];
        this.insertModeChanges = [];
        this.searchQueries = [];
        this.linewise = false;
      },
      toString: function() {
        return this.keyBuffer.join('');
      }
    };

    /**
     * Defines an external register.
     *
     * The name should be a single character that will be used to reference the register.
     * The register should support setText, pushText, clear, and toString(). See Register
     * for a reference implementation.
     */
    function defineRegister(name, register) {
      var registers = vimGlobalState.registerController.registers;
      if (!name || name.length != 1) {
        throw Error('Register name must be 1 character');
      }
      if (registers[name]) {
        throw Error('Register already defined ' + name);
      }
      registers[name] = register;
      validRegisters.push(name);
    }

    /*
     * vim registers allow you to keep many independent copy and paste buffers.
     * See http://usevim.com/2012/04/13/registers/ for an introduction.
     *
     * RegisterController keeps the state of all the registers.  An initial
     * state may be passed in.  The unnamed register '"' will always be
     * overridden.
     */
    function RegisterController(registers) {
      this.registers = registers;
      this.unnamedRegister = registers['"'] = new Register();
      registers['.'] = new Register();
      registers[':'] = new Register();
      registers['/'] = new Register();
    }
    RegisterController.prototype = {
      pushText: function(registerName, operator, text, linewise, blockwise) {
        // The black hole register, "_, means delete/yank to nowhere.
        if (registerName === '_') return;
        if (linewise && text.charAt(text.length - 1) !== '\n'){
          text += '\n';
        }
        // Lowercase and uppercase registers refer to the same register.
        // Uppercase just means append.
        var register = this.isValidRegister(registerName) ?
            this.getRegister(registerName) : null;
        // if no register/an invalid register was specified, things go to the
        // default registers
        if (!register) {
          switch (operator) {
            case 'yank':
              // The 0 register contains the text from the most recent yank.
              this.registers['0'] = new Register(text, linewise, blockwise);
              break;
            case 'delete':
            case 'change':
              if (text.indexOf('\n') == -1) {
                // Delete less than 1 line. Update the small delete register.
                this.registers['-'] = new Register(text, linewise);
              } else {
                // Shift down the contents of the numbered registers and put the
                // deleted text into register 1.
                this.shiftNumericRegisters_();
                this.registers['1'] = new Register(text, linewise);
              }
              break;
          }
          // Make sure the unnamed register is set to what just happened
          this.unnamedRegister.setText(text, linewise, blockwise);
          return;
        }

        // If we've gotten to this point, we've actually specified a register
        var append = isUpperCase(registerName);
        if (append) {
          register.pushText(text, linewise);
        } else {
          register.setText(text, linewise, blockwise);
        }
        // The unnamed register always has the same value as the last used
        // register.
        this.unnamedRegister.setText(register.toString(), linewise);
      },
      // Gets the register named @name.  If one of @name doesn't already exist,
      // create it.  If @name is invalid, return the unnamedRegister.
      getRegister: function(name) {
        if (!this.isValidRegister(name)) {
          return this.unnamedRegister;
        }
        name = name.toLowerCase();
        if (!this.registers[name]) {
          this.registers[name] = new Register();
        }
        return this.registers[name];
      },
      isValidRegister: function(name) {
        return name && inArray(name, validRegisters);
      },
      shiftNumericRegisters_: function() {
        for (var i = 9; i >= 2; i--) {
          this.registers[i] = this.getRegister('' + (i - 1));
        }
      }
    };
    function HistoryController() {
        this.historyBuffer = [];
        this.iterator = 0;
        this.initialPrefix = null;
    }
    HistoryController.prototype = {
      // the input argument here acts a user entered prefix for a small time
      // until we start autocompletion in which case it is the autocompleted.
      nextMatch: function (input, up) {
        var historyBuffer = this.historyBuffer;
        var dir = up ? -1 : 1;
        if (this.initialPrefix === null) this.initialPrefix = input;
        for (var i = this.iterator + dir; up ? i >= 0 : i < historyBuffer.length; i+= dir) {
          var element = historyBuffer[i];
          for (var j = 0; j <= element.length; j++) {
            if (this.initialPrefix == element.substring(0, j)) {
              this.iterator = i;
              return element;
            }
          }
        }
        // should return the user input in case we reach the end of buffer.
        if (i >= historyBuffer.length) {
          this.iterator = historyBuffer.length;
          return this.initialPrefix;
        }
        // return the last autocompleted query or exCommand as it is.
        if (i < 0 ) return input;
      },
      pushInput: function(input) {
        var index = this.historyBuffer.indexOf(input);
        if (index > -1) this.historyBuffer.splice(index, 1);
        if (input.length) this.historyBuffer.push(input);
      },
      reset: function() {
        this.initialPrefix = null;
        this.iterator = this.historyBuffer.length;
      }
    };
    var commandDispatcher = {
      matchCommand: function(keys, keyMap, inputState, context) {
        var matches = commandMatches(keys, keyMap, context, inputState);
        if (!matches.full && !matches.partial) {
          return {type: 'none'};
        } else if (!matches.full && matches.partial) {
          return {type: 'partial'};
        }

        var bestMatch;
        for (var i = 0; i < matches.full.length; i++) {
          var match = matches.full[i];
          if (!bestMatch) {
            bestMatch = match;
          }
        }
        if (bestMatch.keys.slice(-11) == '<character>') {
          var character = lastChar(keys);
          if (!character) return {type: 'none'};
          inputState.selectedCharacter = character;
        }
        return {type: 'full', command: bestMatch};
      },
      processCommand: function(cm, vim, command) {
        vim.inputState.repeatOverride = command.repeatOverride;
        switch (command.type) {
          case 'motion':
            this.processMotion(cm, vim, command);
            break;
          case 'operator':
            this.processOperator(cm, vim, command);
            break;
          case 'operatorMotion':
            this.processOperatorMotion(cm, vim, command);
            break;
          case 'action':
            this.processAction(cm, vim, command);
            break;
          case 'search':
            this.processSearch(cm, vim, command);
            break;
          case 'ex':
          case 'keyToEx':
            this.processEx(cm, vim, command);
            break;
          default:
            break;
        }
      },
      processMotion: function(cm, vim, command) {
        vim.inputState.motion = command.motion;
        vim.inputState.motionArgs = copyArgs(command.motionArgs);
        this.evalInput(cm, vim);
      },
      processOperator: function(cm, vim, command) {
        var inputState = vim.inputState;
        if (inputState.operator) {
          if (inputState.operator == command.operator) {
            // Typing an operator twice like 'dd' makes the operator operate
            // linewise
            inputState.motion = 'expandToLine';
            inputState.motionArgs = { linewise: true };
            this.evalInput(cm, vim);
            return;
          } else {
            // 2 different operators in a row doesn't make sense.
            clearInputState(cm);
          }
        }
        inputState.operator = command.operator;
        inputState.operatorArgs = copyArgs(command.operatorArgs);
        if (command.exitVisualBlock) {
            vim.visualBlock = false;
            updateCmSelection(cm);
        }
        if (vim.visualMode) {
          // Operating on a selection in visual mode. We don't need a motion.
          this.evalInput(cm, vim);
        }
      },
      processOperatorMotion: function(cm, vim, command) {
        var visualMode = vim.visualMode;
        var operatorMotionArgs = copyArgs(command.operatorMotionArgs);
        if (operatorMotionArgs) {
          // Operator motions may have special behavior in visual mode.
          if (visualMode && operatorMotionArgs.visualLine) {
            vim.visualLine = true;
          }
        }
        this.processOperator(cm, vim, command);
        if (!visualMode) {
          this.processMotion(cm, vim, command);
        }
      },
      processAction: function(cm, vim, command) {
        var inputState = vim.inputState;
        var repeat = inputState.getRepeat();
        var repeatIsExplicit = !!repeat;
        var actionArgs = copyArgs(command.actionArgs) || {};
        if (inputState.selectedCharacter) {
          actionArgs.selectedCharacter = inputState.selectedCharacter;
        }
        // Actions may or may not have motions and operators. Do these first.
        if (command.operator) {
          this.processOperator(cm, vim, command);
        }
        if (command.motion) {
          this.processMotion(cm, vim, command);
        }
        if (command.motion || command.operator) {
          this.evalInput(cm, vim);
        }
        actionArgs.repeat = repeat || 1;
        actionArgs.repeatIsExplicit = repeatIsExplicit;
        actionArgs.registerName = inputState.registerName;
        clearInputState(cm);
        vim.lastMotion = null;
        if (command.isEdit) {
          this.recordLastEdit(vim, inputState, command);
        }
        actions[command.action](cm, actionArgs, vim);
      },
      processSearch: function(cm, vim, command) {
        if (!cm.getSearchCursor) {
          // Search depends on SearchCursor.
          return;
        }
        var forward = command.searchArgs.forward;
        var wholeWordOnly = command.searchArgs.wholeWordOnly;
        getSearchState(cm).setReversed(!forward);
        var promptPrefix = (forward) ? '/' : '?';
        var originalQuery = getSearchState(cm).getQuery();
        var originalScrollPos = cm.getScrollInfo();
        function handleQuery(query, ignoreCase, smartCase) {
          vimGlobalState.searchHistoryController.pushInput(query);
          vimGlobalState.searchHistoryController.reset();
          try {
            updateSearchQuery(cm, query, ignoreCase, smartCase);
          } catch (e) {
            showConfirm(cm, 'Invalid regex: ' + query);
            clearInputState(cm);
            return;
          }
          commandDispatcher.processMotion(cm, vim, {
            type: 'motion',
            motion: 'findNext',
            motionArgs: { forward: true, toJumplist: command.searchArgs.toJumplist }
          });
        }
        function onPromptClose(query) {
          cm.scrollTo(originalScrollPos.left, originalScrollPos.top);
          handleQuery(query, true /** ignoreCase */, true /** smartCase */);
          var macroModeState = vimGlobalState.macroModeState;
          if (macroModeState.isRecording) {
            logSearchQuery(macroModeState, query);
          }
        }
        function onPromptKeyUp(e, query, close) {
          var keyName = CodeMirror.keyName(e), up, offset;
          if (keyName == 'Up' || keyName == 'Down') {
            up = keyName == 'Up' ? true : false;
            offset = e.target ? e.target.selectionEnd : 0;
            query = vimGlobalState.searchHistoryController.nextMatch(query, up) || '';
            close(query);
            if (offset && e.target) e.target.selectionEnd = e.target.selectionStart = Math.min(offset, e.target.value.length);
          } else {
            if ( keyName != 'Left' && keyName != 'Right' && keyName != 'Ctrl' && keyName != 'Alt' && keyName != 'Shift')
              vimGlobalState.searchHistoryController.reset();
          }
          var parsedQuery;
          try {
            parsedQuery = updateSearchQuery(cm, query,
                true /** ignoreCase */, true /** smartCase */);
          } catch (e) {
            // Swallow bad regexes for incremental search.
          }
          if (parsedQuery) {
            cm.scrollIntoView(findNext(cm, !forward, parsedQuery), 30);
          } else {
            clearSearchHighlight(cm);
            cm.scrollTo(originalScrollPos.left, originalScrollPos.top);
          }
        }
        function onPromptKeyDown(e, query, close) {
          var keyName = CodeMirror.keyName(e);
          if (keyName == 'Esc' || keyName == 'Ctrl-C' || keyName == 'Ctrl-[' ||
              (keyName == 'Backspace' && query == '')) {
            vimGlobalState.searchHistoryController.pushInput(query);
            vimGlobalState.searchHistoryController.reset();
            updateSearchQuery(cm, originalQuery);
            clearSearchHighlight(cm);
            cm.scrollTo(originalScrollPos.left, originalScrollPos.top);
            CodeMirror.e_stop(e);
            clearInputState(cm);
            close();
            cm.focus();
          } else if (keyName == 'Up' || keyName == 'Down') {
            CodeMirror.e_stop(e);
          } else if (keyName == 'Ctrl-U') {
            // Ctrl-U clears input.
            CodeMirror.e_stop(e);
            close('');
          }
        }
        switch (command.searchArgs.querySrc) {
          case 'prompt':
            var macroModeState = vimGlobalState.macroModeState;
            if (macroModeState.isPlaying) {
              var query = macroModeState.replaySearchQueries.shift();
              handleQuery(query, true /** ignoreCase */, false /** smartCase */);
            } else {
              showPrompt(cm, {
                  onClose: onPromptClose,
                  prefix: promptPrefix,
                  desc: searchPromptDesc,
                  onKeyUp: onPromptKeyUp,
                  onKeyDown: onPromptKeyDown
              });
            }
            break;
          case 'wordUnderCursor':
            var word = expandWordUnderCursor(cm, false /** inclusive */,
                true /** forward */, false /** bigWord */,
                true /** noSymbol */);
            var isKeyword = true;
            if (!word) {
              word = expandWordUnderCursor(cm, false /** inclusive */,
                  true /** forward */, false /** bigWord */,
                  false /** noSymbol */);
              isKeyword = false;
            }
            if (!word) {
              return;
            }
            var query = cm.getLine(word.start.line).substring(word.start.ch,
                word.end.ch);
            if (isKeyword && wholeWordOnly) {
                query = '\\b' + query + '\\b';
            } else {
              query = escapeRegex(query);
            }

            // cachedCursor is used to save the old position of the cursor
            // when * or # causes vim to seek for the nearest word and shift
            // the cursor before entering the motion.
            vimGlobalState.jumpList.cachedCursor = cm.getCursor();
            cm.setCursor(word.start);

            handleQuery(query, true /** ignoreCase */, false /** smartCase */);
            break;
        }
      },
      processEx: function(cm, vim, command) {
        function onPromptClose(input) {
          // Give the prompt some time to close so that if processCommand shows
          // an error, the elements don't overlap.
          vimGlobalState.exCommandHistoryController.pushInput(input);
          vimGlobalState.exCommandHistoryController.reset();
          exCommandDispatcher.processCommand(cm, input);
        }
        function onPromptKeyDown(e, input, close) {
          var keyName = CodeMirror.keyName(e), up, offset;
          if (keyName == 'Esc' || keyName == 'Ctrl-C' || keyName == 'Ctrl-[' ||
              (keyName == 'Backspace' && input == '')) {
            vimGlobalState.exCommandHistoryController.pushInput(input);
            vimGlobalState.exCommandHistoryController.reset();
            CodeMirror.e_stop(e);
            clearInputState(cm);
            close();
            cm.focus();
          }
          if (keyName == 'Up' || keyName == 'Down') {
            CodeMirror.e_stop(e);
            up = keyName == 'Up' ? true : false;
            offset = e.target ? e.target.selectionEnd : 0;
            input = vimGlobalState.exCommandHistoryController.nextMatch(input, up) || '';
            close(input);
            if (offset && e.target) e.target.selectionEnd = e.target.selectionStart = Math.min(offset, e.target.value.length);
          } else if (keyName == 'Ctrl-U') {
            // Ctrl-U clears input.
            CodeMirror.e_stop(e);
            close('');
          } else {
            if ( keyName != 'Left' && keyName != 'Right' && keyName != 'Ctrl' && keyName != 'Alt' && keyName != 'Shift')
              vimGlobalState.exCommandHistoryController.reset();
          }
        }
        if (command.type == 'keyToEx') {
          // Handle user defined Ex to Ex mappings
          exCommandDispatcher.processCommand(cm, command.exArgs.input);
        } else {
          if (vim.visualMode) {
            showPrompt(cm, { onClose: onPromptClose, prefix: ':', value: '\'<,\'>',
                onKeyDown: onPromptKeyDown, selectValueOnOpen: false});
          } else {
            showPrompt(cm, { onClose: onPromptClose, prefix: ':',
                onKeyDown: onPromptKeyDown});
          }
        }
      },
      evalInput: function(cm, vim) {
        // If the motion command is set, execute both the operator and motion.
        // Otherwise return.
        var inputState = vim.inputState;
        var motion = inputState.motion;
        var motionArgs = inputState.motionArgs || {};
        var operator = inputState.operator;
        var operatorArgs = inputState.operatorArgs || {};
        var registerName = inputState.registerName;
        var sel = vim.sel;
        // TODO: Make sure cm and vim selections are identical outside visual mode.
        var origHead = copyCursor(vim.visualMode ? clipCursorToContent(cm, sel.head): cm.getCursor('head'));
        var origAnchor = copyCursor(vim.visualMode ? clipCursorToContent(cm, sel.anchor) : cm.getCursor('anchor'));
        var oldHead = copyCursor(origHead);
        var oldAnchor = copyCursor(origAnchor);
        var newHead, newAnchor;
        var repeat;
        if (operator) {
          this.recordLastEdit(vim, inputState);
        }
        if (inputState.repeatOverride !== undefined) {
          // If repeatOverride is specified, that takes precedence over the
          // input state's repeat. Used by Ex mode and can be user defined.
          repeat = inputState.repeatOverride;
        } else {
          repeat = inputState.getRepeat();
        }
        if (repeat > 0 && motionArgs.explicitRepeat) {
          motionArgs.repeatIsExplicit = true;
        } else if (motionArgs.noRepeat ||
            (!motionArgs.explicitRepeat && repeat === 0)) {
          repeat = 1;
          motionArgs.repeatIsExplicit = false;
        }
        if (inputState.selectedCharacter) {
          // If there is a character input, stick it in all of the arg arrays.
          motionArgs.selectedCharacter = operatorArgs.selectedCharacter =
              inputState.selectedCharacter;
        }
        motionArgs.repeat = repeat;
        clearInputState(cm);
        if (motion) {
          var motionResult = motions[motion](cm, origHead, motionArgs, vim, inputState);
          vim.lastMotion = motions[motion];
          if (!motionResult) {
            return;
          }
          if (motionArgs.toJumplist) {
            var jumpList = vimGlobalState.jumpList;
            // if the current motion is # or *, use cachedCursor
            var cachedCursor = jumpList.cachedCursor;
            if (cachedCursor) {
              recordJumpPosition(cm, cachedCursor, motionResult);
              delete jumpList.cachedCursor;
            } else {
              recordJumpPosition(cm, origHead, motionResult);
            }
          }
          if (motionResult instanceof Array) {
            newAnchor = motionResult[0];
            newHead = motionResult[1];
          } else {
            newHead = motionResult;
          }
          // TODO: Handle null returns from motion commands better.
          if (!newHead) {
            newHead = copyCursor(origHead);
          }
          if (vim.visualMode) {
            if (!(vim.visualBlock && newHead.ch === Infinity)) {
              newHead = clipCursorToContent(cm, newHead);
            }
            if (newAnchor) {
              newAnchor = clipCursorToContent(cm, newAnchor);
            }
            newAnchor = newAnchor || oldAnchor;
            sel.anchor = newAnchor;
            sel.head = newHead;
            updateCmSelection(cm);
            updateMark(cm, vim, '<',
                cursorIsBefore(newAnchor, newHead) ? newAnchor
                    : newHead);
            updateMark(cm, vim, '>',
                cursorIsBefore(newAnchor, newHead) ? newHead
                    : newAnchor);
          } else if (!operator) {
            newHead = clipCursorToContent(cm, newHead);
            cm.setCursor(newHead.line, newHead.ch);
          }
        }
        if (operator) {
          if (operatorArgs.lastSel) {
            // Replaying a visual mode operation
            newAnchor = oldAnchor;
            var lastSel = operatorArgs.lastSel;
            var lineOffset = Math.abs(lastSel.head.line - lastSel.anchor.line);
            var chOffset = Math.abs(lastSel.head.ch - lastSel.anchor.ch);
            if (lastSel.visualLine) {
              // Linewise Visual mode: The same number of lines.
              newHead = Pos(oldAnchor.line + lineOffset, oldAnchor.ch);
            } else if (lastSel.visualBlock) {
              // Blockwise Visual mode: The same number of lines and columns.
              newHead = Pos(oldAnchor.line + lineOffset, oldAnchor.ch + chOffset);
            } else if (lastSel.head.line == lastSel.anchor.line) {
              // Normal Visual mode within one line: The same number of characters.
              newHead = Pos(oldAnchor.line, oldAnchor.ch + chOffset);
            } else {
              // Normal Visual mode with several lines: The same number of lines, in the
              // last line the same number of characters as in the last line the last time.
              newHead = Pos(oldAnchor.line + lineOffset, oldAnchor.ch);
            }
            vim.visualMode = true;
            vim.visualLine = lastSel.visualLine;
            vim.visualBlock = lastSel.visualBlock;
            sel = vim.sel = {
              anchor: newAnchor,
              head: newHead
            };
            updateCmSelection(cm);
          } else if (vim.visualMode) {
            operatorArgs.lastSel = {
              anchor: copyCursor(sel.anchor),
              head: copyCursor(sel.head),
              visualBlock: vim.visualBlock,
              visualLine: vim.visualLine
            };
          }
          var curStart, curEnd, linewise, mode;
          var cmSel;
          if (vim.visualMode) {
            // Init visual op
            curStart = cursorMin(sel.head, sel.anchor);
            curEnd = cursorMax(sel.head, sel.anchor);
            linewise = vim.visualLine || operatorArgs.linewise;
            mode = vim.visualBlock ? 'block' :
                   linewise ? 'line' :
                   'char';
            cmSel = makeCmSelection(cm, {
              anchor: curStart,
              head: curEnd
            }, mode);
            if (linewise) {
              var ranges = cmSel.ranges;
              if (mode == 'block') {
                // Linewise operators in visual block mode extend to end of line
                for (var i = 0; i < ranges.length; i++) {
                  ranges[i].head.ch = lineLength(cm, ranges[i].head.line);
                }
              } else if (mode == 'line') {
                ranges[0].head = Pos(ranges[0].head.line + 1, 0);
              }
            }
          } else {
            // Init motion op
            curStart = copyCursor(newAnchor || oldAnchor);
            curEnd = copyCursor(newHead || oldHead);
            if (cursorIsBefore(curEnd, curStart)) {
              var tmp = curStart;
              curStart = curEnd;
              curEnd = tmp;
            }
            linewise = motionArgs.linewise || operatorArgs.linewise;
            if (linewise) {
              // Expand selection to entire line.
              expandSelectionToLine(cm, curStart, curEnd);
            } else if (motionArgs.forward) {
              // Clip to trailing newlines only if the motion goes forward.
              clipToLine(cm, curStart, curEnd);
            }
            mode = 'char';
            var exclusive = !motionArgs.inclusive || linewise;
            cmSel = makeCmSelection(cm, {
              anchor: curStart,
              head: curEnd
            }, mode, exclusive);
          }
          cm.setSelections(cmSel.ranges, cmSel.primary);
          vim.lastMotion = null;
          operatorArgs.repeat = repeat; // For indent in visual mode.
          operatorArgs.registerName = registerName;
          // Keep track of linewise as it affects how paste and change behave.
          operatorArgs.linewise = linewise;
          var operatorMoveTo = operators[operator](
            cm, operatorArgs, cmSel.ranges, oldAnchor, newHead);
          if (vim.visualMode) {
            exitVisualMode(cm, operatorMoveTo != null);
          }
          if (operatorMoveTo) {
            cm.setCursor(operatorMoveTo);
          }
        }
      },
      recordLastEdit: function(vim, inputState, actionCommand) {
        var macroModeState = vimGlobalState.macroModeState;
        if (macroModeState.isPlaying) { return; }
        vim.lastEditInputState = inputState;
        vim.lastEditActionCommand = actionCommand;
        macroModeState.lastInsertModeChanges.changes = [];
        macroModeState.lastInsertModeChanges.expectCursorActivityForChange = false;
        macroModeState.lastInsertModeChanges.visualBlock = vim.visualBlock ? vim.sel.head.line - vim.sel.anchor.line : 0;
      }
    };

    /**
     * typedef {Object{line:number,ch:number}} Cursor An object containing the
     *     position of the cursor.
     */
    // All of the functions below return Cursor objects.
    var motions = {
      moveToTopLine: function(cm, _head, motionArgs) {
        var line = getUserVisibleLines(cm).top + motionArgs.repeat -1;
        return Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));
      },
      moveToMiddleLine: function(cm) {
        var range = getUserVisibleLines(cm);
        var line = Math.floor((range.top + range.bottom) * 0.5);
        return Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));
      },
      moveToBottomLine: function(cm, _head, motionArgs) {
        var line = getUserVisibleLines(cm).bottom - motionArgs.repeat +1;
        return Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));
      },
      expandToLine: function(_cm, head, motionArgs) {
        // Expands forward to end of line, and then to next line if repeat is
        // >1. Does not handle backward motion!
        var cur = head;
        return Pos(cur.line + motionArgs.repeat - 1, Infinity);
      },
      findNext: function(cm, _head, motionArgs) {
        var state = getSearchState(cm);
        var query = state.getQuery();
        if (!query) {
          return;
        }
        var prev = !motionArgs.forward;
        // If search is initiated with ? instead of /, negate direction.
        prev = (state.isReversed()) ? !prev : prev;
        highlightSearchMatches(cm, query);
        return findNext(cm, prev/** prev */, query, motionArgs.repeat);
      },
      /**
       * Find and select the next occurrence of the search query. If the cursor is currently
       * within a match, then find and select the current match. Otherwise, find the next occurrence in the
       * appropriate direction.
       *
       * This differs from `findNext` in the following ways:
       *
       * 1. Instead of only returning the "from", this returns a "from", "to" range.
       * 2. If the cursor is currently inside a search match, this selects the current match
       *    instead of the next match.
       * 3. If there is no associated operator, this will turn on visual mode.
       */
      findAndSelectNextInclusive: function(cm, _head, motionArgs, vim, prevInputState) {
        var state = getSearchState(cm);
        var query = state.getQuery();

        if (!query) {
          return;
        }

        var prev = !motionArgs.forward;
        prev = (state.isReversed()) ? !prev : prev;

        // next: [from, to] | null
        var next = findNextFromAndToInclusive(cm, prev, query, motionArgs.repeat, vim);

        // No matches.
        if (!next) {
          return;
        }

        // If there's an operator that will be executed, return the selection.
        if (prevInputState.operator) {
          return next;
        }

        // At this point, we know that there is no accompanying operator -- let's
        // deal with visual mode in order to select an appropriate match.

        var from = next[0];
        // For whatever reason, when we use the "to" as returned by searchcursor.js directly,
        // the resulting selection is extended by 1 char. Let's shrink it so that only the
        // match is selected.
        var to = Pos(next[1].line, next[1].ch - 1);

        if (vim.visualMode) {
          // If we were in visualLine or visualBlock mode, get out of it.
          if (vim.visualLine || vim.visualBlock) {
            vim.visualLine = false;
            vim.visualBlock = false;
            CodeMirror.signal(cm, "vim-mode-change", {mode: "visual", subMode: ""});
          }

          // If we're currently in visual mode, we should extend the selection to include
          // the search result.
          var anchor = vim.sel.anchor;
          if (anchor) {
            if (state.isReversed()) {
              if (motionArgs.forward) {
                return [anchor, from];
              }

              return [anchor, to];
            } else {
              if (motionArgs.forward) {
                return [anchor, to];
              }

              return [anchor, from];
            }
          }
        } else {
          // Let's turn visual mode on.
          vim.visualMode = true;
          vim.visualLine = false;
          vim.visualBlock = false;
          CodeMirror.signal(cm, "vim-mode-change", {mode: "visual", subMode: ""});
        }

        return prev ? [to, from] : [from, to];
      },
      goToMark: function(cm, _head, motionArgs, vim) {
        var pos = getMarkPos(cm, vim, motionArgs.selectedCharacter);
        if (pos) {
          return motionArgs.linewise ? { line: pos.line, ch: findFirstNonWhiteSpaceCharacter(cm.getLine(pos.line)) } : pos;
        }
        return null;
      },
      moveToOtherHighlightedEnd: function(cm, _head, motionArgs, vim) {
        if (vim.visualBlock && motionArgs.sameLine) {
          var sel = vim.sel;
          return [
            clipCursorToContent(cm, Pos(sel.anchor.line, sel.head.ch)),
            clipCursorToContent(cm, Pos(sel.head.line, sel.anchor.ch))
          ];
        } else {
          return ([vim.sel.head, vim.sel.anchor]);
        }
      },
      jumpToMark: function(cm, head, motionArgs, vim) {
        var best = head;
        for (var i = 0; i < motionArgs.repeat; i++) {
          var cursor = best;
          for (var key in vim.marks) {
            if (!isLowerCase(key)) {
              continue;
            }
            var mark = vim.marks[key].find();
            var isWrongDirection = (motionArgs.forward) ?
              cursorIsBefore(mark, cursor) : cursorIsBefore(cursor, mark);

            if (isWrongDirection) {
              continue;
            }
            if (motionArgs.linewise && (mark.line == cursor.line)) {
              continue;
            }

            var equal = cursorEqual(cursor, best);
            var between = (motionArgs.forward) ?
              cursorIsBetween(cursor, mark, best) :
              cursorIsBetween(best, mark, cursor);

            if (equal || between) {
              best = mark;
            }
          }
        }

        if (motionArgs.linewise) {
          // Vim places the cursor on the first non-whitespace character of
          // the line if there is one, else it places the cursor at the end
          // of the line, regardless of whether a mark was found.
          best = Pos(best.line, findFirstNonWhiteSpaceCharacter(cm.getLine(best.line)));
        }
        return best;
      },
      moveByCharacters: function(_cm, head, motionArgs) {
        var cur = head;
        var repeat = motionArgs.repeat;
        var ch = motionArgs.forward ? cur.ch + repeat : cur.ch - repeat;
        return Pos(cur.line, ch);
      },
      moveByLines: function(cm, head, motionArgs, vim) {
        var cur = head;
        var endCh = cur.ch;
        // Depending what our last motion was, we may want to do different
        // things. If our last motion was moving vertically, we want to
        // preserve the HPos from our last horizontal move.  If our last motion
        // was going to the end of a line, moving vertically we should go to
        // the end of the line, etc.
        switch (vim.lastMotion) {
          case this.moveByLines:
          case this.moveByDisplayLines:
          case this.moveByScroll:
          case this.moveToColumn:
          case this.moveToEol:
            endCh = vim.lastHPos;
            break;
          default:
            vim.lastHPos = endCh;
        }
        var repeat = motionArgs.repeat+(motionArgs.repeatOffset||0);
        var line = motionArgs.forward ? cur.line + repeat : cur.line - repeat;
        var first = cm.firstLine();
        var last = cm.lastLine();
        var posV = cm.findPosV(cur, (motionArgs.forward ? repeat : -repeat), 'line', vim.lastHSPos);
        var hasMarkedText = motionArgs.forward ? posV.line > line : posV.line < line;
        if (hasMarkedText) {
          line = posV.line;
          endCh = posV.ch;
        }
        // Vim go to line begin or line end when cursor at first/last line and
        // move to previous/next line is triggered.
        if (line < first && cur.line == first){
          return this.moveToStartOfLine(cm, head, motionArgs, vim);
        } else if (line > last && cur.line == last){
            return moveToEol(cm, head, motionArgs, vim, true);
        }
        if (motionArgs.toFirstChar){
          endCh=findFirstNonWhiteSpaceCharacter(cm.getLine(line));
          vim.lastHPos = endCh;
        }
        vim.lastHSPos = cm.charCoords(Pos(line, endCh),'div').left;
        return Pos(line, endCh);
      },
      moveByDisplayLines: function(cm, head, motionArgs, vim) {
        var cur = head;
        switch (vim.lastMotion) {
          case this.moveByDisplayLines:
          case this.moveByScroll:
          case this.moveByLines:
          case this.moveToColumn:
          case this.moveToEol:
            break;
          default:
            vim.lastHSPos = cm.charCoords(cur,'div').left;
        }
        var repeat = motionArgs.repeat;
        var res=cm.findPosV(cur,(motionArgs.forward ? repeat : -repeat),'line',vim.lastHSPos);
        if (res.hitSide) {
          if (motionArgs.forward) {
            var lastCharCoords = cm.charCoords(res, 'div');
            var goalCoords = { top: lastCharCoords.top + 8, left: vim.lastHSPos };
            var res = cm.coordsChar(goalCoords, 'div');
          } else {
            var resCoords = cm.charCoords(Pos(cm.firstLine(), 0), 'div');
            resCoords.left = vim.lastHSPos;
            res = cm.coordsChar(resCoords, 'div');
          }
        }
        vim.lastHPos = res.ch;
        return res;
      },
      moveByPage: function(cm, head, motionArgs) {
        // CodeMirror only exposes functions that move the cursor page down, so
        // doing this bad hack to move the cursor and move it back. evalInput
        // will move the cursor to where it should be in the end.
        var curStart = head;
        var repeat = motionArgs.repeat;
        return cm.findPosV(curStart, (motionArgs.forward ? repeat : -repeat), 'page');
      },
      moveByParagraph: function(cm, head, motionArgs) {
        var dir = motionArgs.forward ? 1 : -1;
        return findParagraph(cm, head, motionArgs.repeat, dir);
      },
      moveBySentence: function(cm, head, motionArgs) {
        var dir = motionArgs.forward ? 1 : -1;
        return findSentence(cm, head, motionArgs.repeat, dir);
      },
      moveByScroll: function(cm, head, motionArgs, vim) {
        var scrollbox = cm.getScrollInfo();
        var curEnd = null;
        var repeat = motionArgs.repeat;
        if (!repeat) {
          repeat = scrollbox.clientHeight / (2 * cm.defaultTextHeight());
        }
        var orig = cm.charCoords(head, 'local');
        motionArgs.repeat = repeat;
        var curEnd = motions.moveByDisplayLines(cm, head, motionArgs, vim);
        if (!curEnd) {
          return null;
        }
        var dest = cm.charCoords(curEnd, 'local');
        cm.scrollTo(null, scrollbox.top + dest.top - orig.top);
        return curEnd;
      },
      moveByWords: function(cm, head, motionArgs) {
        return moveToWord(cm, head, motionArgs.repeat, !!motionArgs.forward,
            !!motionArgs.wordEnd, !!motionArgs.bigWord);
      },
      moveTillCharacter: function(cm, _head, motionArgs) {
        var repeat = motionArgs.repeat;
        var curEnd = moveToCharacter(cm, repeat, motionArgs.forward,
            motionArgs.selectedCharacter);
        var increment = motionArgs.forward ? -1 : 1;
        recordLastCharacterSearch(increment, motionArgs);
        if (!curEnd) return null;
        curEnd.ch += increment;
        return curEnd;
      },
      moveToCharacter: function(cm, head, motionArgs) {
        var repeat = motionArgs.repeat;
        recordLastCharacterSearch(0, motionArgs);
        return moveToCharacter(cm, repeat, motionArgs.forward,
            motionArgs.selectedCharacter) || head;
      },
      moveToSymbol: function(cm, head, motionArgs) {
        var repeat = motionArgs.repeat;
        return findSymbol(cm, repeat, motionArgs.forward,
            motionArgs.selectedCharacter) || head;
      },
      moveToColumn: function(cm, head, motionArgs, vim) {
        var repeat = motionArgs.repeat;
        // repeat is equivalent to which column we want to move to!
        vim.lastHPos = repeat - 1;
        vim.lastHSPos = cm.charCoords(head,'div').left;
        return moveToColumn(cm, repeat);
      },
      moveToEol: function(cm, head, motionArgs, vim) {
        return moveToEol(cm, head, motionArgs, vim, false);
      },
      moveToFirstNonWhiteSpaceCharacter: function(cm, head) {
        // Go to the start of the line where the text begins, or the end for
        // whitespace-only lines
        var cursor = head;
        return Pos(cursor.line,
                   findFirstNonWhiteSpaceCharacter(cm.getLine(cursor.line)));
      },
      moveToMatchedSymbol: function(cm, head) {
        var cursor = head;
        var line = cursor.line;
        var ch = cursor.ch;
        var lineText = cm.getLine(line);
        var symbol;
        for (; ch < lineText.length; ch++) {
          symbol = lineText.charAt(ch);
          if (symbol && isMatchableSymbol(symbol)) {
            var style = cm.getTokenTypeAt(Pos(line, ch + 1));
            if (style !== "string" && style !== "comment") {
              break;
            }
          }
        }
        if (ch < lineText.length) {
          // Only include angle brackets in analysis if they are being matched.
          var re = (ch === '<' || ch === '>') ? /[(){}[\]<>]/ : /[(){}[\]]/;
          var matched = cm.findMatchingBracket(Pos(line, ch), {bracketRegex: re});
          return matched.to;
        } else {
          return cursor;
        }
      },
      moveToStartOfLine: function(_cm, head) {
        return Pos(head.line, 0);
      },
      moveToLineOrEdgeOfDocument: function(cm, _head, motionArgs) {
        var lineNum = motionArgs.forward ? cm.lastLine() : cm.firstLine();
        if (motionArgs.repeatIsExplicit) {
          lineNum = motionArgs.repeat - cm.getOption('firstLineNumber');
        }
        return Pos(lineNum,
                   findFirstNonWhiteSpaceCharacter(cm.getLine(lineNum)));
      },
      textObjectManipulation: function(cm, head, motionArgs, vim) {
        // TODO: lots of possible exceptions that can be thrown here. Try da(
        //     outside of a () block.
        var mirroredPairs = {'(': ')', ')': '(',
                             '{': '}', '}': '{',
                             '[': ']', ']': '[',
                             '<': '>', '>': '<'};
        var selfPaired = {'\'': true, '"': true, '`': true};

        var character = motionArgs.selectedCharacter;
        // 'b' refers to  '()' block.
        // 'B' refers to  '{}' block.
        if (character == 'b') {
          character = '(';
        } else if (character == 'B') {
          character = '{';
        }

        // Inclusive is the difference between a and i
        // TODO: Instead of using the additional text object map to perform text
        //     object operations, merge the map into the defaultKeyMap and use
        //     motionArgs to define behavior. Define separate entries for 'aw',
        //     'iw', 'a[', 'i[', etc.
        var inclusive = !motionArgs.textObjectInner;

        var tmp;
        if (mirroredPairs[character]) {
          tmp = selectCompanionObject(cm, head, character, inclusive);
        } else if (selfPaired[character]) {
          tmp = findBeginningAndEnd(cm, head, character, inclusive);
        } else if (character === 'W') {
          tmp = expandWordUnderCursor(cm, inclusive, true /** forward */,
                                                     true /** bigWord */);
        } else if (character === 'w') {
          tmp = expandWordUnderCursor(cm, inclusive, true /** forward */,
                                                     false /** bigWord */);
        } else if (character === 'p') {
          tmp = findParagraph(cm, head, motionArgs.repeat, 0, inclusive);
          motionArgs.linewise = true;
          if (vim.visualMode) {
            if (!vim.visualLine) { vim.visualLine = true; }
          } else {
            var operatorArgs = vim.inputState.operatorArgs;
            if (operatorArgs) { operatorArgs.linewise = true; }
            tmp.end.line--;
          }
        } else if (character === 't') {
          tmp = expandTagUnderCursor(cm, head, inclusive);
        } else {
          // No text object defined for this, don't move.
          return null;
        }

        if (!cm.state.vim.visualMode) {
          return [tmp.start, tmp.end];
        } else {
          return expandSelection(cm, tmp.start, tmp.end);
        }
      },

      repeatLastCharacterSearch: function(cm, head, motionArgs) {
        var lastSearch = vimGlobalState.lastCharacterSearch;
        var repeat = motionArgs.repeat;
        var forward = motionArgs.forward === lastSearch.forward;
        var increment = (lastSearch.increment ? 1 : 0) * (forward ? -1 : 1);
        cm.moveH(-increment, 'char');
        motionArgs.inclusive = forward ? true : false;
        var curEnd = moveToCharacter(cm, repeat, forward, lastSearch.selectedCharacter);
        if (!curEnd) {
          cm.moveH(increment, 'char');
          return head;
        }
        curEnd.ch += increment;
        return curEnd;
      }
    };

    function defineMotion(name, fn) {
      motions[name] = fn;
    }

    function fillArray(val, times) {
      var arr = [];
      for (var i = 0; i < times; i++) {
        arr.push(val);
      }
      return arr;
    }
    /**
     * An operator acts on a text selection. It receives the list of selections
     * as input. The corresponding CodeMirror selection is guaranteed to
    * match the input selection.
     */
    var operators = {
      change: function(cm, args, ranges) {
        var finalHead, text;
        var vim = cm.state.vim;
        var anchor = ranges[0].anchor,
            head = ranges[0].head;
        if (!vim.visualMode) {
          text = cm.getRange(anchor, head);
          var lastState = vim.lastEditInputState || {};
          if (lastState.motion == "moveByWords" && !isWhiteSpaceString(text)) {
            // Exclude trailing whitespace if the range is not all whitespace.
            var match = (/\s+$/).exec(text);
            if (match && lastState.motionArgs && lastState.motionArgs.forward) {
              head = offsetCursor(head, 0, - match[0].length);
              text = text.slice(0, - match[0].length);
            }
          }
          var prevLineEnd = new Pos(anchor.line - 1, Number.MAX_VALUE);
          var wasLastLine = cm.firstLine() == cm.lastLine();
          if (head.line > cm.lastLine() && args.linewise && !wasLastLine) {
            cm.replaceRange('', prevLineEnd, head);
          } else {
            cm.replaceRange('', anchor, head);
          }
          if (args.linewise) {
            // Push the next line back down, if there is a next line.
            if (!wasLastLine) {
              cm.setCursor(prevLineEnd);
              CodeMirror.commands.newlineAndIndent(cm);
            }
            // make sure cursor ends up at the end of the line.
            anchor.ch = Number.MAX_VALUE;
          }
          finalHead = anchor;
        } else if (args.fullLine) {
            head.ch = Number.MAX_VALUE;
            head.line--;
            cm.setSelection(anchor, head)
            text = cm.getSelection();
            cm.replaceSelection("");
            finalHead = anchor;
        } else {
          text = cm.getSelection();
          var replacement = fillArray('', ranges.length);
          cm.replaceSelections(replacement);
          finalHead = cursorMin(ranges[0].head, ranges[0].anchor);
        }
        vimGlobalState.registerController.pushText(
            args.registerName, 'change', text,
            args.linewise, ranges.length > 1);
        actions.enterInsertMode(cm, {head: finalHead}, cm.state.vim);
      },
      // delete is a javascript keyword.
      'delete': function(cm, args, ranges) {
        var finalHead, text;
        var vim = cm.state.vim;
        if (!vim.visualBlock) {
          var anchor = ranges[0].anchor,
              head = ranges[0].head;
          if (args.linewise &&
              head.line != cm.firstLine() &&
              anchor.line == cm.lastLine() &&
              anchor.line == head.line - 1) {
            // Special case for dd on last line (and first line).
            if (anchor.line == cm.firstLine()) {
              anchor.ch = 0;
            } else {
              anchor = Pos(anchor.line - 1, lineLength(cm, anchor.line - 1));
            }
          }
          text = cm.getRange(anchor, head);
          cm.replaceRange('', anchor, head);
          finalHead = anchor;
          if (args.linewise) {
            finalHead = motions.moveToFirstNonWhiteSpaceCharacter(cm, anchor);
          }
        } else {
          text = cm.getSelection();
          var replacement = fillArray('', ranges.length);
          cm.replaceSelections(replacement);
          finalHead = ranges[0].anchor;
        }
        vimGlobalState.registerController.pushText(
            args.registerName, 'delete', text,
            args.linewise, vim.visualBlock);
        return clipCursorToContent(cm, finalHead);
      },
      indent: function(cm, args, ranges) {
        var vim = cm.state.vim;
        var startLine = ranges[0].anchor.line;
        var endLine = vim.visualBlock ?
          ranges[ranges.length - 1].anchor.line :
          ranges[0].head.line;
        // In visual mode, n> shifts the selection right n times, instead of
        // shifting n lines right once.
        var repeat = (vim.visualMode) ? args.repeat : 1;
        if (args.linewise) {
          // The only way to delete a newline is to delete until the start of
          // the next line, so in linewise mode evalInput will include the next
          // line. We don't want this in indent, so we go back a line.
          endLine--;
        }
        for (var i = startLine; i <= endLine; i++) {
          for (var j = 0; j < repeat; j++) {
            cm.indentLine(i, args.indentRight);
          }
        }
        return motions.moveToFirstNonWhiteSpaceCharacter(cm, ranges[0].anchor);
      },
      indentAuto: function(cm, _args, ranges) {
        cm.execCommand("indentAuto");
        return motions.moveToFirstNonWhiteSpaceCharacter(cm, ranges[0].anchor);
      },
      changeCase: function(cm, args, ranges, oldAnchor, newHead) {
        var selections = cm.getSelections();
        var swapped = [];
        var toLower = args.toLower;
        for (var j = 0; j < selections.length; j++) {
          var toSwap = selections[j];
          var text = '';
          if (toLower === true) {
            text = toSwap.toLowerCase();
          } else if (toLower === false) {
            text = toSwap.toUpperCase();
          } else {
            for (var i = 0; i < toSwap.length; i++) {
              var character = toSwap.charAt(i);
              text += isUpperCase(character) ? character.toLowerCase() :
                  character.toUpperCase();
            }
          }
          swapped.push(text);
        }
        cm.replaceSelections(swapped);
        if (args.shouldMoveCursor){
          return newHead;
        } else if (!cm.state.vim.visualMode && args.linewise && ranges[0].anchor.line + 1 == ranges[0].head.line) {
          return motions.moveToFirstNonWhiteSpaceCharacter(cm, oldAnchor);
        } else if (args.linewise){
          return oldAnchor;
        } else {
          return cursorMin(ranges[0].anchor, ranges[0].head);
        }
      },
      yank: function(cm, args, ranges, oldAnchor) {
        var vim = cm.state.vim;
        var text = cm.getSelection();
        var endPos = vim.visualMode
          ? cursorMin(vim.sel.anchor, vim.sel.head, ranges[0].head, ranges[0].anchor)
          : oldAnchor;
        vimGlobalState.registerController.pushText(
            args.registerName, 'yank',
            text, args.linewise, vim.visualBlock);
        return endPos;
      }
    };

    function defineOperator(name, fn) {
      operators[name] = fn;
    }

    var actions = {
      jumpListWalk: function(cm, actionArgs, vim) {
        if (vim.visualMode) {
          return;
        }
        var repeat = actionArgs.repeat;
        var forward = actionArgs.forward;
        var jumpList = vimGlobalState.jumpList;

        var mark = jumpList.move(cm, forward ? repeat : -repeat);
        var markPos = mark ? mark.find() : undefined;
        markPos = markPos ? markPos : cm.getCursor();
        cm.setCursor(markPos);
      },
      scroll: function(cm, actionArgs, vim) {
        if (vim.visualMode) {
          return;
        }
        var repeat = actionArgs.repeat || 1;
        var lineHeight = cm.defaultTextHeight();
        var top = cm.getScrollInfo().top;
        var delta = lineHeight * repeat;
        var newPos = actionArgs.forward ? top + delta : top - delta;
        var cursor = copyCursor(cm.getCursor());
        var cursorCoords = cm.charCoords(cursor, 'local');
        if (actionArgs.forward) {
          if (newPos > cursorCoords.top) {
             cursor.line += (newPos - cursorCoords.top) / lineHeight;
             cursor.line = Math.ceil(cursor.line);
             cm.setCursor(cursor);
             cursorCoords = cm.charCoords(cursor, 'local');
             cm.scrollTo(null, cursorCoords.top);
          } else {
             // Cursor stays within bounds.  Just reposition the scroll window.
             cm.scrollTo(null, newPos);
          }
        } else {
          var newBottom = newPos + cm.getScrollInfo().clientHeight;
          if (newBottom < cursorCoords.bottom) {
             cursor.line -= (cursorCoords.bottom - newBottom) / lineHeight;
             cursor.line = Math.floor(cursor.line);
             cm.setCursor(cursor);
             cursorCoords = cm.charCoords(cursor, 'local');
             cm.scrollTo(
                 null, cursorCoords.bottom - cm.getScrollInfo().clientHeight);
          } else {
             // Cursor stays within bounds.  Just reposition the scroll window.
             cm.scrollTo(null, newPos);
          }
        }
      },
      scrollToCursor: function(cm, actionArgs) {
        var lineNum = cm.getCursor().line;
        var charCoords = cm.charCoords(Pos(lineNum, 0), 'local');
        var height = cm.getScrollInfo().clientHeight;
        var y = charCoords.top;
        var lineHeight = charCoords.bottom - y;
        switch (actionArgs.position) {
          case 'center': y = y - (height / 2) + lineHeight;
            break;
          case 'bottom': y = y - height + lineHeight;
            break;
        }
        cm.scrollTo(null, y);
      },
      replayMacro: function(cm, actionArgs, vim) {
        var registerName = actionArgs.selectedCharacter;
        var repeat = actionArgs.repeat;
        var macroModeState = vimGlobalState.macroModeState;
        if (registerName == '@') {
          registerName = macroModeState.latestRegister;
        } else {
          macroModeState.latestRegister = registerName;
        }
        while(repeat--){
          executeMacroRegister(cm, vim, macroModeState, registerName);
        }
      },
      enterMacroRecordMode: function(cm, actionArgs) {
        var macroModeState = vimGlobalState.macroModeState;
        var registerName = actionArgs.selectedCharacter;
        if (vimGlobalState.registerController.isValidRegister(registerName)) {
          macroModeState.enterMacroRecordMode(cm, registerName);
        }
      },
      toggleOverwrite: function(cm) {
        if (!cm.state.overwrite) {
          cm.toggleOverwrite(true);
          cm.setOption('keyMap', 'vim-replace');
          CodeMirror.signal(cm, "vim-mode-change", {mode: "replace"});
        } else {
          cm.toggleOverwrite(false);
          cm.setOption('keyMap', 'vim-insert');
          CodeMirror.signal(cm, "vim-mode-change", {mode: "insert"});
        }
      },
      enterInsertMode: function(cm, actionArgs, vim) {
        if (cm.getOption('readOnly')) { return; }
        vim.insertMode = true;
        vim.insertModeRepeat = actionArgs && actionArgs.repeat || 1;
        var insertAt = (actionArgs) ? actionArgs.insertAt : null;
        var sel = vim.sel;
        var head = actionArgs.head || cm.getCursor('head');
        var height = cm.listSelections().length;
        if (insertAt == 'eol') {
          head = Pos(head.line, lineLength(cm, head.line));
        } else if (insertAt == 'bol') {
          head = Pos(head.line, 0);
        } else if (insertAt == 'charAfter') {
          head = offsetCursor(head, 0, 1);
        } else if (insertAt == 'firstNonBlank') {
          head = motions.moveToFirstNonWhiteSpaceCharacter(cm, head);
        } else if (insertAt == 'startOfSelectedArea') {
          if (!vim.visualMode)
              return;
          if (!vim.visualBlock) {
            if (sel.head.line < sel.anchor.line) {
              head = sel.head;
            } else {
              head = Pos(sel.anchor.line, 0);
            }
          } else {
            head = Pos(
                Math.min(sel.head.line, sel.anchor.line),
                Math.min(sel.head.ch, sel.anchor.ch));
            height = Math.abs(sel.head.line - sel.anchor.line) + 1;
          }
        } else if (insertAt == 'endOfSelectedArea') {
            if (!vim.visualMode)
              return;
          if (!vim.visualBlock) {
            if (sel.head.line >= sel.anchor.line) {
              head = offsetCursor(sel.head, 0, 1);
            } else {
              head = Pos(sel.anchor.line, 0);
            }
          } else {
            head = Pos(
                Math.min(sel.head.line, sel.anchor.line),
                Math.max(sel.head.ch + 1, sel.anchor.ch));
            height = Math.abs(sel.head.line - sel.anchor.line) + 1;
          }
        } else if (insertAt == 'inplace') {
          if (vim.visualMode){
            return;
          }
        } else if (insertAt == 'lastEdit') {
          head = getLastEditPos(cm) || head;
        }
        cm.setOption('disableInput', false);
        if (actionArgs && actionArgs.replace) {
          // Handle Replace-mode as a special case of insert mode.
          cm.toggleOverwrite(true);
          cm.setOption('keyMap', 'vim-replace');
          CodeMirror.signal(cm, "vim-mode-change", {mode: "replace"});
        } else {
          cm.toggleOverwrite(false);
          cm.setOption('keyMap', 'vim-insert');
          CodeMirror.signal(cm, "vim-mode-change", {mode: "insert"});
        }
        if (!vimGlobalState.macroModeState.isPlaying) {
          // Only record if not replaying.
          cm.on('change', onChange);
          CodeMirror.on(cm.getInputField(), 'keydown', onKeyEventTargetKeyDown);
        }
        if (vim.visualMode) {
          exitVisualMode(cm);
        }
        selectForInsert(cm, head, height);
      },
      toggleVisualMode: function(cm, actionArgs, vim) {
        var repeat = actionArgs.repeat;
        var anchor = cm.getCursor();
        var head;
        // TODO: The repeat should actually select number of characters/lines
        //     equal to the repeat times the size of the previous visual
        //     operation.
        if (!vim.visualMode) {
          // Entering visual mode
          vim.visualMode = true;
          vim.visualLine = !!actionArgs.linewise;
          vim.visualBlock = !!actionArgs.blockwise;
          head = clipCursorToContent(
              cm, Pos(anchor.line, anchor.ch + repeat - 1));
          vim.sel = {
            anchor: anchor,
            head: head
          };
          CodeMirror.signal(cm, "vim-mode-change", {mode: "visual", subMode: vim.visualLine ? "linewise" : vim.visualBlock ? "blockwise" : ""});
          updateCmSelection(cm);
          updateMark(cm, vim, '<', cursorMin(anchor, head));
          updateMark(cm, vim, '>', cursorMax(anchor, head));
        } else if (vim.visualLine ^ actionArgs.linewise ||
            vim.visualBlock ^ actionArgs.blockwise) {
          // Toggling between modes
          vim.visualLine = !!actionArgs.linewise;
          vim.visualBlock = !!actionArgs.blockwise;
          CodeMirror.signal(cm, "vim-mode-change", {mode: "visual", subMode: vim.visualLine ? "linewise" : vim.visualBlock ? "blockwise" : ""});
          updateCmSelection(cm);
        } else {
          exitVisualMode(cm);
        }
      },
      reselectLastSelection: function(cm, _actionArgs, vim) {
        var lastSelection = vim.lastSelection;
        if (vim.visualMode) {
          updateLastSelection(cm, vim);
        }
        if (lastSelection) {
          var anchor = lastSelection.anchorMark.find();
          var head = lastSelection.headMark.find();
          if (!anchor || !head) {
            // If the marks have been destroyed due to edits, do nothing.
            return;
          }
          vim.sel = {
            anchor: anchor,
            head: head
          };
          vim.visualMode = true;
          vim.visualLine = lastSelection.visualLine;
          vim.visualBlock = lastSelection.visualBlock;
          updateCmSelection(cm);
          updateMark(cm, vim, '<', cursorMin(anchor, head));
          updateMark(cm, vim, '>', cursorMax(anchor, head));
          CodeMirror.signal(cm, 'vim-mode-change', {
            mode: 'visual',
            subMode: vim.visualLine ? 'linewise' :
                     vim.visualBlock ? 'blockwise' : ''});
        }
      },
      joinLines: function(cm, actionArgs, vim) {
        var curStart, curEnd;
        if (vim.visualMode) {
          curStart = cm.getCursor('anchor');
          curEnd = cm.getCursor('head');
          if (cursorIsBefore(curEnd, curStart)) {
            var tmp = curEnd;
            curEnd = curStart;
            curStart = tmp;
          }
          curEnd.ch = lineLength(cm, curEnd.line) - 1;
        } else {
          // Repeat is the number of lines to join. Minimum 2 lines.
          var repeat = Math.max(actionArgs.repeat, 2);
          curStart = cm.getCursor();
          curEnd = clipCursorToContent(cm, Pos(curStart.line + repeat - 1,
                                               Infinity));
        }
        var finalCh = 0;
        for (var i = curStart.line; i < curEnd.line; i++) {
          finalCh = lineLength(cm, curStart.line);
          var tmp = Pos(curStart.line + 1,
                        lineLength(cm, curStart.line + 1));
          var text = cm.getRange(curStart, tmp);
          text = actionArgs.keepSpaces
            ? text.replace(/\n\r?/g, '')
            : text.replace(/\n\s*/g, ' ');
          cm.replaceRange(text, curStart, tmp);
        }
        var curFinalPos = Pos(curStart.line, finalCh);
        if (vim.visualMode) {
          exitVisualMode(cm, false);
        }
        cm.setCursor(curFinalPos);
      },
      newLineAndEnterInsertMode: function(cm, actionArgs, vim) {
        vim.insertMode = true;
        var insertAt = copyCursor(cm.getCursor());
        if (insertAt.line === cm.firstLine() && !actionArgs.after) {
          // Special case for inserting newline before start of document.
          cm.replaceRange('\n', Pos(cm.firstLine(), 0));
          cm.setCursor(cm.firstLine(), 0);
        } else {
          insertAt.line = (actionArgs.after) ? insertAt.line :
              insertAt.line - 1;
          insertAt.ch = lineLength(cm, insertAt.line);
          cm.setCursor(insertAt);
          var newlineFn = CodeMirror.commands.newlineAndIndentContinueComment ||
              CodeMirror.commands.newlineAndIndent;
          newlineFn(cm);
        }
        this.enterInsertMode(cm, { repeat: actionArgs.repeat }, vim);
      },
      paste: function(cm, actionArgs, vim) {
        var cur = copyCursor(cm.getCursor());
        var register = vimGlobalState.registerController.getRegister(
            actionArgs.registerName);
        var text = register.toString();
        if (!text) {
          return;
        }
        if (actionArgs.matchIndent) {
          var tabSize = cm.getOption("tabSize");
          // length that considers tabs and tabSize
          var whitespaceLength = function(str) {
            var tabs = (str.split("\t").length - 1);
            var spaces = (str.split(" ").length - 1);
            return tabs * tabSize + spaces * 1;
          };
          var currentLine = cm.getLine(cm.getCursor().line);
          var indent = whitespaceLength(currentLine.match(/^\s*/)[0]);
          // chomp last newline b/c don't want it to match /^\s*/gm
          var chompedText = text.replace(/\n$/, '');
          var wasChomped = text !== chompedText;
          var firstIndent = whitespaceLength(text.match(/^\s*/)[0]);
          var text = chompedText.replace(/^\s*/gm, function(wspace) {
            var newIndent = indent + (whitespaceLength(wspace) - firstIndent);
            if (newIndent < 0) {
              return "";
            }
            else if (cm.getOption("indentWithTabs")) {
              var quotient = Math.floor(newIndent / tabSize);
              return Array(quotient + 1).join('\t');
            }
            else {
              return Array(newIndent + 1).join(' ');
            }
          });
          text += wasChomped ? "\n" : "";
        }
        if (actionArgs.repeat > 1) {
          var text = Array(actionArgs.repeat + 1).join(text);
        }
        var linewise = register.linewise;
        var blockwise = register.blockwise;
        if (blockwise) {
          text = text.split('\n');
          if (linewise) {
              text.pop();
          }
          for (var i = 0; i < text.length; i++) {
            text[i] = (text[i] == '') ? ' ' : text[i];
          }
          cur.ch += actionArgs.after ? 1 : 0;
          cur.ch = Math.min(lineLength(cm, cur.line), cur.ch);
        } else if (linewise) {
          if(vim.visualMode) {
            text = vim.visualLine ? text.slice(0, -1) : '\n' + text.slice(0, text.length - 1) + '\n';
          } else if (actionArgs.after) {
            // Move the newline at the end to the start instead, and paste just
            // before the newline character of the line we are on right now.
            text = '\n' + text.slice(0, text.length - 1);
            cur.ch = lineLength(cm, cur.line);
          } else {
            cur.ch = 0;
          }
        } else {
          cur.ch += actionArgs.after ? 1 : 0;
        }
        var curPosFinal;
        var idx;
        if (vim.visualMode) {
          //  save the pasted text for reselection if the need arises
          vim.lastPastedText = text;
          var lastSelectionCurEnd;
          var selectedArea = getSelectedAreaRange(cm, vim);
          var selectionStart = selectedArea[0];
          var selectionEnd = selectedArea[1];
          var selectedText = cm.getSelection();
          var selections = cm.listSelections();
          var emptyStrings = new Array(selections.length).join('1').split('1');
          // save the curEnd marker before it get cleared due to cm.replaceRange.
          if (vim.lastSelection) {
            lastSelectionCurEnd = vim.lastSelection.headMark.find();
          }
          // push the previously selected text to unnamed register
          vimGlobalState.registerController.unnamedRegister.setText(selectedText);
          if (blockwise) {
            // first delete the selected text
            cm.replaceSelections(emptyStrings);
            // Set new selections as per the block length of the yanked text
            selectionEnd = Pos(selectionStart.line + text.length-1, selectionStart.ch);
            cm.setCursor(selectionStart);
            selectBlock(cm, selectionEnd);
            cm.replaceSelections(text);
            curPosFinal = selectionStart;
          } else if (vim.visualBlock) {
            cm.replaceSelections(emptyStrings);
            cm.setCursor(selectionStart);
            cm.replaceRange(text, selectionStart, selectionStart);
            curPosFinal = selectionStart;
          } else {
            cm.replaceRange(text, selectionStart, selectionEnd);
            curPosFinal = cm.posFromIndex(cm.indexFromPos(selectionStart) + text.length - 1);
          }
          // restore the the curEnd marker
          if(lastSelectionCurEnd) {
            vim.lastSelection.headMark = cm.setBookmark(lastSelectionCurEnd);
          }
          if (linewise) {
            curPosFinal.ch=0;
          }
        } else {
          if (blockwise) {
            cm.setCursor(cur);
            for (var i = 0; i < text.length; i++) {
              var line = cur.line+i;
              if (line > cm.lastLine()) {
                cm.replaceRange('\n',  Pos(line, 0));
              }
              var lastCh = lineLength(cm, line);
              if (lastCh < cur.ch) {
                extendLineToColumn(cm, line, cur.ch);
              }
            }
            cm.setCursor(cur);
            selectBlock(cm, Pos(cur.line + text.length-1, cur.ch));
            cm.replaceSelections(text);
            curPosFinal = cur;
          } else {
            cm.replaceRange(text, cur);
            // Now fine tune the cursor to where we want it.
            if (linewise && actionArgs.after) {
              curPosFinal = Pos(
              cur.line + 1,
              findFirstNonWhiteSpaceCharacter(cm.getLine(cur.line + 1)));
            } else if (linewise && !actionArgs.after) {
              curPosFinal = Pos(
                cur.line,
                findFirstNonWhiteSpaceCharacter(cm.getLine(cur.line)));
            } else if (!linewise && actionArgs.after) {
              idx = cm.indexFromPos(cur);
              curPosFinal = cm.posFromIndex(idx + text.length - 1);
            } else {
              idx = cm.indexFromPos(cur);
              curPosFinal = cm.posFromIndex(idx + text.length);
            }
          }
        }
        if (vim.visualMode) {
          exitVisualMode(cm, false);
        }
        cm.setCursor(curPosFinal);
      },
      undo: function(cm, actionArgs) {
        cm.operation(function() {
          repeatFn(cm, CodeMirror.commands.undo, actionArgs.repeat)();
          cm.setCursor(cm.getCursor('anchor'));
        });
      },
      redo: function(cm, actionArgs) {
        repeatFn(cm, CodeMirror.commands.redo, actionArgs.repeat)();
      },
      setRegister: function(_cm, actionArgs, vim) {
        vim.inputState.registerName = actionArgs.selectedCharacter;
      },
      setMark: function(cm, actionArgs, vim) {
        var markName = actionArgs.selectedCharacter;
        updateMark(cm, vim, markName, cm.getCursor());
      },
      replace: function(cm, actionArgs, vim) {
        var replaceWith = actionArgs.selectedCharacter;
        var curStart = cm.getCursor();
        var replaceTo;
        var curEnd;
        var selections = cm.listSelections();
        if (vim.visualMode) {
          curStart = cm.getCursor('start');
          curEnd = cm.getCursor('end');
        } else {
          var line = cm.getLine(curStart.line);
          replaceTo = curStart.ch + actionArgs.repeat;
          if (replaceTo > line.length) {
            replaceTo=line.length;
          }
          curEnd = Pos(curStart.line, replaceTo);
        }
        if (replaceWith=='\n') {
          if (!vim.visualMode) cm.replaceRange('', curStart, curEnd);
          // special case, where vim help says to replace by just one line-break
          (CodeMirror.commands.newlineAndIndentContinueComment || CodeMirror.commands.newlineAndIndent)(cm);
        } else {
          var replaceWithStr = cm.getRange(curStart, curEnd);
          //replace all characters in range by selected, but keep linebreaks
          replaceWithStr = replaceWithStr.replace(/[^\n]/g, replaceWith);
          if (vim.visualBlock) {
            // Tabs are split in visua block before replacing
            var spaces = new Array(cm.getOption("tabSize")+1).join(' ');
            replaceWithStr = cm.getSelection();
            replaceWithStr = replaceWithStr.replace(/\t/g, spaces).replace(/[^\n]/g, replaceWith).split('\n');
            cm.replaceSelections(replaceWithStr);
          } else {
            cm.replaceRange(replaceWithStr, curStart, curEnd);
          }
          if (vim.visualMode) {
            curStart = cursorIsBefore(selections[0].anchor, selections[0].head) ?
                         selections[0].anchor : selections[0].head;
            cm.setCursor(curStart);
            exitVisualMode(cm, false);
          } else {
            cm.setCursor(offsetCursor(curEnd, 0, -1));
          }
        }
      },
      incrementNumberToken: function(cm, actionArgs) {
        var cur = cm.getCursor();
        var lineStr = cm.getLine(cur.line);
        var re = /(-?)(?:(0x)([\da-f]+)|(0b|0|)(\d+))/gi;
        var match;
        var start;
        var end;
        var numberStr;
        while ((match = re.exec(lineStr)) !== null) {
          start = match.index;
          end = start + match[0].length;
          if (cur.ch < end)break;
        }
        if (!actionArgs.backtrack && (end <= cur.ch))return;
        if (match) {
          var baseStr = match[2] || match[4]
          var digits = match[3] || match[5]
          var increment = actionArgs.increase ? 1 : -1;
          var base = {'0b': 2, '0': 8, '': 10, '0x': 16}[baseStr.toLowerCase()];
          var number = parseInt(match[1] + digits, base) + (increment * actionArgs.repeat);
          numberStr = number.toString(base);
          var zeroPadding = baseStr ? new Array(digits.length - numberStr.length + 1 + match[1].length).join('0') : ''
          if (numberStr.charAt(0) === '-') {
            numberStr = '-' + baseStr + zeroPadding + numberStr.substr(1);
          } else {
            numberStr = baseStr + zeroPadding + numberStr;
          }
          var from = Pos(cur.line, start);
          var to = Pos(cur.line, end);
          cm.replaceRange(numberStr, from, to);
        } else {
          return;
        }
        cm.setCursor(Pos(cur.line, start + numberStr.length - 1));
      },
      repeatLastEdit: function(cm, actionArgs, vim) {
        var lastEditInputState = vim.lastEditInputState;
        if (!lastEditInputState) { return; }
        var repeat = actionArgs.repeat;
        if (repeat && actionArgs.repeatIsExplicit) {
          vim.lastEditInputState.repeatOverride = repeat;
        } else {
          repeat = vim.lastEditInputState.repeatOverride || repeat;
        }
        repeatLastEdit(cm, vim, repeat, false /** repeatForInsert */);
      },
      indent: function(cm, actionArgs) {
        cm.indentLine(cm.getCursor().line, actionArgs.indentRight);
      },
      exitInsertMode: exitInsertMode
    };

    function defineAction(name, fn) {
      actions[name] = fn;
    }

    /*
     * Below are miscellaneous utility functions used by vim.js
     */

    /**
     * Clips cursor to ensure that line is within the buffer's range
     * If includeLineBreak is true, then allow cur.ch == lineLength.
     */
    function clipCursorToContent(cm, cur) {
      var vim = cm.state.vim;
      var includeLineBreak = vim.insertMode || vim.visualMode;
      var line = Math.min(Math.max(cm.firstLine(), cur.line), cm.lastLine() );
      var maxCh = lineLength(cm, line) - 1 + !!includeLineBreak;
      var ch = Math.min(Math.max(0, cur.ch), maxCh);
      return Pos(line, ch);
    }
    function copyArgs(args) {
      var ret = {};
      for (var prop in args) {
        if (args.hasOwnProperty(prop)) {
          ret[prop] = args[prop];
        }
      }
      return ret;
    }
    function offsetCursor(cur, offsetLine, offsetCh) {
      if (typeof offsetLine === 'object') {
        offsetCh = offsetLine.ch;
        offsetLine = offsetLine.line;
      }
      return Pos(cur.line + offsetLine, cur.ch + offsetCh);
    }
    function commandMatches(keys, keyMap, context, inputState) {
      // Partial matches are not applied. They inform the key handler
      // that the current key sequence is a subsequence of a valid key
      // sequence, so that the key buffer is not cleared.
      var match, partial = [], full = [];
      for (var i = 0; i < keyMap.length; i++) {
        var command = keyMap[i];
        if (context == 'insert' && command.context != 'insert' ||
            command.context && command.context != context ||
            inputState.operator && command.type == 'action' ||
            !(match = commandMatch(keys, command.keys))) { continue; }
        if (match == 'partial') { partial.push(command); }
        if (match == 'full') { full.push(command); }
      }
      return {
        partial: partial.length && partial,
        full: full.length && full
      };
    }
    function commandMatch(pressed, mapped) {
      if (mapped.slice(-11) == '<character>') {
        // Last character matches anything.
        var prefixLen = mapped.length - 11;
        var pressedPrefix = pressed.slice(0, prefixLen);
        var mappedPrefix = mapped.slice(0, prefixLen);
        return pressedPrefix == mappedPrefix && pressed.length > prefixLen ? 'full' :
               mappedPrefix.indexOf(pressedPrefix) == 0 ? 'partial' : false;
      } else {
        return pressed == mapped ? 'full' :
               mapped.indexOf(pressed) == 0 ? 'partial' : false;
      }
    }
    function lastChar(keys) {
      var match = /^.*(<[^>]+>)$/.exec(keys);
      var selectedCharacter = match ? match[1] : keys.slice(-1);
      if (selectedCharacter.length > 1){
        switch(selectedCharacter){
          case '<CR>':
            selectedCharacter='\n';
            break;
          case '<Space>':
            selectedCharacter=' ';
            break;
          default:
            selectedCharacter='';
            break;
        }
      }
      return selectedCharacter;
    }
    function repeatFn(cm, fn, repeat) {
      return function() {
        for (var i = 0; i < repeat; i++) {
          fn(cm);
        }
      };
    }
    function copyCursor(cur) {
      return Pos(cur.line, cur.ch);
    }
    function cursorEqual(cur1, cur2) {
      return cur1.ch == cur2.ch && cur1.line == cur2.line;
    }
    function cursorIsBefore(cur1, cur2) {
      if (cur1.line < cur2.line) {
        return true;
      }
      if (cur1.line == cur2.line && cur1.ch < cur2.ch) {
        return true;
      }
      return false;
    }
    function cursorMin(cur1, cur2) {
      if (arguments.length > 2) {
        cur2 = cursorMin.apply(undefined, Array.prototype.slice.call(arguments, 1));
      }
      return cursorIsBefore(cur1, cur2) ? cur1 : cur2;
    }
    function cursorMax(cur1, cur2) {
      if (arguments.length > 2) {
        cur2 = cursorMax.apply(undefined, Array.prototype.slice.call(arguments, 1));
      }
      return cursorIsBefore(cur1, cur2) ? cur2 : cur1;
    }
    function cursorIsBetween(cur1, cur2, cur3) {
      // returns true if cur2 is between cur1 and cur3.
      var cur1before2 = cursorIsBefore(cur1, cur2);
      var cur2before3 = cursorIsBefore(cur2, cur3);
      return cur1before2 && cur2before3;
    }
    function lineLength(cm, lineNum) {
      return cm.getLine(lineNum).length;
    }
    function trim(s) {
      if (s.trim) {
        return s.trim();
      }
      return s.replace(/^\s+|\s+$/g, '');
    }
    function escapeRegex(s) {
      return s.replace(/([.?*+$\[\]\/\\(){}|\-])/g, '\\$1');
    }
    function extendLineToColumn(cm, lineNum, column) {
      var endCh = lineLength(cm, lineNum);
      var spaces = new Array(column-endCh+1).join(' ');
      cm.setCursor(Pos(lineNum, endCh));
      cm.replaceRange(spaces, cm.getCursor());
    }
    // This functions selects a rectangular block
    // of text with selectionEnd as any of its corner
    // Height of block:
    // Difference in selectionEnd.line and first/last selection.line
    // Width of the block:
    // Distance between selectionEnd.ch and any(first considered here) selection.ch
    function selectBlock(cm, selectionEnd) {
      var selections = [], ranges = cm.listSelections();
      var head = copyCursor(cm.clipPos(selectionEnd));
      var isClipped = !cursorEqual(selectionEnd, head);
      var curHead = cm.getCursor('head');
      var primIndex = getIndex(ranges, curHead);
      var wasClipped = cursorEqual(ranges[primIndex].head, ranges[primIndex].anchor);
      var max = ranges.length - 1;
      var index = max - primIndex > primIndex ? max : 0;
      var base = ranges[index].anchor;

      var firstLine = Math.min(base.line, head.line);
      var lastLine = Math.max(base.line, head.line);
      var baseCh = base.ch, headCh = head.ch;

      var dir = ranges[index].head.ch - baseCh;
      var newDir = headCh - baseCh;
      if (dir > 0 && newDir <= 0) {
        baseCh++;
        if (!isClipped) { headCh--; }
      } else if (dir < 0 && newDir >= 0) {
        baseCh--;
        if (!wasClipped) { headCh++; }
      } else if (dir < 0 && newDir == -1) {
        baseCh--;
        headCh++;
      }
      for (var line = firstLine; line <= lastLine; line++) {
        var range = {anchor: new Pos(line, baseCh), head: new Pos(line, headCh)};
        selections.push(range);
      }
      cm.setSelections(selections);
      selectionEnd.ch = headCh;
      base.ch = baseCh;
      return base;
    }
    function selectForInsert(cm, head, height) {
      var sel = [];
      for (var i = 0; i < height; i++) {
        var lineHead = offsetCursor(head, i, 0);
        sel.push({anchor: lineHead, head: lineHead});
      }
      cm.setSelections(sel, 0);
    }
    // getIndex returns the index of the cursor in the selections.
    function getIndex(ranges, cursor, end) {
      for (var i = 0; i < ranges.length; i++) {
        var atAnchor = end != 'head' && cursorEqual(ranges[i].anchor, cursor);
        var atHead = end != 'anchor' && cursorEqual(ranges[i].head, cursor);
        if (atAnchor || atHead) {
          return i;
        }
      }
      return -1;
    }
    function getSelectedAreaRange(cm, vim) {
      var lastSelection = vim.lastSelection;
      var getCurrentSelectedAreaRange = function() {
        var selections = cm.listSelections();
        var start =  selections[0];
        var end = selections[selections.length-1];
        var selectionStart = cursorIsBefore(start.anchor, start.head) ? start.anchor : start.head;
        var selectionEnd = cursorIsBefore(end.anchor, end.head) ? end.head : end.anchor;
        return [selectionStart, selectionEnd];
      };
      var getLastSelectedAreaRange = function() {
        var selectionStart = cm.getCursor();
        var selectionEnd = cm.getCursor();
        var block = lastSelection.visualBlock;
        if (block) {
          var width = block.width;
          var height = block.height;
          selectionEnd = Pos(selectionStart.line + height, selectionStart.ch + width);
          var selections = [];
          // selectBlock creates a 'proper' rectangular block.
          // We do not want that in all cases, so we manually set selections.
          for (var i = selectionStart.line; i < selectionEnd.line; i++) {
            var anchor = Pos(i, selectionStart.ch);
            var head = Pos(i, selectionEnd.ch);
            var range = {anchor: anchor, head: head};
            selections.push(range);
          }
          cm.setSelections(selections);
        } else {
          var start = lastSelection.anchorMark.find();
          var end = lastSelection.headMark.find();
          var line = end.line - start.line;
          var ch = end.ch - start.ch;
          selectionEnd = {line: selectionEnd.line + line, ch: line ? selectionEnd.ch : ch + selectionEnd.ch};
          if (lastSelection.visualLine) {
            selectionStart = Pos(selectionStart.line, 0);
            selectionEnd = Pos(selectionEnd.line, lineLength(cm, selectionEnd.line));
          }
          cm.setSelection(selectionStart, selectionEnd);
        }
        return [selectionStart, selectionEnd];
      };
      if (!vim.visualMode) {
      // In case of replaying the action.
        return getLastSelectedAreaRange();
      } else {
        return getCurrentSelectedAreaRange();
      }
    }
    // Updates the previous selection with the current selection's values. This
    // should only be called in visual mode.
    function updateLastSelection(cm, vim) {
      var anchor = vim.sel.anchor;
      var head = vim.sel.head;
      // To accommodate the effect of lastPastedText in the last selection
      if (vim.lastPastedText) {
        head = cm.posFromIndex(cm.indexFromPos(anchor) + vim.lastPastedText.length);
        vim.lastPastedText = null;
      }
      vim.lastSelection = {'anchorMark': cm.setBookmark(anchor),
                           'headMark': cm.setBookmark(head),
                           'anchor': copyCursor(anchor),
                           'head': copyCursor(head),
                           'visualMode': vim.visualMode,
                           'visualLine': vim.visualLine,
                           'visualBlock': vim.visualBlock};
    }
    function expandSelection(cm, start, end) {
      var sel = cm.state.vim.sel;
      var head = sel.head;
      var anchor = sel.anchor;
      var tmp;
      if (cursorIsBefore(end, start)) {
        tmp = end;
        end = start;
        start = tmp;
      }
      if (cursorIsBefore(head, anchor)) {
        head = cursorMin(start, head);
        anchor = cursorMax(anchor, end);
      } else {
        anchor = cursorMin(start, anchor);
        head = cursorMax(head, end);
        head = offsetCursor(head, 0, -1);
        if (head.ch == -1 && head.line != cm.firstLine()) {
          head = Pos(head.line - 1, lineLength(cm, head.line - 1));
        }
      }
      return [anchor, head];
    }
    /**
     * Updates the CodeMirror selection to match the provided vim selection.
     * If no arguments are given, it uses the current vim selection state.
     */
    function updateCmSelection(cm, sel, mode) {
      var vim = cm.state.vim;
      sel = sel || vim.sel;
      var mode = mode ||
        vim.visualLine ? 'line' : vim.visualBlock ? 'block' : 'char';
      var cmSel = makeCmSelection(cm, sel, mode);
      cm.setSelections(cmSel.ranges, cmSel.primary);
      updateFakeCursor(cm);
    }
    function makeCmSelection(cm, sel, mode, exclusive) {
      var head = copyCursor(sel.head);
      var anchor = copyCursor(sel.anchor);
      if (mode == 'char') {
        var headOffset = !exclusive && !cursorIsBefore(sel.head, sel.anchor) ? 1 : 0;
        var anchorOffset = cursorIsBefore(sel.head, sel.anchor) ? 1 : 0;
        head = offsetCursor(sel.head, 0, headOffset);
        anchor = offsetCursor(sel.anchor, 0, anchorOffset);
        return {
          ranges: [{anchor: anchor, head: head}],
          primary: 0
        };
      } else if (mode == 'line') {
        if (!cursorIsBefore(sel.head, sel.anchor)) {
          anchor.ch = 0;

          var lastLine = cm.lastLine();
          if (head.line > lastLine) {
            head.line = lastLine;
          }
          head.ch = lineLength(cm, head.line);
        } else {
          head.ch = 0;
          anchor.ch = lineLength(cm, anchor.line);
        }
        return {
          ranges: [{anchor: anchor, head: head}],
          primary: 0
        };
      } else if (mode == 'block') {
        var top = Math.min(anchor.line, head.line),
            left = Math.min(anchor.ch, head.ch),
            bottom = Math.max(anchor.line, head.line),
            right = Math.max(anchor.ch, head.ch) + 1;
        var height = bottom - top + 1;
        var primary = head.line == top ? 0 : height - 1;
        var ranges = [];
        for (var i = 0; i < height; i++) {
          ranges.push({
            anchor: Pos(top + i, left),
            head: Pos(top + i, right)
          });
        }
        return {
          ranges: ranges,
          primary: primary
        };
      }
    }
    function getHead(cm) {
      var cur = cm.getCursor('head');
      if (cm.getSelection().length == 1) {
        // Small corner case when only 1 character is selected. The "real"
        // head is the left of head and anchor.
        cur = cursorMin(cur, cm.getCursor('anchor'));
      }
      return cur;
    }

    /**
     * If moveHead is set to false, the CodeMirror selection will not be
     * touched. The caller assumes the responsibility of putting the cursor
    * in the right place.
     */
    function exitVisualMode(cm, moveHead) {
      var vim = cm.state.vim;
      if (moveHead !== false) {
        cm.setCursor(clipCursorToContent(cm, vim.sel.head));
      }
      updateLastSelection(cm, vim);
      vim.visualMode = false;
      vim.visualLine = false;
      vim.visualBlock = false;
      if (!vim.insertMode) CodeMirror.signal(cm, "vim-mode-change", {mode: "normal"});
      clearFakeCursor(vim);
    }

    // Remove any trailing newlines from the selection. For
    // example, with the caret at the start of the last word on the line,
    // 'dw' should word, but not the newline, while 'w' should advance the
    // caret to the first character of the next line.
    function clipToLine(cm, curStart, curEnd) {
      var selection = cm.getRange(curStart, curEnd);
      // Only clip if the selection ends with trailing newline + whitespace
      if (/\n\s*$/.test(selection)) {
        var lines = selection.split('\n');
        // We know this is all whitespace.
        lines.pop();

        // Cases:
        // 1. Last word is an empty line - do not clip the trailing '\n'
        // 2. Last word is not an empty line - clip the trailing '\n'
        var line;
        // Find the line containing the last word, and clip all whitespace up
        // to it.
        for (var line = lines.pop(); lines.length > 0 && line && isWhiteSpaceString(line); line = lines.pop()) {
          curEnd.line--;
          curEnd.ch = 0;
        }
        // If the last word is not an empty line, clip an additional newline
        if (line) {
          curEnd.line--;
          curEnd.ch = lineLength(cm, curEnd.line);
        } else {
          curEnd.ch = 0;
        }
      }
    }

    // Expand the selection to line ends.
    function expandSelectionToLine(_cm, curStart, curEnd) {
      curStart.ch = 0;
      curEnd.ch = 0;
      curEnd.line++;
    }

    function findFirstNonWhiteSpaceCharacter(text) {
      if (!text) {
        return 0;
      }
      var firstNonWS = text.search(/\S/);
      return firstNonWS == -1 ? text.length : firstNonWS;
    }

    function expandWordUnderCursor(cm, inclusive, _forward, bigWord, noSymbol) {
      var cur = getHead(cm);
      var line = cm.getLine(cur.line);
      var idx = cur.ch;

      // Seek to first word or non-whitespace character, depending on if
      // noSymbol is true.
      var test = noSymbol ? wordCharTest[0] : bigWordCharTest [0];
      while (!test(line.charAt(idx))) {
        idx++;
        if (idx >= line.length) { return null; }
      }

      if (bigWord) {
        test = bigWordCharTest[0];
      } else {
        test = wordCharTest[0];
        if (!test(line.charAt(idx))) {
          test = wordCharTest[1];
        }
      }

      var end = idx, start = idx;
      while (test(line.charAt(end)) && end < line.length) { end++; }
      while (test(line.charAt(start)) && start >= 0) { start--; }
      start++;

      if (inclusive) {
        // If present, include all whitespace after word.
        // Otherwise, include all whitespace before word, except indentation.
        var wordEnd = end;
        while (/\s/.test(line.charAt(end)) && end < line.length) { end++; }
        if (wordEnd == end) {
          var wordStart = start;
          while (/\s/.test(line.charAt(start - 1)) && start > 0) { start--; }
          if (!start) { start = wordStart; }
        }
      }
      return { start: Pos(cur.line, start), end: Pos(cur.line, end) };
    }

    /**
     * Depends on the following:
     *
     * - editor mode should be htmlmixedmode / xml
     * - mode/xml/xml.js should be loaded
     * - addon/fold/xml-fold.js should be loaded
     *
     * If any of the above requirements are not true, this function noops.
     *
     * This is _NOT_ a 100% accurate implementation of vim tag text objects.
     * The following caveats apply (based off cursory testing, I'm sure there
     * are other discrepancies):
     *
     * - Does not work inside comments:
     *   ```
     *   <!-- <div>broken</div> -->
     *   ```
     * - Does not work when tags have different cases:
     *   ```
     *   <div>broken</DIV>
     *   ```
     * - Does not work when cursor is inside a broken tag:
     *   ```
     *   <div><brok><en></div>
     *   ```
     */
    function expandTagUnderCursor(cm, head, inclusive) {
      var cur = head;
      if (!CodeMirror.findMatchingTag || !CodeMirror.findEnclosingTag) {
        return { start: cur, end: cur };
      }

      var tags = CodeMirror.findMatchingTag(cm, head) || CodeMirror.findEnclosingTag(cm, head);
      if (!tags || !tags.open || !tags.close) {
        return { start: cur, end: cur };
      }

      if (inclusive) {
        return { start: tags.open.from, end: tags.close.to };
      }
      return { start: tags.open.to, end: tags.close.from };
    }

    function recordJumpPosition(cm, oldCur, newCur) {
      if (!cursorEqual(oldCur, newCur)) {
        vimGlobalState.jumpList.add(cm, oldCur, newCur);
      }
    }

    function recordLastCharacterSearch(increment, args) {
        vimGlobalState.lastCharacterSearch.increment = increment;
        vimGlobalState.lastCharacterSearch.forward = args.forward;
        vimGlobalState.lastCharacterSearch.selectedCharacter = args.selectedCharacter;
    }

    var symbolToMode = {
        '(': 'bracket', ')': 'bracket', '{': 'bracket', '}': 'bracket',
        '[': 'section', ']': 'section',
        '*': 'comment', '/': 'comment',
        'm': 'method', 'M': 'method',
        '#': 'preprocess'
    };
    var findSymbolModes = {
      bracket: {
        isComplete: function(state) {
          if (state.nextCh === state.symb) {
            state.depth++;
            if (state.depth >= 1)return true;
          } else if (state.nextCh === state.reverseSymb) {
            state.depth--;
          }
          return false;
        }
      },
      section: {
        init: function(state) {
          state.curMoveThrough = true;
          state.symb = (state.forward ? ']' : '[') === state.symb ? '{' : '}';
        },
        isComplete: function(state) {
          return state.index === 0 && state.nextCh === state.symb;
        }
      },
      comment: {
        isComplete: function(state) {
          var found = state.lastCh === '*' && state.nextCh === '/';
          state.lastCh = state.nextCh;
          return found;
        }
      },
      // TODO: The original Vim implementation only operates on level 1 and 2.
      // The current implementation doesn't check for code block level and
      // therefore it operates on any levels.
      method: {
        init: function(state) {
          state.symb = (state.symb === 'm' ? '{' : '}');
          state.reverseSymb = state.symb === '{' ? '}' : '{';
        },
        isComplete: function(state) {
          if (state.nextCh === state.symb)return true;
          return false;
        }
      },
      preprocess: {
        init: function(state) {
          state.index = 0;
        },
        isComplete: function(state) {
          if (state.nextCh === '#') {
            var token = state.lineText.match(/#(\w+)/)[1];
            if (token === 'endif') {
              if (state.forward && state.depth === 0) {
                return true;
              }
              state.depth++;
            } else if (token === 'if') {
              if (!state.forward && state.depth === 0) {
                return true;
              }
              state.depth--;
            }
            if (token === 'else' && state.depth === 0)return true;
          }
          return false;
        }
      }
    };
    function findSymbol(cm, repeat, forward, symb) {
      var cur = copyCursor(cm.getCursor());
      var increment = forward ? 1 : -1;
      var endLine = forward ? cm.lineCount() : -1;
      var curCh = cur.ch;
      var line = cur.line;
      var lineText = cm.getLine(line);
      var state = {
        lineText: lineText,
        nextCh: lineText.charAt(curCh),
        lastCh: null,
        index: curCh,
        symb: symb,
        reverseSymb: (forward ?  { ')': '(', '}': '{' } : { '(': ')', '{': '}' })[symb],
        forward: forward,
        depth: 0,
        curMoveThrough: false
      };
      var mode = symbolToMode[symb];
      if (!mode)return cur;
      var init = findSymbolModes[mode].init;
      var isComplete = findSymbolModes[mode].isComplete;
      if (init) { init(state); }
      while (line !== endLine && repeat) {
        state.index += increment;
        state.nextCh = state.lineText.charAt(state.index);
        if (!state.nextCh) {
          line += increment;
          state.lineText = cm.getLine(line) || '';
          if (increment > 0) {
            state.index = 0;
          } else {
            var lineLen = state.lineText.length;
            state.index = (lineLen > 0) ? (lineLen-1) : 0;
          }
          state.nextCh = state.lineText.charAt(state.index);
        }
        if (isComplete(state)) {
          cur.line = line;
          cur.ch = state.index;
          repeat--;
        }
      }
      if (state.nextCh || state.curMoveThrough) {
        return Pos(line, state.index);
      }
      return cur;
    }

    /*
     * Returns the boundaries of the next word. If the cursor in the middle of
     * the word, then returns the boundaries of the current word, starting at
     * the cursor. If the cursor is at the start/end of a word, and we are going
     * forward/backward, respectively, find the boundaries of the next word.
     *
     * @param {CodeMirror} cm CodeMirror object.
     * @param {Cursor} cur The cursor position.
     * @param {boolean} forward True to search forward. False to search
     *     backward.
     * @param {boolean} bigWord True if punctuation count as part of the word.
     *     False if only [a-zA-Z0-9] characters count as part of the word.
     * @param {boolean} emptyLineIsWord True if empty lines should be treated
     *     as words.
     * @return {Object{from:number, to:number, line: number}} The boundaries of
     *     the word, or null if there are no more words.
     */
    function findWord(cm, cur, forward, bigWord, emptyLineIsWord) {
      var lineNum = cur.line;
      var pos = cur.ch;
      var line = cm.getLine(lineNum);
      var dir = forward ? 1 : -1;
      var charTests = bigWord ? bigWordCharTest: wordCharTest;

      if (emptyLineIsWord && line == '') {
        lineNum += dir;
        line = cm.getLine(lineNum);
        if (!isLine(cm, lineNum)) {
          return null;
        }
        pos = (forward) ? 0 : line.length;
      }

      while (true) {
        if (emptyLineIsWord && line == '') {
          return { from: 0, to: 0, line: lineNum };
        }
        var stop = (dir > 0) ? line.length : -1;
        var wordStart = stop, wordEnd = stop;
        // Find bounds of next word.
        while (pos != stop) {
          var foundWord = false;
          for (var i = 0; i < charTests.length && !foundWord; ++i) {
            if (charTests[i](line.charAt(pos))) {
              wordStart = pos;
              // Advance to end of word.
              while (pos != stop && charTests[i](line.charAt(pos))) {
                pos += dir;
              }
              wordEnd = pos;
              foundWord = wordStart != wordEnd;
              if (wordStart == cur.ch && lineNum == cur.line &&
                  wordEnd == wordStart + dir) {
                // We started at the end of a word. Find the next one.
                continue;
              } else {
                return {
                  from: Math.min(wordStart, wordEnd + 1),
                  to: Math.max(wordStart, wordEnd),
                  line: lineNum };
              }
            }
          }
          if (!foundWord) {
            pos += dir;
          }
        }
        // Advance to next/prev line.
        lineNum += dir;
        if (!isLine(cm, lineNum)) {
          return null;
        }
        line = cm.getLine(lineNum);
        pos = (dir > 0) ? 0 : line.length;
      }
    }

    /**
     * @param {CodeMirror} cm CodeMirror object.
     * @param {Pos} cur The position to start from.
     * @param {int} repeat Number of words to move past.
     * @param {boolean} forward True to search forward. False to search
     *     backward.
     * @param {boolean} wordEnd True to move to end of word. False to move to
     *     beginning of word.
     * @param {boolean} bigWord True if punctuation count as part of the word.
     *     False if only alphabet characters count as part of the word.
     * @return {Cursor} The position the cursor should move to.
     */
    function moveToWord(cm, cur, repeat, forward, wordEnd, bigWord) {
      var curStart = copyCursor(cur);
      var words = [];
      if (forward && !wordEnd || !forward && wordEnd) {
        repeat++;
      }
      // For 'e', empty lines are not considered words, go figure.
      var emptyLineIsWord = !(forward && wordEnd);
      for (var i = 0; i < repeat; i++) {
        var word = findWord(cm, cur, forward, bigWord, emptyLineIsWord);
        if (!word) {
          var eodCh = lineLength(cm, cm.lastLine());
          words.push(forward
              ? {line: cm.lastLine(), from: eodCh, to: eodCh}
              : {line: 0, from: 0, to: 0});
          break;
        }
        words.push(word);
        cur = Pos(word.line, forward ? (word.to - 1) : word.from);
      }
      var shortCircuit = words.length != repeat;
      var firstWord = words[0];
      var lastWord = words.pop();
      if (forward && !wordEnd) {
        // w
        if (!shortCircuit && (firstWord.from != curStart.ch || firstWord.line != curStart.line)) {
          // We did not start in the middle of a word. Discard the extra word at the end.
          lastWord = words.pop();
        }
        return Pos(lastWord.line, lastWord.from);
      } else if (forward && wordEnd) {
        return Pos(lastWord.line, lastWord.to - 1);
      } else if (!forward && wordEnd) {
        // ge
        if (!shortCircuit && (firstWord.to != curStart.ch || firstWord.line != curStart.line)) {
          // We did not start in the middle of a word. Discard the extra word at the end.
          lastWord = words.pop();
        }
        return Pos(lastWord.line, lastWord.to);
      } else {
        // b
        return Pos(lastWord.line, lastWord.from);
      }
    }

    function moveToEol(cm, head, motionArgs, vim, keepHPos) {
      var cur = head;
      var retval= Pos(cur.line + motionArgs.repeat - 1, Infinity);
      var end=cm.clipPos(retval);
      end.ch--;
      if (!keepHPos) {
        vim.lastHPos = Infinity;
        vim.lastHSPos = cm.charCoords(end,'div').left;
      }
      return retval;
    }

    function moveToCharacter(cm, repeat, forward, character) {
      var cur = cm.getCursor();
      var start = cur.ch;
      var idx;
      for (var i = 0; i < repeat; i ++) {
        var line = cm.getLine(cur.line);
        idx = charIdxInLine(start, line, character, forward, true);
        if (idx == -1) {
          return null;
        }
        start = idx;
      }
      return Pos(cm.getCursor().line, idx);
    }

    function moveToColumn(cm, repeat) {
      // repeat is always >= 1, so repeat - 1 always corresponds
      // to the column we want to go to.
      var line = cm.getCursor().line;
      return clipCursorToContent(cm, Pos(line, repeat - 1));
    }

    function updateMark(cm, vim, markName, pos) {
      if (!inArray(markName, validMarks)) {
        return;
      }
      if (vim.marks[markName]) {
        vim.marks[markName].clear();
      }
      vim.marks[markName] = cm.setBookmark(pos);
    }

    function charIdxInLine(start, line, character, forward, includeChar) {
      // Search for char in line.
      // motion_options: {forward, includeChar}
      // If includeChar = true, include it too.
      // If forward = true, search forward, else search backwards.
      // If char is not found on this line, do nothing
      var idx;
      if (forward) {
        idx = line.indexOf(character, start + 1);
        if (idx != -1 && !includeChar) {
          idx -= 1;
        }
      } else {
        idx = line.lastIndexOf(character, start - 1);
        if (idx != -1 && !includeChar) {
          idx += 1;
        }
      }
      return idx;
    }

    function findParagraph(cm, head, repeat, dir, inclusive) {
      var line = head.line;
      var min = cm.firstLine();
      var max = cm.lastLine();
      var start, end, i = line;
      function isEmpty(i) { return !cm.getLine(i); }
      function isBoundary(i, dir, any) {
        if (any) { return isEmpty(i) != isEmpty(i + dir); }
        return !isEmpty(i) && isEmpty(i + dir);
      }
      if (dir) {
        while (min <= i && i <= max && repeat > 0) {
          if (isBoundary(i, dir)) { repeat--; }
          i += dir;
        }
        return new Pos(i, 0);
      }

      var vim = cm.state.vim;
      if (vim.visualLine && isBoundary(line, 1, true)) {
        var anchor = vim.sel.anchor;
        if (isBoundary(anchor.line, -1, true)) {
          if (!inclusive || anchor.line != line) {
            line += 1;
          }
        }
      }
      var startState = isEmpty(line);
      for (i = line; i <= max && repeat; i++) {
        if (isBoundary(i, 1, true)) {
          if (!inclusive || isEmpty(i) != startState) {
            repeat--;
          }
        }
      }
      end = new Pos(i, 0);
      // select boundary before paragraph for the last one
      if (i > max && !startState) { startState = true; }
      else { inclusive = false; }
      for (i = line; i > min; i--) {
        if (!inclusive || isEmpty(i) == startState || i == line) {
          if (isBoundary(i, -1, true)) { break; }
        }
      }
      start = new Pos(i, 0);
      return { start: start, end: end };
    }

    function findSentence(cm, cur, repeat, dir) {

      /*
        Takes an index object
        {
          line: the line string,
          ln: line number,
          pos: index in line,
          dir: direction of traversal (-1 or 1)
        }
        and modifies the line, ln, and pos members to represent the
        next valid position or sets them to null if there are
        no more valid positions.
       */
      function nextChar(cm, idx) {
        if (idx.pos + idx.dir < 0 || idx.pos + idx.dir >= idx.line.length) {
          idx.ln += idx.dir;
          if (!isLine(cm, idx.ln)) {
            idx.line = null;
            idx.ln = null;
            idx.pos = null;
            return;
          }
          idx.line = cm.getLine(idx.ln);
          idx.pos = (idx.dir > 0) ? 0 : idx.line.length - 1;
        }
        else {
          idx.pos += idx.dir;
        }
      }

      /*
        Performs one iteration of traversal in forward direction
        Returns an index object of the new location
       */
      function forward(cm, ln, pos, dir) {
        var line = cm.getLine(ln);
        var stop = (line === "");

        var curr = {
          line: line,
          ln: ln,
          pos: pos,
          dir: dir,
        }

        var last_valid = {
          ln: curr.ln,
          pos: curr.pos,
        }

        var skip_empty_lines = (curr.line === "");

        // Move one step to skip character we start on
        nextChar(cm, curr);

        while (curr.line !== null) {
          last_valid.ln = curr.ln;
          last_valid.pos = curr.pos;

          if (curr.line === "" && !skip_empty_lines) {
            return { ln: curr.ln, pos: curr.pos, };
          }
          else if (stop && curr.line !== "" && !isWhiteSpaceString(curr.line[curr.pos])) {
            return { ln: curr.ln, pos: curr.pos, };
          }
          else if (isEndOfSentenceSymbol(curr.line[curr.pos])
            && !stop
            && (curr.pos === curr.line.length - 1
              || isWhiteSpaceString(curr.line[curr.pos + 1]))) {
            stop = true;
          }

          nextChar(cm, curr);
        }

        /*
          Set the position to the last non whitespace character on the last
          valid line in the case that we reach the end of the document.
        */
        var line = cm.getLine(last_valid.ln);
        last_valid.pos = 0;
        for(var i = line.length - 1; i >= 0; --i) {
          if (!isWhiteSpaceString(line[i])) {
            last_valid.pos = i;
            break;
          }
        }

        return last_valid;

      }

      /*
        Performs one iteration of traversal in reverse direction
        Returns an index object of the new location
       */
      function reverse(cm, ln, pos, dir) {
        var line = cm.getLine(ln);

        var curr = {
          line: line,
          ln: ln,
          pos: pos,
          dir: dir,
        }

        var last_valid = {
          ln: curr.ln,
          pos: null,
        };

        var skip_empty_lines = (curr.line === "");

        // Move one step to skip character we start on
        nextChar(cm, curr);

        while (curr.line !== null) {

          if (curr.line === "" && !skip_empty_lines) {
            if (last_valid.pos !== null) {
              return last_valid;
            }
            else {
              return { ln: curr.ln, pos: curr.pos };
            }
          }
          else if (isEndOfSentenceSymbol(curr.line[curr.pos])
              && last_valid.pos !== null
              && !(curr.ln === last_valid.ln && curr.pos + 1 === last_valid.pos)) {
            return last_valid;
          }
          else if (curr.line !== "" && !isWhiteSpaceString(curr.line[curr.pos])) {
            skip_empty_lines = false;
            last_valid = { ln: curr.ln, pos: curr.pos }
          }

          nextChar(cm, curr);
        }

        /*
          Set the position to the first non whitespace character on the last
          valid line in the case that we reach the beginning of the document.
        */
        var line = cm.getLine(last_valid.ln);
        last_valid.pos = 0;
        for(var i = 0; i < line.length; ++i) {
          if (!isWhiteSpaceString(line[i])) {
            last_valid.pos = i;
            break;
          }
        }
        return last_valid;
      }

      var curr_index = {
        ln: cur.line,
        pos: cur.ch,
      };

      while (repeat > 0) {
        if (dir < 0) {
          curr_index = reverse(cm, curr_index.ln, curr_index.pos, dir);
        }
        else {
          curr_index = forward(cm, curr_index.ln, curr_index.pos, dir);
        }
        repeat--;
      }

      return Pos(curr_index.ln, curr_index.pos);
    }

    // TODO: perhaps this finagling of start and end positions belongs
    // in codemirror/replaceRange?
    function selectCompanionObject(cm, head, symb, inclusive) {
      var cur = head, start, end;

      var bracketRegexp = ({
        '(': /[()]/, ')': /[()]/,
        '[': /[[\]]/, ']': /[[\]]/,
        '{': /[{}]/, '}': /[{}]/,
        '<': /[<>]/, '>': /[<>]/})[symb];
      var openSym = ({
        '(': '(', ')': '(',
        '[': '[', ']': '[',
        '{': '{', '}': '{',
        '<': '<', '>': '<'})[symb];
      var curChar = cm.getLine(cur.line).charAt(cur.ch);
      // Due to the behavior of scanForBracket, we need to add an offset if the
      // cursor is on a matching open bracket.
      var offset = curChar === openSym ? 1 : 0;

      start = cm.scanForBracket(Pos(cur.line, cur.ch + offset), -1, undefined, {'bracketRegex': bracketRegexp});
      end = cm.scanForBracket(Pos(cur.line, cur.ch + offset), 1, undefined, {'bracketRegex': bracketRegexp});

      if (!start || !end) {
        return { start: cur, end: cur };
      }

      start = start.pos;
      end = end.pos;

      if ((start.line == end.line && start.ch > end.ch)
          || (start.line > end.line)) {
        var tmp = start;
        start = end;
        end = tmp;
      }

      if (inclusive) {
        end.ch += 1;
      } else {
        start.ch += 1;
      }

      return { start: start, end: end };
    }

    // Takes in a symbol and a cursor and tries to simulate text objects that
    // have identical opening and closing symbols
    // TODO support across multiple lines
    function findBeginningAndEnd(cm, head, symb, inclusive) {
      var cur = copyCursor(head);
      var line = cm.getLine(cur.line);
      var chars = line.split('');
      var start, end, i, len;
      var firstIndex = chars.indexOf(symb);

      // the decision tree is to always look backwards for the beginning first,
      // but if the cursor is in front of the first instance of the symb,
      // then move the cursor forward
      if (cur.ch < firstIndex) {
        cur.ch = firstIndex;
        // Why is this line even here???
        // cm.setCursor(cur.line, firstIndex+1);
      }
      // otherwise if the cursor is currently on the closing symbol
      else if (firstIndex < cur.ch && chars[cur.ch] == symb) {
        end = cur.ch; // assign end to the current cursor
        --cur.ch; // make sure to look backwards
      }

      // if we're currently on the symbol, we've got a start
      if (chars[cur.ch] == symb && !end) {
        start = cur.ch + 1; // assign start to ahead of the cursor
      } else {
        // go backwards to find the start
        for (i = cur.ch; i > -1 && !start; i--) {
          if (chars[i] == symb) {
            start = i + 1;
          }
        }
      }

      // look forwards for the end symbol
      if (start && !end) {
        for (i = start, len = chars.length; i < len && !end; i++) {
          if (chars[i] == symb) {
            end = i;
          }
        }
      }

      // nothing found
      if (!start || !end) {
        return { start: cur, end: cur };
      }

      // include the symbols
      if (inclusive) {
        --start; ++end;
      }

      return {
        start: Pos(cur.line, start),
        end: Pos(cur.line, end)
      };
    }

    // Search functions
    defineOption('pcre', true, 'boolean');
    function SearchState() {}
    SearchState.prototype = {
      getQuery: function() {
        return vimGlobalState.query;
      },
      setQuery: function(query) {
        vimGlobalState.query = query;
      },
      getOverlay: function() {
        return this.searchOverlay;
      },
      setOverlay: function(overlay) {
        this.searchOverlay = overlay;
      },
      isReversed: function() {
        return vimGlobalState.isReversed;
      },
      setReversed: function(reversed) {
        vimGlobalState.isReversed = reversed;
      },
      getScrollbarAnnotate: function() {
        return this.annotate;
      },
      setScrollbarAnnotate: function(annotate) {
        this.annotate = annotate;
      }
    };
    function getSearchState(cm) {
      var vim = cm.state.vim;
      return vim.searchState_ || (vim.searchState_ = new SearchState());
    }
    function dialog(cm, template, shortText, onClose, options) {
      if (cm.openDialog) {
        cm.openDialog(template, onClose, { bottom: true, value: options.value,
            onKeyDown: options.onKeyDown, onKeyUp: options.onKeyUp,
            selectValueOnOpen: false});
      }
      else {
        onClose(prompt(shortText, ''));
      }
    }
    function splitBySlash(argString) {
      return splitBySeparator(argString, '/');
    }

    function findUnescapedSlashes(argString) {
      return findUnescapedSeparators(argString, '/');
    }

    function splitBySeparator(argString, separator) {
      var slashes = findUnescapedSeparators(argString, separator) || [];
      if (!slashes.length) return [];
      var tokens = [];
      // in case of strings like foo/bar
      if (slashes[0] !== 0) return;
      for (var i = 0; i < slashes.length; i++) {
        if (typeof slashes[i] == 'number')
          tokens.push(argString.substring(slashes[i] + 1, slashes[i+1]));
      }
      return tokens;
    }

    function findUnescapedSeparators(str, separator) {
      if (!separator)
        separator = '/';

      var escapeNextChar = false;
      var slashes = [];
      for (var i = 0; i < str.length; i++) {
        var c = str.charAt(i);
        if (!escapeNextChar && c == separator) {
          slashes.push(i);
        }
        escapeNextChar = !escapeNextChar && (c == '\\');
      }
      return slashes;
    }

    // Translates a search string from ex (vim) syntax into javascript form.
    function translateRegex(str) {
      // When these match, add a '\' if unescaped or remove one if escaped.
      var specials = '|(){';
      // Remove, but never add, a '\' for these.
      var unescape = '}';
      var escapeNextChar = false;
      var out = [];
      for (var i = -1; i < str.length; i++) {
        var c = str.charAt(i) || '';
        var n = str.charAt(i+1) || '';
        var specialComesNext = (n && specials.indexOf(n) != -1);
        if (escapeNextChar) {
          if (c !== '\\' || !specialComesNext) {
            out.push(c);
          }
          escapeNextChar = false;
        } else {
          if (c === '\\') {
            escapeNextChar = true;
            // Treat the unescape list as special for removing, but not adding '\'.
            if (n && unescape.indexOf(n) != -1) {
              specialComesNext = true;
            }
            // Not passing this test means removing a '\'.
            if (!specialComesNext || n === '\\') {
              out.push(c);
            }
          } else {
            out.push(c);
            if (specialComesNext && n !== '\\') {
              out.push('\\');
            }
          }
        }
      }
      return out.join('');
    }

    // Translates the replace part of a search and replace from ex (vim) syntax into
    // javascript form.  Similar to translateRegex, but additionally fixes back references
    // (translates '\[0..9]' to '$[0..9]') and follows different rules for escaping '$'.
    var charUnescapes = {'\\n': '\n', '\\r': '\r', '\\t': '\t'};
    function translateRegexReplace(str) {
      var escapeNextChar = false;
      var out = [];
      for (var i = -1; i < str.length; i++) {
        var c = str.charAt(i) || '';
        var n = str.charAt(i+1) || '';
        if (charUnescapes[c + n]) {
          out.push(charUnescapes[c+n]);
          i++;
        } else if (escapeNextChar) {
          // At any point in the loop, escapeNextChar is true if the previous
          // character was a '\' and was not escaped.
          out.push(c);
          escapeNextChar = false;
        } else {
          if (c === '\\') {
            escapeNextChar = true;
            if ((isNumber(n) || n === '$')) {
              out.push('$');
            } else if (n !== '/' && n !== '\\') {
              out.push('\\');
            }
          } else {
            if (c === '$') {
              out.push('$');
            }
            out.push(c);
            if (n === '/') {
              out.push('\\');
            }
          }
        }
      }
      return out.join('');
    }

    // Unescape \ and / in the replace part, for PCRE mode.
    var unescapes = {'\\/': '/', '\\\\': '\\', '\\n': '\n', '\\r': '\r', '\\t': '\t', '\\&':'&'};
    function unescapeRegexReplace(str) {
      var stream = new CodeMirror.StringStream(str);
      var output = [];
      while (!stream.eol()) {
        // Search for \.
        while (stream.peek() && stream.peek() != '\\') {
          output.push(stream.next());
        }
        var matched = false;
        for (var matcher in unescapes) {
          if (stream.match(matcher, true)) {
            matched = true;
            output.push(unescapes[matcher]);
            break;
          }
        }
        if (!matched) {
          // Don't change anything
          output.push(stream.next());
        }
      }
      return output.join('');
    }

    /**
     * Extract the regular expression from the query and return a Regexp object.
     * Returns null if the query is blank.
     * If ignoreCase is passed in, the Regexp object will have the 'i' flag set.
     * If smartCase is passed in, and the query contains upper case letters,
     *   then ignoreCase is overridden, and the 'i' flag will not be set.
     * If the query contains the /i in the flag part of the regular expression,
     *   then both ignoreCase and smartCase are ignored, and 'i' will be passed
     *   through to the Regex object.
     */
    function parseQuery(query, ignoreCase, smartCase) {
      // First update the last search register
      var lastSearchRegister = vimGlobalState.registerController.getRegister('/');
      lastSearchRegister.setText(query);
      // Check if the query is already a regex.
      if (query instanceof RegExp) { return query; }
      // First try to extract regex + flags from the input. If no flags found,
      // extract just the regex. IE does not accept flags directly defined in
      // the regex string in the form /regex/flags
      var slashes = findUnescapedSlashes(query);
      var regexPart;
      var forceIgnoreCase;
      if (!slashes.length) {
        // Query looks like 'regexp'
        regexPart = query;
      } else {
        // Query looks like 'regexp/...'
        regexPart = query.substring(0, slashes[0]);
        var flagsPart = query.substring(slashes[0]);
        forceIgnoreCase = (flagsPart.indexOf('i') != -1);
      }
      if (!regexPart) {
        return null;
      }
      if (!getOption('pcre')) {
        regexPart = translateRegex(regexPart);
      }
      if (smartCase) {
        ignoreCase = (/^[^A-Z]*$/).test(regexPart);
      }
      var regexp = new RegExp(regexPart,
          (ignoreCase || forceIgnoreCase) ? 'i' : undefined);
      return regexp;
    }
    function showConfirm(cm, text) {
      if (cm.openNotification) {
        cm.openNotification('<span style="color: red">' + text + '</span>',
                            {bottom: true, duration: 5000});
      } else {
        alert(text);
      }
    }
    function makePrompt(prefix, desc) {
      var raw = '<span style="font-family: monospace; white-space: pre">' +
          (prefix || "") + '<input type="text" autocorrect="off" ' +
          'autocapitalize="off" spellcheck="false"></span>';
      if (desc)
        raw += ' <span style="color: #888">' + desc + '</span>';
      return raw;
    }
    var searchPromptDesc = '(Javascript regexp)';
    function showPrompt(cm, options) {
      var shortText = (options.prefix || '') + ' ' + (options.desc || '');
      var prompt = makePrompt(options.prefix, options.desc);
      dialog(cm, prompt, shortText, options.onClose, options);
    }
    function regexEqual(r1, r2) {
      if (r1 instanceof RegExp && r2 instanceof RegExp) {
          var props = ['global', 'multiline', 'ignoreCase', 'source'];
          for (var i = 0; i < props.length; i++) {
              var prop = props[i];
              if (r1[prop] !== r2[prop]) {
                  return false;
              }
          }
          return true;
      }
      return false;
    }
    // Returns true if the query is valid.
    function updateSearchQuery(cm, rawQuery, ignoreCase, smartCase) {
      if (!rawQuery) {
        return;
      }
      var state = getSearchState(cm);
      var query = parseQuery(rawQuery, !!ignoreCase, !!smartCase);
      if (!query) {
        return;
      }
      highlightSearchMatches(cm, query);
      if (regexEqual(query, state.getQuery())) {
        return query;
      }
      state.setQuery(query);
      return query;
    }
    function searchOverlay(query) {
      if (query.source.charAt(0) == '^') {
        var matchSol = true;
      }
      return {
        token: function(stream) {
          if (matchSol && !stream.sol()) {
            stream.skipToEnd();
            return;
          }
          var match = stream.match(query, false);
          if (match) {
            if (match[0].length == 0) {
              // Matched empty string, skip to next.
              stream.next();
              return 'searching';
            }
            if (!stream.sol()) {
              // Backtrack 1 to match \b
              stream.backUp(1);
              if (!query.exec(stream.next() + match[0])) {
                stream.next();
                return null;
              }
            }
            stream.match(query);
            return 'searching';
          }
          while (!stream.eol()) {
            stream.next();
            if (stream.match(query, false)) break;
          }
        },
        query: query
      };
    }
    var highlightTimeout = 0;
    function highlightSearchMatches(cm, query) {
      clearTimeout(highlightTimeout);
      highlightTimeout = setTimeout(function() {
        var searchState = getSearchState(cm);
        var overlay = searchState.getOverlay();
        if (!overlay || query != overlay.query) {
          if (overlay) {
            cm.removeOverlay(overlay);
          }
          overlay = searchOverlay(query);
          cm.addOverlay(overlay);
          if (cm.showMatchesOnScrollbar) {
            if (searchState.getScrollbarAnnotate()) {
              searchState.getScrollbarAnnotate().clear();
            }
            searchState.setScrollbarAnnotate(cm.showMatchesOnScrollbar(query));
          }
          searchState.setOverlay(overlay);
        }
      }, 50);
    }
    function findNext(cm, prev, query, repeat) {
      if (repeat === undefined) { repeat = 1; }
      return cm.operation(function() {
        var pos = cm.getCursor();
        var cursor = cm.getSearchCursor(query, pos);
        for (var i = 0; i < repeat; i++) {
          var found = cursor.find(prev);
          if (i == 0 && found && cursorEqual(cursor.from(), pos)) { found = cursor.find(prev); }
          if (!found) {
            // SearchCursor may have returned null because it hit EOF, wrap
            // around and try again.
            cursor = cm.getSearchCursor(query,
                (prev) ? Pos(cm.lastLine()) : Pos(cm.firstLine(), 0) );
            if (!cursor.find(prev)) {
              return;
            }
          }
        }
        return cursor.from();
      });
    }
    /**
     * Pretty much the same as `findNext`, except for the following differences:
     *
     * 1. Before starting the search, move to the previous search. This way if our cursor is
     * already inside a match, we should return the current match.
     * 2. Rather than only returning the cursor's from, we return the cursor's from and to as a tuple.
     */
    function findNextFromAndToInclusive(cm, prev, query, repeat, vim) {
      if (repeat === undefined) { repeat = 1; }
      return cm.operation(function() {
        var pos = cm.getCursor();
        var cursor = cm.getSearchCursor(query, pos);

        // Go back one result to ensure that if the cursor is currently a match, we keep it.
        var found = cursor.find(!prev);

        // If we haven't moved, go back one more (similar to if i==0 logic in findNext).
        if (!vim.visualMode && found && cursorEqual(cursor.from(), pos)) {
          cursor.find(!prev);
        }

        for (var i = 0; i < repeat; i++) {
          found = cursor.find(prev);
          if (!found) {
            // SearchCursor may have returned null because it hit EOF, wrap
            // around and try again.
            cursor = cm.getSearchCursor(query,
                (prev) ? Pos(cm.lastLine()) : Pos(cm.firstLine(), 0) );
            if (!cursor.find(prev)) {
              return;
            }
          }
        }
        return [cursor.from(), cursor.to()];
      });
    }
    function clearSearchHighlight(cm) {
      var state = getSearchState(cm);
      cm.removeOverlay(getSearchState(cm).getOverlay());
      state.setOverlay(null);
      if (state.getScrollbarAnnotate()) {
        state.getScrollbarAnnotate().clear();
        state.setScrollbarAnnotate(null);
      }
    }
    /**
     * Check if pos is in the specified range, INCLUSIVE.
     * Range can be specified with 1 or 2 arguments.
     * If the first range argument is an array, treat it as an array of line
     * numbers. Match pos against any of the lines.
     * If the first range argument is a number,
     *   if there is only 1 range argument, check if pos has the same line
     *       number
     *   if there are 2 range arguments, then check if pos is in between the two
     *       range arguments.
     */
    function isInRange(pos, start, end) {
      if (typeof pos != 'number') {
        // Assume it is a cursor position. Get the line number.
        pos = pos.line;
      }
      if (start instanceof Array) {
        return inArray(pos, start);
      } else {
        if (end) {
          return (pos >= start && pos <= end);
        } else {
          return pos == start;
        }
      }
    }
    function getUserVisibleLines(cm) {
      var scrollInfo = cm.getScrollInfo();
      var occludeToleranceTop = 6;
      var occludeToleranceBottom = 10;
      var from = cm.coordsChar({left:0, top: occludeToleranceTop + scrollInfo.top}, 'local');
      var bottomY = scrollInfo.clientHeight - occludeToleranceBottom + scrollInfo.top;
      var to = cm.coordsChar({left:0, top: bottomY}, 'local');
      return {top: from.line, bottom: to.line};
    }

    function getMarkPos(cm, vim, markName) {
      if (markName == '\'' || markName == '`') {
        return vimGlobalState.jumpList.find(cm, -1) || Pos(0, 0);
      } else if (markName == '.') {
        return getLastEditPos(cm);
      }

      var mark = vim.marks[markName];
      return mark && mark.find();
    }

    function getLastEditPos(cm) {
      var done = cm.doc.history.done;
      for (var i = done.length; i--;) {
        if (done[i].changes) {
          return copyCursor(done[i].changes[0].to);
        }
      }
    }

    var ExCommandDispatcher = function() {
      this.buildCommandMap_();
    };
    ExCommandDispatcher.prototype = {
      processCommand: function(cm, input, opt_params) {
        var that = this;
        cm.operation(function () {
          cm.curOp.isVimOp = true;
          that._processCommand(cm, input, opt_params);
        });
      },
      _processCommand: function(cm, input, opt_params) {
        var vim = cm.state.vim;
        var commandHistoryRegister = vimGlobalState.registerController.getRegister(':');
        var previousCommand = commandHistoryRegister.toString();
        if (vim.visualMode) {
          exitVisualMode(cm);
        }
        var inputStream = new CodeMirror.StringStream(input);
        // update ": with the latest command whether valid or invalid
        commandHistoryRegister.setText(input);
        var params = opt_params || {};
        params.input = input;
        try {
          this.parseInput_(cm, inputStream, params);
        } catch(e) {
          showConfirm(cm, e);
          throw e;
        }
        var command;
        var commandName;
        if (!params.commandName) {
          // If only a line range is defined, move to the line.
          if (params.line !== undefined) {
            commandName = 'move';
          }
        } else {
          command = this.matchCommand_(params.commandName);
          if (command) {
            commandName = command.name;
            if (command.excludeFromCommandHistory) {
              commandHistoryRegister.setText(previousCommand);
            }
            this.parseCommandArgs_(inputStream, params, command);
            if (command.type == 'exToKey') {
              // Handle Ex to Key mapping.
              for (var i = 0; i < command.toKeys.length; i++) {
                CodeMirror.Vim.handleKey(cm, command.toKeys[i], 'mapping');
              }
              return;
            } else if (command.type == 'exToEx') {
              // Handle Ex to Ex mapping.
              this.processCommand(cm, command.toInput);
              return;
            }
          }
        }
        if (!commandName) {
          showConfirm(cm, 'Not an editor command ":' + input + '"');
          return;
        }
        try {
          exCommands[commandName](cm, params);
          // Possibly asynchronous commands (e.g. substitute, which might have a
          // user confirmation), are responsible for calling the callback when
          // done. All others have it taken care of for them here.
          if ((!command || !command.possiblyAsync) && params.callback) {
            params.callback();
          }
        } catch(e) {
          showConfirm(cm, e);
          throw e;
        }
      },
      parseInput_: function(cm, inputStream, result) {
        inputStream.eatWhile(':');
        // Parse range.
        if (inputStream.eat('%')) {
          result.line = cm.firstLine();
          result.lineEnd = cm.lastLine();
        } else {
          result.line = this.parseLineSpec_(cm, inputStream);
          if (result.line !== undefined && inputStream.eat(',')) {
            result.lineEnd = this.parseLineSpec_(cm, inputStream);
          }
        }

        // Parse command name.
        var commandMatch = inputStream.match(/^(\w+|!!|@@|[!#&*<=>@~])/);
        if (commandMatch) {
          result.commandName = commandMatch[1];
        } else {
          result.commandName = inputStream.match(/.*/)[0];
        }

        return result;
      },
      parseLineSpec_: function(cm, inputStream) {
        var numberMatch = inputStream.match(/^(\d+)/);
        if (numberMatch) {
          // Absolute line number plus offset (N+M or N-M) is probably a typo,
          // not something the user actually wanted. (NB: vim does allow this.)
          return parseInt(numberMatch[1], 10) - 1;
        }
        switch (inputStream.next()) {
          case '.':
            return this.parseLineSpecOffset_(inputStream, cm.getCursor().line);
          case '$':
            return this.parseLineSpecOffset_(inputStream, cm.lastLine());
          case '\'':
            var markName = inputStream.next();
            var markPos = getMarkPos(cm, cm.state.vim, markName);
            if (!markPos) throw new Error('Mark not set');
            return this.parseLineSpecOffset_(inputStream, markPos.line);
          case '-':
          case '+':
            inputStream.backUp(1);
            // Offset is relative to current line if not otherwise specified.
            return this.parseLineSpecOffset_(inputStream, cm.getCursor().line);
          default:
            inputStream.backUp(1);
            return undefined;
        }
      },
      parseLineSpecOffset_: function(inputStream, line) {
        var offsetMatch = inputStream.match(/^([+-])?(\d+)/);
        if (offsetMatch) {
          var offset = parseInt(offsetMatch[2], 10);
          if (offsetMatch[1] == "-") {
            line -= offset;
          } else {
            line += offset;
          }
        }
        return line;
      },
      parseCommandArgs_: function(inputStream, params, command) {
        if (inputStream.eol()) {
          return;
        }
        params.argString = inputStream.match(/.*/)[0];
        // Parse command-line arguments
        var delim = command.argDelimiter || /\s+/;
        var args = trim(params.argString).split(delim);
        if (args.length && args[0]) {
          params.args = args;
        }
      },
      matchCommand_: function(commandName) {
        // Return the command in the command map that matches the shortest
        // prefix of the passed in command name. The match is guaranteed to be
        // unambiguous if the defaultExCommandMap's shortNames are set up
        // correctly. (see @code{defaultExCommandMap}).
        for (var i = commandName.length; i > 0; i--) {
          var prefix = commandName.substring(0, i);
          if (this.commandMap_[prefix]) {
            var command = this.commandMap_[prefix];
            if (command.name.indexOf(commandName) === 0) {
              return command;
            }
          }
        }
        return null;
      },
      buildCommandMap_: function() {
        this.commandMap_ = {};
        for (var i = 0; i < defaultExCommandMap.length; i++) {
          var command = defaultExCommandMap[i];
          var key = command.shortName || command.name;
          this.commandMap_[key] = command;
        }
      },
      map: function(lhs, rhs, ctx) {
        if (lhs != ':' && lhs.charAt(0) == ':') {
          if (ctx) { throw Error('Mode not supported for ex mappings'); }
          var commandName = lhs.substring(1);
          if (rhs != ':' && rhs.charAt(0) == ':') {
            // Ex to Ex mapping
            this.commandMap_[commandName] = {
              name: commandName,
              type: 'exToEx',
              toInput: rhs.substring(1),
              user: true
            };
          } else {
            // Ex to key mapping
            this.commandMap_[commandName] = {
              name: commandName,
              type: 'exToKey',
              toKeys: rhs,
              user: true
            };
          }
        } else {
          if (rhs != ':' && rhs.charAt(0) == ':') {
            // Key to Ex mapping.
            var mapping = {
              keys: lhs,
              type: 'keyToEx',
              exArgs: { input: rhs.substring(1) }
            };
            if (ctx) { mapping.context = ctx; }
            defaultKeymap.unshift(mapping);
          } else {
            // Key to key mapping
            var mapping = {
              keys: lhs,
              type: 'keyToKey',
              toKeys: rhs
            };
            if (ctx) { mapping.context = ctx; }
            defaultKeymap.unshift(mapping);
          }
        }
      },
      unmap: function(lhs, ctx) {
        if (lhs != ':' && lhs.charAt(0) == ':') {
          // Ex to Ex or Ex to key mapping
          if (ctx) { throw Error('Mode not supported for ex mappings'); }
          var commandName = lhs.substring(1);
          if (this.commandMap_[commandName] && this.commandMap_[commandName].user) {
            delete this.commandMap_[commandName];
            return;
          }
        } else {
          // Key to Ex or key to key mapping
          var keys = lhs;
          for (var i = 0; i < defaultKeymap.length; i++) {
            if (keys == defaultKeymap[i].keys
                && defaultKeymap[i].context === ctx) {
              defaultKeymap.splice(i, 1);
              return;
            }
          }
        }
        throw Error('No such mapping.');
      }
    };

    var exCommands = {
      colorscheme: function(cm, params) {
        if (!params.args || params.args.length < 1) {
          showConfirm(cm, cm.getOption('theme'));
          return;
        }
        cm.setOption('theme', params.args[0]);
      },
      map: function(cm, params, ctx) {
        var mapArgs = params.args;
        if (!mapArgs || mapArgs.length < 2) {
          if (cm) {
            showConfirm(cm, 'Invalid mapping: ' + params.input);
          }
          return;
        }
        exCommandDispatcher.map(mapArgs[0], mapArgs[1], ctx);
      },
      imap: function(cm, params) { this.map(cm, params, 'insert'); },
      nmap: function(cm, params) { this.map(cm, params, 'normal'); },
      vmap: function(cm, params) { this.map(cm, params, 'visual'); },
      unmap: function(cm, params, ctx) {
        var mapArgs = params.args;
        if (!mapArgs || mapArgs.length < 1) {
          if (cm) {
            showConfirm(cm, 'No such mapping: ' + params.input);
          }
          return;
        }
        exCommandDispatcher.unmap(mapArgs[0], ctx);
      },
      move: function(cm, params) {
        commandDispatcher.processCommand(cm, cm.state.vim, {
            type: 'motion',
            motion: 'moveToLineOrEdgeOfDocument',
            motionArgs: { forward: false, explicitRepeat: true,
              linewise: true },
            repeatOverride: params.line+1});
      },
      set: function(cm, params) {
        var setArgs = params.args;
        // Options passed through to the setOption/getOption calls. May be passed in by the
        // local/global versions of the set command
        var setCfg = params.setCfg || {};
        if (!setArgs || setArgs.length < 1) {
          if (cm) {
            showConfirm(cm, 'Invalid mapping: ' + params.input);
          }
          return;
        }
        var expr = setArgs[0].split('=');
        var optionName = expr[0];
        var value = expr[1];
        var forceGet = false;

        if (optionName.charAt(optionName.length - 1) == '?') {
          // If post-fixed with ?, then the set is actually a get.
          if (value) { throw Error('Trailing characters: ' + params.argString); }
          optionName = optionName.substring(0, optionName.length - 1);
          forceGet = true;
        }
        if (value === undefined && optionName.substring(0, 2) == 'no') {
          // To set boolean options to false, the option name is prefixed with
          // 'no'.
          optionName = optionName.substring(2);
          value = false;
        }

        var optionIsBoolean = options[optionName] && options[optionName].type == 'boolean';
        if (optionIsBoolean && value == undefined) {
          // Calling set with a boolean option sets it to true.
          value = true;
        }
        // If no value is provided, then we assume this is a get.
        if (!optionIsBoolean && value === undefined || forceGet) {
          var oldValue = getOption(optionName, cm, setCfg);
          if (oldValue instanceof Error) {
            showConfirm(cm, oldValue.message);
          } else if (oldValue === true || oldValue === false) {
            showConfirm(cm, ' ' + (oldValue ? '' : 'no') + optionName);
          } else {
            showConfirm(cm, '  ' + optionName + '=' + oldValue);
          }
        } else {
          var setOptionReturn = setOption(optionName, value, cm, setCfg);
          if (setOptionReturn instanceof Error) {
            showConfirm(cm, setOptionReturn.message);
          }
        }
      },
      setlocal: function (cm, params) {
        // setCfg is passed through to setOption
        params.setCfg = {scope: 'local'};
        this.set(cm, params);
      },
      setglobal: function (cm, params) {
        // setCfg is passed through to setOption
        params.setCfg = {scope: 'global'};
        this.set(cm, params);
      },
      registers: function(cm, params) {
        var regArgs = params.args;
        var registers = vimGlobalState.registerController.registers;
        var regInfo = '----------Registers----------<br><br>';
        if (!regArgs) {
          for (var registerName in registers) {
            var text = registers[registerName].toString();
            if (text.length) {
              regInfo += '"' + registerName + '    ' + text + '<br>';
            }
          }
        } else {
          var registerName;
          regArgs = regArgs.join('');
          for (var i = 0; i < regArgs.length; i++) {
            registerName = regArgs.charAt(i);
            if (!vimGlobalState.registerController.isValidRegister(registerName)) {
              continue;
            }
            var register = registers[registerName] || new Register();
            regInfo += '"' + registerName + '    ' + register.toString() + '<br>';
          }
        }
        showConfirm(cm, regInfo);
      },
      sort: function(cm, params) {
        var reverse, ignoreCase, unique, number, pattern;
        function parseArgs() {
          if (params.argString) {
            var args = new CodeMirror.StringStream(params.argString);
            if (args.eat('!')) { reverse = true; }
            if (args.eol()) { return; }
            if (!args.eatSpace()) { return 'Invalid arguments'; }
            var opts = args.match(/([dinuox]+)?\s*(\/.+\/)?\s*/);
            if (!opts && !args.eol()) { return 'Invalid arguments'; }
            if (opts[1]) {
              ignoreCase = opts[1].indexOf('i') != -1;
              unique = opts[1].indexOf('u') != -1;
              var decimal = opts[1].indexOf('d') != -1 || opts[1].indexOf('n') != -1 && 1;
              var hex = opts[1].indexOf('x') != -1 && 1;
              var octal = opts[1].indexOf('o') != -1 && 1;
              if (decimal + hex + octal > 1) { return 'Invalid arguments'; }
              number = decimal && 'decimal' || hex && 'hex' || octal && 'octal';
            }
            if (opts[2]) {
              pattern = new RegExp(opts[2].substr(1, opts[2].length - 2), ignoreCase ? 'i' : '');
            }
          }
        }
        var err = parseArgs();
        if (err) {
          showConfirm(cm, err + ': ' + params.argString);
          return;
        }
        var lineStart = params.line || cm.firstLine();
        var lineEnd = params.lineEnd || params.line || cm.lastLine();
        if (lineStart == lineEnd) { return; }
        var curStart = Pos(lineStart, 0);
        var curEnd = Pos(lineEnd, lineLength(cm, lineEnd));
        var text = cm.getRange(curStart, curEnd).split('\n');
        var numberRegex = pattern ? pattern :
           (number == 'decimal') ? /(-?)([\d]+)/ :
           (number == 'hex') ? /(-?)(?:0x)?([0-9a-f]+)/i :
           (number == 'octal') ? /([0-7]+)/ : null;
        var radix = (number == 'decimal') ? 10 : (number == 'hex') ? 16 : (number == 'octal') ? 8 : null;
        var numPart = [], textPart = [];
        if (number || pattern) {
          for (var i = 0; i < text.length; i++) {
            var matchPart = pattern ? text[i].match(pattern) : null;
            if (matchPart && matchPart[0] != '') {
              numPart.push(matchPart);
            } else if (!pattern && numberRegex.exec(text[i])) {
              numPart.push(text[i]);
            } else {
              textPart.push(text[i]);
            }
          }
        } else {
          textPart = text;
        }
        function compareFn(a, b) {
          if (reverse) { var tmp; tmp = a; a = b; b = tmp; }
          if (ignoreCase) { a = a.toLowerCase(); b = b.toLowerCase(); }
          var anum = number && numberRegex.exec(a);
          var bnum = number && numberRegex.exec(b);
          if (!anum) { return a < b ? -1 : 1; }
          anum = parseInt((anum[1] + anum[2]).toLowerCase(), radix);
          bnum = parseInt((bnum[1] + bnum[2]).toLowerCase(), radix);
          return anum - bnum;
        }
        function comparePatternFn(a, b) {
          if (reverse) { var tmp; tmp = a; a = b; b = tmp; }
          if (ignoreCase) { a[0] = a[0].toLowerCase(); b[0] = b[0].toLowerCase(); }
          return (a[0] < b[0]) ? -1 : 1;
        }
        numPart.sort(pattern ? comparePatternFn : compareFn);
        if (pattern) {
          for (var i = 0; i < numPart.length; i++) {
            numPart[i] = numPart[i].input;
          }
        } else if (!number) { textPart.sort(compareFn); }
        text = (!reverse) ? textPart.concat(numPart) : numPart.concat(textPart);
        if (unique) { // Remove duplicate lines
          var textOld = text;
          var lastLine;
          text = [];
          for (var i = 0; i < textOld.length; i++) {
            if (textOld[i] != lastLine) {
              text.push(textOld[i]);
            }
            lastLine = textOld[i];
          }
        }
        cm.replaceRange(text.join('\n'), curStart, curEnd);
      },
      global: function(cm, params) {
        // a global command is of the form
        // :[range]g/pattern/[cmd]
        // argString holds the string /pattern/[cmd]
        var argString = params.argString;
        if (!argString) {
          showConfirm(cm, 'Regular Expression missing from global');
          return;
        }
        // range is specified here
        var lineStart = (params.line !== undefined) ? params.line : cm.firstLine();
        var lineEnd = params.lineEnd || params.line || cm.lastLine();
        // get the tokens from argString
        var tokens = splitBySlash(argString);
        var regexPart = argString, cmd;
        if (tokens.length) {
          regexPart = tokens[0];
          cmd = tokens.slice(1, tokens.length).join('/');
        }
        if (regexPart) {
          // If regex part is empty, then use the previous query. Otherwise
          // use the regex part as the new query.
          try {
           updateSearchQuery(cm, regexPart, true /** ignoreCase */,
             true /** smartCase */);
          } catch (e) {
           showConfirm(cm, 'Invalid regex: ' + regexPart);
           return;
          }
        }
        // now that we have the regexPart, search for regex matches in the
        // specified range of lines
        var query = getSearchState(cm).getQuery();
        var matchedLines = [], content = '';
        for (var i = lineStart; i <= lineEnd; i++) {
          var matched = query.test(cm.getLine(i));
          if (matched) {
            matchedLines.push(i+1);
            content+= cm.getLine(i) + '<br>';
          }
        }
        // if there is no [cmd], just display the list of matched lines
        if (!cmd) {
          showConfirm(cm, content);
          return;
        }
        var index = 0;
        var nextCommand = function() {
          if (index < matchedLines.length) {
            var command = matchedLines[index] + cmd;
            exCommandDispatcher.processCommand(cm, command, {
              callback: nextCommand
            });
          }
          index++;
        };
        nextCommand();
      },
      substitute: function(cm, params) {
        if (!cm.getSearchCursor) {
          throw new Error('Search feature not available. Requires searchcursor.js or ' +
              'any other getSearchCursor implementation.');
        }
        var argString = params.argString;
        var tokens = argString ? splitBySeparator(argString, argString[0]) : [];
        var regexPart, replacePart = '', trailing, flagsPart, count;
        var confirm = false; // Whether to confirm each replace.
        var global = false; // True to replace all instances on a line, false to replace only 1.
        if (tokens.length) {
          regexPart = tokens[0];
          if (getOption('pcre') && regexPart !== '') {
              regexPart = new RegExp(regexPart).source; //normalize not escaped characters
          }
          replacePart = tokens[1];
          if (regexPart && regexPart[regexPart.length - 1] === '$') {
            regexPart = regexPart.slice(0, regexPart.length - 1) + '\\n';
            replacePart = replacePart ? replacePart + '\n' : '\n';
          }
          if (replacePart !== undefined) {
            if (getOption('pcre')) {
              replacePart = unescapeRegexReplace(replacePart.replace(/([^\\])&/g,"$1$$&"));
            } else {
              replacePart = translateRegexReplace(replacePart);
            }
            vimGlobalState.lastSubstituteReplacePart = replacePart;
          }
          trailing = tokens[2] ? tokens[2].split(' ') : [];
        } else {
          // either the argString is empty or its of the form ' hello/world'
          // actually splitBySlash returns a list of tokens
          // only if the string starts with a '/'
          if (argString && argString.length) {
            showConfirm(cm, 'Substitutions should be of the form ' +
                ':s/pattern/replace/');
            return;
          }
        }
        // After the 3rd slash, we can have flags followed by a space followed
        // by count.
        if (trailing) {
          flagsPart = trailing[0];
          count = parseInt(trailing[1]);
          if (flagsPart) {
            if (flagsPart.indexOf('c') != -1) {
              confirm = true;
              flagsPart.replace('c', '');
            }
            if (flagsPart.indexOf('g') != -1) {
              global = true;
              flagsPart.replace('g', '');
            }
            if (getOption('pcre')) {
               regexPart = regexPart + '/' + flagsPart;
            } else {
               regexPart = regexPart.replace(/\//g, "\\/") + '/' + flagsPart;
            }
          }
        }
        if (regexPart) {
          // If regex part is empty, then use the previous query. Otherwise use
          // the regex part as the new query.
          try {
            updateSearchQuery(cm, regexPart, true /** ignoreCase */,
              true /** smartCase */);
          } catch (e) {
            showConfirm(cm, 'Invalid regex: ' + regexPart);
            return;
          }
        }
        replacePart = replacePart || vimGlobalState.lastSubstituteReplacePart;
        if (replacePart === undefined) {
          showConfirm(cm, 'No previous substitute regular expression');
          return;
        }
        var state = getSearchState(cm);
        var query = state.getQuery();
        var lineStart = (params.line !== undefined) ? params.line : cm.getCursor().line;
        var lineEnd = params.lineEnd || lineStart;
        if (lineStart == cm.firstLine() && lineEnd == cm.lastLine()) {
          lineEnd = Infinity;
        }
        if (count) {
          lineStart = lineEnd;
          lineEnd = lineStart + count - 1;
        }
        var startPos = clipCursorToContent(cm, Pos(lineStart, 0));
        var cursor = cm.getSearchCursor(query, startPos);
        doReplace(cm, confirm, global, lineStart, lineEnd, cursor, query, replacePart, params.callback);
      },
      redo: CodeMirror.commands.redo,
      undo: CodeMirror.commands.undo,
      write: function(cm) {
        if (CodeMirror.commands.save) {
          // If a save command is defined, call it.
          CodeMirror.commands.save(cm);
        } else if (cm.save) {
          // Saves to text area if no save command is defined and cm.save() is available.
          cm.save();
        }
      },
      nohlsearch: function(cm) {
        clearSearchHighlight(cm);
      },
      yank: function (cm) {
        var cur = copyCursor(cm.getCursor());
        var line = cur.line;
        var lineText = cm.getLine(line);
        vimGlobalState.registerController.pushText(
          '0', 'yank', lineText, true, true);
      },
      delmarks: function(cm, params) {
        if (!params.argString || !trim(params.argString)) {
          showConfirm(cm, 'Argument required');
          return;
        }

        var state = cm.state.vim;
        var stream = new CodeMirror.StringStream(trim(params.argString));
        while (!stream.eol()) {
          stream.eatSpace();

          // Record the streams position at the beginning of the loop for use
          // in error messages.
          var count = stream.pos;

          if (!stream.match(/[a-zA-Z]/, false)) {
            showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));
            return;
          }

          var sym = stream.next();
          // Check if this symbol is part of a range
          if (stream.match('-', true)) {
            // This symbol is part of a range.

            // The range must terminate at an alphabetic character.
            if (!stream.match(/[a-zA-Z]/, false)) {
              showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));
              return;
            }

            var startMark = sym;
            var finishMark = stream.next();
            // The range must terminate at an alphabetic character which
            // shares the same case as the start of the range.
            if (isLowerCase(startMark) && isLowerCase(finishMark) ||
                isUpperCase(startMark) && isUpperCase(finishMark)) {
              var start = startMark.charCodeAt(0);
              var finish = finishMark.charCodeAt(0);
              if (start >= finish) {
                showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));
                return;
              }

              // Because marks are always ASCII values, and we have
              // determined that they are the same case, we can use
              // their char codes to iterate through the defined range.
              for (var j = 0; j <= finish - start; j++) {
                var mark = String.fromCharCode(start + j);
                delete state.marks[mark];
              }
            } else {
              showConfirm(cm, 'Invalid argument: ' + startMark + '-');
              return;
            }
          } else {
            // This symbol is a valid mark, and is not part of a range.
            delete state.marks[sym];
          }
        }
      }
    };

    var exCommandDispatcher = new ExCommandDispatcher();

    /**
    * @param {CodeMirror} cm CodeMirror instance we are in.
    * @param {boolean} confirm Whether to confirm each replace.
    * @param {Cursor} lineStart Line to start replacing from.
    * @param {Cursor} lineEnd Line to stop replacing at.
    * @param {RegExp} query Query for performing matches with.
    * @param {string} replaceWith Text to replace matches with. May contain $1,
    *     $2, etc for replacing captured groups using Javascript replace.
    * @param {function()} callback A callback for when the replace is done.
    */
    function doReplace(cm, confirm, global, lineStart, lineEnd, searchCursor, query,
        replaceWith, callback) {
      // Set up all the functions.
      cm.state.vim.exMode = true;
      var done = false;
      var lastPos = searchCursor.from();
      function replaceAll() {
        cm.operation(function() {
          while (!done) {
            replace();
            next();
          }
          stop();
        });
      }
      function replace() {
        var text = cm.getRange(searchCursor.from(), searchCursor.to());
        var newText = text.replace(query, replaceWith);
        searchCursor.replace(newText);
      }
      function next() {
        // The below only loops to skip over multiple occurrences on the same
        // line when 'global' is not true.
        while(searchCursor.findNext() &&
              isInRange(searchCursor.from(), lineStart, lineEnd)) {
          if (!global && lastPos && searchCursor.from().line == lastPos.line) {
            continue;
          }
          cm.scrollIntoView(searchCursor.from(), 30);
          cm.setSelection(searchCursor.from(), searchCursor.to());
          lastPos = searchCursor.from();
          done = false;
          return;
        }
        done = true;
      }
      function stop(close) {
        if (close) { close(); }
        cm.focus();
        if (lastPos) {
          cm.setCursor(lastPos);
          var vim = cm.state.vim;
          vim.exMode = false;
          vim.lastHPos = vim.lastHSPos = lastPos.ch;
        }
        if (callback) { callback(); }
      }
      function onPromptKeyDown(e, _value, close) {
        // Swallow all keys.
        CodeMirror.e_stop(e);
        var keyName = CodeMirror.keyName(e);
        switch (keyName) {
          case 'Y':
            replace(); next(); break;
          case 'N':
            next(); break;
          case 'A':
            // replaceAll contains a call to close of its own. We don't want it
            // to fire too early or multiple times.
            var savedCallback = callback;
            callback = undefined;
            cm.operation(replaceAll);
            callback = savedCallback;
            break;
          case 'L':
            replace();
            // fall through and exit.
          case 'Q':
          case 'Esc':
          case 'Ctrl-C':
          case 'Ctrl-[':
            stop(close);
            break;
        }
        if (done) { stop(close); }
        return true;
      }

      // Actually do replace.
      next();
      if (done) {
        showConfirm(cm, 'No matches for ' + query.source);
        return;
      }
      if (!confirm) {
        replaceAll();
        if (callback) { callback(); }
        return;
      }
      showPrompt(cm, {
        prefix: 'replace with <strong>' + replaceWith + '</strong> (y/n/a/q/l)',
        onKeyDown: onPromptKeyDown
      });
    }

    CodeMirror.keyMap.vim = {
      attach: attachVimMap,
      detach: detachVimMap,
      call: cmKey
    };

    function exitInsertMode(cm) {
      var vim = cm.state.vim;
      var macroModeState = vimGlobalState.macroModeState;
      var insertModeChangeRegister = vimGlobalState.registerController.getRegister('.');
      var isPlaying = macroModeState.isPlaying;
      var lastChange = macroModeState.lastInsertModeChanges;
      if (!isPlaying) {
        cm.off('change', onChange);
        CodeMirror.off(cm.getInputField(), 'keydown', onKeyEventTargetKeyDown);
      }
      if (!isPlaying && vim.insertModeRepeat > 1) {
        // Perform insert mode repeat for commands like 3,a and 3,o.
        repeatLastEdit(cm, vim, vim.insertModeRepeat - 1,
            true /** repeatForInsert */);
        vim.lastEditInputState.repeatOverride = vim.insertModeRepeat;
      }
      delete vim.insertModeRepeat;
      vim.insertMode = false;
      cm.setCursor(cm.getCursor().line, cm.getCursor().ch-1);
      cm.setOption('keyMap', 'vim');
      cm.setOption('disableInput', true);
      cm.toggleOverwrite(false); // exit replace mode if we were in it.
      // update the ". register before exiting insert mode
      insertModeChangeRegister.setText(lastChange.changes.join(''));
      CodeMirror.signal(cm, "vim-mode-change", {mode: "normal"});
      if (macroModeState.isRecording) {
        logInsertModeChange(macroModeState);
      }
    }

    function _mapCommand(command) {
      defaultKeymap.unshift(command);
    }

    function mapCommand(keys, type, name, args, extra) {
      var command = {keys: keys, type: type};
      command[type] = name;
      command[type + "Args"] = args;
      for (var key in extra)
        command[key] = extra[key];
      _mapCommand(command);
    }

    // The timeout in milliseconds for the two-character ESC keymap should be
    // adjusted according to your typing speed to prevent false positives.
    defineOption('insertModeEscKeysTimeout', 200, 'number');

    CodeMirror.keyMap['vim-insert'] = {
      // TODO: override navigation keys so that Esc will cancel automatic
      // indentation from o, O, i_<CR>
      fallthrough: ['default'],
      attach: attachVimMap,
      detach: detachVimMap,
      call: cmKey
    };

    CodeMirror.keyMap['vim-replace'] = {
      'Backspace': 'goCharLeft',
      fallthrough: ['vim-insert'],
      attach: attachVimMap,
      detach: detachVimMap,
      call: cmKey
    };

    function executeMacroRegister(cm, vim, macroModeState, registerName) {
      var register = vimGlobalState.registerController.getRegister(registerName);
      if (registerName == ':') {
        // Read-only register containing last Ex command.
        if (register.keyBuffer[0]) {
          exCommandDispatcher.processCommand(cm, register.keyBuffer[0]);
        }
        macroModeState.isPlaying = false;
        return;
      }
      var keyBuffer = register.keyBuffer;
      var imc = 0;
      macroModeState.isPlaying = true;
      macroModeState.replaySearchQueries = register.searchQueries.slice(0);
      for (var i = 0; i < keyBuffer.length; i++) {
        var text = keyBuffer[i];
        var match, key;
        while (text) {
          // Pull off one command key, which is either a single character
          // or a special sequence wrapped in '<' and '>', e.g. '<Space>'.
          match = (/<\w+-.+?>|<\w+>|./).exec(text);
          key = match[0];
          text = text.substring(match.index + key.length);
          CodeMirror.Vim.handleKey(cm, key, 'macro');
          if (vim.insertMode) {
            var changes = register.insertModeChanges[imc++].changes;
            vimGlobalState.macroModeState.lastInsertModeChanges.changes =
                changes;
            repeatInsertModeChanges(cm, changes, 1);
            exitInsertMode(cm);
          }
        }
      }
      macroModeState.isPlaying = false;
    }

    function logKey(macroModeState, key) {
      if (macroModeState.isPlaying) { return; }
      var registerName = macroModeState.latestRegister;
      var register = vimGlobalState.registerController.getRegister(registerName);
      if (register) {
        register.pushText(key);
      }
    }

    function logInsertModeChange(macroModeState) {
      if (macroModeState.isPlaying) { return; }
      var registerName = macroModeState.latestRegister;
      var register = vimGlobalState.registerController.getRegister(registerName);
      if (register && register.pushInsertModeChanges) {
        register.pushInsertModeChanges(macroModeState.lastInsertModeChanges);
      }
    }

    function logSearchQuery(macroModeState, query) {
      if (macroModeState.isPlaying) { return; }
      var registerName = macroModeState.latestRegister;
      var register = vimGlobalState.registerController.getRegister(registerName);
      if (register && register.pushSearchQuery) {
        register.pushSearchQuery(query);
      }
    }

    /**
     * Listens for changes made in insert mode.
     * Should only be active in insert mode.
     */
    function onChange(cm, changeObj) {
      var macroModeState = vimGlobalState.macroModeState;
      var lastChange = macroModeState.lastInsertModeChanges;
      if (!macroModeState.isPlaying) {
        while(changeObj) {
          lastChange.expectCursorActivityForChange = true;
          if (lastChange.ignoreCount > 1) {
            lastChange.ignoreCount--;
          } else if (changeObj.origin == '+input' || changeObj.origin == 'paste'
              || changeObj.origin === undefined /* only in testing */) {
            var selectionCount = cm.listSelections().length;
            if (selectionCount > 1)
              lastChange.ignoreCount = selectionCount;
            var text = changeObj.text.join('\n');
            if (lastChange.maybeReset) {
              lastChange.changes = [];
              lastChange.maybeReset = false;
            }
            if (text) {
              if (cm.state.overwrite && !/\n/.test(text)) {
                lastChange.changes.push([text]);
              } else {
                lastChange.changes.push(text);
              }
            }
          }
          // Change objects may be chained with next.
          changeObj = changeObj.next;
        }
      }
    }

    /**
    * Listens for any kind of cursor activity on CodeMirror.
    */
    function onCursorActivity(cm) {
      var vim = cm.state.vim;
      if (vim.insertMode) {
        // Tracking cursor activity in insert mode (for macro support).
        var macroModeState = vimGlobalState.macroModeState;
        if (macroModeState.isPlaying) { return; }
        var lastChange = macroModeState.lastInsertModeChanges;
        if (lastChange.expectCursorActivityForChange) {
          lastChange.expectCursorActivityForChange = false;
        } else {
          // Cursor moved outside the context of an edit. Reset the change.
          lastChange.maybeReset = true;
        }
      } else if (!cm.curOp.isVimOp) {
        handleExternalSelection(cm, vim);
      }
      if (vim.visualMode) {
        updateFakeCursor(cm);
      }
    }
    /**
     * Keeps track of a fake cursor to support visual mode cursor behavior.
     */
    function updateFakeCursor(cm) {
      var className = 'cm-animate-fat-cursor';
      var vim = cm.state.vim;
      var from = clipCursorToContent(cm, copyCursor(vim.sel.head));
      var to = offsetCursor(from, 0, 1);
      clearFakeCursor(vim);
      // In visual mode, the cursor may be positioned over EOL.
      if (from.ch == cm.getLine(from.line).length) {
        var widget = document.createElement("span");
        widget.textContent = "\u00a0";
        widget.className = className;
        vim.fakeCursorBookmark = cm.setBookmark(from, {widget: widget});
      } else {
        vim.fakeCursor = cm.markText(from, to, {className: className});
      }
    }
    function clearFakeCursor(vim) {
      if (vim.fakeCursor) {
        vim.fakeCursor.clear();
        vim.fakeCursor = null;
      }
      if (vim.fakeCursorBookmark) {
        vim.fakeCursorBookmark.clear();
        vim.fakeCursorBookmark = null;
      }
    }
    function handleExternalSelection(cm, vim) {
      var anchor = cm.getCursor('anchor');
      var head = cm.getCursor('head');
      // Enter or exit visual mode to match mouse selection.
      if (vim.visualMode && !cm.somethingSelected()) {
        exitVisualMode(cm, false);
      } else if (!vim.visualMode && !vim.insertMode && cm.somethingSelected()) {
        vim.visualMode = true;
        vim.visualLine = false;
        CodeMirror.signal(cm, "vim-mode-change", {mode: "visual"});
      }
      if (vim.visualMode) {
        // Bind CodeMirror selection model to vim selection model.
        // Mouse selections are considered visual characterwise.
        var headOffset = !cursorIsBefore(head, anchor) ? -1 : 0;
        var anchorOffset = cursorIsBefore(head, anchor) ? -1 : 0;
        head = offsetCursor(head, 0, headOffset);
        anchor = offsetCursor(anchor, 0, anchorOffset);
        vim.sel = {
          anchor: anchor,
          head: head
        };
        updateMark(cm, vim, '<', cursorMin(head, anchor));
        updateMark(cm, vim, '>', cursorMax(head, anchor));
      } else if (!vim.insertMode) {
        // Reset lastHPos if selection was modified by something outside of vim mode e.g. by mouse.
        vim.lastHPos = cm.getCursor().ch;
      }
    }

    /** Wrapper for special keys pressed in insert mode */
    function InsertModeKey(keyName) {
      this.keyName = keyName;
    }

    /**
    * Handles raw key down events from the text area.
    * - Should only be active in insert mode.
    * - For recording deletes in insert mode.
    */
    function onKeyEventTargetKeyDown(e) {
      var macroModeState = vimGlobalState.macroModeState;
      var lastChange = macroModeState.lastInsertModeChanges;
      var keyName = CodeMirror.keyName(e);
      if (!keyName) { return; }
      function onKeyFound() {
        if (lastChange.maybeReset) {
          lastChange.changes = [];
          lastChange.maybeReset = false;
        }
        lastChange.changes.push(new InsertModeKey(keyName));
        return true;
      }
      if (keyName.indexOf('Delete') != -1 || keyName.indexOf('Backspace') != -1) {
        CodeMirror.lookupKey(keyName, 'vim-insert', onKeyFound);
      }
    }

    /**
     * Repeats the last edit, which includes exactly 1 command and at most 1
     * insert. Operator and motion commands are read from lastEditInputState,
     * while action commands are read from lastEditActionCommand.
     *
     * If repeatForInsert is true, then the function was called by
     * exitInsertMode to repeat the insert mode changes the user just made. The
     * corresponding enterInsertMode call was made with a count.
     */
    function repeatLastEdit(cm, vim, repeat, repeatForInsert) {
      var macroModeState = vimGlobalState.macroModeState;
      macroModeState.isPlaying = true;
      var isAction = !!vim.lastEditActionCommand;
      var cachedInputState = vim.inputState;
      function repeatCommand() {
        if (isAction) {
          commandDispatcher.processAction(cm, vim, vim.lastEditActionCommand);
        } else {
          commandDispatcher.evalInput(cm, vim);
        }
      }
      function repeatInsert(repeat) {
        if (macroModeState.lastInsertModeChanges.changes.length > 0) {
          // For some reason, repeat cw in desktop VIM does not repeat
          // insert mode changes. Will conform to that behavior.
          repeat = !vim.lastEditActionCommand ? 1 : repeat;
          var changeObject = macroModeState.lastInsertModeChanges;
          repeatInsertModeChanges(cm, changeObject.changes, repeat);
        }
      }
      vim.inputState = vim.lastEditInputState;
      if (isAction && vim.lastEditActionCommand.interlaceInsertRepeat) {
        // o and O repeat have to be interlaced with insert repeats so that the
        // insertions appear on separate lines instead of the last line.
        for (var i = 0; i < repeat; i++) {
          repeatCommand();
          repeatInsert(1);
        }
      } else {
        if (!repeatForInsert) {
          // Hack to get the cursor to end up at the right place. If I is
          // repeated in insert mode repeat, cursor will be 1 insert
          // change set left of where it should be.
          repeatCommand();
        }
        repeatInsert(repeat);
      }
      vim.inputState = cachedInputState;
      if (vim.insertMode && !repeatForInsert) {
        // Don't exit insert mode twice. If repeatForInsert is set, then we
        // were called by an exitInsertMode call lower on the stack.
        exitInsertMode(cm);
      }
      macroModeState.isPlaying = false;
    }

    function repeatInsertModeChanges(cm, changes, repeat) {
      function keyHandler(binding) {
        if (typeof binding == 'string') {
          CodeMirror.commands[binding](cm);
        } else {
          binding(cm);
        }
        return true;
      }
      var head = cm.getCursor('head');
      var visualBlock = vimGlobalState.macroModeState.lastInsertModeChanges.visualBlock;
      if (visualBlock) {
        // Set up block selection again for repeating the changes.
        selectForInsert(cm, head, visualBlock + 1);
        repeat = cm.listSelections().length;
        cm.setCursor(head);
      }
      for (var i = 0; i < repeat; i++) {
        if (visualBlock) {
          cm.setCursor(offsetCursor(head, i, 0));
        }
        for (var j = 0; j < changes.length; j++) {
          var change = changes[j];
          if (change instanceof InsertModeKey) {
            CodeMirror.lookupKey(change.keyName, 'vim-insert', keyHandler);
          } else if (typeof change == "string") {
            var cur = cm.getCursor();
            cm.replaceRange(change, cur, cur);
          } else {
            var start = cm.getCursor();
            var end = offsetCursor(start, 0, change[0].length);
            cm.replaceRange(change[0], start, end);
          }
        }
      }
      if (visualBlock) {
        cm.setCursor(offsetCursor(head, 0, 1));
      }
    }

    resetVimGlobalState();
    return vimApi;
  };
  // Initialize Vim and make it available as an API.
  CodeMirror.Vim = Vim();
});

},{"../addon/dialog/dialog":91,"../addon/edit/matchbrackets.js":95,"../addon/search/searchcursor":98,"../lib/codemirror":101}],101:[function(require,module,exports){
// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

// This is CodeMirror (https://codemirror.net), a code editor
// implemented in JavaScript on top of the browser's DOM.
//
// You can find some technical background for some of the code below
// at http://marijnhaverbeke.nl/blog/#cm-internals .

(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global = global || self, global.CodeMirror = factory());
}(this, (function () { 'use strict';

  // Kludges for bugs and behavior differences that can't be feature
  // detected are enabled based on userAgent etc sniffing.
  var userAgent = navigator.userAgent;
  var platform = navigator.platform;

  var gecko = /gecko\/\d/i.test(userAgent);
  var ie_upto10 = /MSIE \d/.test(userAgent);
  var ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(userAgent);
  var edge = /Edge\/(\d+)/.exec(userAgent);
  var ie = ie_upto10 || ie_11up || edge;
  var ie_version = ie && (ie_upto10 ? document.documentMode || 6 : +(edge || ie_11up)[1]);
  var webkit = !edge && /WebKit\//.test(userAgent);
  var qtwebkit = webkit && /Qt\/\d+\.\d+/.test(userAgent);
  var chrome = !edge && /Chrome\//.test(userAgent);
  var presto = /Opera\//.test(userAgent);
  var safari = /Apple Computer/.test(navigator.vendor);
  var mac_geMountainLion = /Mac OS X 1\d\D([8-9]|\d\d)\D/.test(userAgent);
  var phantom = /PhantomJS/.test(userAgent);

  var ios = !edge && /AppleWebKit/.test(userAgent) && /Mobile\/\w+/.test(userAgent);
  var android = /Android/.test(userAgent);
  // This is woefully incomplete. Suggestions for alternative methods welcome.
  var mobile = ios || android || /webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(userAgent);
  var mac = ios || /Mac/.test(platform);
  var chromeOS = /\bCrOS\b/.test(userAgent);
  var windows = /win/i.test(platform);

  var presto_version = presto && userAgent.match(/Version\/(\d*\.\d*)/);
  if (presto_version) { presto_version = Number(presto_version[1]); }
  if (presto_version && presto_version >= 15) { presto = false; webkit = true; }
  // Some browsers use the wrong event properties to signal cmd/ctrl on OS X
  var flipCtrlCmd = mac && (qtwebkit || presto && (presto_version == null || presto_version < 12.11));
  var captureRightClick = gecko || (ie && ie_version >= 9);

  function classTest(cls) { return new RegExp("(^|\\s)" + cls + "(?:$|\\s)\\s*") }

  var rmClass = function(node, cls) {
    var current = node.className;
    var match = classTest(cls).exec(current);
    if (match) {
      var after = current.slice(match.index + match[0].length);
      node.className = current.slice(0, match.index) + (after ? match[1] + after : "");
    }
  };

  function removeChildren(e) {
    for (var count = e.childNodes.length; count > 0; --count)
      { e.removeChild(e.firstChild); }
    return e
  }

  function removeChildrenAndAdd(parent, e) {
    return removeChildren(parent).appendChild(e)
  }

  function elt(tag, content, className, style) {
    var e = document.createElement(tag);
    if (className) { e.className = className; }
    if (style) { e.style.cssText = style; }
    if (typeof content == "string") { e.appendChild(document.createTextNode(content)); }
    else if (content) { for (var i = 0; i < content.length; ++i) { e.appendChild(content[i]); } }
    return e
  }
  // wrapper for elt, which removes the elt from the accessibility tree
  function eltP(tag, content, className, style) {
    var e = elt(tag, content, className, style);
    e.setAttribute("role", "presentation");
    return e
  }

  var range;
  if (document.createRange) { range = function(node, start, end, endNode) {
    var r = document.createRange();
    r.setEnd(endNode || node, end);
    r.setStart(node, start);
    return r
  }; }
  else { range = function(node, start, end) {
    var r = document.body.createTextRange();
    try { r.moveToElementText(node.parentNode); }
    catch(e) { return r }
    r.collapse(true);
    r.moveEnd("character", end);
    r.moveStart("character", start);
    return r
  }; }

  function contains(parent, child) {
    if (child.nodeType == 3) // Android browser always returns false when child is a textnode
      { child = child.parentNode; }
    if (parent.contains)
      { return parent.contains(child) }
    do {
      if (child.nodeType == 11) { child = child.host; }
      if (child == parent) { return true }
    } while (child = child.parentNode)
  }

  function activeElt() {
    // IE and Edge may throw an "Unspecified Error" when accessing document.activeElement.
    // IE < 10 will throw when accessed while the page is loading or in an iframe.
    // IE > 9 and Edge will throw when accessed in an iframe if document.body is unavailable.
    var activeElement;
    try {
      activeElement = document.activeElement;
    } catch(e) {
      activeElement = document.body || null;
    }
    while (activeElement && activeElement.shadowRoot && activeElement.shadowRoot.activeElement)
      { activeElement = activeElement.shadowRoot.activeElement; }
    return activeElement
  }

  function addClass(node, cls) {
    var current = node.className;
    if (!classTest(cls).test(current)) { node.className += (current ? " " : "") + cls; }
  }
  function joinClasses(a, b) {
    var as = a.split(" ");
    for (var i = 0; i < as.length; i++)
      { if (as[i] && !classTest(as[i]).test(b)) { b += " " + as[i]; } }
    return b
  }

  var selectInput = function(node) { node.select(); };
  if (ios) // Mobile Safari apparently has a bug where select() is broken.
    { selectInput = function(node) { node.selectionStart = 0; node.selectionEnd = node.value.length; }; }
  else if (ie) // Suppress mysterious IE10 errors
    { selectInput = function(node) { try { node.select(); } catch(_e) {} }; }

  function bind(f) {
    var args = Array.prototype.slice.call(arguments, 1);
    return function(){return f.apply(null, args)}
  }

  function copyObj(obj, target, overwrite) {
    if (!target) { target = {}; }
    for (var prop in obj)
      { if (obj.hasOwnProperty(prop) && (overwrite !== false || !target.hasOwnProperty(prop)))
        { target[prop] = obj[prop]; } }
    return target
  }

  // Counts the column offset in a string, taking tabs into account.
  // Used mostly to find indentation.
  function countColumn(string, end, tabSize, startIndex, startValue) {
    if (end == null) {
      end = string.search(/[^\s\u00a0]/);
      if (end == -1) { end = string.length; }
    }
    for (var i = startIndex || 0, n = startValue || 0;;) {
      var nextTab = string.indexOf("\t", i);
      if (nextTab < 0 || nextTab >= end)
        { return n + (end - i) }
      n += nextTab - i;
      n += tabSize - (n % tabSize);
      i = nextTab + 1;
    }
  }

  var Delayed = function() {
    this.id = null;
    this.f = null;
    this.time = 0;
    this.handler = bind(this.onTimeout, this);
  };
  Delayed.prototype.onTimeout = function (self) {
    self.id = 0;
    if (self.time <= +new Date) {
      self.f();
    } else {
      setTimeout(self.handler, self.time - +new Date);
    }
  };
  Delayed.prototype.set = function (ms, f) {
    this.f = f;
    var time = +new Date + ms;
    if (!this.id || time < this.time) {
      clearTimeout(this.id);
      this.id = setTimeout(this.handler, ms);
      this.time = time;
    }
  };

  function indexOf(array, elt) {
    for (var i = 0; i < array.length; ++i)
      { if (array[i] == elt) { return i } }
    return -1
  }

  // Number of pixels added to scroller and sizer to hide scrollbar
  var scrollerGap = 50;

  // Returned or thrown by various protocols to signal 'I'm not
  // handling this'.
  var Pass = {toString: function(){return "CodeMirror.Pass"}};

  // Reused option objects for setSelection & friends
  var sel_dontScroll = {scroll: false}, sel_mouse = {origin: "*mouse"}, sel_move = {origin: "+move"};

  // The inverse of countColumn -- find the offset that corresponds to
  // a particular column.
  function findColumn(string, goal, tabSize) {
    for (var pos = 0, col = 0;;) {
      var nextTab = string.indexOf("\t", pos);
      if (nextTab == -1) { nextTab = string.length; }
      var skipped = nextTab - pos;
      if (nextTab == string.length || col + skipped >= goal)
        { return pos + Math.min(skipped, goal - col) }
      col += nextTab - pos;
      col += tabSize - (col % tabSize);
      pos = nextTab + 1;
      if (col >= goal) { return pos }
    }
  }

  var spaceStrs = [""];
  function spaceStr(n) {
    while (spaceStrs.length <= n)
      { spaceStrs.push(lst(spaceStrs) + " "); }
    return spaceStrs[n]
  }

  function lst(arr) { return arr[arr.length-1] }

  function map(array, f) {
    var out = [];
    for (var i = 0; i < array.length; i++) { out[i] = f(array[i], i); }
    return out
  }

  function insertSorted(array, value, score) {
    var pos = 0, priority = score(value);
    while (pos < array.length && score(array[pos]) <= priority) { pos++; }
    array.splice(pos, 0, value);
  }

  function nothing() {}

  function createObj(base, props) {
    var inst;
    if (Object.create) {
      inst = Object.create(base);
    } else {
      nothing.prototype = base;
      inst = new nothing();
    }
    if (props) { copyObj(props, inst); }
    return inst
  }

  var nonASCIISingleCaseWordChar = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
  function isWordCharBasic(ch) {
    return /\w/.test(ch) || ch > "\x80" &&
      (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch))
  }
  function isWordChar(ch, helper) {
    if (!helper) { return isWordCharBasic(ch) }
    if (helper.source.indexOf("\\w") > -1 && isWordCharBasic(ch)) { return true }
    return helper.test(ch)
  }

  function isEmpty(obj) {
    for (var n in obj) { if (obj.hasOwnProperty(n) && obj[n]) { return false } }
    return true
  }

  // Extending unicode characters. A series of a non-extending char +
  // any number of extending chars is treated as a single unit as far
  // as editing and measuring is concerned. This is not fully correct,
  // since some scripts/fonts/browsers also treat other configurations
  // of code points as a group.
  var extendingChars = /[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/;
  function isExtendingChar(ch) { return ch.charCodeAt(0) >= 768 && extendingChars.test(ch) }

  // Returns a number from the range [`0`; `str.length`] unless `pos` is outside that range.
  function skipExtendingChars(str, pos, dir) {
    while ((dir < 0 ? pos > 0 : pos < str.length) && isExtendingChar(str.charAt(pos))) { pos += dir; }
    return pos
  }

  // Returns the value from the range [`from`; `to`] that satisfies
  // `pred` and is closest to `from`. Assumes that at least `to`
  // satisfies `pred`. Supports `from` being greater than `to`.
  function findFirst(pred, from, to) {
    // At any point we are certain `to` satisfies `pred`, don't know
    // whether `from` does.
    var dir = from > to ? -1 : 1;
    for (;;) {
      if (from == to) { return from }
      var midF = (from + to) / 2, mid = dir < 0 ? Math.ceil(midF) : Math.floor(midF);
      if (mid == from) { return pred(mid) ? from : to }
      if (pred(mid)) { to = mid; }
      else { from = mid + dir; }
    }
  }

  // BIDI HELPERS

  function iterateBidiSections(order, from, to, f) {
    if (!order) { return f(from, to, "ltr", 0) }
    var found = false;
    for (var i = 0; i < order.length; ++i) {
      var part = order[i];
      if (part.from < to && part.to > from || from == to && part.to == from) {
        f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? "rtl" : "ltr", i);
        found = true;
      }
    }
    if (!found) { f(from, to, "ltr"); }
  }

  var bidiOther = null;
  function getBidiPartAt(order, ch, sticky) {
    var found;
    bidiOther = null;
    for (var i = 0; i < order.length; ++i) {
      var cur = order[i];
      if (cur.from < ch && cur.to > ch) { return i }
      if (cur.to == ch) {
        if (cur.from != cur.to && sticky == "before") { found = i; }
        else { bidiOther = i; }
      }
      if (cur.from == ch) {
        if (cur.from != cur.to && sticky != "before") { found = i; }
        else { bidiOther = i; }
      }
    }
    return found != null ? found : bidiOther
  }

  // Bidirectional ordering algorithm
  // See http://unicode.org/reports/tr9/tr9-13.html for the algorithm
  // that this (partially) implements.

  // One-char codes used for character types:
  // L (L):   Left-to-Right
  // R (R):   Right-to-Left
  // r (AL):  Right-to-Left Arabic
  // 1 (EN):  European Number
  // + (ES):  European Number Separator
  // % (ET):  European Number Terminator
  // n (AN):  Arabic Number
  // , (CS):  Common Number Separator
  // m (NSM): Non-Spacing Mark
  // b (BN):  Boundary Neutral
  // s (B):   Paragraph Separator
  // t (S):   Segment Separator
  // w (WS):  Whitespace
  // N (ON):  Other Neutrals

  // Returns null if characters are ordered as they appear
  // (left-to-right), or an array of sections ({from, to, level}
  // objects) in the order in which they occur visually.
  var bidiOrdering = (function() {
    // Character types for codepoints 0 to 0xff
    var lowTypes = "bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN";
    // Character types for codepoints 0x600 to 0x6f9
    var arabicTypes = "nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111";
    function charType(code) {
      if (code <= 0xf7) { return lowTypes.charAt(code) }
      else if (0x590 <= code && code <= 0x5f4) { return "R" }
      else if (0x600 <= code && code <= 0x6f9) { return arabicTypes.charAt(code - 0x600) }
      else if (0x6ee <= code && code <= 0x8ac) { return "r" }
      else if (0x2000 <= code && code <= 0x200b) { return "w" }
      else if (code == 0x200c) { return "b" }
      else { return "L" }
    }

    var bidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
    var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;

    function BidiSpan(level, from, to) {
      this.level = level;
      this.from = from; this.to = to;
    }

    return function(str, direction) {
      var outerType = direction == "ltr" ? "L" : "R";

      if (str.length == 0 || direction == "ltr" && !bidiRE.test(str)) { return false }
      var len = str.length, types = [];
      for (var i = 0; i < len; ++i)
        { types.push(charType(str.charCodeAt(i))); }

      // W1. Examine each non-spacing mark (NSM) in the level run, and
      // change the type of the NSM to the type of the previous
      // character. If the NSM is at the start of the level run, it will
      // get the type of sor.
      for (var i$1 = 0, prev = outerType; i$1 < len; ++i$1) {
        var type = types[i$1];
        if (type == "m") { types[i$1] = prev; }
        else { prev = type; }
      }

      // W2. Search backwards from each instance of a European number
      // until the first strong type (R, L, AL, or sor) is found. If an
      // AL is found, change the type of the European number to Arabic
      // number.
      // W3. Change all ALs to R.
      for (var i$2 = 0, cur = outerType; i$2 < len; ++i$2) {
        var type$1 = types[i$2];
        if (type$1 == "1" && cur == "r") { types[i$2] = "n"; }
        else if (isStrong.test(type$1)) { cur = type$1; if (type$1 == "r") { types[i$2] = "R"; } }
      }

      // W4. A single European separator between two European numbers
      // changes to a European number. A single common separator between
      // two numbers of the same type changes to that type.
      for (var i$3 = 1, prev$1 = types[0]; i$3 < len - 1; ++i$3) {
        var type$2 = types[i$3];
        if (type$2 == "+" && prev$1 == "1" && types[i$3+1] == "1") { types[i$3] = "1"; }
        else if (type$2 == "," && prev$1 == types[i$3+1] &&
                 (prev$1 == "1" || prev$1 == "n")) { types[i$3] = prev$1; }
        prev$1 = type$2;
      }

      // W5. A sequence of European terminators adjacent to European
      // numbers changes to all European numbers.
      // W6. Otherwise, separators and terminators change to Other
      // Neutral.
      for (var i$4 = 0; i$4 < len; ++i$4) {
        var type$3 = types[i$4];
        if (type$3 == ",") { types[i$4] = "N"; }
        else if (type$3 == "%") {
          var end = (void 0);
          for (end = i$4 + 1; end < len && types[end] == "%"; ++end) {}
          var replace = (i$4 && types[i$4-1] == "!") || (end < len && types[end] == "1") ? "1" : "N";
          for (var j = i$4; j < end; ++j) { types[j] = replace; }
          i$4 = end - 1;
        }
      }

      // W7. Search backwards from each instance of a European number
      // until the first strong type (R, L, or sor) is found. If an L is
      // found, then change the type of the European number to L.
      for (var i$5 = 0, cur$1 = outerType; i$5 < len; ++i$5) {
        var type$4 = types[i$5];
        if (cur$1 == "L" && type$4 == "1") { types[i$5] = "L"; }
        else if (isStrong.test(type$4)) { cur$1 = type$4; }
      }

      // N1. A sequence of neutrals takes the direction of the
      // surrounding strong text if the text on both sides has the same
      // direction. European and Arabic numbers act as if they were R in
      // terms of their influence on neutrals. Start-of-level-run (sor)
      // and end-of-level-run (eor) are used at level run boundaries.
      // N2. Any remaining neutrals take the embedding direction.
      for (var i$6 = 0; i$6 < len; ++i$6) {
        if (isNeutral.test(types[i$6])) {
          var end$1 = (void 0);
          for (end$1 = i$6 + 1; end$1 < len && isNeutral.test(types[end$1]); ++end$1) {}
          var before = (i$6 ? types[i$6-1] : outerType) == "L";
          var after = (end$1 < len ? types[end$1] : outerType) == "L";
          var replace$1 = before == after ? (before ? "L" : "R") : outerType;
          for (var j$1 = i$6; j$1 < end$1; ++j$1) { types[j$1] = replace$1; }
          i$6 = end$1 - 1;
        }
      }

      // Here we depart from the documented algorithm, in order to avoid
      // building up an actual levels array. Since there are only three
      // levels (0, 1, 2) in an implementation that doesn't take
      // explicit embedding into account, we can build up the order on
      // the fly, without following the level-based algorithm.
      var order = [], m;
      for (var i$7 = 0; i$7 < len;) {
        if (countsAsLeft.test(types[i$7])) {
          var start = i$7;
          for (++i$7; i$7 < len && countsAsLeft.test(types[i$7]); ++i$7) {}
          order.push(new BidiSpan(0, start, i$7));
        } else {
          var pos = i$7, at = order.length, isRTL = direction == "rtl" ? 1 : 0;
          for (++i$7; i$7 < len && types[i$7] != "L"; ++i$7) {}
          for (var j$2 = pos; j$2 < i$7;) {
            if (countsAsNum.test(types[j$2])) {
              if (pos < j$2) { order.splice(at, 0, new BidiSpan(1, pos, j$2)); at += isRTL; }
              var nstart = j$2;
              for (++j$2; j$2 < i$7 && countsAsNum.test(types[j$2]); ++j$2) {}
              order.splice(at, 0, new BidiSpan(2, nstart, j$2));
              at += isRTL;
              pos = j$2;
            } else { ++j$2; }
          }
          if (pos < i$7) { order.splice(at, 0, new BidiSpan(1, pos, i$7)); }
        }
      }
      if (direction == "ltr") {
        if (order[0].level == 1 && (m = str.match(/^\s+/))) {
          order[0].from = m[0].length;
          order.unshift(new BidiSpan(0, 0, m[0].length));
        }
        if (lst(order).level == 1 && (m = str.match(/\s+$/))) {
          lst(order).to -= m[0].length;
          order.push(new BidiSpan(0, len - m[0].length, len));
        }
      }

      return direction == "rtl" ? order.reverse() : order
    }
  })();

  // Get the bidi ordering for the given line (and cache it). Returns
  // false for lines that are fully left-to-right, and an array of
  // BidiSpan objects otherwise.
  function getOrder(line, direction) {
    var order = line.order;
    if (order == null) { order = line.order = bidiOrdering(line.text, direction); }
    return order
  }

  // EVENT HANDLING

  // Lightweight event framework. on/off also work on DOM nodes,
  // registering native DOM handlers.

  var noHandlers = [];

  var on = function(emitter, type, f) {
    if (emitter.addEventListener) {
      emitter.addEventListener(type, f, false);
    } else if (emitter.attachEvent) {
      emitter.attachEvent("on" + type, f);
    } else {
      var map = emitter._handlers || (emitter._handlers = {});
      map[type] = (map[type] || noHandlers).concat(f);
    }
  };

  function getHandlers(emitter, type) {
    return emitter._handlers && emitter._handlers[type] || noHandlers
  }

  function off(emitter, type, f) {
    if (emitter.removeEventListener) {
      emitter.removeEventListener(type, f, false);
    } else if (emitter.detachEvent) {
      emitter.detachEvent("on" + type, f);
    } else {
      var map = emitter._handlers, arr = map && map[type];
      if (arr) {
        var index = indexOf(arr, f);
        if (index > -1)
          { map[type] = arr.slice(0, index).concat(arr.slice(index + 1)); }
      }
    }
  }

  function signal(emitter, type /*, values...*/) {
    var handlers = getHandlers(emitter, type);
    if (!handlers.length) { return }
    var args = Array.prototype.slice.call(arguments, 2);
    for (var i = 0; i < handlers.length; ++i) { handlers[i].apply(null, args); }
  }

  // The DOM events that CodeMirror handles can be overridden by
  // registering a (non-DOM) handler on the editor for the event name,
  // and preventDefault-ing the event in that handler.
  function signalDOMEvent(cm, e, override) {
    if (typeof e == "string")
      { e = {type: e, preventDefault: function() { this.defaultPrevented = true; }}; }
    signal(cm, override || e.type, cm, e);
    return e_defaultPrevented(e) || e.codemirrorIgnore
  }

  function signalCursorActivity(cm) {
    var arr = cm._handlers && cm._handlers.cursorActivity;
    if (!arr) { return }
    var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []);
    for (var i = 0; i < arr.length; ++i) { if (indexOf(set, arr[i]) == -1)
      { set.push(arr[i]); } }
  }

  function hasHandler(emitter, type) {
    return getHandlers(emitter, type).length > 0
  }

  // Add on and off methods to a constructor's prototype, to make
  // registering events on such objects more convenient.
  function eventMixin(ctor) {
    ctor.prototype.on = function(type, f) {on(this, type, f);};
    ctor.prototype.off = function(type, f) {off(this, type, f);};
  }

  // Due to the fact that we still support jurassic IE versions, some
  // compatibility wrappers are needed.

  function e_preventDefault(e) {
    if (e.preventDefault) { e.preventDefault(); }
    else { e.returnValue = false; }
  }
  function e_stopPropagation(e) {
    if (e.stopPropagation) { e.stopPropagation(); }
    else { e.cancelBubble = true; }
  }
  function e_defaultPrevented(e) {
    return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false
  }
  function e_stop(e) {e_preventDefault(e); e_stopPropagation(e);}

  function e_target(e) {return e.target || e.srcElement}
  function e_button(e) {
    var b = e.which;
    if (b == null) {
      if (e.button & 1) { b = 1; }
      else if (e.button & 2) { b = 3; }
      else if (e.button & 4) { b = 2; }
    }
    if (mac && e.ctrlKey && b == 1) { b = 3; }
    return b
  }

  // Detect drag-and-drop
  var dragAndDrop = function() {
    // There is *some* kind of drag-and-drop support in IE6-8, but I
    // couldn't get it to work yet.
    if (ie && ie_version < 9) { return false }
    var div = elt('div');
    return "draggable" in div || "dragDrop" in div
  }();

  var zwspSupported;
  function zeroWidthElement(measure) {
    if (zwspSupported == null) {
      var test = elt("span", "\u200b");
      removeChildrenAndAdd(measure, elt("span", [test, document.createTextNode("x")]));
      if (measure.firstChild.offsetHeight != 0)
        { zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !(ie && ie_version < 8); }
    }
    var node = zwspSupported ? elt("span", "\u200b") :
      elt("span", "\u00a0", null, "display: inline-block; width: 1px; margin-right: -1px");
    node.setAttribute("cm-text", "");
    return node
  }

  // Feature-detect IE's crummy client rect reporting for bidi text
  var badBidiRects;
  function hasBadBidiRects(measure) {
    if (badBidiRects != null) { return badBidiRects }
    var txt = removeChildrenAndAdd(measure, document.createTextNode("A\u062eA"));
    var r0 = range(txt, 0, 1).getBoundingClientRect();
    var r1 = range(txt, 1, 2).getBoundingClientRect();
    removeChildren(measure);
    if (!r0 || r0.left == r0.right) { return false } // Safari returns null in some cases (#2780)
    return badBidiRects = (r1.right - r0.right < 3)
  }

  // See if "".split is the broken IE version, if so, provide an
  // alternative way to split lines.
  var splitLinesAuto = "\n\nb".split(/\n/).length != 3 ? function (string) {
    var pos = 0, result = [], l = string.length;
    while (pos <= l) {
      var nl = string.indexOf("\n", pos);
      if (nl == -1) { nl = string.length; }
      var line = string.slice(pos, string.charAt(nl - 1) == "\r" ? nl - 1 : nl);
      var rt = line.indexOf("\r");
      if (rt != -1) {
        result.push(line.slice(0, rt));
        pos += rt + 1;
      } else {
        result.push(line);
        pos = nl + 1;
      }
    }
    return result
  } : function (string) { return string.split(/\r\n?|\n/); };

  var hasSelection = window.getSelection ? function (te) {
    try { return te.selectionStart != te.selectionEnd }
    catch(e) { return false }
  } : function (te) {
    var range;
    try {range = te.ownerDocument.selection.createRange();}
    catch(e) {}
    if (!range || range.parentElement() != te) { return false }
    return range.compareEndPoints("StartToEnd", range) != 0
  };

  var hasCopyEvent = (function () {
    var e = elt("div");
    if ("oncopy" in e) { return true }
    e.setAttribute("oncopy", "return;");
    return typeof e.oncopy == "function"
  })();

  var badZoomedRects = null;
  function hasBadZoomedRects(measure) {
    if (badZoomedRects != null) { return badZoomedRects }
    var node = removeChildrenAndAdd(measure, elt("span", "x"));
    var normal = node.getBoundingClientRect();
    var fromRange = range(node, 0, 1).getBoundingClientRect();
    return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1
  }

  // Known modes, by name and by MIME
  var modes = {}, mimeModes = {};

  // Extra arguments are stored as the mode's dependencies, which is
  // used by (legacy) mechanisms like loadmode.js to automatically
  // load a mode. (Preferred mechanism is the require/define calls.)
  function defineMode(name, mode) {
    if (arguments.length > 2)
      { mode.dependencies = Array.prototype.slice.call(arguments, 2); }
    modes[name] = mode;
  }

  function defineMIME(mime, spec) {
    mimeModes[mime] = spec;
  }

  // Given a MIME type, a {name, ...options} config object, or a name
  // string, return a mode config object.
  function resolveMode(spec) {
    if (typeof spec == "string" && mimeModes.hasOwnProperty(spec)) {
      spec = mimeModes[spec];
    } else if (spec && typeof spec.name == "string" && mimeModes.hasOwnProperty(spec.name)) {
      var found = mimeModes[spec.name];
      if (typeof found == "string") { found = {name: found}; }
      spec = createObj(found, spec);
      spec.name = found.name;
    } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+xml$/.test(spec)) {
      return resolveMode("application/xml")
    } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+json$/.test(spec)) {
      return resolveMode("application/json")
    }
    if (typeof spec == "string") { return {name: spec} }
    else { return spec || {name: "null"} }
  }

  // Given a mode spec (anything that resolveMode accepts), find and
  // initialize an actual mode object.
  function getMode(options, spec) {
    spec = resolveMode(spec);
    var mfactory = modes[spec.name];
    if (!mfactory) { return getMode(options, "text/plain") }
    var modeObj = mfactory(options, spec);
    if (modeExtensions.hasOwnProperty(spec.name)) {
      var exts = modeExtensions[spec.name];
      for (var prop in exts) {
        if (!exts.hasOwnProperty(prop)) { continue }
        if (modeObj.hasOwnProperty(prop)) { modeObj["_" + prop] = modeObj[prop]; }
        modeObj[prop] = exts[prop];
      }
    }
    modeObj.name = spec.name;
    if (spec.helperType) { modeObj.helperType = spec.helperType; }
    if (spec.modeProps) { for (var prop$1 in spec.modeProps)
      { modeObj[prop$1] = spec.modeProps[prop$1]; } }

    return modeObj
  }

  // This can be used to attach properties to mode objects from
  // outside the actual mode definition.
  var modeExtensions = {};
  function extendMode(mode, properties) {
    var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : (modeExtensions[mode] = {});
    copyObj(properties, exts);
  }

  function copyState(mode, state) {
    if (state === true) { return state }
    if (mode.copyState) { return mode.copyState(state) }
    var nstate = {};
    for (var n in state) {
      var val = state[n];
      if (val instanceof Array) { val = val.concat([]); }
      nstate[n] = val;
    }
    return nstate
  }

  // Given a mode and a state (for that mode), find the inner mode and
  // state at the position that the state refers to.
  function innerMode(mode, state) {
    var info;
    while (mode.innerMode) {
      info = mode.innerMode(state);
      if (!info || info.mode == mode) { break }
      state = info.state;
      mode = info.mode;
    }
    return info || {mode: mode, state: state}
  }

  function startState(mode, a1, a2) {
    return mode.startState ? mode.startState(a1, a2) : true
  }

  // STRING STREAM

  // Fed to the mode parsers, provides helper functions to make
  // parsers more succinct.

  var StringStream = function(string, tabSize, lineOracle) {
    this.pos = this.start = 0;
    this.string = string;
    this.tabSize = tabSize || 8;
    this.lastColumnPos = this.lastColumnValue = 0;
    this.lineStart = 0;
    this.lineOracle = lineOracle;
  };

  StringStream.prototype.eol = function () {return this.pos >= this.string.length};
  StringStream.prototype.sol = function () {return this.pos == this.lineStart};
  StringStream.prototype.peek = function () {return this.string.charAt(this.pos) || undefined};
  StringStream.prototype.next = function () {
    if (this.pos < this.string.length)
      { return this.string.charAt(this.pos++) }
  };
  StringStream.prototype.eat = function (match) {
    var ch = this.string.charAt(this.pos);
    var ok;
    if (typeof match == "string") { ok = ch == match; }
    else { ok = ch && (match.test ? match.test(ch) : match(ch)); }
    if (ok) {++this.pos; return ch}
  };
  StringStream.prototype.eatWhile = function (match) {
    var start = this.pos;
    while (this.eat(match)){}
    return this.pos > start
  };
  StringStream.prototype.eatSpace = function () {
    var start = this.pos;
    while (/[\s\u00a0]/.test(this.string.charAt(this.pos))) { ++this.pos; }
    return this.pos > start
  };
  StringStream.prototype.skipToEnd = function () {this.pos = this.string.length;};
  StringStream.prototype.skipTo = function (ch) {
    var found = this.string.indexOf(ch, this.pos);
    if (found > -1) {this.pos = found; return true}
  };
  StringStream.prototype.backUp = function (n) {this.pos -= n;};
  StringStream.prototype.column = function () {
    if (this.lastColumnPos < this.start) {
      this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);
      this.lastColumnPos = this.start;
    }
    return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0)
  };
  StringStream.prototype.indentation = function () {
    return countColumn(this.string, null, this.tabSize) -
      (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0)
  };
  StringStream.prototype.match = function (pattern, consume, caseInsensitive) {
    if (typeof pattern == "string") {
      var cased = function (str) { return caseInsensitive ? str.toLowerCase() : str; };
      var substr = this.string.substr(this.pos, pattern.length);
      if (cased(substr) == cased(pattern)) {
        if (consume !== false) { this.pos += pattern.length; }
        return true
      }
    } else {
      var match = this.string.slice(this.pos).match(pattern);
      if (match && match.index > 0) { return null }
      if (match && consume !== false) { this.pos += match[0].length; }
      return match
    }
  };
  StringStream.prototype.current = function (){return this.string.slice(this.start, this.pos)};
  StringStream.prototype.hideFirstChars = function (n, inner) {
    this.lineStart += n;
    try { return inner() }
    finally { this.lineStart -= n; }
  };
  StringStream.prototype.lookAhead = function (n) {
    var oracle = this.lineOracle;
    return oracle && oracle.lookAhead(n)
  };
  StringStream.prototype.baseToken = function () {
    var oracle = this.lineOracle;
    return oracle && oracle.baseToken(this.pos)
  };

  // Find the line object corresponding to the given line number.
  function getLine(doc, n) {
    n -= doc.first;
    if (n < 0 || n >= doc.size) { throw new Error("There is no line " + (n + doc.first) + " in the document.") }
    var chunk = doc;
    while (!chunk.lines) {
      for (var i = 0;; ++i) {
        var child = chunk.children[i], sz = child.chunkSize();
        if (n < sz) { chunk = child; break }
        n -= sz;
      }
    }
    return chunk.lines[n]
  }

  // Get the part of a document between two positions, as an array of
  // strings.
  function getBetween(doc, start, end) {
    var out = [], n = start.line;
    doc.iter(start.line, end.line + 1, function (line) {
      var text = line.text;
      if (n == end.line) { text = text.slice(0, end.ch); }
      if (n == start.line) { text = text.slice(start.ch); }
      out.push(text);
      ++n;
    });
    return out
  }
  // Get the lines between from and to, as array of strings.
  function getLines(doc, from, to) {
    var out = [];
    doc.iter(from, to, function (line) { out.push(line.text); }); // iter aborts when callback returns truthy value
    return out
  }

  // Update the height of a line, propagating the height change
  // upwards to parent nodes.
  function updateLineHeight(line, height) {
    var diff = height - line.height;
    if (diff) { for (var n = line; n; n = n.parent) { n.height += diff; } }
  }

  // Given a line object, find its line number by walking up through
  // its parent links.
  function lineNo(line) {
    if (line.parent == null) { return null }
    var cur = line.parent, no = indexOf(cur.lines, line);
    for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {
      for (var i = 0;; ++i) {
        if (chunk.children[i] == cur) { break }
        no += chunk.children[i].chunkSize();
      }
    }
    return no + cur.first
  }

  // Find the line at the given vertical position, using the height
  // information in the document tree.
  function lineAtHeight(chunk, h) {
    var n = chunk.first;
    outer: do {
      for (var i$1 = 0; i$1 < chunk.children.length; ++i$1) {
        var child = chunk.children[i$1], ch = child.height;
        if (h < ch) { chunk = child; continue outer }
        h -= ch;
        n += child.chunkSize();
      }
      return n
    } while (!chunk.lines)
    var i = 0;
    for (; i < chunk.lines.length; ++i) {
      var line = chunk.lines[i], lh = line.height;
      if (h < lh) { break }
      h -= lh;
    }
    return n + i
  }

  function isLine(doc, l) {return l >= doc.first && l < doc.first + doc.size}

  function lineNumberFor(options, i) {
    return String(options.lineNumberFormatter(i + options.firstLineNumber))
  }

  // A Pos instance represents a position within the text.
  function Pos(line, ch, sticky) {
    if ( sticky === void 0 ) sticky = null;

    if (!(this instanceof Pos)) { return new Pos(line, ch, sticky) }
    this.line = line;
    this.ch = ch;
    this.sticky = sticky;
  }

  // Compare two positions, return 0 if they are the same, a negative
  // number when a is less, and a positive number otherwise.
  function cmp(a, b) { return a.line - b.line || a.ch - b.ch }

  function equalCursorPos(a, b) { return a.sticky == b.sticky && cmp(a, b) == 0 }

  function copyPos(x) {return Pos(x.line, x.ch)}
  function maxPos(a, b) { return cmp(a, b) < 0 ? b : a }
  function minPos(a, b) { return cmp(a, b) < 0 ? a : b }

  // Most of the external API clips given positions to make sure they
  // actually exist within the document.
  function clipLine(doc, n) {return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1))}
  function clipPos(doc, pos) {
    if (pos.line < doc.first) { return Pos(doc.first, 0) }
    var last = doc.first + doc.size - 1;
    if (pos.line > last) { return Pos(last, getLine(doc, last).text.length) }
    return clipToLen(pos, getLine(doc, pos.line).text.length)
  }
  function clipToLen(pos, linelen) {
    var ch = pos.ch;
    if (ch == null || ch > linelen) { return Pos(pos.line, linelen) }
    else if (ch < 0) { return Pos(pos.line, 0) }
    else { return pos }
  }
  function clipPosArray(doc, array) {
    var out = [];
    for (var i = 0; i < array.length; i++) { out[i] = clipPos(doc, array[i]); }
    return out
  }

  var SavedContext = function(state, lookAhead) {
    this.state = state;
    this.lookAhead = lookAhead;
  };

  var Context = function(doc, state, line, lookAhead) {
    this.state = state;
    this.doc = doc;
    this.line = line;
    this.maxLookAhead = lookAhead || 0;
    this.baseTokens = null;
    this.baseTokenPos = 1;
  };

  Context.prototype.lookAhead = function (n) {
    var line = this.doc.getLine(this.line + n);
    if (line != null && n > this.maxLookAhead) { this.maxLookAhead = n; }
    return line
  };

  Context.prototype.baseToken = function (n) {
    if (!this.baseTokens) { return null }
    while (this.baseTokens[this.baseTokenPos] <= n)
      { this.baseTokenPos += 2; }
    var type = this.baseTokens[this.baseTokenPos + 1];
    return {type: type && type.replace(/( |^)overlay .*/, ""),
            size: this.baseTokens[this.baseTokenPos] - n}
  };

  Context.prototype.nextLine = function () {
    this.line++;
    if (this.maxLookAhead > 0) { this.maxLookAhead--; }
  };

  Context.fromSaved = function (doc, saved, line) {
    if (saved instanceof SavedContext)
      { return new Context(doc, copyState(doc.mode, saved.state), line, saved.lookAhead) }
    else
      { return new Context(doc, copyState(doc.mode, saved), line) }
  };

  Context.prototype.save = function (copy) {
    var state = copy !== false ? copyState(this.doc.mode, this.state) : this.state;
    return this.maxLookAhead > 0 ? new SavedContext(state, this.maxLookAhead) : state
  };


  // Compute a style array (an array starting with a mode generation
  // -- for invalidation -- followed by pairs of end positions and
  // style strings), which is used to highlight the tokens on the
  // line.
  function highlightLine(cm, line, context, forceToEnd) {
    // A styles array always starts with a number identifying the
    // mode/overlays that it is based on (for easy invalidation).
    var st = [cm.state.modeGen], lineClasses = {};
    // Compute the base array of styles
    runMode(cm, line.text, cm.doc.mode, context, function (end, style) { return st.push(end, style); },
            lineClasses, forceToEnd);
    var state = context.state;

    // Run overlays, adjust style array.
    var loop = function ( o ) {
      context.baseTokens = st;
      var overlay = cm.state.overlays[o], i = 1, at = 0;
      context.state = true;
      runMode(cm, line.text, overlay.mode, context, function (end, style) {
        var start = i;
        // Ensure there's a token end at the current position, and that i points at it
        while (at < end) {
          var i_end = st[i];
          if (i_end > end)
            { st.splice(i, 1, end, st[i+1], i_end); }
          i += 2;
          at = Math.min(end, i_end);
        }
        if (!style) { return }
        if (overlay.opaque) {
          st.splice(start, i - start, end, "overlay " + style);
          i = start + 2;
        } else {
          for (; start < i; start += 2) {
            var cur = st[start+1];
            st[start+1] = (cur ? cur + " " : "") + "overlay " + style;
          }
        }
      }, lineClasses);
      context.state = state;
      context.baseTokens = null;
      context.baseTokenPos = 1;
    };

    for (var o = 0; o < cm.state.overlays.length; ++o) loop( o );

    return {styles: st, classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null}
  }

  function getLineStyles(cm, line, updateFrontier) {
    if (!line.styles || line.styles[0] != cm.state.modeGen) {
      var context = getContextBefore(cm, lineNo(line));
      var resetState = line.text.length > cm.options.maxHighlightLength && copyState(cm.doc.mode, context.state);
      var result = highlightLine(cm, line, context);
      if (resetState) { context.state = resetState; }
      line.stateAfter = context.save(!resetState);
      line.styles = result.styles;
      if (result.classes) { line.styleClasses = result.classes; }
      else if (line.styleClasses) { line.styleClasses = null; }
      if (updateFrontier === cm.doc.highlightFrontier)
        { cm.doc.modeFrontier = Math.max(cm.doc.modeFrontier, ++cm.doc.highlightFrontier); }
    }
    return line.styles
  }

  function getContextBefore(cm, n, precise) {
    var doc = cm.doc, display = cm.display;
    if (!doc.mode.startState) { return new Context(doc, true, n) }
    var start = findStartLine(cm, n, precise);
    var saved = start > doc.first && getLine(doc, start - 1).stateAfter;
    var context = saved ? Context.fromSaved(doc, saved, start) : new Context(doc, startState(doc.mode), start);

    doc.iter(start, n, function (line) {
      processLine(cm, line.text, context);
      var pos = context.line;
      line.stateAfter = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo ? context.save() : null;
      context.nextLine();
    });
    if (precise) { doc.modeFrontier = context.line; }
    return context
  }

  // Lightweight form of highlight -- proceed over this line and
  // update state, but don't save a style array. Used for lines that
  // aren't currently visible.
  function processLine(cm, text, context, startAt) {
    var mode = cm.doc.mode;
    var stream = new StringStream(text, cm.options.tabSize, context);
    stream.start = stream.pos = startAt || 0;
    if (text == "") { callBlankLine(mode, context.state); }
    while (!stream.eol()) {
      readToken(mode, stream, context.state);
      stream.start = stream.pos;
    }
  }

  function callBlankLine(mode, state) {
    if (mode.blankLine) { return mode.blankLine(state) }
    if (!mode.innerMode) { return }
    var inner = innerMode(mode, state);
    if (inner.mode.blankLine) { return inner.mode.blankLine(inner.state) }
  }

  function readToken(mode, stream, state, inner) {
    for (var i = 0; i < 10; i++) {
      if (inner) { inner[0] = innerMode(mode, state).mode; }
      var style = mode.token(stream, state);
      if (stream.pos > stream.start) { return style }
    }
    throw new Error("Mode " + mode.name + " failed to advance stream.")
  }

  var Token = function(stream, type, state) {
    this.start = stream.start; this.end = stream.pos;
    this.string = stream.current();
    this.type = type || null;
    this.state = state;
  };

  // Utility for getTokenAt and getLineTokens
  function takeToken(cm, pos, precise, asArray) {
    var doc = cm.doc, mode = doc.mode, style;
    pos = clipPos(doc, pos);
    var line = getLine(doc, pos.line), context = getContextBefore(cm, pos.line, precise);
    var stream = new StringStream(line.text, cm.options.tabSize, context), tokens;
    if (asArray) { tokens = []; }
    while ((asArray || stream.pos < pos.ch) && !stream.eol()) {
      stream.start = stream.pos;
      style = readToken(mode, stream, context.state);
      if (asArray) { tokens.push(new Token(stream, style, copyState(doc.mode, context.state))); }
    }
    return asArray ? tokens : new Token(stream, style, context.state)
  }

  function extractLineClasses(type, output) {
    if (type) { for (;;) {
      var lineClass = type.match(/(?:^|\s+)line-(background-)?(\S+)/);
      if (!lineClass) { break }
      type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);
      var prop = lineClass[1] ? "bgClass" : "textClass";
      if (output[prop] == null)
        { output[prop] = lineClass[2]; }
      else if (!(new RegExp("(?:^|\\s)" + lineClass[2] + "(?:$|\\s)")).test(output[prop]))
        { output[prop] += " " + lineClass[2]; }
    } }
    return type
  }

  // Run the given mode's parser over a line, calling f for each token.
  function runMode(cm, text, mode, context, f, lineClasses, forceToEnd) {
    var flattenSpans = mode.flattenSpans;
    if (flattenSpans == null) { flattenSpans = cm.options.flattenSpans; }
    var curStart = 0, curStyle = null;
    var stream = new StringStream(text, cm.options.tabSize, context), style;
    var inner = cm.options.addModeClass && [null];
    if (text == "") { extractLineClasses(callBlankLine(mode, context.state), lineClasses); }
    while (!stream.eol()) {
      if (stream.pos > cm.options.maxHighlightLength) {
        flattenSpans = false;
        if (forceToEnd) { processLine(cm, text, context, stream.pos); }
        stream.pos = text.length;
        style = null;
      } else {
        style = extractLineClasses(readToken(mode, stream, context.state, inner), lineClasses);
      }
      if (inner) {
        var mName = inner[0].name;
        if (mName) { style = "m-" + (style ? mName + " " + style : mName); }
      }
      if (!flattenSpans || curStyle != style) {
        while (curStart < stream.start) {
          curStart = Math.min(stream.start, curStart + 5000);
          f(curStart, curStyle);
        }
        curStyle = style;
      }
      stream.start = stream.pos;
    }
    while (curStart < stream.pos) {
      // Webkit seems to refuse to render text nodes longer than 57444
      // characters, and returns inaccurate measurements in nodes
      // starting around 5000 chars.
      var pos = Math.min(stream.pos, curStart + 5000);
      f(pos, curStyle);
      curStart = pos;
    }
  }

  // Finds the line to start with when starting a parse. Tries to
  // find a line with a stateAfter, so that it can start with a
  // valid state. If that fails, it returns the line with the
  // smallest indentation, which tends to need the least context to
  // parse correctly.
  function findStartLine(cm, n, precise) {
    var minindent, minline, doc = cm.doc;
    var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1000 : 100);
    for (var search = n; search > lim; --search) {
      if (search <= doc.first) { return doc.first }
      var line = getLine(doc, search - 1), after = line.stateAfter;
      if (after && (!precise || search + (after instanceof SavedContext ? after.lookAhead : 0) <= doc.modeFrontier))
        { return search }
      var indented = countColumn(line.text, null, cm.options.tabSize);
      if (minline == null || minindent > indented) {
        minline = search - 1;
        minindent = indented;
      }
    }
    return minline
  }

  function retreatFrontier(doc, n) {
    doc.modeFrontier = Math.min(doc.modeFrontier, n);
    if (doc.highlightFrontier < n - 10) { return }
    var start = doc.first;
    for (var line = n - 1; line > start; line--) {
      var saved = getLine(doc, line).stateAfter;
      // change is on 3
      // state on line 1 looked ahead 2 -- so saw 3
      // test 1 + 2 < 3 should cover this
      if (saved && (!(saved instanceof SavedContext) || line + saved.lookAhead < n)) {
        start = line + 1;
        break
      }
    }
    doc.highlightFrontier = Math.min(doc.highlightFrontier, start);
  }

  // Optimize some code when these features are not used.
  var sawReadOnlySpans = false, sawCollapsedSpans = false;

  function seeReadOnlySpans() {
    sawReadOnlySpans = true;
  }

  function seeCollapsedSpans() {
    sawCollapsedSpans = true;
  }

  // TEXTMARKER SPANS

  function MarkedSpan(marker, from, to) {
    this.marker = marker;
    this.from = from; this.to = to;
  }

  // Search an array of spans for a span matching the given marker.
  function getMarkedSpanFor(spans, marker) {
    if (spans) { for (var i = 0; i < spans.length; ++i) {
      var span = spans[i];
      if (span.marker == marker) { return span }
    } }
  }
  // Remove a span from an array, returning undefined if no spans are
  // left (we don't store arrays for lines without spans).
  function removeMarkedSpan(spans, span) {
    var r;
    for (var i = 0; i < spans.length; ++i)
      { if (spans[i] != span) { (r || (r = [])).push(spans[i]); } }
    return r
  }
  // Add a span to a line.
  function addMarkedSpan(line, span) {
    line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];
    span.marker.attachLine(line);
  }

  // Used for the algorithm that adjusts markers for a change in the
  // document. These functions cut an array of spans at a given
  // character position, returning an array of remaining chunks (or
  // undefined if nothing remains).
  function markedSpansBefore(old, startCh, isInsert) {
    var nw;
    if (old) { for (var i = 0; i < old.length; ++i) {
      var span = old[i], marker = span.marker;
      var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);
      if (startsBefore || span.from == startCh && marker.type == "bookmark" && (!isInsert || !span.marker.insertLeft)) {
        var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh)
        ;(nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to));
      }
    } }
    return nw
  }
  function markedSpansAfter(old, endCh, isInsert) {
    var nw;
    if (old) { for (var i = 0; i < old.length; ++i) {
      var span = old[i], marker = span.marker;
      var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);
      if (endsAfter || span.from == endCh && marker.type == "bookmark" && (!isInsert || span.marker.insertLeft)) {
        var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh)
        ;(nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh,
                                              span.to == null ? null : span.to - endCh));
      }
    } }
    return nw
  }

  // Given a change object, compute the new set of marker spans that
  // cover the line in which the change took place. Removes spans
  // entirely within the change, reconnects spans belonging to the
  // same marker that appear on both sides of the change, and cuts off
  // spans partially within the change. Returns an array of span
  // arrays with one element for each line in (after) the change.
  function stretchSpansOverChange(doc, change) {
    if (change.full) { return null }
    var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;
    var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;
    if (!oldFirst && !oldLast) { return null }

    var startCh = change.from.ch, endCh = change.to.ch, isInsert = cmp(change.from, change.to) == 0;
    // Get the spans that 'stick out' on both sides
    var first = markedSpansBefore(oldFirst, startCh, isInsert);
    var last = markedSpansAfter(oldLast, endCh, isInsert);

    // Next, merge those two ends
    var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0);
    if (first) {
      // Fix up .to properties of first
      for (var i = 0; i < first.length; ++i) {
        var span = first[i];
        if (span.to == null) {
          var found = getMarkedSpanFor(last, span.marker);
          if (!found) { span.to = startCh; }
          else if (sameLine) { span.to = found.to == null ? null : found.to + offset; }
        }
      }
    }
    if (last) {
      // Fix up .from in last (or move them into first in case of sameLine)
      for (var i$1 = 0; i$1 < last.length; ++i$1) {
        var span$1 = last[i$1];
        if (span$1.to != null) { span$1.to += offset; }
        if (span$1.from == null) {
          var found$1 = getMarkedSpanFor(first, span$1.marker);
          if (!found$1) {
            span$1.from = offset;
            if (sameLine) { (first || (first = [])).push(span$1); }
          }
        } else {
          span$1.from += offset;
          if (sameLine) { (first || (first = [])).push(span$1); }
        }
      }
    }
    // Make sure we didn't create any zero-length spans
    if (first) { first = clearEmptySpans(first); }
    if (last && last != first) { last = clearEmptySpans(last); }

    var newMarkers = [first];
    if (!sameLine) {
      // Fill gap with whole-line-spans
      var gap = change.text.length - 2, gapMarkers;
      if (gap > 0 && first)
        { for (var i$2 = 0; i$2 < first.length; ++i$2)
          { if (first[i$2].to == null)
            { (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i$2].marker, null, null)); } } }
      for (var i$3 = 0; i$3 < gap; ++i$3)
        { newMarkers.push(gapMarkers); }
      newMarkers.push(last);
    }
    return newMarkers
  }

  // Remove spans that are empty and don't have a clearWhenEmpty
  // option of false.
  function clearEmptySpans(spans) {
    for (var i = 0; i < spans.length; ++i) {
      var span = spans[i];
      if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false)
        { spans.splice(i--, 1); }
    }
    if (!spans.length) { return null }
    return spans
  }

  // Used to 'clip' out readOnly ranges when making a change.
  function removeReadOnlyRanges(doc, from, to) {
    var markers = null;
    doc.iter(from.line, to.line + 1, function (line) {
      if (line.markedSpans) { for (var i = 0; i < line.markedSpans.length; ++i) {
        var mark = line.markedSpans[i].marker;
        if (mark.readOnly && (!markers || indexOf(markers, mark) == -1))
          { (markers || (markers = [])).push(mark); }
      } }
    });
    if (!markers) { return null }
    var parts = [{from: from, to: to}];
    for (var i = 0; i < markers.length; ++i) {
      var mk = markers[i], m = mk.find(0);
      for (var j = 0; j < parts.length; ++j) {
        var p = parts[j];
        if (cmp(p.to, m.from) < 0 || cmp(p.from, m.to) > 0) { continue }
        var newParts = [j, 1], dfrom = cmp(p.from, m.from), dto = cmp(p.to, m.to);
        if (dfrom < 0 || !mk.inclusiveLeft && !dfrom)
          { newParts.push({from: p.from, to: m.from}); }
        if (dto > 0 || !mk.inclusiveRight && !dto)
          { newParts.push({from: m.to, to: p.to}); }
        parts.splice.apply(parts, newParts);
        j += newParts.length - 3;
      }
    }
    return parts
  }

  // Connect or disconnect spans from a line.
  function detachMarkedSpans(line) {
    var spans = line.markedSpans;
    if (!spans) { return }
    for (var i = 0; i < spans.length; ++i)
      { spans[i].marker.detachLine(line); }
    line.markedSpans = null;
  }
  function attachMarkedSpans(line, spans) {
    if (!spans) { return }
    for (var i = 0; i < spans.length; ++i)
      { spans[i].marker.attachLine(line); }
    line.markedSpans = spans;
  }

  // Helpers used when computing which overlapping collapsed span
  // counts as the larger one.
  function extraLeft(marker) { return marker.inclusiveLeft ? -1 : 0 }
  function extraRight(marker) { return marker.inclusiveRight ? 1 : 0 }

  // Returns a number indicating which of two overlapping collapsed
  // spans is larger (and thus includes the other). Falls back to
  // comparing ids when the spans cover exactly the same range.
  function compareCollapsedMarkers(a, b) {
    var lenDiff = a.lines.length - b.lines.length;
    if (lenDiff != 0) { return lenDiff }
    var aPos = a.find(), bPos = b.find();
    var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);
    if (fromCmp) { return -fromCmp }
    var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);
    if (toCmp) { return toCmp }
    return b.id - a.id
  }

  // Find out whether a line ends or starts in a collapsed span. If
  // so, return the marker for that span.
  function collapsedSpanAtSide(line, start) {
    var sps = sawCollapsedSpans && line.markedSpans, found;
    if (sps) { for (var sp = (void 0), i = 0; i < sps.length; ++i) {
      sp = sps[i];
      if (sp.marker.collapsed && (start ? sp.from : sp.to) == null &&
          (!found || compareCollapsedMarkers(found, sp.marker) < 0))
        { found = sp.marker; }
    } }
    return found
  }
  function collapsedSpanAtStart(line) { return collapsedSpanAtSide(line, true) }
  function collapsedSpanAtEnd(line) { return collapsedSpanAtSide(line, false) }

  function collapsedSpanAround(line, ch) {
    var sps = sawCollapsedSpans && line.markedSpans, found;
    if (sps) { for (var i = 0; i < sps.length; ++i) {
      var sp = sps[i];
      if (sp.marker.collapsed && (sp.from == null || sp.from < ch) && (sp.to == null || sp.to > ch) &&
          (!found || compareCollapsedMarkers(found, sp.marker) < 0)) { found = sp.marker; }
    } }
    return found
  }

  // Test whether there exists a collapsed span that partially
  // overlaps (covers the start or end, but not both) of a new span.
  // Such overlap is not allowed.
  function conflictingCollapsedRange(doc, lineNo, from, to, marker) {
    var line = getLine(doc, lineNo);
    var sps = sawCollapsedSpans && line.markedSpans;
    if (sps) { for (var i = 0; i < sps.length; ++i) {
      var sp = sps[i];
      if (!sp.marker.collapsed) { continue }
      var found = sp.marker.find(0);
      var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);
      var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);
      if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) { continue }
      if (fromCmp <= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.to, from) >= 0 : cmp(found.to, from) > 0) ||
          fromCmp >= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.from, to) <= 0 : cmp(found.from, to) < 0))
        { return true }
    } }
  }

  // A visual line is a line as drawn on the screen. Folding, for
  // example, can cause multiple logical lines to appear on the same
  // visual line. This finds the start of the visual line that the
  // given line is part of (usually that is the line itself).
  function visualLine(line) {
    var merged;
    while (merged = collapsedSpanAtStart(line))
      { line = merged.find(-1, true).line; }
    return line
  }

  function visualLineEnd(line) {
    var merged;
    while (merged = collapsedSpanAtEnd(line))
      { line = merged.find(1, true).line; }
    return line
  }

  // Returns an array of logical lines that continue the visual line
  // started by the argument, or undefined if there are no such lines.
  function visualLineContinued(line) {
    var merged, lines;
    while (merged = collapsedSpanAtEnd(line)) {
      line = merged.find(1, true).line
      ;(lines || (lines = [])).push(line);
    }
    return lines
  }

  // Get the line number of the start of the visual line that the
  // given line number is part of.
  function visualLineNo(doc, lineN) {
    var line = getLine(doc, lineN), vis = visualLine(line);
    if (line == vis) { return lineN }
    return lineNo(vis)
  }

  // Get the line number of the start of the next visual line after
  // the given line.
  function visualLineEndNo(doc, lineN) {
    if (lineN > doc.lastLine()) { return lineN }
    var line = getLine(doc, lineN), merged;
    if (!lineIsHidden(doc, line)) { return lineN }
    while (merged = collapsedSpanAtEnd(line))
      { line = merged.find(1, true).line; }
    return lineNo(line) + 1
  }

  // Compute whether a line is hidden. Lines count as hidden when they
  // are part of a visual line that starts with another line, or when
  // they are entirely covered by collapsed, non-widget span.
  function lineIsHidden(doc, line) {
    var sps = sawCollapsedSpans && line.markedSpans;
    if (sps) { for (var sp = (void 0), i = 0; i < sps.length; ++i) {
      sp = sps[i];
      if (!sp.marker.collapsed) { continue }
      if (sp.from == null) { return true }
      if (sp.marker.widgetNode) { continue }
      if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp))
        { return true }
    } }
  }
  function lineIsHiddenInner(doc, line, span) {
    if (span.to == null) {
      var end = span.marker.find(1, true);
      return lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker))
    }
    if (span.marker.inclusiveRight && span.to == line.text.length)
      { return true }
    for (var sp = (void 0), i = 0; i < line.markedSpans.length; ++i) {
      sp = line.markedSpans[i];
      if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to &&
          (sp.to == null || sp.to != span.from) &&
          (sp.marker.inclusiveLeft || span.marker.inclusiveRight) &&
          lineIsHiddenInner(doc, line, sp)) { return true }
    }
  }

  // Find the height above the given line.
  function heightAtLine(lineObj) {
    lineObj = visualLine(lineObj);

    var h = 0, chunk = lineObj.parent;
    for (var i = 0; i < chunk.lines.length; ++i) {
      var line = chunk.lines[i];
      if (line == lineObj) { break }
      else { h += line.height; }
    }
    for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {
      for (var i$1 = 0; i$1 < p.children.length; ++i$1) {
        var cur = p.children[i$1];
        if (cur == chunk) { break }
        else { h += cur.height; }
      }
    }
    return h
  }

  // Compute the character length of a line, taking into account
  // collapsed ranges (see markText) that might hide parts, and join
  // other lines onto it.
  function lineLength(line) {
    if (line.height == 0) { return 0 }
    var len = line.text.length, merged, cur = line;
    while (merged = collapsedSpanAtStart(cur)) {
      var found = merged.find(0, true);
      cur = found.from.line;
      len += found.from.ch - found.to.ch;
    }
    cur = line;
    while (merged = collapsedSpanAtEnd(cur)) {
      var found$1 = merged.find(0, true);
      len -= cur.text.length - found$1.from.ch;
      cur = found$1.to.line;
      len += cur.text.length - found$1.to.ch;
    }
    return len
  }

  // Find the longest line in the document.
  function findMaxLine(cm) {
    var d = cm.display, doc = cm.doc;
    d.maxLine = getLine(doc, doc.first);
    d.maxLineLength = lineLength(d.maxLine);
    d.maxLineChanged = true;
    doc.iter(function (line) {
      var len = lineLength(line);
      if (len > d.maxLineLength) {
        d.maxLineLength = len;
        d.maxLine = line;
      }
    });
  }

  // LINE DATA STRUCTURE

  // Line objects. These hold state related to a line, including
  // highlighting info (the styles array).
  var Line = function(text, markedSpans, estimateHeight) {
    this.text = text;
    attachMarkedSpans(this, markedSpans);
    this.height = estimateHeight ? estimateHeight(this) : 1;
  };

  Line.prototype.lineNo = function () { return lineNo(this) };
  eventMixin(Line);

  // Change the content (text, markers) of a line. Automatically
  // invalidates cached information and tries to re-estimate the
  // line's height.
  function updateLine(line, text, markedSpans, estimateHeight) {
    line.text = text;
    if (line.stateAfter) { line.stateAfter = null; }
    if (line.styles) { line.styles = null; }
    if (line.order != null) { line.order = null; }
    detachMarkedSpans(line);
    attachMarkedSpans(line, markedSpans);
    var estHeight = estimateHeight ? estimateHeight(line) : 1;
    if (estHeight != line.height) { updateLineHeight(line, estHeight); }
  }

  // Detach a line from the document tree and its markers.
  function cleanUpLine(line) {
    line.parent = null;
    detachMarkedSpans(line);
  }

  // Convert a style as returned by a mode (either null, or a string
  // containing one or more styles) to a CSS style. This is cached,
  // and also looks for line-wide styles.
  var styleToClassCache = {}, styleToClassCacheWithMode = {};
  function interpretTokenStyle(style, options) {
    if (!style || /^\s*$/.test(style)) { return null }
    var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;
    return cache[style] ||
      (cache[style] = style.replace(/\S+/g, "cm-$&"))
  }

  // Render the DOM representation of the text of a line. Also builds
  // up a 'line map', which points at the DOM nodes that represent
  // specific stretches of text, and is used by the measuring code.
  // The returned object contains the DOM node, this map, and
  // information about line-wide styles that were set by the mode.
  function buildLineContent(cm, lineView) {
    // The padding-right forces the element to have a 'border', which
    // is needed on Webkit to be able to get line-level bounding
    // rectangles for it (in measureChar).
    var content = eltP("span", null, null, webkit ? "padding-right: .1px" : null);
    var builder = {pre: eltP("pre", [content], "CodeMirror-line"), content: content,
                   col: 0, pos: 0, cm: cm,
                   trailingSpace: false,
                   splitSpaces: cm.getOption("lineWrapping")};
    lineView.measure = {};

    // Iterate over the logical lines that make up this visual line.
    for (var i = 0; i <= (lineView.rest ? lineView.rest.length : 0); i++) {
      var line = i ? lineView.rest[i - 1] : lineView.line, order = (void 0);
      builder.pos = 0;
      builder.addToken = buildToken;
      // Optionally wire in some hacks into the token-rendering
      // algorithm, to deal with browser quirks.
      if (hasBadBidiRects(cm.display.measure) && (order = getOrder(line, cm.doc.direction)))
        { builder.addToken = buildTokenBadBidi(builder.addToken, order); }
      builder.map = [];
      var allowFrontierUpdate = lineView != cm.display.externalMeasured && lineNo(line);
      insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate));
      if (line.styleClasses) {
        if (line.styleClasses.bgClass)
          { builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || ""); }
        if (line.styleClasses.textClass)
          { builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || ""); }
      }

      // Ensure at least a single node is present, for measuring.
      if (builder.map.length == 0)
        { builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure))); }

      // Store the map and a cache object for the current logical line
      if (i == 0) {
        lineView.measure.map = builder.map;
        lineView.measure.cache = {};
      } else {
  (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map)
        ;(lineView.measure.caches || (lineView.measure.caches = [])).push({});
      }
    }

    // See issue #2901
    if (webkit) {
      var last = builder.content.lastChild;
      if (/\bcm-tab\b/.test(last.className) || (last.querySelector && last.querySelector(".cm-tab")))
        { builder.content.className = "cm-tab-wrap-hack"; }
    }

    signal(cm, "renderLine", cm, lineView.line, builder.pre);
    if (builder.pre.className)
      { builder.textClass = joinClasses(builder.pre.className, builder.textClass || ""); }

    return builder
  }

  function defaultSpecialCharPlaceholder(ch) {
    var token = elt("span", "\u2022", "cm-invalidchar");
    token.title = "\\u" + ch.charCodeAt(0).toString(16);
    token.setAttribute("aria-label", token.title);
    return token
  }

  // Build up the DOM representation for a single token, and add it to
  // the line map. Takes care to render special characters separately.
  function buildToken(builder, text, style, startStyle, endStyle, css, attributes) {
    if (!text) { return }
    var displayText = builder.splitSpaces ? splitSpaces(text, builder.trailingSpace) : text;
    var special = builder.cm.state.specialChars, mustWrap = false;
    var content;
    if (!special.test(text)) {
      builder.col += text.length;
      content = document.createTextNode(displayText);
      builder.map.push(builder.pos, builder.pos + text.length, content);
      if (ie && ie_version < 9) { mustWrap = true; }
      builder.pos += text.length;
    } else {
      content = document.createDocumentFragment();
      var pos = 0;
      while (true) {
        special.lastIndex = pos;
        var m = special.exec(text);
        var skipped = m ? m.index - pos : text.length - pos;
        if (skipped) {
          var txt = document.createTextNode(displayText.slice(pos, pos + skipped));
          if (ie && ie_version < 9) { content.appendChild(elt("span", [txt])); }
          else { content.appendChild(txt); }
          builder.map.push(builder.pos, builder.pos + skipped, txt);
          builder.col += skipped;
          builder.pos += skipped;
        }
        if (!m) { break }
        pos += skipped + 1;
        var txt$1 = (void 0);
        if (m[0] == "\t") {
          var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;
          txt$1 = content.appendChild(elt("span", spaceStr(tabWidth), "cm-tab"));
          txt$1.setAttribute("role", "presentation");
          txt$1.setAttribute("cm-text", "\t");
          builder.col += tabWidth;
        } else if (m[0] == "\r" || m[0] == "\n") {
          txt$1 = content.appendChild(elt("span", m[0] == "\r" ? "\u240d" : "\u2424", "cm-invalidchar"));
          txt$1.setAttribute("cm-text", m[0]);
          builder.col += 1;
        } else {
          txt$1 = builder.cm.options.specialCharPlaceholder(m[0]);
          txt$1.setAttribute("cm-text", m[0]);
          if (ie && ie_version < 9) { content.appendChild(elt("span", [txt$1])); }
          else { content.appendChild(txt$1); }
          builder.col += 1;
        }
        builder.map.push(builder.pos, builder.pos + 1, txt$1);
        builder.pos++;
      }
    }
    builder.trailingSpace = displayText.charCodeAt(text.length - 1) == 32;
    if (style || startStyle || endStyle || mustWrap || css || attributes) {
      var fullStyle = style || "";
      if (startStyle) { fullStyle += startStyle; }
      if (endStyle) { fullStyle += endStyle; }
      var token = elt("span", [content], fullStyle, css);
      if (attributes) {
        for (var attr in attributes) { if (attributes.hasOwnProperty(attr) && attr != "style" && attr != "class")
          { token.setAttribute(attr, attributes[attr]); } }
      }
      return builder.content.appendChild(token)
    }
    builder.content.appendChild(content);
  }

  // Change some spaces to NBSP to prevent the browser from collapsing
  // trailing spaces at the end of a line when rendering text (issue #1362).
  function splitSpaces(text, trailingBefore) {
    if (text.length > 1 && !/  /.test(text)) { return text }
    var spaceBefore = trailingBefore, result = "";
    for (var i = 0; i < text.length; i++) {
      var ch = text.charAt(i);
      if (ch == " " && spaceBefore && (i == text.length - 1 || text.charCodeAt(i + 1) == 32))
        { ch = "\u00a0"; }
      result += ch;
      spaceBefore = ch == " ";
    }
    return result
  }

  // Work around nonsense dimensions being reported for stretches of
  // right-to-left text.
  function buildTokenBadBidi(inner, order) {
    return function (builder, text, style, startStyle, endStyle, css, attributes) {
      style = style ? style + " cm-force-border" : "cm-force-border";
      var start = builder.pos, end = start + text.length;
      for (;;) {
        // Find the part that overlaps with the start of this text
        var part = (void 0);
        for (var i = 0; i < order.length; i++) {
          part = order[i];
          if (part.to > start && part.from <= start) { break }
        }
        if (part.to >= end) { return inner(builder, text, style, startStyle, endStyle, css, attributes) }
        inner(builder, text.slice(0, part.to - start), style, startStyle, null, css, attributes);
        startStyle = null;
        text = text.slice(part.to - start);
        start = part.to;
      }
    }
  }

  function buildCollapsedSpan(builder, size, marker, ignoreWidget) {
    var widget = !ignoreWidget && marker.widgetNode;
    if (widget) { builder.map.push(builder.pos, builder.pos + size, widget); }
    if (!ignoreWidget && builder.cm.display.input.needsContentAttribute) {
      if (!widget)
        { widget = builder.content.appendChild(document.createElement("span")); }
      widget.setAttribute("cm-marker", marker.id);
    }
    if (widget) {
      builder.cm.display.input.setUneditable(widget);
      builder.content.appendChild(widget);
    }
    builder.pos += size;
    builder.trailingSpace = false;
  }

  // Outputs a number of spans to make up a line, taking highlighting
  // and marked text into account.
  function insertLineContent(line, builder, styles) {
    var spans = line.markedSpans, allText = line.text, at = 0;
    if (!spans) {
      for (var i$1 = 1; i$1 < styles.length; i$1+=2)
        { builder.addToken(builder, allText.slice(at, at = styles[i$1]), interpretTokenStyle(styles[i$1+1], builder.cm.options)); }
      return
    }

    var len = allText.length, pos = 0, i = 1, text = "", style, css;
    var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, collapsed, attributes;
    for (;;) {
      if (nextChange == pos) { // Update current marker set
        spanStyle = spanEndStyle = spanStartStyle = css = "";
        attributes = null;
        collapsed = null; nextChange = Infinity;
        var foundBookmarks = [], endStyles = (void 0);
        for (var j = 0; j < spans.length; ++j) {
          var sp = spans[j], m = sp.marker;
          if (m.type == "bookmark" && sp.from == pos && m.widgetNode) {
            foundBookmarks.push(m);
          } else if (sp.from <= pos && (sp.to == null || sp.to > pos || m.collapsed && sp.to == pos && sp.from == pos)) {
            if (sp.to != null && sp.to != pos && nextChange > sp.to) {
              nextChange = sp.to;
              spanEndStyle = "";
            }
            if (m.className) { spanStyle += " " + m.className; }
            if (m.css) { css = (css ? css + ";" : "") + m.css; }
            if (m.startStyle && sp.from == pos) { spanStartStyle += " " + m.startStyle; }
            if (m.endStyle && sp.to == nextChange) { (endStyles || (endStyles = [])).push(m.endStyle, sp.to); }
            // support for the old title property
            // https://github.com/codemirror/CodeMirror/pull/5673
            if (m.title) { (attributes || (attributes = {})).title = m.title; }
            if (m.attributes) {
              for (var attr in m.attributes)
                { (attributes || (attributes = {}))[attr] = m.attributes[attr]; }
            }
            if (m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0))
              { collapsed = sp; }
          } else if (sp.from > pos && nextChange > sp.from) {
            nextChange = sp.from;
          }
        }
        if (endStyles) { for (var j$1 = 0; j$1 < endStyles.length; j$1 += 2)
          { if (endStyles[j$1 + 1] == nextChange) { spanEndStyle += " " + endStyles[j$1]; } } }

        if (!collapsed || collapsed.from == pos) { for (var j$2 = 0; j$2 < foundBookmarks.length; ++j$2)
          { buildCollapsedSpan(builder, 0, foundBookmarks[j$2]); } }
        if (collapsed && (collapsed.from || 0) == pos) {
          buildCollapsedSpan(builder, (collapsed.to == null ? len + 1 : collapsed.to) - pos,
                             collapsed.marker, collapsed.from == null);
          if (collapsed.to == null) { return }
          if (collapsed.to == pos) { collapsed = false; }
        }
      }
      if (pos >= len) { break }

      var upto = Math.min(len, nextChange);
      while (true) {
        if (text) {
          var end = pos + text.length;
          if (!collapsed) {
            var tokenText = end > upto ? text.slice(0, upto - pos) : text;
            builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle,
                             spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : "", css, attributes);
          }
          if (end >= upto) {text = text.slice(upto - pos); pos = upto; break}
          pos = end;
          spanStartStyle = "";
        }
        text = allText.slice(at, at = styles[i++]);
        style = interpretTokenStyle(styles[i++], builder.cm.options);
      }
    }
  }


  // These objects are used to represent the visible (currently drawn)
  // part of the document. A LineView may correspond to multiple
  // logical lines, if those are connected by collapsed ranges.
  function LineView(doc, line, lineN) {
    // The starting line
    this.line = line;
    // Continuing lines, if any
    this.rest = visualLineContinued(line);
    // Number of logical lines in this visual line
    this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1;
    this.node = this.text = null;
    this.hidden = lineIsHidden(doc, line);
  }

  // Create a range of LineView objects for the given lines.
  function buildViewArray(cm, from, to) {
    var array = [], nextPos;
    for (var pos = from; pos < to; pos = nextPos) {
      var view = new LineView(cm.doc, getLine(cm.doc, pos), pos);
      nextPos = pos + view.size;
      array.push(view);
    }
    return array
  }

  var operationGroup = null;

  function pushOperation(op) {
    if (operationGroup) {
      operationGroup.ops.push(op);
    } else {
      op.ownsGroup = operationGroup = {
        ops: [op],
        delayedCallbacks: []
      };
    }
  }

  function fireCallbacksForOps(group) {
    // Calls delayed callbacks and cursorActivity handlers until no
    // new ones appear
    var callbacks = group.delayedCallbacks, i = 0;
    do {
      for (; i < callbacks.length; i++)
        { callbacks[i].call(null); }
      for (var j = 0; j < group.ops.length; j++) {
        var op = group.ops[j];
        if (op.cursorActivityHandlers)
          { while (op.cursorActivityCalled < op.cursorActivityHandlers.length)
            { op.cursorActivityHandlers[op.cursorActivityCalled++].call(null, op.cm); } }
      }
    } while (i < callbacks.length)
  }

  function finishOperation(op, endCb) {
    var group = op.ownsGroup;
    if (!group) { return }

    try { fireCallbacksForOps(group); }
    finally {
      operationGroup = null;
      endCb(group);
    }
  }

  var orphanDelayedCallbacks = null;

  // Often, we want to signal events at a point where we are in the
  // middle of some work, but don't want the handler to start calling
  // other methods on the editor, which might be in an inconsistent
  // state or simply not expect any other events to happen.
  // signalLater looks whether there are any handlers, and schedules
  // them to be executed when the last operation ends, or, if no
  // operation is active, when a timeout fires.
  function signalLater(emitter, type /*, values...*/) {
    var arr = getHandlers(emitter, type);
    if (!arr.length) { return }
    var args = Array.prototype.slice.call(arguments, 2), list;
    if (operationGroup) {
      list = operationGroup.delayedCallbacks;
    } else if (orphanDelayedCallbacks) {
      list = orphanDelayedCallbacks;
    } else {
      list = orphanDelayedCallbacks = [];
      setTimeout(fireOrphanDelayed, 0);
    }
    var loop = function ( i ) {
      list.push(function () { return arr[i].apply(null, args); });
    };

    for (var i = 0; i < arr.length; ++i)
      loop( i );
  }

  function fireOrphanDelayed() {
    var delayed = orphanDelayedCallbacks;
    orphanDelayedCallbacks = null;
    for (var i = 0; i < delayed.length; ++i) { delayed[i](); }
  }

  // When an aspect of a line changes, a string is added to
  // lineView.changes. This updates the relevant part of the line's
  // DOM structure.
  function updateLineForChanges(cm, lineView, lineN, dims) {
    for (var j = 0; j < lineView.changes.length; j++) {
      var type = lineView.changes[j];
      if (type == "text") { updateLineText(cm, lineView); }
      else if (type == "gutter") { updateLineGutter(cm, lineView, lineN, dims); }
      else if (type == "class") { updateLineClasses(cm, lineView); }
      else if (type == "widget") { updateLineWidgets(cm, lineView, dims); }
    }
    lineView.changes = null;
  }

  // Lines with gutter elements, widgets or a background class need to
  // be wrapped, and have the extra elements added to the wrapper div
  function ensureLineWrapped(lineView) {
    if (lineView.node == lineView.text) {
      lineView.node = elt("div", null, null, "position: relative");
      if (lineView.text.parentNode)
        { lineView.text.parentNode.replaceChild(lineView.node, lineView.text); }
      lineView.node.appendChild(lineView.text);
      if (ie && ie_version < 8) { lineView.node.style.zIndex = 2; }
    }
    return lineView.node
  }

  function updateLineBackground(cm, lineView) {
    var cls = lineView.bgClass ? lineView.bgClass + " " + (lineView.line.bgClass || "") : lineView.line.bgClass;
    if (cls) { cls += " CodeMirror-linebackground"; }
    if (lineView.background) {
      if (cls) { lineView.background.className = cls; }
      else { lineView.background.parentNode.removeChild(lineView.background); lineView.background = null; }
    } else if (cls) {
      var wrap = ensureLineWrapped(lineView);
      lineView.background = wrap.insertBefore(elt("div", null, cls), wrap.firstChild);
      cm.display.input.setUneditable(lineView.background);
    }
  }

  // Wrapper around buildLineContent which will reuse the structure
  // in display.externalMeasured when possible.
  function getLineContent(cm, lineView) {
    var ext = cm.display.externalMeasured;
    if (ext && ext.line == lineView.line) {
      cm.display.externalMeasured = null;
      lineView.measure = ext.measure;
      return ext.built
    }
    return buildLineContent(cm, lineView)
  }

  // Redraw the line's text. Interacts with the background and text
  // classes because the mode may output tokens that influence these
  // classes.
  function updateLineText(cm, lineView) {
    var cls = lineView.text.className;
    var built = getLineContent(cm, lineView);
    if (lineView.text == lineView.node) { lineView.node = built.pre; }
    lineView.text.parentNode.replaceChild(built.pre, lineView.text);
    lineView.text = built.pre;
    if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {
      lineView.bgClass = built.bgClass;
      lineView.textClass = built.textClass;
      updateLineClasses(cm, lineView);
    } else if (cls) {
      lineView.text.className = cls;
    }
  }

  function updateLineClasses(cm, lineView) {
    updateLineBackground(cm, lineView);
    if (lineView.line.wrapClass)
      { ensureLineWrapped(lineView).className = lineView.line.wrapClass; }
    else if (lineView.node != lineView.text)
      { lineView.node.className = ""; }
    var textClass = lineView.textClass ? lineView.textClass + " " + (lineView.line.textClass || "") : lineView.line.textClass;
    lineView.text.className = textClass || "";
  }

  function updateLineGutter(cm, lineView, lineN, dims) {
    if (lineView.gutter) {
      lineView.node.removeChild(lineView.gutter);
      lineView.gutter = null;
    }
    if (lineView.gutterBackground) {
      lineView.node.removeChild(lineView.gutterBackground);
      lineView.gutterBackground = null;
    }
    if (lineView.line.gutterClass) {
      var wrap = ensureLineWrapped(lineView);
      lineView.gutterBackground = elt("div", null, "CodeMirror-gutter-background " + lineView.line.gutterClass,
                                      ("left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px; width: " + (dims.gutterTotalWidth) + "px"));
      cm.display.input.setUneditable(lineView.gutterBackground);
      wrap.insertBefore(lineView.gutterBackground, lineView.text);
    }
    var markers = lineView.line.gutterMarkers;
    if (cm.options.lineNumbers || markers) {
      var wrap$1 = ensureLineWrapped(lineView);
      var gutterWrap = lineView.gutter = elt("div", null, "CodeMirror-gutter-wrapper", ("left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px"));
      cm.display.input.setUneditable(gutterWrap);
      wrap$1.insertBefore(gutterWrap, lineView.text);
      if (lineView.line.gutterClass)
        { gutterWrap.className += " " + lineView.line.gutterClass; }
      if (cm.options.lineNumbers && (!markers || !markers["CodeMirror-linenumbers"]))
        { lineView.lineNumber = gutterWrap.appendChild(
          elt("div", lineNumberFor(cm.options, lineN),
              "CodeMirror-linenumber CodeMirror-gutter-elt",
              ("left: " + (dims.gutterLeft["CodeMirror-linenumbers"]) + "px; width: " + (cm.display.lineNumInnerWidth) + "px"))); }
      if (markers) { for (var k = 0; k < cm.display.gutterSpecs.length; ++k) {
        var id = cm.display.gutterSpecs[k].className, found = markers.hasOwnProperty(id) && markers[id];
        if (found)
          { gutterWrap.appendChild(elt("div", [found], "CodeMirror-gutter-elt",
                                     ("left: " + (dims.gutterLeft[id]) + "px; width: " + (dims.gutterWidth[id]) + "px"))); }
      } }
    }
  }

  function updateLineWidgets(cm, lineView, dims) {
    if (lineView.alignable) { lineView.alignable = null; }
    var isWidget = classTest("CodeMirror-linewidget");
    for (var node = lineView.node.firstChild, next = (void 0); node; node = next) {
      next = node.nextSibling;
      if (isWidget.test(node.className)) { lineView.node.removeChild(node); }
    }
    insertLineWidgets(cm, lineView, dims);
  }

  // Build a line's DOM representation from scratch
  function buildLineElement(cm, lineView, lineN, dims) {
    var built = getLineContent(cm, lineView);
    lineView.text = lineView.node = built.pre;
    if (built.bgClass) { lineView.bgClass = built.bgClass; }
    if (built.textClass) { lineView.textClass = built.textClass; }

    updateLineClasses(cm, lineView);
    updateLineGutter(cm, lineView, lineN, dims);
    insertLineWidgets(cm, lineView, dims);
    return lineView.node
  }

  // A lineView may contain multiple logical lines (when merged by
  // collapsed spans). The widgets for all of them need to be drawn.
  function insertLineWidgets(cm, lineView, dims) {
    insertLineWidgetsFor(cm, lineView.line, lineView, dims, true);
    if (lineView.rest) { for (var i = 0; i < lineView.rest.length; i++)
      { insertLineWidgetsFor(cm, lineView.rest[i], lineView, dims, false); } }
  }

  function insertLineWidgetsFor(cm, line, lineView, dims, allowAbove) {
    if (!line.widgets) { return }
    var wrap = ensureLineWrapped(lineView);
    for (var i = 0, ws = line.widgets; i < ws.length; ++i) {
      var widget = ws[i], node = elt("div", [widget.node], "CodeMirror-linewidget" + (widget.className ? " " + widget.className : ""));
      if (!widget.handleMouseEvents) { node.setAttribute("cm-ignore-events", "true"); }
      positionLineWidget(widget, node, lineView, dims);
      cm.display.input.setUneditable(node);
      if (allowAbove && widget.above)
        { wrap.insertBefore(node, lineView.gutter || lineView.text); }
      else
        { wrap.appendChild(node); }
      signalLater(widget, "redraw");
    }
  }

  function positionLineWidget(widget, node, lineView, dims) {
    if (widget.noHScroll) {
  (lineView.alignable || (lineView.alignable = [])).push(node);
      var width = dims.wrapperWidth;
      node.style.left = dims.fixedPos + "px";
      if (!widget.coverGutter) {
        width -= dims.gutterTotalWidth;
        node.style.paddingLeft = dims.gutterTotalWidth + "px";
      }
      node.style.width = width + "px";
    }
    if (widget.coverGutter) {
      node.style.zIndex = 5;
      node.style.position = "relative";
      if (!widget.noHScroll) { node.style.marginLeft = -dims.gutterTotalWidth + "px"; }
    }
  }

  function widgetHeight(widget) {
    if (widget.height != null) { return widget.height }
    var cm = widget.doc.cm;
    if (!cm) { return 0 }
    if (!contains(document.body, widget.node)) {
      var parentStyle = "position: relative;";
      if (widget.coverGutter)
        { parentStyle += "margin-left: -" + cm.display.gutters.offsetWidth + "px;"; }
      if (widget.noHScroll)
        { parentStyle += "width: " + cm.display.wrapper.clientWidth + "px;"; }
      removeChildrenAndAdd(cm.display.measure, elt("div", [widget.node], null, parentStyle));
    }
    return widget.height = widget.node.parentNode.offsetHeight
  }

  // Return true when the given mouse event happened in a widget
  function eventInWidget(display, e) {
    for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {
      if (!n || (n.nodeType == 1 && n.getAttribute("cm-ignore-events") == "true") ||
          (n.parentNode == display.sizer && n != display.mover))
        { return true }
    }
  }

  // POSITION MEASUREMENT

  function paddingTop(display) {return display.lineSpace.offsetTop}
  function paddingVert(display) {return display.mover.offsetHeight - display.lineSpace.offsetHeight}
  function paddingH(display) {
    if (display.cachedPaddingH) { return display.cachedPaddingH }
    var e = removeChildrenAndAdd(display.measure, elt("pre", "x", "CodeMirror-line-like"));
    var style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle;
    var data = {left: parseInt(style.paddingLeft), right: parseInt(style.paddingRight)};
    if (!isNaN(data.left) && !isNaN(data.right)) { display.cachedPaddingH = data; }
    return data
  }

  function scrollGap(cm) { return scrollerGap - cm.display.nativeBarWidth }
  function displayWidth(cm) {
    return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth
  }
  function displayHeight(cm) {
    return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight
  }

  // Ensure the lineView.wrapping.heights array is populated. This is
  // an array of bottom offsets for the lines that make up a drawn
  // line. When lineWrapping is on, there might be more than one
  // height.
  function ensureLineHeights(cm, lineView, rect) {
    var wrapping = cm.options.lineWrapping;
    var curWidth = wrapping && displayWidth(cm);
    if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {
      var heights = lineView.measure.heights = [];
      if (wrapping) {
        lineView.measure.width = curWidth;
        var rects = lineView.text.firstChild.getClientRects();
        for (var i = 0; i < rects.length - 1; i++) {
          var cur = rects[i], next = rects[i + 1];
          if (Math.abs(cur.bottom - next.bottom) > 2)
            { heights.push((cur.bottom + next.top) / 2 - rect.top); }
        }
      }
      heights.push(rect.bottom - rect.top);
    }
  }

  // Find a line map (mapping character offsets to text nodes) and a
  // measurement cache for the given line number. (A line view might
  // contain multiple lines when collapsed ranges are present.)
  function mapFromLineView(lineView, line, lineN) {
    if (lineView.line == line)
      { return {map: lineView.measure.map, cache: lineView.measure.cache} }
    for (var i = 0; i < lineView.rest.length; i++)
      { if (lineView.rest[i] == line)
        { return {map: lineView.measure.maps[i], cache: lineView.measure.caches[i]} } }
    for (var i$1 = 0; i$1 < lineView.rest.length; i$1++)
      { if (lineNo(lineView.rest[i$1]) > lineN)
        { return {map: lineView.measure.maps[i$1], cache: lineView.measure.caches[i$1], before: true} } }
  }

  // Render a line into the hidden node display.externalMeasured. Used
  // when measurement is needed for a line that's not in the viewport.
  function updateExternalMeasurement(cm, line) {
    line = visualLine(line);
    var lineN = lineNo(line);
    var view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN);
    view.lineN = lineN;
    var built = view.built = buildLineContent(cm, view);
    view.text = built.pre;
    removeChildrenAndAdd(cm.display.lineMeasure, built.pre);
    return view
  }

  // Get a {top, bottom, left, right} box (in line-local coordinates)
  // for a given character.
  function measureChar(cm, line, ch, bias) {
    return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias)
  }

  // Find a line view that corresponds to the given line number.
  function findViewForLine(cm, lineN) {
    if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo)
      { return cm.display.view[findViewIndex(cm, lineN)] }
    var ext = cm.display.externalMeasured;
    if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size)
      { return ext }
  }

  // Measurement can be split in two steps, the set-up work that
  // applies to the whole line, and the measurement of the actual
  // character. Functions like coordsChar, that need to do a lot of
  // measurements in a row, can thus ensure that the set-up work is
  // only done once.
  function prepareMeasureForLine(cm, line) {
    var lineN = lineNo(line);
    var view = findViewForLine(cm, lineN);
    if (view && !view.text) {
      view = null;
    } else if (view && view.changes) {
      updateLineForChanges(cm, view, lineN, getDimensions(cm));
      cm.curOp.forceUpdate = true;
    }
    if (!view)
      { view = updateExternalMeasurement(cm, line); }

    var info = mapFromLineView(view, line, lineN);
    return {
      line: line, view: view, rect: null,
      map: info.map, cache: info.cache, before: info.before,
      hasHeights: false
    }
  }

  // Given a prepared measurement object, measures the position of an
  // actual character (or fetches it from the cache).
  function measureCharPrepared(cm, prepared, ch, bias, varHeight) {
    if (prepared.before) { ch = -1; }
    var key = ch + (bias || ""), found;
    if (prepared.cache.hasOwnProperty(key)) {
      found = prepared.cache[key];
    } else {
      if (!prepared.rect)
        { prepared.rect = prepared.view.text.getBoundingClientRect(); }
      if (!prepared.hasHeights) {
        ensureLineHeights(cm, prepared.view, prepared.rect);
        prepared.hasHeights = true;
      }
      found = measureCharInner(cm, prepared, ch, bias);
      if (!found.bogus) { prepared.cache[key] = found; }
    }
    return {left: found.left, right: found.right,
            top: varHeight ? found.rtop : found.top,
            bottom: varHeight ? found.rbottom : found.bottom}
  }

  var nullRect = {left: 0, right: 0, top: 0, bottom: 0};

  function nodeAndOffsetInLineMap(map, ch, bias) {
    var node, start, end, collapse, mStart, mEnd;
    // First, search the line map for the text node corresponding to,
    // or closest to, the target character.
    for (var i = 0; i < map.length; i += 3) {
      mStart = map[i];
      mEnd = map[i + 1];
      if (ch < mStart) {
        start = 0; end = 1;
        collapse = "left";
      } else if (ch < mEnd) {
        start = ch - mStart;
        end = start + 1;
      } else if (i == map.length - 3 || ch == mEnd && map[i + 3] > ch) {
        end = mEnd - mStart;
        start = end - 1;
        if (ch >= mEnd) { collapse = "right"; }
      }
      if (start != null) {
        node = map[i + 2];
        if (mStart == mEnd && bias == (node.insertLeft ? "left" : "right"))
          { collapse = bias; }
        if (bias == "left" && start == 0)
          { while (i && map[i - 2] == map[i - 3] && map[i - 1].insertLeft) {
            node = map[(i -= 3) + 2];
            collapse = "left";
          } }
        if (bias == "right" && start == mEnd - mStart)
          { while (i < map.length - 3 && map[i + 3] == map[i + 4] && !map[i + 5].insertLeft) {
            node = map[(i += 3) + 2];
            collapse = "right";
          } }
        break
      }
    }
    return {node: node, start: start, end: end, collapse: collapse, coverStart: mStart, coverEnd: mEnd}
  }

  function getUsefulRect(rects, bias) {
    var rect = nullRect;
    if (bias == "left") { for (var i = 0; i < rects.length; i++) {
      if ((rect = rects[i]).left != rect.right) { break }
    } } else { for (var i$1 = rects.length - 1; i$1 >= 0; i$1--) {
      if ((rect = rects[i$1]).left != rect.right) { break }
    } }
    return rect
  }

  function measureCharInner(cm, prepared, ch, bias) {
    var place = nodeAndOffsetInLineMap(prepared.map, ch, bias);
    var node = place.node, start = place.start, end = place.end, collapse = place.collapse;

    var rect;
    if (node.nodeType == 3) { // If it is a text node, use a range to retrieve the coordinates.
      for (var i$1 = 0; i$1 < 4; i$1++) { // Retry a maximum of 4 times when nonsense rectangles are returned
        while (start && isExtendingChar(prepared.line.text.charAt(place.coverStart + start))) { --start; }
        while (place.coverStart + end < place.coverEnd && isExtendingChar(prepared.line.text.charAt(place.coverStart + end))) { ++end; }
        if (ie && ie_version < 9 && start == 0 && end == place.coverEnd - place.coverStart)
          { rect = node.parentNode.getBoundingClientRect(); }
        else
          { rect = getUsefulRect(range(node, start, end).getClientRects(), bias); }
        if (rect.left || rect.right || start == 0) { break }
        end = start;
        start = start - 1;
        collapse = "right";
      }
      if (ie && ie_version < 11) { rect = maybeUpdateRectForZooming(cm.display.measure, rect); }
    } else { // If it is a widget, simply get the box for the whole widget.
      if (start > 0) { collapse = bias = "right"; }
      var rects;
      if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1)
        { rect = rects[bias == "right" ? rects.length - 1 : 0]; }
      else
        { rect = node.getBoundingClientRect(); }
    }
    if (ie && ie_version < 9 && !start && (!rect || !rect.left && !rect.right)) {
      var rSpan = node.parentNode.getClientRects()[0];
      if (rSpan)
        { rect = {left: rSpan.left, right: rSpan.left + charWidth(cm.display), top: rSpan.top, bottom: rSpan.bottom}; }
      else
        { rect = nullRect; }
    }

    var rtop = rect.top - prepared.rect.top, rbot = rect.bottom - prepared.rect.top;
    var mid = (rtop + rbot) / 2;
    var heights = prepared.view.measure.heights;
    var i = 0;
    for (; i < heights.length - 1; i++)
      { if (mid < heights[i]) { break } }
    var top = i ? heights[i - 1] : 0, bot = heights[i];
    var result = {left: (collapse == "right" ? rect.right : rect.left) - prepared.rect.left,
                  right: (collapse == "left" ? rect.left : rect.right) - prepared.rect.left,
                  top: top, bottom: bot};
    if (!rect.left && !rect.right) { result.bogus = true; }
    if (!cm.options.singleCursorHeightPerLine) { result.rtop = rtop; result.rbottom = rbot; }

    return result
  }

  // Work around problem with bounding client rects on ranges being
  // returned incorrectly when zoomed on IE10 and below.
  function maybeUpdateRectForZooming(measure, rect) {
    if (!window.screen || screen.logicalXDPI == null ||
        screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure))
      { return rect }
    var scaleX = screen.logicalXDPI / screen.deviceXDPI;
    var scaleY = screen.logicalYDPI / screen.deviceYDPI;
    return {left: rect.left * scaleX, right: rect.right * scaleX,
            top: rect.top * scaleY, bottom: rect.bottom * scaleY}
  }

  function clearLineMeasurementCacheFor(lineView) {
    if (lineView.measure) {
      lineView.measure.cache = {};
      lineView.measure.heights = null;
      if (lineView.rest) { for (var i = 0; i < lineView.rest.length; i++)
        { lineView.measure.caches[i] = {}; } }
    }
  }

  function clearLineMeasurementCache(cm) {
    cm.display.externalMeasure = null;
    removeChildren(cm.display.lineMeasure);
    for (var i = 0; i < cm.display.view.length; i++)
      { clearLineMeasurementCacheFor(cm.display.view[i]); }
  }

  function clearCaches(cm) {
    clearLineMeasurementCache(cm);
    cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;
    if (!cm.options.lineWrapping) { cm.display.maxLineChanged = true; }
    cm.display.lineNumChars = null;
  }

  function pageScrollX() {
    // Work around https://bugs.chromium.org/p/chromium/issues/detail?id=489206
    // which causes page_Offset and bounding client rects to use
    // different reference viewports and invalidate our calculations.
    if (chrome && android) { return -(document.body.getBoundingClientRect().left - parseInt(getComputedStyle(document.body).marginLeft)) }
    return window.pageXOffset || (document.documentElement || document.body).scrollLeft
  }
  function pageScrollY() {
    if (chrome && android) { return -(document.body.getBoundingClientRect().top - parseInt(getComputedStyle(document.body).marginTop)) }
    return window.pageYOffset || (document.documentElement || document.body).scrollTop
  }

  function widgetTopHeight(lineObj) {
    var height = 0;
    if (lineObj.widgets) { for (var i = 0; i < lineObj.widgets.length; ++i) { if (lineObj.widgets[i].above)
      { height += widgetHeight(lineObj.widgets[i]); } } }
    return height
  }

  // Converts a {top, bottom, left, right} box from line-local
  // coordinates into another coordinate system. Context may be one of
  // "line", "div" (display.lineDiv), "local"./null (editor), "window",
  // or "page".
  function intoCoordSystem(cm, lineObj, rect, context, includeWidgets) {
    if (!includeWidgets) {
      var height = widgetTopHeight(lineObj);
      rect.top += height; rect.bottom += height;
    }
    if (context == "line") { return rect }
    if (!context) { context = "local"; }
    var yOff = heightAtLine(lineObj);
    if (context == "local") { yOff += paddingTop(cm.display); }
    else { yOff -= cm.display.viewOffset; }
    if (context == "page" || context == "window") {
      var lOff = cm.display.lineSpace.getBoundingClientRect();
      yOff += lOff.top + (context == "window" ? 0 : pageScrollY());
      var xOff = lOff.left + (context == "window" ? 0 : pageScrollX());
      rect.left += xOff; rect.right += xOff;
    }
    rect.top += yOff; rect.bottom += yOff;
    return rect
  }

  // Coverts a box from "div" coords to another coordinate system.
  // Context may be "window", "page", "div", or "local"./null.
  function fromCoordSystem(cm, coords, context) {
    if (context == "div") { return coords }
    var left = coords.left, top = coords.top;
    // First move into "page" coordinate system
    if (context == "page") {
      left -= pageScrollX();
      top -= pageScrollY();
    } else if (context == "local" || !context) {
      var localBox = cm.display.sizer.getBoundingClientRect();
      left += localBox.left;
      top += localBox.top;
    }

    var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();
    return {left: left - lineSpaceBox.left, top: top - lineSpaceBox.top}
  }

  function charCoords(cm, pos, context, lineObj, bias) {
    if (!lineObj) { lineObj = getLine(cm.doc, pos.line); }
    return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context)
  }

  // Returns a box for a given cursor position, which may have an
  // 'other' property containing the position of the secondary cursor
  // on a bidi boundary.
  // A cursor Pos(line, char, "before") is on the same visual line as `char - 1`
  // and after `char - 1` in writing order of `char - 1`
  // A cursor Pos(line, char, "after") is on the same visual line as `char`
  // and before `char` in writing order of `char`
  // Examples (upper-case letters are RTL, lower-case are LTR):
  //     Pos(0, 1, ...)
  //     before   after
  // ab     a|b     a|b
  // aB     a|B     aB|
  // Ab     |Ab     A|b
  // AB     B|A     B|A
  // Every position after the last character on a line is considered to stick
  // to the last character on the line.
  function cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {
    lineObj = lineObj || getLine(cm.doc, pos.line);
    if (!preparedMeasure) { preparedMeasure = prepareMeasureForLine(cm, lineObj); }
    function get(ch, right) {
      var m = measureCharPrepared(cm, preparedMeasure, ch, right ? "right" : "left", varHeight);
      if (right) { m.left = m.right; } else { m.right = m.left; }
      return intoCoordSystem(cm, lineObj, m, context)
    }
    var order = getOrder(lineObj, cm.doc.direction), ch = pos.ch, sticky = pos.sticky;
    if (ch >= lineObj.text.length) {
      ch = lineObj.text.length;
      sticky = "before";
    } else if (ch <= 0) {
      ch = 0;
      sticky = "after";
    }
    if (!order) { return get(sticky == "before" ? ch - 1 : ch, sticky == "before") }

    function getBidi(ch, partPos, invert) {
      var part = order[partPos], right = part.level == 1;
      return get(invert ? ch - 1 : ch, right != invert)
    }
    var partPos = getBidiPartAt(order, ch, sticky);
    var other = bidiOther;
    var val = getBidi(ch, partPos, sticky == "before");
    if (other != null) { val.other = getBidi(ch, other, sticky != "before"); }
    return val
  }

  // Used to cheaply estimate the coordinates for a position. Used for
  // intermediate scroll updates.
  function estimateCoords(cm, pos) {
    var left = 0;
    pos = clipPos(cm.doc, pos);
    if (!cm.options.lineWrapping) { left = charWidth(cm.display) * pos.ch; }
    var lineObj = getLine(cm.doc, pos.line);
    var top = heightAtLine(lineObj) + paddingTop(cm.display);
    return {left: left, right: left, top: top, bottom: top + lineObj.height}
  }

  // Positions returned by coordsChar contain some extra information.
  // xRel is the relative x position of the input coordinates compared
  // to the found position (so xRel > 0 means the coordinates are to
  // the right of the character position, for example). When outside
  // is true, that means the coordinates lie outside the line's
  // vertical range.
  function PosWithInfo(line, ch, sticky, outside, xRel) {
    var pos = Pos(line, ch, sticky);
    pos.xRel = xRel;
    if (outside) { pos.outside = outside; }
    return pos
  }

  // Compute the character position closest to the given coordinates.
  // Input must be lineSpace-local ("div" coordinate system).
  function coordsChar(cm, x, y) {
    var doc = cm.doc;
    y += cm.display.viewOffset;
    if (y < 0) { return PosWithInfo(doc.first, 0, null, -1, -1) }
    var lineN = lineAtHeight(doc, y), last = doc.first + doc.size - 1;
    if (lineN > last)
      { return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, null, 1, 1) }
    if (x < 0) { x = 0; }

    var lineObj = getLine(doc, lineN);
    for (;;) {
      var found = coordsCharInner(cm, lineObj, lineN, x, y);
      var collapsed = collapsedSpanAround(lineObj, found.ch + (found.xRel > 0 || found.outside > 0 ? 1 : 0));
      if (!collapsed) { return found }
      var rangeEnd = collapsed.find(1);
      if (rangeEnd.line == lineN) { return rangeEnd }
      lineObj = getLine(doc, lineN = rangeEnd.line);
    }
  }

  function wrappedLineExtent(cm, lineObj, preparedMeasure, y) {
    y -= widgetTopHeight(lineObj);
    var end = lineObj.text.length;
    var begin = findFirst(function (ch) { return measureCharPrepared(cm, preparedMeasure, ch - 1).bottom <= y; }, end, 0);
    end = findFirst(function (ch) { return measureCharPrepared(cm, preparedMeasure, ch).top > y; }, begin, end);
    return {begin: begin, end: end}
  }

  function wrappedLineExtentChar(cm, lineObj, preparedMeasure, target) {
    if (!preparedMeasure) { preparedMeasure = prepareMeasureForLine(cm, lineObj); }
    var targetTop = intoCoordSystem(cm, lineObj, measureCharPrepared(cm, preparedMeasure, target), "line").top;
    return wrappedLineExtent(cm, lineObj, preparedMeasure, targetTop)
  }

  // Returns true if the given side of a box is after the given
  // coordinates, in top-to-bottom, left-to-right order.
  function boxIsAfter(box, x, y, left) {
    return box.bottom <= y ? false : box.top > y ? true : (left ? box.left : box.right) > x
  }

  function coordsCharInner(cm, lineObj, lineNo, x, y) {
    // Move y into line-local coordinate space
    y -= heightAtLine(lineObj);
    var preparedMeasure = prepareMeasureForLine(cm, lineObj);
    // When directly calling `measureCharPrepared`, we have to adjust
    // for the widgets at this line.
    var widgetHeight = widgetTopHeight(lineObj);
    var begin = 0, end = lineObj.text.length, ltr = true;

    var order = getOrder(lineObj, cm.doc.direction);
    // If the line isn't plain left-to-right text, first figure out
    // which bidi section the coordinates fall into.
    if (order) {
      var part = (cm.options.lineWrapping ? coordsBidiPartWrapped : coordsBidiPart)
                   (cm, lineObj, lineNo, preparedMeasure, order, x, y);
      ltr = part.level != 1;
      // The awkward -1 offsets are needed because findFirst (called
      // on these below) will treat its first bound as inclusive,
      // second as exclusive, but we want to actually address the
      // characters in the part's range
      begin = ltr ? part.from : part.to - 1;
      end = ltr ? part.to : part.from - 1;
    }

    // A binary search to find the first character whose bounding box
    // starts after the coordinates. If we run across any whose box wrap
    // the coordinates, store that.
    var chAround = null, boxAround = null;
    var ch = findFirst(function (ch) {
      var box = measureCharPrepared(cm, preparedMeasure, ch);
      box.top += widgetHeight; box.bottom += widgetHeight;
      if (!boxIsAfter(box, x, y, false)) { return false }
      if (box.top <= y && box.left <= x) {
        chAround = ch;
        boxAround = box;
      }
      return true
    }, begin, end);

    var baseX, sticky, outside = false;
    // If a box around the coordinates was found, use that
    if (boxAround) {
      // Distinguish coordinates nearer to the left or right side of the box
      var atLeft = x - boxAround.left < boxAround.right - x, atStart = atLeft == ltr;
      ch = chAround + (atStart ? 0 : 1);
      sticky = atStart ? "after" : "before";
      baseX = atLeft ? boxAround.left : boxAround.right;
    } else {
      // (Adjust for extended bound, if necessary.)
      if (!ltr && (ch == end || ch == begin)) { ch++; }
      // To determine which side to associate with, get the box to the
      // left of the character and compare it's vertical position to the
      // coordinates
      sticky = ch == 0 ? "after" : ch == lineObj.text.length ? "before" :
        (measureCharPrepared(cm, preparedMeasure, ch - (ltr ? 1 : 0)).bottom + widgetHeight <= y) == ltr ?
        "after" : "before";
      // Now get accurate coordinates for this place, in order to get a
      // base X position
      var coords = cursorCoords(cm, Pos(lineNo, ch, sticky), "line", lineObj, preparedMeasure);
      baseX = coords.left;
      outside = y < coords.top ? -1 : y >= coords.bottom ? 1 : 0;
    }

    ch = skipExtendingChars(lineObj.text, ch, 1);
    return PosWithInfo(lineNo, ch, sticky, outside, x - baseX)
  }

  function coordsBidiPart(cm, lineObj, lineNo, preparedMeasure, order, x, y) {
    // Bidi parts are sorted left-to-right, and in a non-line-wrapping
    // situation, we can take this ordering to correspond to the visual
    // ordering. This finds the first part whose end is after the given
    // coordinates.
    var index = findFirst(function (i) {
      var part = order[i], ltr = part.level != 1;
      return boxIsAfter(cursorCoords(cm, Pos(lineNo, ltr ? part.to : part.from, ltr ? "before" : "after"),
                                     "line", lineObj, preparedMeasure), x, y, true)
    }, 0, order.length - 1);
    var part = order[index];
    // If this isn't the first part, the part's start is also after
    // the coordinates, and the coordinates aren't on the same line as
    // that start, move one part back.
    if (index > 0) {
      var ltr = part.level != 1;
      var start = cursorCoords(cm, Pos(lineNo, ltr ? part.from : part.to, ltr ? "after" : "before"),
                               "line", lineObj, preparedMeasure);
      if (boxIsAfter(start, x, y, true) && start.top > y)
        { part = order[index - 1]; }
    }
    return part
  }

  function coordsBidiPartWrapped(cm, lineObj, _lineNo, preparedMeasure, order, x, y) {
    // In a wrapped line, rtl text on wrapping boundaries can do things
    // that don't correspond to the ordering in our `order` array at
    // all, so a binary search doesn't work, and we want to return a
    // part that only spans one line so that the binary search in
    // coordsCharInner is safe. As such, we first find the extent of the
    // wrapped line, and then do a flat search in which we discard any
    // spans that aren't on the line.
    var ref = wrappedLineExtent(cm, lineObj, preparedMeasure, y);
    var begin = ref.begin;
    var end = ref.end;
    if (/\s/.test(lineObj.text.charAt(end - 1))) { end--; }
    var part = null, closestDist = null;
    for (var i = 0; i < order.length; i++) {
      var p = order[i];
      if (p.from >= end || p.to <= begin) { continue }
      var ltr = p.level != 1;
      var endX = measureCharPrepared(cm, preparedMeasure, ltr ? Math.min(end, p.to) - 1 : Math.max(begin, p.from)).right;
      // Weigh against spans ending before this, so that they are only
      // picked if nothing ends after
      var dist = endX < x ? x - endX + 1e9 : endX - x;
      if (!part || closestDist > dist) {
        part = p;
        closestDist = dist;
      }
    }
    if (!part) { part = order[order.length - 1]; }
    // Clip the part to the wrapped line.
    if (part.from < begin) { part = {from: begin, to: part.to, level: part.level}; }
    if (part.to > end) { part = {from: part.from, to: end, level: part.level}; }
    return part
  }

  var measureText;
  // Compute the default text height.
  function textHeight(display) {
    if (display.cachedTextHeight != null) { return display.cachedTextHeight }
    if (measureText == null) {
      measureText = elt("pre", null, "CodeMirror-line-like");
      // Measure a bunch of lines, for browsers that compute
      // fractional heights.
      for (var i = 0; i < 49; ++i) {
        measureText.appendChild(document.createTextNode("x"));
        measureText.appendChild(elt("br"));
      }
      measureText.appendChild(document.createTextNode("x"));
    }
    removeChildrenAndAdd(display.measure, measureText);
    var height = measureText.offsetHeight / 50;
    if (height > 3) { display.cachedTextHeight = height; }
    removeChildren(display.measure);
    return height || 1
  }

  // Compute the default character width.
  function charWidth(display) {
    if (display.cachedCharWidth != null) { return display.cachedCharWidth }
    var anchor = elt("span", "xxxxxxxxxx");
    var pre = elt("pre", [anchor], "CodeMirror-line-like");
    removeChildrenAndAdd(display.measure, pre);
    var rect = anchor.getBoundingClientRect(), width = (rect.right - rect.left) / 10;
    if (width > 2) { display.cachedCharWidth = width; }
    return width || 10
  }

  // Do a bulk-read of the DOM positions and sizes needed to draw the
  // view, so that we don't interleave reading and writing to the DOM.
  function getDimensions(cm) {
    var d = cm.display, left = {}, width = {};
    var gutterLeft = d.gutters.clientLeft;
    for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {
      var id = cm.display.gutterSpecs[i].className;
      left[id] = n.offsetLeft + n.clientLeft + gutterLeft;
      width[id] = n.clientWidth;
    }
    return {fixedPos: compensateForHScroll(d),
            gutterTotalWidth: d.gutters.offsetWidth,
            gutterLeft: left,
            gutterWidth: width,
            wrapperWidth: d.wrapper.clientWidth}
  }

  // Computes display.scroller.scrollLeft + display.gutters.offsetWidth,
  // but using getBoundingClientRect to get a sub-pixel-accurate
  // result.
  function compensateForHScroll(display) {
    return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left
  }

  // Returns a function that estimates the height of a line, to use as
  // first approximation until the line becomes visible (and is thus
  // properly measurable).
  function estimateHeight(cm) {
    var th = textHeight(cm.display), wrapping = cm.options.lineWrapping;
    var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);
    return function (line) {
      if (lineIsHidden(cm.doc, line)) { return 0 }

      var widgetsHeight = 0;
      if (line.widgets) { for (var i = 0; i < line.widgets.length; i++) {
        if (line.widgets[i].height) { widgetsHeight += line.widgets[i].height; }
      } }

      if (wrapping)
        { return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th }
      else
        { return widgetsHeight + th }
    }
  }

  function estimateLineHeights(cm) {
    var doc = cm.doc, est = estimateHeight(cm);
    doc.iter(function (line) {
      var estHeight = est(line);
      if (estHeight != line.height) { updateLineHeight(line, estHeight); }
    });
  }

  // Given a mouse event, find the corresponding position. If liberal
  // is false, it checks whether a gutter or scrollbar was clicked,
  // and returns null if it was. forRect is used by rectangular
  // selections, and tries to estimate a character position even for
  // coordinates beyond the right of the text.
  function posFromMouse(cm, e, liberal, forRect) {
    var display = cm.display;
    if (!liberal && e_target(e).getAttribute("cm-not-content") == "true") { return null }

    var x, y, space = display.lineSpace.getBoundingClientRect();
    // Fails unpredictably on IE[67] when mouse is dragged around quickly.
    try { x = e.clientX - space.left; y = e.clientY - space.top; }
    catch (e$1) { return null }
    var coords = coordsChar(cm, x, y), line;
    if (forRect && coords.xRel > 0 && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {
      var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;
      coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));
    }
    return coords
  }

  // Find the view element corresponding to a given line. Return null
  // when the line isn't visible.
  function findViewIndex(cm, n) {
    if (n >= cm.display.viewTo) { return null }
    n -= cm.display.viewFrom;
    if (n < 0) { return null }
    var view = cm.display.view;
    for (var i = 0; i < view.length; i++) {
      n -= view[i].size;
      if (n < 0) { return i }
    }
  }

  // Updates the display.view data structure for a given change to the
  // document. From and to are in pre-change coordinates. Lendiff is
  // the amount of lines added or subtracted by the change. This is
  // used for changes that span multiple lines, or change the way
  // lines are divided into visual lines. regLineChange (below)
  // registers single-line changes.
  function regChange(cm, from, to, lendiff) {
    if (from == null) { from = cm.doc.first; }
    if (to == null) { to = cm.doc.first + cm.doc.size; }
    if (!lendiff) { lendiff = 0; }

    var display = cm.display;
    if (lendiff && to < display.viewTo &&
        (display.updateLineNumbers == null || display.updateLineNumbers > from))
      { display.updateLineNumbers = from; }

    cm.curOp.viewChanged = true;

    if (from >= display.viewTo) { // Change after
      if (sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo)
        { resetView(cm); }
    } else if (to <= display.viewFrom) { // Change before
      if (sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom) {
        resetView(cm);
      } else {
        display.viewFrom += lendiff;
        display.viewTo += lendiff;
      }
    } else if (from <= display.viewFrom && to >= display.viewTo) { // Full overlap
      resetView(cm);
    } else if (from <= display.viewFrom) { // Top overlap
      var cut = viewCuttingPoint(cm, to, to + lendiff, 1);
      if (cut) {
        display.view = display.view.slice(cut.index);
        display.viewFrom = cut.lineN;
        display.viewTo += lendiff;
      } else {
        resetView(cm);
      }
    } else if (to >= display.viewTo) { // Bottom overlap
      var cut$1 = viewCuttingPoint(cm, from, from, -1);
      if (cut$1) {
        display.view = display.view.slice(0, cut$1.index);
        display.viewTo = cut$1.lineN;
      } else {
        resetView(cm);
      }
    } else { // Gap in the middle
      var cutTop = viewCuttingPoint(cm, from, from, -1);
      var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);
      if (cutTop && cutBot) {
        display.view = display.view.slice(0, cutTop.index)
          .concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN))
          .concat(display.view.slice(cutBot.index));
        display.viewTo += lendiff;
      } else {
        resetView(cm);
      }
    }

    var ext = display.externalMeasured;
    if (ext) {
      if (to < ext.lineN)
        { ext.lineN += lendiff; }
      else if (from < ext.lineN + ext.size)
        { display.externalMeasured = null; }
    }
  }

  // Register a change to a single line. Type must be one of "text",
  // "gutter", "class", "widget"
  function regLineChange(cm, line, type) {
    cm.curOp.viewChanged = true;
    var display = cm.display, ext = cm.display.externalMeasured;
    if (ext && line >= ext.lineN && line < ext.lineN + ext.size)
      { display.externalMeasured = null; }

    if (line < display.viewFrom || line >= display.viewTo) { return }
    var lineView = display.view[findViewIndex(cm, line)];
    if (lineView.node == null) { return }
    var arr = lineView.changes || (lineView.changes = []);
    if (indexOf(arr, type) == -1) { arr.push(type); }
  }

  // Clear the view.
  function resetView(cm) {
    cm.display.viewFrom = cm.display.viewTo = cm.doc.first;
    cm.display.view = [];
    cm.display.viewOffset = 0;
  }

  function viewCuttingPoint(cm, oldN, newN, dir) {
    var index = findViewIndex(cm, oldN), diff, view = cm.display.view;
    if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size)
      { return {index: index, lineN: newN} }
    var n = cm.display.viewFrom;
    for (var i = 0; i < index; i++)
      { n += view[i].size; }
    if (n != oldN) {
      if (dir > 0) {
        if (index == view.length - 1) { return null }
        diff = (n + view[index].size) - oldN;
        index++;
      } else {
        diff = n - oldN;
      }
      oldN += diff; newN += diff;
    }
    while (visualLineNo(cm.doc, newN) != newN) {
      if (index == (dir < 0 ? 0 : view.length - 1)) { return null }
      newN += dir * view[index - (dir < 0 ? 1 : 0)].size;
      index += dir;
    }
    return {index: index, lineN: newN}
  }

  // Force the view to cover a given range, adding empty view element
  // or clipping off existing ones as needed.
  function adjustView(cm, from, to) {
    var display = cm.display, view = display.view;
    if (view.length == 0 || from >= display.viewTo || to <= display.viewFrom) {
      display.view = buildViewArray(cm, from, to);
      display.viewFrom = from;
    } else {
      if (display.viewFrom > from)
        { display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view); }
      else if (display.viewFrom < from)
        { display.view = display.view.slice(findViewIndex(cm, from)); }
      display.viewFrom = from;
      if (display.viewTo < to)
        { display.view = display.view.concat(buildViewArray(cm, display.viewTo, to)); }
      else if (display.viewTo > to)
        { display.view = display.view.slice(0, findViewIndex(cm, to)); }
    }
    display.viewTo = to;
  }

  // Count the number of lines in the view whose DOM representation is
  // out of date (or nonexistent).
  function countDirtyView(cm) {
    var view = cm.display.view, dirty = 0;
    for (var i = 0; i < view.length; i++) {
      var lineView = view[i];
      if (!lineView.hidden && (!lineView.node || lineView.changes)) { ++dirty; }
    }
    return dirty
  }

  function updateSelection(cm) {
    cm.display.input.showSelection(cm.display.input.prepareSelection());
  }

  function prepareSelection(cm, primary) {
    if ( primary === void 0 ) primary = true;

    var doc = cm.doc, result = {};
    var curFragment = result.cursors = document.createDocumentFragment();
    var selFragment = result.selection = document.createDocumentFragment();

    for (var i = 0; i < doc.sel.ranges.length; i++) {
      if (!primary && i == doc.sel.primIndex) { continue }
      var range = doc.sel.ranges[i];
      if (range.from().line >= cm.display.viewTo || range.to().line < cm.display.viewFrom) { continue }
      var collapsed = range.empty();
      if (collapsed || cm.options.showCursorWhenSelecting)
        { drawSelectionCursor(cm, range.head, curFragment); }
      if (!collapsed)
        { drawSelectionRange(cm, range, selFragment); }
    }
    return result
  }

  // Draws a cursor for the given range
  function drawSelectionCursor(cm, head, output) {
    var pos = cursorCoords(cm, head, "div", null, null, !cm.options.singleCursorHeightPerLine);

    var cursor = output.appendChild(elt("div", "\u00a0", "CodeMirror-cursor"));
    cursor.style.left = pos.left + "px";
    cursor.style.top = pos.top + "px";
    cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + "px";

    if (pos.other) {
      // Secondary cursor, shown when on a 'jump' in bi-directional text
      var otherCursor = output.appendChild(elt("div", "\u00a0", "CodeMirror-cursor CodeMirror-secondarycursor"));
      otherCursor.style.display = "";
      otherCursor.style.left = pos.other.left + "px";
      otherCursor.style.top = pos.other.top + "px";
      otherCursor.style.height = (pos.other.bottom - pos.other.top) * .85 + "px";
    }
  }

  function cmpCoords(a, b) { return a.top - b.top || a.left - b.left }

  // Draws the given range as a highlighted selection
  function drawSelectionRange(cm, range, output) {
    var display = cm.display, doc = cm.doc;
    var fragment = document.createDocumentFragment();
    var padding = paddingH(cm.display), leftSide = padding.left;
    var rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right;
    var docLTR = doc.direction == "ltr";

    function add(left, top, width, bottom) {
      if (top < 0) { top = 0; }
      top = Math.round(top);
      bottom = Math.round(bottom);
      fragment.appendChild(elt("div", null, "CodeMirror-selected", ("position: absolute; left: " + left + "px;\n                             top: " + top + "px; width: " + (width == null ? rightSide - left : width) + "px;\n                             height: " + (bottom - top) + "px")));
    }

    function drawForLine(line, fromArg, toArg) {
      var lineObj = getLine(doc, line);
      var lineLen = lineObj.text.length;
      var start, end;
      function coords(ch, bias) {
        return charCoords(cm, Pos(line, ch), "div", lineObj, bias)
      }

      function wrapX(pos, dir, side) {
        var extent = wrappedLineExtentChar(cm, lineObj, null, pos);
        var prop = (dir == "ltr") == (side == "after") ? "left" : "right";
        var ch = side == "after" ? extent.begin : extent.end - (/\s/.test(lineObj.text.charAt(extent.end - 1)) ? 2 : 1);
        return coords(ch, prop)[prop]
      }

      var order = getOrder(lineObj, doc.direction);
      iterateBidiSections(order, fromArg || 0, toArg == null ? lineLen : toArg, function (from, to, dir, i) {
        var ltr = dir == "ltr";
        var fromPos = coords(from, ltr ? "left" : "right");
        var toPos = coords(to - 1, ltr ? "right" : "left");

        var openStart = fromArg == null && from == 0, openEnd = toArg == null && to == lineLen;
        var first = i == 0, last = !order || i == order.length - 1;
        if (toPos.top - fromPos.top <= 3) { // Single line
          var openLeft = (docLTR ? openStart : openEnd) && first;
          var openRight = (docLTR ? openEnd : openStart) && last;
          var left = openLeft ? leftSide : (ltr ? fromPos : toPos).left;
          var right = openRight ? rightSide : (ltr ? toPos : fromPos).right;
          add(left, fromPos.top, right - left, fromPos.bottom);
        } else { // Multiple lines
          var topLeft, topRight, botLeft, botRight;
          if (ltr) {
            topLeft = docLTR && openStart && first ? leftSide : fromPos.left;
            topRight = docLTR ? rightSide : wrapX(from, dir, "before");
            botLeft = docLTR ? leftSide : wrapX(to, dir, "after");
            botRight = docLTR && openEnd && last ? rightSide : toPos.right;
          } else {
            topLeft = !docLTR ? leftSide : wrapX(from, dir, "before");
            topRight = !docLTR && openStart && first ? rightSide : fromPos.right;
            botLeft = !docLTR && openEnd && last ? leftSide : toPos.left;
            botRight = !docLTR ? rightSide : wrapX(to, dir, "after");
          }
          add(topLeft, fromPos.top, topRight - topLeft, fromPos.bottom);
          if (fromPos.bottom < toPos.top) { add(leftSide, fromPos.bottom, null, toPos.top); }
          add(botLeft, toPos.top, botRight - botLeft, toPos.bottom);
        }

        if (!start || cmpCoords(fromPos, start) < 0) { start = fromPos; }
        if (cmpCoords(toPos, start) < 0) { start = toPos; }
        if (!end || cmpCoords(fromPos, end) < 0) { end = fromPos; }
        if (cmpCoords(toPos, end) < 0) { end = toPos; }
      });
      return {start: start, end: end}
    }

    var sFrom = range.from(), sTo = range.to();
    if (sFrom.line == sTo.line) {
      drawForLine(sFrom.line, sFrom.ch, sTo.ch);
    } else {
      var fromLine = getLine(doc, sFrom.line), toLine = getLine(doc, sTo.line);
      var singleVLine = visualLine(fromLine) == visualLine(toLine);
      var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end;
      var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;
      if (singleVLine) {
        if (leftEnd.top < rightStart.top - 2) {
          add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);
          add(leftSide, rightStart.top, rightStart.left, rightStart.bottom);
        } else {
          add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);
        }
      }
      if (leftEnd.bottom < rightStart.top)
        { add(leftSide, leftEnd.bottom, null, rightStart.top); }
    }

    output.appendChild(fragment);
  }

  // Cursor-blinking
  function restartBlink(cm) {
    if (!cm.state.focused) { return }
    var display = cm.display;
    clearInterval(display.blinker);
    var on = true;
    display.cursorDiv.style.visibility = "";
    if (cm.options.cursorBlinkRate > 0)
      { display.blinker = setInterval(function () {
        if (!cm.hasFocus()) { onBlur(cm); }
        display.cursorDiv.style.visibility = (on = !on) ? "" : "hidden";
      }, cm.options.cursorBlinkRate); }
    else if (cm.options.cursorBlinkRate < 0)
      { display.cursorDiv.style.visibility = "hidden"; }
  }

  function ensureFocus(cm) {
    if (!cm.state.focused) { cm.display.input.focus(); onFocus(cm); }
  }

  function delayBlurEvent(cm) {
    cm.state.delayingBlurEvent = true;
    setTimeout(function () { if (cm.state.delayingBlurEvent) {
      cm.state.delayingBlurEvent = false;
      onBlur(cm);
    } }, 100);
  }

  function onFocus(cm, e) {
    if (cm.state.delayingBlurEvent) { cm.state.delayingBlurEvent = false; }

    if (cm.options.readOnly == "nocursor") { return }
    if (!cm.state.focused) {
      signal(cm, "focus", cm, e);
      cm.state.focused = true;
      addClass(cm.display.wrapper, "CodeMirror-focused");
      // This test prevents this from firing when a context
      // menu is closed (since the input reset would kill the
      // select-all detection hack)
      if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel) {
        cm.display.input.reset();
        if (webkit) { setTimeout(function () { return cm.display.input.reset(true); }, 20); } // Issue #1730
      }
      cm.display.input.receivedFocus();
    }
    restartBlink(cm);
  }
  function onBlur(cm, e) {
    if (cm.state.delayingBlurEvent) { return }

    if (cm.state.focused) {
      signal(cm, "blur", cm, e);
      cm.state.focused = false;
      rmClass(cm.display.wrapper, "CodeMirror-focused");
    }
    clearInterval(cm.display.blinker);
    setTimeout(function () { if (!cm.state.focused) { cm.display.shift = false; } }, 150);
  }

  // Read the actual heights of the rendered lines, and update their
  // stored heights to match.
  function updateHeightsInViewport(cm) {
    var display = cm.display;
    var prevBottom = display.lineDiv.offsetTop;
    for (var i = 0; i < display.view.length; i++) {
      var cur = display.view[i], wrapping = cm.options.lineWrapping;
      var height = (void 0), width = 0;
      if (cur.hidden) { continue }
      if (ie && ie_version < 8) {
        var bot = cur.node.offsetTop + cur.node.offsetHeight;
        height = bot - prevBottom;
        prevBottom = bot;
      } else {
        var box = cur.node.getBoundingClientRect();
        height = box.bottom - box.top;
        // Check that lines don't extend past the right of the current
        // editor width
        if (!wrapping && cur.text.firstChild)
          { width = cur.text.firstChild.getBoundingClientRect().right - box.left - 1; }
      }
      var diff = cur.line.height - height;
      if (diff > .005 || diff < -.005) {
        updateLineHeight(cur.line, height);
        updateWidgetHeight(cur.line);
        if (cur.rest) { for (var j = 0; j < cur.rest.length; j++)
          { updateWidgetHeight(cur.rest[j]); } }
      }
      if (width > cm.display.sizerWidth) {
        var chWidth = Math.ceil(width / charWidth(cm.display));
        if (chWidth > cm.display.maxLineLength) {
          cm.display.maxLineLength = chWidth;
          cm.display.maxLine = cur.line;
          cm.display.maxLineChanged = true;
        }
      }
    }
  }

  // Read and store the height of line widgets associated with the
  // given line.
  function updateWidgetHeight(line) {
    if (line.widgets) { for (var i = 0; i < line.widgets.length; ++i) {
      var w = line.widgets[i], parent = w.node.parentNode;
      if (parent) { w.height = parent.offsetHeight; }
    } }
  }

  // Compute the lines that are visible in a given viewport (defaults
  // the the current scroll position). viewport may contain top,
  // height, and ensure (see op.scrollToPos) properties.
  function visibleLines(display, doc, viewport) {
    var top = viewport && viewport.top != null ? Math.max(0, viewport.top) : display.scroller.scrollTop;
    top = Math.floor(top - paddingTop(display));
    var bottom = viewport && viewport.bottom != null ? viewport.bottom : top + display.wrapper.clientHeight;

    var from = lineAtHeight(doc, top), to = lineAtHeight(doc, bottom);
    // Ensure is a {from: {line, ch}, to: {line, ch}} object, and
    // forces those lines into the viewport (if possible).
    if (viewport && viewport.ensure) {
      var ensureFrom = viewport.ensure.from.line, ensureTo = viewport.ensure.to.line;
      if (ensureFrom < from) {
        from = ensureFrom;
        to = lineAtHeight(doc, heightAtLine(getLine(doc, ensureFrom)) + display.wrapper.clientHeight);
      } else if (Math.min(ensureTo, doc.lastLine()) >= to) {
        from = lineAtHeight(doc, heightAtLine(getLine(doc, ensureTo)) - display.wrapper.clientHeight);
        to = ensureTo;
      }
    }
    return {from: from, to: Math.max(to, from + 1)}
  }

  // SCROLLING THINGS INTO VIEW

  // If an editor sits on the top or bottom of the window, partially
  // scrolled out of view, this ensures that the cursor is visible.
  function maybeScrollWindow(cm, rect) {
    if (signalDOMEvent(cm, "scrollCursorIntoView")) { return }

    var display = cm.display, box = display.sizer.getBoundingClientRect(), doScroll = null;
    if (rect.top + box.top < 0) { doScroll = true; }
    else if (rect.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight)) { doScroll = false; }
    if (doScroll != null && !phantom) {
      var scrollNode = elt("div", "\u200b", null, ("position: absolute;\n                         top: " + (rect.top - display.viewOffset - paddingTop(cm.display)) + "px;\n                         height: " + (rect.bottom - rect.top + scrollGap(cm) + display.barHeight) + "px;\n                         left: " + (rect.left) + "px; width: " + (Math.max(2, rect.right - rect.left)) + "px;"));
      cm.display.lineSpace.appendChild(scrollNode);
      scrollNode.scrollIntoView(doScroll);
      cm.display.lineSpace.removeChild(scrollNode);
    }
  }

  // Scroll a given position into view (immediately), verifying that
  // it actually became visible (as line heights are accurately
  // measured, the position of something may 'drift' during drawing).
  function scrollPosIntoView(cm, pos, end, margin) {
    if (margin == null) { margin = 0; }
    var rect;
    if (!cm.options.lineWrapping && pos == end) {
      // Set pos and end to the cursor positions around the character pos sticks to
      // If pos.sticky == "before", that is around pos.ch - 1, otherwise around pos.ch
      // If pos == Pos(_, 0, "before"), pos and end are unchanged
      pos = pos.ch ? Pos(pos.line, pos.sticky == "before" ? pos.ch - 1 : pos.ch, "after") : pos;
      end = pos.sticky == "before" ? Pos(pos.line, pos.ch + 1, "before") : pos;
    }
    for (var limit = 0; limit < 5; limit++) {
      var changed = false;
      var coords = cursorCoords(cm, pos);
      var endCoords = !end || end == pos ? coords : cursorCoords(cm, end);
      rect = {left: Math.min(coords.left, endCoords.left),
              top: Math.min(coords.top, endCoords.top) - margin,
              right: Math.max(coords.left, endCoords.left),
              bottom: Math.max(coords.bottom, endCoords.bottom) + margin};
      var scrollPos = calculateScrollPos(cm, rect);
      var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;
      if (scrollPos.scrollTop != null) {
        updateScrollTop(cm, scrollPos.scrollTop);
        if (Math.abs(cm.doc.scrollTop - startTop) > 1) { changed = true; }
      }
      if (scrollPos.scrollLeft != null) {
        setScrollLeft(cm, scrollPos.scrollLeft);
        if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) { changed = true; }
      }
      if (!changed) { break }
    }
    return rect
  }

  // Scroll a given set of coordinates into view (immediately).
  function scrollIntoView(cm, rect) {
    var scrollPos = calculateScrollPos(cm, rect);
    if (scrollPos.scrollTop != null) { updateScrollTop(cm, scrollPos.scrollTop); }
    if (scrollPos.scrollLeft != null) { setScrollLeft(cm, scrollPos.scrollLeft); }
  }

  // Calculate a new scroll position needed to scroll the given
  // rectangle into view. Returns an object with scrollTop and
  // scrollLeft properties. When these are undefined, the
  // vertical/horizontal position does not need to be adjusted.
  function calculateScrollPos(cm, rect) {
    var display = cm.display, snapMargin = textHeight(cm.display);
    if (rect.top < 0) { rect.top = 0; }
    var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop;
    var screen = displayHeight(cm), result = {};
    if (rect.bottom - rect.top > screen) { rect.bottom = rect.top + screen; }
    var docBottom = cm.doc.height + paddingVert(display);
    var atTop = rect.top < snapMargin, atBottom = rect.bottom > docBottom - snapMargin;
    if (rect.top < screentop) {
      result.scrollTop = atTop ? 0 : rect.top;
    } else if (rect.bottom > screentop + screen) {
      var newTop = Math.min(rect.top, (atBottom ? docBottom : rect.bottom) - screen);
      if (newTop != screentop) { result.scrollTop = newTop; }
    }

    var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft;
    var screenw = displayWidth(cm) - (cm.options.fixedGutter ? display.gutters.offsetWidth : 0);
    var tooWide = rect.right - rect.left > screenw;
    if (tooWide) { rect.right = rect.left + screenw; }
    if (rect.left < 10)
      { result.scrollLeft = 0; }
    else if (rect.left < screenleft)
      { result.scrollLeft = Math.max(0, rect.left - (tooWide ? 0 : 10)); }
    else if (rect.right > screenw + screenleft - 3)
      { result.scrollLeft = rect.right + (tooWide ? 0 : 10) - screenw; }
    return result
  }

  // Store a relative adjustment to the scroll position in the current
  // operation (to be applied when the operation finishes).
  function addToScrollTop(cm, top) {
    if (top == null) { return }
    resolveScrollToPos(cm);
    cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top;
  }

  // Make sure that at the end of the operation the current cursor is
  // shown.
  function ensureCursorVisible(cm) {
    resolveScrollToPos(cm);
    var cur = cm.getCursor();
    cm.curOp.scrollToPos = {from: cur, to: cur, margin: cm.options.cursorScrollMargin};
  }

  function scrollToCoords(cm, x, y) {
    if (x != null || y != null) { resolveScrollToPos(cm); }
    if (x != null) { cm.curOp.scrollLeft = x; }
    if (y != null) { cm.curOp.scrollTop = y; }
  }

  function scrollToRange(cm, range) {
    resolveScrollToPos(cm);
    cm.curOp.scrollToPos = range;
  }

  // When an operation has its scrollToPos property set, and another
  // scroll action is applied before the end of the operation, this
  // 'simulates' scrolling that position into view in a cheap way, so
  // that the effect of intermediate scroll commands is not ignored.
  function resolveScrollToPos(cm) {
    var range = cm.curOp.scrollToPos;
    if (range) {
      cm.curOp.scrollToPos = null;
      var from = estimateCoords(cm, range.from), to = estimateCoords(cm, range.to);
      scrollToCoordsRange(cm, from, to, range.margin);
    }
  }

  function scrollToCoordsRange(cm, from, to, margin) {
    var sPos = calculateScrollPos(cm, {
      left: Math.min(from.left, to.left),
      top: Math.min(from.top, to.top) - margin,
      right: Math.max(from.right, to.right),
      bottom: Math.max(from.bottom, to.bottom) + margin
    });
    scrollToCoords(cm, sPos.scrollLeft, sPos.scrollTop);
  }

  // Sync the scrollable area and scrollbars, ensure the viewport
  // covers the visible area.
  function updateScrollTop(cm, val) {
    if (Math.abs(cm.doc.scrollTop - val) < 2) { return }
    if (!gecko) { updateDisplaySimple(cm, {top: val}); }
    setScrollTop(cm, val, true);
    if (gecko) { updateDisplaySimple(cm); }
    startWorker(cm, 100);
  }

  function setScrollTop(cm, val, forceScroll) {
    val = Math.max(0, Math.min(cm.display.scroller.scrollHeight - cm.display.scroller.clientHeight, val));
    if (cm.display.scroller.scrollTop == val && !forceScroll) { return }
    cm.doc.scrollTop = val;
    cm.display.scrollbars.setScrollTop(val);
    if (cm.display.scroller.scrollTop != val) { cm.display.scroller.scrollTop = val; }
  }

  // Sync scroller and scrollbar, ensure the gutter elements are
  // aligned.
  function setScrollLeft(cm, val, isScroller, forceScroll) {
    val = Math.max(0, Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth));
    if ((isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) && !forceScroll) { return }
    cm.doc.scrollLeft = val;
    alignHorizontally(cm);
    if (cm.display.scroller.scrollLeft != val) { cm.display.scroller.scrollLeft = val; }
    cm.display.scrollbars.setScrollLeft(val);
  }

  // SCROLLBARS

  // Prepare DOM reads needed to update the scrollbars. Done in one
  // shot to minimize update/measure roundtrips.
  function measureForScrollbars(cm) {
    var d = cm.display, gutterW = d.gutters.offsetWidth;
    var docH = Math.round(cm.doc.height + paddingVert(cm.display));
    return {
      clientHeight: d.scroller.clientHeight,
      viewHeight: d.wrapper.clientHeight,
      scrollWidth: d.scroller.scrollWidth, clientWidth: d.scroller.clientWidth,
      viewWidth: d.wrapper.clientWidth,
      barLeft: cm.options.fixedGutter ? gutterW : 0,
      docHeight: docH,
      scrollHeight: docH + scrollGap(cm) + d.barHeight,
      nativeBarWidth: d.nativeBarWidth,
      gutterWidth: gutterW
    }
  }

  var NativeScrollbars = function(place, scroll, cm) {
    this.cm = cm;
    var vert = this.vert = elt("div", [elt("div", null, null, "min-width: 1px")], "CodeMirror-vscrollbar");
    var horiz = this.horiz = elt("div", [elt("div", null, null, "height: 100%; min-height: 1px")], "CodeMirror-hscrollbar");
    vert.tabIndex = horiz.tabIndex = -1;
    place(vert); place(horiz);

    on(vert, "scroll", function () {
      if (vert.clientHeight) { scroll(vert.scrollTop, "vertical"); }
    });
    on(horiz, "scroll", function () {
      if (horiz.clientWidth) { scroll(horiz.scrollLeft, "horizontal"); }
    });

    this.checkedZeroWidth = false;
    // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).
    if (ie && ie_version < 8) { this.horiz.style.minHeight = this.vert.style.minWidth = "18px"; }
  };

  NativeScrollbars.prototype.update = function (measure) {
    var needsH = measure.scrollWidth > measure.clientWidth + 1;
    var needsV = measure.scrollHeight > measure.clientHeight + 1;
    var sWidth = measure.nativeBarWidth;

    if (needsV) {
      this.vert.style.display = "block";
      this.vert.style.bottom = needsH ? sWidth + "px" : "0";
      var totalHeight = measure.viewHeight - (needsH ? sWidth : 0);
      // A bug in IE8 can cause this value to be negative, so guard it.
      this.vert.firstChild.style.height =
        Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + "px";
    } else {
      this.vert.style.display = "";
      this.vert.firstChild.style.height = "0";
    }

    if (needsH) {
      this.horiz.style.display = "block";
      this.horiz.style.right = needsV ? sWidth + "px" : "0";
      this.horiz.style.left = measure.barLeft + "px";
      var totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0);
      this.horiz.firstChild.style.width =
        Math.max(0, measure.scrollWidth - measure.clientWidth + totalWidth) + "px";
    } else {
      this.horiz.style.display = "";
      this.horiz.firstChild.style.width = "0";
    }

    if (!this.checkedZeroWidth && measure.clientHeight > 0) {
      if (sWidth == 0) { this.zeroWidthHack(); }
      this.checkedZeroWidth = true;
    }

    return {right: needsV ? sWidth : 0, bottom: needsH ? sWidth : 0}
  };

  NativeScrollbars.prototype.setScrollLeft = function (pos) {
    if (this.horiz.scrollLeft != pos) { this.horiz.scrollLeft = pos; }
    if (this.disableHoriz) { this.enableZeroWidthBar(this.horiz, this.disableHoriz, "horiz"); }
  };

  NativeScrollbars.prototype.setScrollTop = function (pos) {
    if (this.vert.scrollTop != pos) { this.vert.scrollTop = pos; }
    if (this.disableVert) { this.enableZeroWidthBar(this.vert, this.disableVert, "vert"); }
  };

  NativeScrollbars.prototype.zeroWidthHack = function () {
    var w = mac && !mac_geMountainLion ? "12px" : "18px";
    this.horiz.style.height = this.vert.style.width = w;
    this.horiz.style.pointerEvents = this.vert.style.pointerEvents = "none";
    this.disableHoriz = new Delayed;
    this.disableVert = new Delayed;
  };

  NativeScrollbars.prototype.enableZeroWidthBar = function (bar, delay, type) {
    bar.style.pointerEvents = "auto";
    function maybeDisable() {
      // To find out whether the scrollbar is still visible, we
      // check whether the element under the pixel in the bottom
      // right corner of the scrollbar box is the scrollbar box
      // itself (when the bar is still visible) or its filler child
      // (when the bar is hidden). If it is still visible, we keep
      // it enabled, if it's hidden, we disable pointer events.
      var box = bar.getBoundingClientRect();
      var elt = type == "vert" ? document.elementFromPoint(box.right - 1, (box.top + box.bottom) / 2)
          : document.elementFromPoint((box.right + box.left) / 2, box.bottom - 1);
      if (elt != bar) { bar.style.pointerEvents = "none"; }
      else { delay.set(1000, maybeDisable); }
    }
    delay.set(1000, maybeDisable);
  };

  NativeScrollbars.prototype.clear = function () {
    var parent = this.horiz.parentNode;
    parent.removeChild(this.horiz);
    parent.removeChild(this.vert);
  };

  var NullScrollbars = function () {};

  NullScrollbars.prototype.update = function () { return {bottom: 0, right: 0} };
  NullScrollbars.prototype.setScrollLeft = function () {};
  NullScrollbars.prototype.setScrollTop = function () {};
  NullScrollbars.prototype.clear = function () {};

  function updateScrollbars(cm, measure) {
    if (!measure) { measure = measureForScrollbars(cm); }
    var startWidth = cm.display.barWidth, startHeight = cm.display.barHeight;
    updateScrollbarsInner(cm, measure);
    for (var i = 0; i < 4 && startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i++) {
      if (startWidth != cm.display.barWidth && cm.options.lineWrapping)
        { updateHeightsInViewport(cm); }
      updateScrollbarsInner(cm, measureForScrollbars(cm));
      startWidth = cm.display.barWidth; startHeight = cm.display.barHeight;
    }
  }

  // Re-synchronize the fake scrollbars with the actual size of the
  // content.
  function updateScrollbarsInner(cm, measure) {
    var d = cm.display;
    var sizes = d.scrollbars.update(measure);

    d.sizer.style.paddingRight = (d.barWidth = sizes.right) + "px";
    d.sizer.style.paddingBottom = (d.barHeight = sizes.bottom) + "px";
    d.heightForcer.style.borderBottom = sizes.bottom + "px solid transparent";

    if (sizes.right && sizes.bottom) {
      d.scrollbarFiller.style.display = "block";
      d.scrollbarFiller.style.height = sizes.bottom + "px";
      d.scrollbarFiller.style.width = sizes.right + "px";
    } else { d.scrollbarFiller.style.display = ""; }
    if (sizes.bottom && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {
      d.gutterFiller.style.display = "block";
      d.gutterFiller.style.height = sizes.bottom + "px";
      d.gutterFiller.style.width = measure.gutterWidth + "px";
    } else { d.gutterFiller.style.display = ""; }
  }

  var scrollbarModel = {"native": NativeScrollbars, "null": NullScrollbars};

  function initScrollbars(cm) {
    if (cm.display.scrollbars) {
      cm.display.scrollbars.clear();
      if (cm.display.scrollbars.addClass)
        { rmClass(cm.display.wrapper, cm.display.scrollbars.addClass); }
    }

    cm.display.scrollbars = new scrollbarModel[cm.options.scrollbarStyle](function (node) {
      cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller);
      // Prevent clicks in the scrollbars from killing focus
      on(node, "mousedown", function () {
        if (cm.state.focused) { setTimeout(function () { return cm.display.input.focus(); }, 0); }
      });
      node.setAttribute("cm-not-content", "true");
    }, function (pos, axis) {
      if (axis == "horizontal") { setScrollLeft(cm, pos); }
      else { updateScrollTop(cm, pos); }
    }, cm);
    if (cm.display.scrollbars.addClass)
      { addClass(cm.display.wrapper, cm.display.scrollbars.addClass); }
  }

  // Operations are used to wrap a series of changes to the editor
  // state in such a way that each change won't have to update the
  // cursor and display (which would be awkward, slow, and
  // error-prone). Instead, display updates are batched and then all
  // combined and executed at once.

  var nextOpId = 0;
  // Start a new operation.
  function startOperation(cm) {
    cm.curOp = {
      cm: cm,
      viewChanged: false,      // Flag that indicates that lines might need to be redrawn
      startHeight: cm.doc.height, // Used to detect need to update scrollbar
      forceUpdate: false,      // Used to force a redraw
      updateInput: 0,       // Whether to reset the input textarea
      typing: false,           // Whether this reset should be careful to leave existing text (for compositing)
      changeObjs: null,        // Accumulated changes, for firing change events
      cursorActivityHandlers: null, // Set of handlers to fire cursorActivity on
      cursorActivityCalled: 0, // Tracks which cursorActivity handlers have been called already
      selectionChanged: false, // Whether the selection needs to be redrawn
      updateMaxLine: false,    // Set when the widest line needs to be determined anew
      scrollLeft: null, scrollTop: null, // Intermediate scroll position, not pushed to DOM yet
      scrollToPos: null,       // Used to scroll to a specific position
      focus: false,
      id: ++nextOpId           // Unique ID
    };
    pushOperation(cm.curOp);
  }

  // Finish an operation, updating the display and signalling delayed events
  function endOperation(cm) {
    var op = cm.curOp;
    if (op) { finishOperation(op, function (group) {
      for (var i = 0; i < group.ops.length; i++)
        { group.ops[i].cm.curOp = null; }
      endOperations(group);
    }); }
  }

  // The DOM updates done when an operation finishes are batched so
  // that the minimum number of relayouts are required.
  function endOperations(group) {
    var ops = group.ops;
    for (var i = 0; i < ops.length; i++) // Read DOM
      { endOperation_R1(ops[i]); }
    for (var i$1 = 0; i$1 < ops.length; i$1++) // Write DOM (maybe)
      { endOperation_W1(ops[i$1]); }
    for (var i$2 = 0; i$2 < ops.length; i$2++) // Read DOM
      { endOperation_R2(ops[i$2]); }
    for (var i$3 = 0; i$3 < ops.length; i$3++) // Write DOM (maybe)
      { endOperation_W2(ops[i$3]); }
    for (var i$4 = 0; i$4 < ops.length; i$4++) // Read DOM
      { endOperation_finish(ops[i$4]); }
  }

  function endOperation_R1(op) {
    var cm = op.cm, display = cm.display;
    maybeClipScrollbars(cm);
    if (op.updateMaxLine) { findMaxLine(cm); }

    op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != null ||
      op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom ||
                         op.scrollToPos.to.line >= display.viewTo) ||
      display.maxLineChanged && cm.options.lineWrapping;
    op.update = op.mustUpdate &&
      new DisplayUpdate(cm, op.mustUpdate && {top: op.scrollTop, ensure: op.scrollToPos}, op.forceUpdate);
  }

  function endOperation_W1(op) {
    op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update);
  }

  function endOperation_R2(op) {
    var cm = op.cm, display = cm.display;
    if (op.updatedDisplay) { updateHeightsInViewport(cm); }

    op.barMeasure = measureForScrollbars(cm);

    // If the max line changed since it was last measured, measure it,
    // and ensure the document's width matches it.
    // updateDisplay_W2 will use these properties to do the actual resizing
    if (display.maxLineChanged && !cm.options.lineWrapping) {
      op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3;
      cm.display.sizerWidth = op.adjustWidthTo;
      op.barMeasure.scrollWidth =
        Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth);
      op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm));
    }

    if (op.updatedDisplay || op.selectionChanged)
      { op.preparedSelection = display.input.prepareSelection(); }
  }

  function endOperation_W2(op) {
    var cm = op.cm;

    if (op.adjustWidthTo != null) {
      cm.display.sizer.style.minWidth = op.adjustWidthTo + "px";
      if (op.maxScrollLeft < cm.doc.scrollLeft)
        { setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true); }
      cm.display.maxLineChanged = false;
    }

    var takeFocus = op.focus && op.focus == activeElt();
    if (op.preparedSelection)
      { cm.display.input.showSelection(op.preparedSelection, takeFocus); }
    if (op.updatedDisplay || op.startHeight != cm.doc.height)
      { updateScrollbars(cm, op.barMeasure); }
    if (op.updatedDisplay)
      { setDocumentHeight(cm, op.barMeasure); }

    if (op.selectionChanged) { restartBlink(cm); }

    if (cm.state.focused && op.updateInput)
      { cm.display.input.reset(op.typing); }
    if (takeFocus) { ensureFocus(op.cm); }
  }

  function endOperation_finish(op) {
    var cm = op.cm, display = cm.display, doc = cm.doc;

    if (op.updatedDisplay) { postUpdateDisplay(cm, op.update); }

    // Abort mouse wheel delta measurement, when scrolling explicitly
    if (display.wheelStartX != null && (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos))
      { display.wheelStartX = display.wheelStartY = null; }

    // Propagate the scroll position to the actual DOM scroller
    if (op.scrollTop != null) { setScrollTop(cm, op.scrollTop, op.forceScroll); }

    if (op.scrollLeft != null) { setScrollLeft(cm, op.scrollLeft, true, true); }
    // If we need to scroll a specific position into view, do so.
    if (op.scrollToPos) {
      var rect = scrollPosIntoView(cm, clipPos(doc, op.scrollToPos.from),
                                   clipPos(doc, op.scrollToPos.to), op.scrollToPos.margin);
      maybeScrollWindow(cm, rect);
    }

    // Fire events for markers that are hidden/unidden by editing or
    // undoing
    var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;
    if (hidden) { for (var i = 0; i < hidden.length; ++i)
      { if (!hidden[i].lines.length) { signal(hidden[i], "hide"); } } }
    if (unhidden) { for (var i$1 = 0; i$1 < unhidden.length; ++i$1)
      { if (unhidden[i$1].lines.length) { signal(unhidden[i$1], "unhide"); } } }

    if (display.wrapper.offsetHeight)
      { doc.scrollTop = cm.display.scroller.scrollTop; }

    // Fire change events, and delayed event handlers
    if (op.changeObjs)
      { signal(cm, "changes", cm, op.changeObjs); }
    if (op.update)
      { op.update.finish(); }
  }

  // Run the given function in an operation
  function runInOp(cm, f) {
    if (cm.curOp) { return f() }
    startOperation(cm);
    try { return f() }
    finally { endOperation(cm); }
  }
  // Wraps a function in an operation. Returns the wrapped function.
  function operation(cm, f) {
    return function() {
      if (cm.curOp) { return f.apply(cm, arguments) }
      startOperation(cm);
      try { return f.apply(cm, arguments) }
      finally { endOperation(cm); }
    }
  }
  // Used to add methods to editor and doc instances, wrapping them in
  // operations.
  function methodOp(f) {
    return function() {
      if (this.curOp) { return f.apply(this, arguments) }
      startOperation(this);
      try { return f.apply(this, arguments) }
      finally { endOperation(this); }
    }
  }
  function docMethodOp(f) {
    return function() {
      var cm = this.cm;
      if (!cm || cm.curOp) { return f.apply(this, arguments) }
      startOperation(cm);
      try { return f.apply(this, arguments) }
      finally { endOperation(cm); }
    }
  }

  // HIGHLIGHT WORKER

  function startWorker(cm, time) {
    if (cm.doc.highlightFrontier < cm.display.viewTo)
      { cm.state.highlight.set(time, bind(highlightWorker, cm)); }
  }

  function highlightWorker(cm) {
    var doc = cm.doc;
    if (doc.highlightFrontier >= cm.display.viewTo) { return }
    var end = +new Date + cm.options.workTime;
    var context = getContextBefore(cm, doc.highlightFrontier);
    var changedLines = [];

    doc.iter(context.line, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function (line) {
      if (context.line >= cm.display.viewFrom) { // Visible
        var oldStyles = line.styles;
        var resetState = line.text.length > cm.options.maxHighlightLength ? copyState(doc.mode, context.state) : null;
        var highlighted = highlightLine(cm, line, context, true);
        if (resetState) { context.state = resetState; }
        line.styles = highlighted.styles;
        var oldCls = line.styleClasses, newCls = highlighted.classes;
        if (newCls) { line.styleClasses = newCls; }
        else if (oldCls) { line.styleClasses = null; }
        var ischange = !oldStyles || oldStyles.length != line.styles.length ||
          oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass);
        for (var i = 0; !ischange && i < oldStyles.length; ++i) { ischange = oldStyles[i] != line.styles[i]; }
        if (ischange) { changedLines.push(context.line); }
        line.stateAfter = context.save();
        context.nextLine();
      } else {
        if (line.text.length <= cm.options.maxHighlightLength)
          { processLine(cm, line.text, context); }
        line.stateAfter = context.line % 5 == 0 ? context.save() : null;
        context.nextLine();
      }
      if (+new Date > end) {
        startWorker(cm, cm.options.workDelay);
        return true
      }
    });
    doc.highlightFrontier = context.line;
    doc.modeFrontier = Math.max(doc.modeFrontier, context.line);
    if (changedLines.length) { runInOp(cm, function () {
      for (var i = 0; i < changedLines.length; i++)
        { regLineChange(cm, changedLines[i], "text"); }
    }); }
  }

  // DISPLAY DRAWING

  var DisplayUpdate = function(cm, viewport, force) {
    var display = cm.display;

    this.viewport = viewport;
    // Store some values that we'll need later (but don't want to force a relayout for)
    this.visible = visibleLines(display, cm.doc, viewport);
    this.editorIsHidden = !display.wrapper.offsetWidth;
    this.wrapperHeight = display.wrapper.clientHeight;
    this.wrapperWidth = display.wrapper.clientWidth;
    this.oldDisplayWidth = displayWidth(cm);
    this.force = force;
    this.dims = getDimensions(cm);
    this.events = [];
  };

  DisplayUpdate.prototype.signal = function (emitter, type) {
    if (hasHandler(emitter, type))
      { this.events.push(arguments); }
  };
  DisplayUpdate.prototype.finish = function () {
    for (var i = 0; i < this.events.length; i++)
      { signal.apply(null, this.events[i]); }
  };

  function maybeClipScrollbars(cm) {
    var display = cm.display;
    if (!display.scrollbarsClipped && display.scroller.offsetWidth) {
      display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth;
      display.heightForcer.style.height = scrollGap(cm) + "px";
      display.sizer.style.marginBottom = -display.nativeBarWidth + "px";
      display.sizer.style.borderRightWidth = scrollGap(cm) + "px";
      display.scrollbarsClipped = true;
    }
  }

  function selectionSnapshot(cm) {
    if (cm.hasFocus()) { return null }
    var active = activeElt();
    if (!active || !contains(cm.display.lineDiv, active)) { return null }
    var result = {activeElt: active};
    if (window.getSelection) {
      var sel = window.getSelection();
      if (sel.anchorNode && sel.extend && contains(cm.display.lineDiv, sel.anchorNode)) {
        result.anchorNode = sel.anchorNode;
        result.anchorOffset = sel.anchorOffset;
        result.focusNode = sel.focusNode;
        result.focusOffset = sel.focusOffset;
      }
    }
    return result
  }

  function restoreSelection(snapshot) {
    if (!snapshot || !snapshot.activeElt || snapshot.activeElt == activeElt()) { return }
    snapshot.activeElt.focus();
    if (!/^(INPUT|TEXTAREA)$/.test(snapshot.activeElt.nodeName) &&
        snapshot.anchorNode && contains(document.body, snapshot.anchorNode) && contains(document.body, snapshot.focusNode)) {
      var sel = window.getSelection(), range = document.createRange();
      range.setEnd(snapshot.anchorNode, snapshot.anchorOffset);
      range.collapse(false);
      sel.removeAllRanges();
      sel.addRange(range);
      sel.extend(snapshot.focusNode, snapshot.focusOffset);
    }
  }

  // Does the actual updating of the line display. Bails out
  // (returning false) when there is nothing to be done and forced is
  // false.
  function updateDisplayIfNeeded(cm, update) {
    var display = cm.display, doc = cm.doc;

    if (update.editorIsHidden) {
      resetView(cm);
      return false
    }

    // Bail out if the visible area is already rendered and nothing changed.
    if (!update.force &&
        update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo &&
        (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo) &&
        display.renderedView == display.view && countDirtyView(cm) == 0)
      { return false }

    if (maybeUpdateLineNumberWidth(cm)) {
      resetView(cm);
      update.dims = getDimensions(cm);
    }

    // Compute a suitable new viewport (from & to)
    var end = doc.first + doc.size;
    var from = Math.max(update.visible.from - cm.options.viewportMargin, doc.first);
    var to = Math.min(end, update.visible.to + cm.options.viewportMargin);
    if (display.viewFrom < from && from - display.viewFrom < 20) { from = Math.max(doc.first, display.viewFrom); }
    if (display.viewTo > to && display.viewTo - to < 20) { to = Math.min(end, display.viewTo); }
    if (sawCollapsedSpans) {
      from = visualLineNo(cm.doc, from);
      to = visualLineEndNo(cm.doc, to);
    }

    var different = from != display.viewFrom || to != display.viewTo ||
      display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth;
    adjustView(cm, from, to);

    display.viewOffset = heightAtLine(getLine(cm.doc, display.viewFrom));
    // Position the mover div to align with the current scroll position
    cm.display.mover.style.top = display.viewOffset + "px";

    var toUpdate = countDirtyView(cm);
    if (!different && toUpdate == 0 && !update.force && display.renderedView == display.view &&
        (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo))
      { return false }

    // For big changes, we hide the enclosing element during the
    // update, since that speeds up the operations on most browsers.
    var selSnapshot = selectionSnapshot(cm);
    if (toUpdate > 4) { display.lineDiv.style.display = "none"; }
    patchDisplay(cm, display.updateLineNumbers, update.dims);
    if (toUpdate > 4) { display.lineDiv.style.display = ""; }
    display.renderedView = display.view;
    // There might have been a widget with a focused element that got
    // hidden or updated, if so re-focus it.
    restoreSelection(selSnapshot);

    // Prevent selection and cursors from interfering with the scroll
    // width and height.
    removeChildren(display.cursorDiv);
    removeChildren(display.selectionDiv);
    display.gutters.style.height = display.sizer.style.minHeight = 0;

    if (different) {
      display.lastWrapHeight = update.wrapperHeight;
      display.lastWrapWidth = update.wrapperWidth;
      startWorker(cm, 400);
    }

    display.updateLineNumbers = null;

    return true
  }

  function postUpdateDisplay(cm, update) {
    var viewport = update.viewport;

    for (var first = true;; first = false) {
      if (!first || !cm.options.lineWrapping || update.oldDisplayWidth == displayWidth(cm)) {
        // Clip forced viewport to actual scrollable area.
        if (viewport && viewport.top != null)
          { viewport = {top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport.top)}; }
        // Updated line heights might result in the drawn area not
        // actually covering the viewport. Keep looping until it does.
        update.visible = visibleLines(cm.display, cm.doc, viewport);
        if (update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo)
          { break }
      } else if (first) {
        update.visible = visibleLines(cm.display, cm.doc, viewport);
      }
      if (!updateDisplayIfNeeded(cm, update)) { break }
      updateHeightsInViewport(cm);
      var barMeasure = measureForScrollbars(cm);
      updateSelection(cm);
      updateScrollbars(cm, barMeasure);
      setDocumentHeight(cm, barMeasure);
      update.force = false;
    }

    update.signal(cm, "update", cm);
    if (cm.display.viewFrom != cm.display.reportedViewFrom || cm.display.viewTo != cm.display.reportedViewTo) {
      update.signal(cm, "viewportChange", cm, cm.display.viewFrom, cm.display.viewTo);
      cm.display.reportedViewFrom = cm.display.viewFrom; cm.display.reportedViewTo = cm.display.viewTo;
    }
  }

  function updateDisplaySimple(cm, viewport) {
    var update = new DisplayUpdate(cm, viewport);
    if (updateDisplayIfNeeded(cm, update)) {
      updateHeightsInViewport(cm);
      postUpdateDisplay(cm, update);
      var barMeasure = measureForScrollbars(cm);
      updateSelection(cm);
      updateScrollbars(cm, barMeasure);
      setDocumentHeight(cm, barMeasure);
      update.finish();
    }
  }

  // Sync the actual display DOM structure with display.view, removing
  // nodes for lines that are no longer in view, and creating the ones
  // that are not there yet, and updating the ones that are out of
  // date.
  function patchDisplay(cm, updateNumbersFrom, dims) {
    var display = cm.display, lineNumbers = cm.options.lineNumbers;
    var container = display.lineDiv, cur = container.firstChild;

    function rm(node) {
      var next = node.nextSibling;
      // Works around a throw-scroll bug in OS X Webkit
      if (webkit && mac && cm.display.currentWheelTarget == node)
        { node.style.display = "none"; }
      else
        { node.parentNode.removeChild(node); }
      return next
    }

    var view = display.view, lineN = display.viewFrom;
    // Loop over the elements in the view, syncing cur (the DOM nodes
    // in display.lineDiv) with the view as we go.
    for (var i = 0; i < view.length; i++) {
      var lineView = view[i];
      if (lineView.hidden) ; else if (!lineView.node || lineView.node.parentNode != container) { // Not drawn yet
        var node = buildLineElement(cm, lineView, lineN, dims);
        container.insertBefore(node, cur);
      } else { // Already drawn
        while (cur != lineView.node) { cur = rm(cur); }
        var updateNumber = lineNumbers && updateNumbersFrom != null &&
          updateNumbersFrom <= lineN && lineView.lineNumber;
        if (lineView.changes) {
          if (indexOf(lineView.changes, "gutter") > -1) { updateNumber = false; }
          updateLineForChanges(cm, lineView, lineN, dims);
        }
        if (updateNumber) {
          removeChildren(lineView.lineNumber);
          lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)));
        }
        cur = lineView.node.nextSibling;
      }
      lineN += lineView.size;
    }
    while (cur) { cur = rm(cur); }
  }

  function updateGutterSpace(display) {
    var width = display.gutters.offsetWidth;
    display.sizer.style.marginLeft = width + "px";
  }

  function setDocumentHeight(cm, measure) {
    cm.display.sizer.style.minHeight = measure.docHeight + "px";
    cm.display.heightForcer.style.top = measure.docHeight + "px";
    cm.display.gutters.style.height = (measure.docHeight + cm.display.barHeight + scrollGap(cm)) + "px";
  }

  // Re-align line numbers and gutter marks to compensate for
  // horizontal scrolling.
  function alignHorizontally(cm) {
    var display = cm.display, view = display.view;
    if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) { return }
    var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;
    var gutterW = display.gutters.offsetWidth, left = comp + "px";
    for (var i = 0; i < view.length; i++) { if (!view[i].hidden) {
      if (cm.options.fixedGutter) {
        if (view[i].gutter)
          { view[i].gutter.style.left = left; }
        if (view[i].gutterBackground)
          { view[i].gutterBackground.style.left = left; }
      }
      var align = view[i].alignable;
      if (align) { for (var j = 0; j < align.length; j++)
        { align[j].style.left = left; } }
    } }
    if (cm.options.fixedGutter)
      { display.gutters.style.left = (comp + gutterW) + "px"; }
  }

  // Used to ensure that the line number gutter is still the right
  // size for the current document size. Returns true when an update
  // is needed.
  function maybeUpdateLineNumberWidth(cm) {
    if (!cm.options.lineNumbers) { return false }
    var doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display;
    if (last.length != display.lineNumChars) {
      var test = display.measure.appendChild(elt("div", [elt("div", last)],
                                                 "CodeMirror-linenumber CodeMirror-gutter-elt"));
      var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;
      display.lineGutter.style.width = "";
      display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding) + 1;
      display.lineNumWidth = display.lineNumInnerWidth + padding;
      display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;
      display.lineGutter.style.width = display.lineNumWidth + "px";
      updateGutterSpace(cm.display);
      return true
    }
    return false
  }

  function getGutters(gutters, lineNumbers) {
    var result = [], sawLineNumbers = false;
    for (var i = 0; i < gutters.length; i++) {
      var name = gutters[i], style = null;
      if (typeof name != "string") { style = name.style; name = name.className; }
      if (name == "CodeMirror-linenumbers") {
        if (!lineNumbers) { continue }
        else { sawLineNumbers = true; }
      }
      result.push({className: name, style: style});
    }
    if (lineNumbers && !sawLineNumbers) { result.push({className: "CodeMirror-linenumbers", style: null}); }
    return result
  }

  // Rebuild the gutter elements, ensure the margin to the left of the
  // code matches their width.
  function renderGutters(display) {
    var gutters = display.gutters, specs = display.gutterSpecs;
    removeChildren(gutters);
    display.lineGutter = null;
    for (var i = 0; i < specs.length; ++i) {
      var ref = specs[i];
      var className = ref.className;
      var style = ref.style;
      var gElt = gutters.appendChild(elt("div", null, "CodeMirror-gutter " + className));
      if (style) { gElt.style.cssText = style; }
      if (className == "CodeMirror-linenumbers") {
        display.lineGutter = gElt;
        gElt.style.width = (display.lineNumWidth || 1) + "px";
      }
    }
    gutters.style.display = specs.length ? "" : "none";
    updateGutterSpace(display);
  }

  function updateGutters(cm) {
    renderGutters(cm.display);
    regChange(cm);
    alignHorizontally(cm);
  }

  // The display handles the DOM integration, both for input reading
  // and content drawing. It holds references to DOM nodes and
  // display-related state.

  function Display(place, doc, input, options) {
    var d = this;
    this.input = input;

    // Covers bottom-right square when both scrollbars are present.
    d.scrollbarFiller = elt("div", null, "CodeMirror-scrollbar-filler");
    d.scrollbarFiller.setAttribute("cm-not-content", "true");
    // Covers bottom of gutter when coverGutterNextToScrollbar is on
    // and h scrollbar is present.
    d.gutterFiller = elt("div", null, "CodeMirror-gutter-filler");
    d.gutterFiller.setAttribute("cm-not-content", "true");
    // Will contain the actual code, positioned to cover the viewport.
    d.lineDiv = eltP("div", null, "CodeMirror-code");
    // Elements are added to these to represent selection and cursors.
    d.selectionDiv = elt("div", null, null, "position: relative; z-index: 1");
    d.cursorDiv = elt("div", null, "CodeMirror-cursors");
    // A visibility: hidden element used to find the size of things.
    d.measure = elt("div", null, "CodeMirror-measure");
    // When lines outside of the viewport are measured, they are drawn in this.
    d.lineMeasure = elt("div", null, "CodeMirror-measure");
    // Wraps everything that needs to exist inside the vertically-padded coordinate system
    d.lineSpace = eltP("div", [d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv],
                      null, "position: relative; outline: none");
    var lines = eltP("div", [d.lineSpace], "CodeMirror-lines");
    // Moved around its parent to cover visible view.
    d.mover = elt("div", [lines], null, "position: relative");
    // Set to the height of the document, allowing scrolling.
    d.sizer = elt("div", [d.mover], "CodeMirror-sizer");
    d.sizerWidth = null;
    // Behavior of elts with overflow: auto and padding is
    // inconsistent across browsers. This is used to ensure the
    // scrollable area is big enough.
    d.heightForcer = elt("div", null, null, "position: absolute; height: " + scrollerGap + "px; width: 1px;");
    // Will contain the gutters, if any.
    d.gutters = elt("div", null, "CodeMirror-gutters");
    d.lineGutter = null;
    // Actual scrollable element.
    d.scroller = elt("div", [d.sizer, d.heightForcer, d.gutters], "CodeMirror-scroll");
    d.scroller.setAttribute("tabIndex", "-1");
    // The element in which the editor lives.
    d.wrapper = elt("div", [d.scrollbarFiller, d.gutterFiller, d.scroller], "CodeMirror");

    // Work around IE7 z-index bug (not perfect, hence IE7 not really being supported)
    if (ie && ie_version < 8) { d.gutters.style.zIndex = -1; d.scroller.style.paddingRight = 0; }
    if (!webkit && !(gecko && mobile)) { d.scroller.draggable = true; }

    if (place) {
      if (place.appendChild) { place.appendChild(d.wrapper); }
      else { place(d.wrapper); }
    }

    // Current rendered range (may be bigger than the view window).
    d.viewFrom = d.viewTo = doc.first;
    d.reportedViewFrom = d.reportedViewTo = doc.first;
    // Information about the rendered lines.
    d.view = [];
    d.renderedView = null;
    // Holds info about a single rendered line when it was rendered
    // for measurement, while not in view.
    d.externalMeasured = null;
    // Empty space (in pixels) above the view
    d.viewOffset = 0;
    d.lastWrapHeight = d.lastWrapWidth = 0;
    d.updateLineNumbers = null;

    d.nativeBarWidth = d.barHeight = d.barWidth = 0;
    d.scrollbarsClipped = false;

    // Used to only resize the line number gutter when necessary (when
    // the amount of lines crosses a boundary that makes its width change)
    d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;
    // Set to true when a non-horizontal-scrolling line widget is
    // added. As an optimization, line widget aligning is skipped when
    // this is false.
    d.alignWidgets = false;

    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;

    // Tracks the maximum line length so that the horizontal scrollbar
    // can be kept static when scrolling.
    d.maxLine = null;
    d.maxLineLength = 0;
    d.maxLineChanged = false;

    // Used for measuring wheel scrolling granularity
    d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;

    // True when shift is held down.
    d.shift = false;

    // Used to track whether anything happened since the context menu
    // was opened.
    d.selForContextMenu = null;

    d.activeTouch = null;

    d.gutterSpecs = getGutters(options.gutters, options.lineNumbers);
    renderGutters(d);

    input.init(d);
  }

  // Since the delta values reported on mouse wheel events are
  // unstandardized between browsers and even browser versions, and
  // generally horribly unpredictable, this code starts by measuring
  // the scroll effect that the first few mouse wheel events have,
  // and, from that, detects the way it can convert deltas to pixel
  // offsets afterwards.
  //
  // The reason we want to know the amount a wheel event will scroll
  // is that it gives us a chance to update the display before the
  // actual scrolling happens, reducing flickering.

  var wheelSamples = 0, wheelPixelsPerUnit = null;
  // Fill in a browser-detected starting value on browsers where we
  // know one. These don't have to be accurate -- the result of them
  // being wrong would just be a slight flicker on the first wheel
  // scroll (if it is large enough).
  if (ie) { wheelPixelsPerUnit = -.53; }
  else if (gecko) { wheelPixelsPerUnit = 15; }
  else if (chrome) { wheelPixelsPerUnit = -.7; }
  else if (safari) { wheelPixelsPerUnit = -1/3; }

  function wheelEventDelta(e) {
    var dx = e.wheelDeltaX, dy = e.wheelDeltaY;
    if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) { dx = e.detail; }
    if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) { dy = e.detail; }
    else if (dy == null) { dy = e.wheelDelta; }
    return {x: dx, y: dy}
  }
  function wheelEventPixels(e) {
    var delta = wheelEventDelta(e);
    delta.x *= wheelPixelsPerUnit;
    delta.y *= wheelPixelsPerUnit;
    return delta
  }

  function onScrollWheel(cm, e) {
    var delta = wheelEventDelta(e), dx = delta.x, dy = delta.y;

    var display = cm.display, scroll = display.scroller;
    // Quit if there's nothing to scroll here
    var canScrollX = scroll.scrollWidth > scroll.clientWidth;
    var canScrollY = scroll.scrollHeight > scroll.clientHeight;
    if (!(dx && canScrollX || dy && canScrollY)) { return }

    // Webkit browsers on OS X abort momentum scrolls when the target
    // of the scroll event is removed from the scrollable element.
    // This hack (see related code in patchDisplay) makes sure the
    // element is kept around.
    if (dy && mac && webkit) {
      outer: for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) {
        for (var i = 0; i < view.length; i++) {
          if (view[i].node == cur) {
            cm.display.currentWheelTarget = cur;
            break outer
          }
        }
      }
    }

    // On some browsers, horizontal scrolling will cause redraws to
    // happen before the gutter has been realigned, causing it to
    // wriggle around in a most unseemly way. When we have an
    // estimated pixels/delta value, we just handle horizontal
    // scrolling entirely here. It'll be slightly off from native, but
    // better than glitching out.
    if (dx && !gecko && !presto && wheelPixelsPerUnit != null) {
      if (dy && canScrollY)
        { updateScrollTop(cm, Math.max(0, scroll.scrollTop + dy * wheelPixelsPerUnit)); }
      setScrollLeft(cm, Math.max(0, scroll.scrollLeft + dx * wheelPixelsPerUnit));
      // Only prevent default scrolling if vertical scrolling is
      // actually possible. Otherwise, it causes vertical scroll
      // jitter on OSX trackpads when deltaX is small and deltaY
      // is large (issue #3579)
      if (!dy || (dy && canScrollY))
        { e_preventDefault(e); }
      display.wheelStartX = null; // Abort measurement, if in progress
      return
    }

    // 'Project' the visible viewport to cover the area that is being
    // scrolled into view (if we know enough to estimate it).
    if (dy && wheelPixelsPerUnit != null) {
      var pixels = dy * wheelPixelsPerUnit;
      var top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight;
      if (pixels < 0) { top = Math.max(0, top + pixels - 50); }
      else { bot = Math.min(cm.doc.height, bot + pixels + 50); }
      updateDisplaySimple(cm, {top: top, bottom: bot});
    }

    if (wheelSamples < 20) {
      if (display.wheelStartX == null) {
        display.wheelStartX = scroll.scrollLeft; display.wheelStartY = scroll.scrollTop;
        display.wheelDX = dx; display.wheelDY = dy;
        setTimeout(function () {
          if (display.wheelStartX == null) { return }
          var movedX = scroll.scrollLeft - display.wheelStartX;
          var movedY = scroll.scrollTop - display.wheelStartY;
          var sample = (movedY && display.wheelDY && movedY / display.wheelDY) ||
            (movedX && display.wheelDX && movedX / display.wheelDX);
          display.wheelStartX = display.wheelStartY = null;
          if (!sample) { return }
          wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);
          ++wheelSamples;
        }, 200);
      } else {
        display.wheelDX += dx; display.wheelDY += dy;
      }
    }
  }

  // Selection objects are immutable. A new one is created every time
  // the selection changes. A selection is one or more non-overlapping
  // (and non-touching) ranges, sorted, and an integer that indicates
  // which one is the primary selection (the one that's scrolled into
  // view, that getCursor returns, etc).
  var Selection = function(ranges, primIndex) {
    this.ranges = ranges;
    this.primIndex = primIndex;
  };

  Selection.prototype.primary = function () { return this.ranges[this.primIndex] };

  Selection.prototype.equals = function (other) {
    if (other == this) { return true }
    if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) { return false }
    for (var i = 0; i < this.ranges.length; i++) {
      var here = this.ranges[i], there = other.ranges[i];
      if (!equalCursorPos(here.anchor, there.anchor) || !equalCursorPos(here.head, there.head)) { return false }
    }
    return true
  };

  Selection.prototype.deepCopy = function () {
    var out = [];
    for (var i = 0; i < this.ranges.length; i++)
      { out[i] = new Range(copyPos(this.ranges[i].anchor), copyPos(this.ranges[i].head)); }
    return new Selection(out, this.primIndex)
  };

  Selection.prototype.somethingSelected = function () {
    for (var i = 0; i < this.ranges.length; i++)
      { if (!this.ranges[i].empty()) { return true } }
    return false
  };

  Selection.prototype.contains = function (pos, end) {
    if (!end) { end = pos; }
    for (var i = 0; i < this.ranges.length; i++) {
      var range = this.ranges[i];
      if (cmp(end, range.from()) >= 0 && cmp(pos, range.to()) <= 0)
        { return i }
    }
    return -1
  };

  var Range = function(anchor, head) {
    this.anchor = anchor; this.head = head;
  };

  Range.prototype.from = function () { return minPos(this.anchor, this.head) };
  Range.prototype.to = function () { return maxPos(this.anchor, this.head) };
  Range.prototype.empty = function () { return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch };

  // Take an unsorted, potentially overlapping set of ranges, and
  // build a selection out of it. 'Consumes' ranges array (modifying
  // it).
  function normalizeSelection(cm, ranges, primIndex) {
    var mayTouch = cm && cm.options.selectionsMayTouch;
    var prim = ranges[primIndex];
    ranges.sort(function (a, b) { return cmp(a.from(), b.from()); });
    primIndex = indexOf(ranges, prim);
    for (var i = 1; i < ranges.length; i++) {
      var cur = ranges[i], prev = ranges[i - 1];
      var diff = cmp(prev.to(), cur.from());
      if (mayTouch && !cur.empty() ? diff > 0 : diff >= 0) {
        var from = minPos(prev.from(), cur.from()), to = maxPos(prev.to(), cur.to());
        var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;
        if (i <= primIndex) { --primIndex; }
        ranges.splice(--i, 2, new Range(inv ? to : from, inv ? from : to));
      }
    }
    return new Selection(ranges, primIndex)
  }

  function simpleSelection(anchor, head) {
    return new Selection([new Range(anchor, head || anchor)], 0)
  }

  // Compute the position of the end of a change (its 'to' property
  // refers to the pre-change end).
  function changeEnd(change) {
    if (!change.text) { return change.to }
    return Pos(change.from.line + change.text.length - 1,
               lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0))
  }

  // Adjust a position to refer to the post-change position of the
  // same text, or the end of the change if the change covers it.
  function adjustForChange(pos, change) {
    if (cmp(pos, change.from) < 0) { return pos }
    if (cmp(pos, change.to) <= 0) { return changeEnd(change) }

    var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;
    if (pos.line == change.to.line) { ch += changeEnd(change).ch - change.to.ch; }
    return Pos(line, ch)
  }

  function computeSelAfterChange(doc, change) {
    var out = [];
    for (var i = 0; i < doc.sel.ranges.length; i++) {
      var range = doc.sel.ranges[i];
      out.push(new Range(adjustForChange(range.anchor, change),
                         adjustForChange(range.head, change)));
    }
    return normalizeSelection(doc.cm, out, doc.sel.primIndex)
  }

  function offsetPos(pos, old, nw) {
    if (pos.line == old.line)
      { return Pos(nw.line, pos.ch - old.ch + nw.ch) }
    else
      { return Pos(nw.line + (pos.line - old.line), pos.ch) }
  }

  // Used by replaceSelections to allow moving the selection to the
  // start or around the replaced test. Hint may be "start" or "around".
  function computeReplacedSel(doc, changes, hint) {
    var out = [];
    var oldPrev = Pos(doc.first, 0), newPrev = oldPrev;
    for (var i = 0; i < changes.length; i++) {
      var change = changes[i];
      var from = offsetPos(change.from, oldPrev, newPrev);
      var to = offsetPos(changeEnd(change), oldPrev, newPrev);
      oldPrev = change.to;
      newPrev = to;
      if (hint == "around") {
        var range = doc.sel.ranges[i], inv = cmp(range.head, range.anchor) < 0;
        out[i] = new Range(inv ? to : from, inv ? from : to);
      } else {
        out[i] = new Range(from, from);
      }
    }
    return new Selection(out, doc.sel.primIndex)
  }

  // Used to get the editor into a consistent state again when options change.

  function loadMode(cm) {
    cm.doc.mode = getMode(cm.options, cm.doc.modeOption);
    resetModeState(cm);
  }

  function resetModeState(cm) {
    cm.doc.iter(function (line) {
      if (line.stateAfter) { line.stateAfter = null; }
      if (line.styles) { line.styles = null; }
    });
    cm.doc.modeFrontier = cm.doc.highlightFrontier = cm.doc.first;
    startWorker(cm, 100);
    cm.state.modeGen++;
    if (cm.curOp) { regChange(cm); }
  }

  // DOCUMENT DATA STRUCTURE

  // By default, updates that start and end at the beginning of a line
  // are treated specially, in order to make the association of line
  // widgets and marker elements with the text behave more intuitive.
  function isWholeLineUpdate(doc, change) {
    return change.from.ch == 0 && change.to.ch == 0 && lst(change.text) == "" &&
      (!doc.cm || doc.cm.options.wholeLineUpdateBefore)
  }

  // Perform a change on the document data structure.
  function updateDoc(doc, change, markedSpans, estimateHeight) {
    function spansFor(n) {return markedSpans ? markedSpans[n] : null}
    function update(line, text, spans) {
      updateLine(line, text, spans, estimateHeight);
      signalLater(line, "change", line, change);
    }
    function linesFor(start, end) {
      var result = [];
      for (var i = start; i < end; ++i)
        { result.push(new Line(text[i], spansFor(i), estimateHeight)); }
      return result
    }

    var from = change.from, to = change.to, text = change.text;
    var firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line);
    var lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line;

    // Adjust the line structure
    if (change.full) {
      doc.insert(0, linesFor(0, text.length));
      doc.remove(text.length, doc.size - text.length);
    } else if (isWholeLineUpdate(doc, change)) {
      // This is a whole-line replace. Treated specially to make
      // sure line objects move the way they are supposed to.
      var added = linesFor(0, text.length - 1);
      update(lastLine, lastLine.text, lastSpans);
      if (nlines) { doc.remove(from.line, nlines); }
      if (added.length) { doc.insert(from.line, added); }
    } else if (firstLine == lastLine) {
      if (text.length == 1) {
        update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);
      } else {
        var added$1 = linesFor(1, text.length - 1);
        added$1.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight));
        update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
        doc.insert(from.line + 1, added$1);
      }
    } else if (text.length == 1) {
      update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));
      doc.remove(from.line + 1, nlines);
    } else {
      update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
      update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);
      var added$2 = linesFor(1, text.length - 1);
      if (nlines > 1) { doc.remove(from.line + 1, nlines - 1); }
      doc.insert(from.line + 1, added$2);
    }

    signalLater(doc, "change", doc, change);
  }

  // Call f for all linked documents.
  function linkedDocs(doc, f, sharedHistOnly) {
    function propagate(doc, skip, sharedHist) {
      if (doc.linked) { for (var i = 0; i < doc.linked.length; ++i) {
        var rel = doc.linked[i];
        if (rel.doc == skip) { continue }
        var shared = sharedHist && rel.sharedHist;
        if (sharedHistOnly && !shared) { continue }
        f(rel.doc, shared);
        propagate(rel.doc, doc, shared);
      } }
    }
    propagate(doc, null, true);
  }

  // Attach a document to an editor.
  function attachDoc(cm, doc) {
    if (doc.cm) { throw new Error("This document is already in use.") }
    cm.doc = doc;
    doc.cm = cm;
    estimateLineHeights(cm);
    loadMode(cm);
    setDirectionClass(cm);
    if (!cm.options.lineWrapping) { findMaxLine(cm); }
    cm.options.mode = doc.modeOption;
    regChange(cm);
  }

  function setDirectionClass(cm) {
  (cm.doc.direction == "rtl" ? addClass : rmClass)(cm.display.lineDiv, "CodeMirror-rtl");
  }

  function directionChanged(cm) {
    runInOp(cm, function () {
      setDirectionClass(cm);
      regChange(cm);
    });
  }

  function History(startGen) {
    // Arrays of change events and selections. Doing something adds an
    // event to done and clears undo. Undoing moves events from done
    // to undone, redoing moves them in the other direction.
    this.done = []; this.undone = [];
    this.undoDepth = Infinity;
    // Used to track when changes can be merged into a single undo
    // event
    this.lastModTime = this.lastSelTime = 0;
    this.lastOp = this.lastSelOp = null;
    this.lastOrigin = this.lastSelOrigin = null;
    // Used by the isClean() method
    this.generation = this.maxGeneration = startGen || 1;
  }

  // Create a history change event from an updateDoc-style change
  // object.
  function historyChangeFromChange(doc, change) {
    var histChange = {from: copyPos(change.from), to: changeEnd(change), text: getBetween(doc, change.from, change.to)};
    attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);
    linkedDocs(doc, function (doc) { return attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1); }, true);
    return histChange
  }

  // Pop all selection events off the end of a history array. Stop at
  // a change event.
  function clearSelectionEvents(array) {
    while (array.length) {
      var last = lst(array);
      if (last.ranges) { array.pop(); }
      else { break }
    }
  }

  // Find the top change event in the history. Pop off selection
  // events that are in the way.
  function lastChangeEvent(hist, force) {
    if (force) {
      clearSelectionEvents(hist.done);
      return lst(hist.done)
    } else if (hist.done.length && !lst(hist.done).ranges) {
      return lst(hist.done)
    } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {
      hist.done.pop();
      return lst(hist.done)
    }
  }

  // Register a change in the history. Merges changes that are within
  // a single operation, or are close together with an origin that
  // allows merging (starting with "+") into a single event.
  function addChangeToHistory(doc, change, selAfter, opId) {
    var hist = doc.history;
    hist.undone.length = 0;
    var time = +new Date, cur;
    var last;

    if ((hist.lastOp == opId ||
         hist.lastOrigin == change.origin && change.origin &&
         ((change.origin.charAt(0) == "+" && hist.lastModTime > time - (doc.cm ? doc.cm.options.historyEventDelay : 500)) ||
          change.origin.charAt(0) == "*")) &&
        (cur = lastChangeEvent(hist, hist.lastOp == opId))) {
      // Merge this change into the last event
      last = lst(cur.changes);
      if (cmp(change.from, change.to) == 0 && cmp(change.from, last.to) == 0) {
        // Optimized case for simple insertion -- don't want to add
        // new changesets for every character typed
        last.to = changeEnd(change);
      } else {
        // Add new sub-event
        cur.changes.push(historyChangeFromChange(doc, change));
      }
    } else {
      // Can not be merged, start a new event.
      var before = lst(hist.done);
      if (!before || !before.ranges)
        { pushSelectionToHistory(doc.sel, hist.done); }
      cur = {changes: [historyChangeFromChange(doc, change)],
             generation: hist.generation};
      hist.done.push(cur);
      while (hist.done.length > hist.undoDepth) {
        hist.done.shift();
        if (!hist.done[0].ranges) { hist.done.shift(); }
      }
    }
    hist.done.push(selAfter);
    hist.generation = ++hist.maxGeneration;
    hist.lastModTime = hist.lastSelTime = time;
    hist.lastOp = hist.lastSelOp = opId;
    hist.lastOrigin = hist.lastSelOrigin = change.origin;

    if (!last) { signal(doc, "historyAdded"); }
  }

  function selectionEventCanBeMerged(doc, origin, prev, sel) {
    var ch = origin.charAt(0);
    return ch == "*" ||
      ch == "+" &&
      prev.ranges.length == sel.ranges.length &&
      prev.somethingSelected() == sel.somethingSelected() &&
      new Date - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500)
  }

  // Called whenever the selection changes, sets the new selection as
  // the pending selection in the history, and pushes the old pending
  // selection into the 'done' array when it was significantly
  // different (in number of selected ranges, emptiness, or time).
  function addSelectionToHistory(doc, sel, opId, options) {
    var hist = doc.history, origin = options && options.origin;

    // A new event is started when the previous origin does not match
    // the current, or the origins don't allow matching. Origins
    // starting with * are always merged, those starting with + are
    // merged when similar and close together in time.
    if (opId == hist.lastSelOp ||
        (origin && hist.lastSelOrigin == origin &&
         (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin ||
          selectionEventCanBeMerged(doc, origin, lst(hist.done), sel))))
      { hist.done[hist.done.length - 1] = sel; }
    else
      { pushSelectionToHistory(sel, hist.done); }

    hist.lastSelTime = +new Date;
    hist.lastSelOrigin = origin;
    hist.lastSelOp = opId;
    if (options && options.clearRedo !== false)
      { clearSelectionEvents(hist.undone); }
  }

  function pushSelectionToHistory(sel, dest) {
    var top = lst(dest);
    if (!(top && top.ranges && top.equals(sel)))
      { dest.push(sel); }
  }

  // Used to store marked span information in the history.
  function attachLocalSpans(doc, change, from, to) {
    var existing = change["spans_" + doc.id], n = 0;
    doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function (line) {
      if (line.markedSpans)
        { (existing || (existing = change["spans_" + doc.id] = {}))[n] = line.markedSpans; }
      ++n;
    });
  }

  // When un/re-doing restores text containing marked spans, those
  // that have been explicitly cleared should not be restored.
  function removeClearedSpans(spans) {
    if (!spans) { return null }
    var out;
    for (var i = 0; i < spans.length; ++i) {
      if (spans[i].marker.explicitlyCleared) { if (!out) { out = spans.slice(0, i); } }
      else if (out) { out.push(spans[i]); }
    }
    return !out ? spans : out.length ? out : null
  }

  // Retrieve and filter the old marked spans stored in a change event.
  function getOldSpans(doc, change) {
    var found = change["spans_" + doc.id];
    if (!found) { return null }
    var nw = [];
    for (var i = 0; i < change.text.length; ++i)
      { nw.push(removeClearedSpans(found[i])); }
    return nw
  }

  // Used for un/re-doing changes from the history. Combines the
  // result of computing the existing spans with the set of spans that
  // existed in the history (so that deleting around a span and then
  // undoing brings back the span).
  function mergeOldSpans(doc, change) {
    var old = getOldSpans(doc, change);
    var stretched = stretchSpansOverChange(doc, change);
    if (!old) { return stretched }
    if (!stretched) { return old }

    for (var i = 0; i < old.length; ++i) {
      var oldCur = old[i], stretchCur = stretched[i];
      if (oldCur && stretchCur) {
        spans: for (var j = 0; j < stretchCur.length; ++j) {
          var span = stretchCur[j];
          for (var k = 0; k < oldCur.length; ++k)
            { if (oldCur[k].marker == span.marker) { continue spans } }
          oldCur.push(span);
        }
      } else if (stretchCur) {
        old[i] = stretchCur;
      }
    }
    return old
  }

  // Used both to provide a JSON-safe object in .getHistory, and, when
  // detaching a document, to split the history in two
  function copyHistoryArray(events, newGroup, instantiateSel) {
    var copy = [];
    for (var i = 0; i < events.length; ++i) {
      var event = events[i];
      if (event.ranges) {
        copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event);
        continue
      }
      var changes = event.changes, newChanges = [];
      copy.push({changes: newChanges});
      for (var j = 0; j < changes.length; ++j) {
        var change = changes[j], m = (void 0);
        newChanges.push({from: change.from, to: change.to, text: change.text});
        if (newGroup) { for (var prop in change) { if (m = prop.match(/^spans_(\d+)$/)) {
          if (indexOf(newGroup, Number(m[1])) > -1) {
            lst(newChanges)[prop] = change[prop];
            delete change[prop];
          }
        } } }
      }
    }
    return copy
  }

  // The 'scroll' parameter given to many of these indicated whether
  // the new cursor position should be scrolled into view after
  // modifying the selection.

  // If shift is held or the extend flag is set, extends a range to
  // include a given position (and optionally a second position).
  // Otherwise, simply returns the range between the given positions.
  // Used for cursor motion and such.
  function extendRange(range, head, other, extend) {
    if (extend) {
      var anchor = range.anchor;
      if (other) {
        var posBefore = cmp(head, anchor) < 0;
        if (posBefore != (cmp(other, anchor) < 0)) {
          anchor = head;
          head = other;
        } else if (posBefore != (cmp(head, other) < 0)) {
          head = other;
        }
      }
      return new Range(anchor, head)
    } else {
      return new Range(other || head, head)
    }
  }

  // Extend the primary selection range, discard the rest.
  function extendSelection(doc, head, other, options, extend) {
    if (extend == null) { extend = doc.cm && (doc.cm.display.shift || doc.extend); }
    setSelection(doc, new Selection([extendRange(doc.sel.primary(), head, other, extend)], 0), options);
  }

  // Extend all selections (pos is an array of selections with length
  // equal the number of selections)
  function extendSelections(doc, heads, options) {
    var out = [];
    var extend = doc.cm && (doc.cm.display.shift || doc.extend);
    for (var i = 0; i < doc.sel.ranges.length; i++)
      { out[i] = extendRange(doc.sel.ranges[i], heads[i], null, extend); }
    var newSel = normalizeSelection(doc.cm, out, doc.sel.primIndex);
    setSelection(doc, newSel, options);
  }

  // Updates a single range in the selection.
  function replaceOneSelection(doc, i, range, options) {
    var ranges = doc.sel.ranges.slice(0);
    ranges[i] = range;
    setSelection(doc, normalizeSelection(doc.cm, ranges, doc.sel.primIndex), options);
  }

  // Reset the selection to a single range.
  function setSimpleSelection(doc, anchor, head, options) {
    setSelection(doc, simpleSelection(anchor, head), options);
  }

  // Give beforeSelectionChange handlers a change to influence a
  // selection update.
  function filterSelectionChange(doc, sel, options) {
    var obj = {
      ranges: sel.ranges,
      update: function(ranges) {
        this.ranges = [];
        for (var i = 0; i < ranges.length; i++)
          { this.ranges[i] = new Range(clipPos(doc, ranges[i].anchor),
                                     clipPos(doc, ranges[i].head)); }
      },
      origin: options && options.origin
    };
    signal(doc, "beforeSelectionChange", doc, obj);
    if (doc.cm) { signal(doc.cm, "beforeSelectionChange", doc.cm, obj); }
    if (obj.ranges != sel.ranges) { return normalizeSelection(doc.cm, obj.ranges, obj.ranges.length - 1) }
    else { return sel }
  }

  function setSelectionReplaceHistory(doc, sel, options) {
    var done = doc.history.done, last = lst(done);
    if (last && last.ranges) {
      done[done.length - 1] = sel;
      setSelectionNoUndo(doc, sel, options);
    } else {
      setSelection(doc, sel, options);
    }
  }

  // Set a new selection.
  function setSelection(doc, sel, options) {
    setSelectionNoUndo(doc, sel, options);
    addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options);
  }

  function setSelectionNoUndo(doc, sel, options) {
    if (hasHandler(doc, "beforeSelectionChange") || doc.cm && hasHandler(doc.cm, "beforeSelectionChange"))
      { sel = filterSelectionChange(doc, sel, options); }

    var bias = options && options.bias ||
      (cmp(sel.primary().head, doc.sel.primary().head) < 0 ? -1 : 1);
    setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, true));

    if (!(options && options.scroll === false) && doc.cm)
      { ensureCursorVisible(doc.cm); }
  }

  function setSelectionInner(doc, sel) {
    if (sel.equals(doc.sel)) { return }

    doc.sel = sel;

    if (doc.cm) {
      doc.cm.curOp.updateInput = 1;
      doc.cm.curOp.selectionChanged = true;
      signalCursorActivity(doc.cm);
    }
    signalLater(doc, "cursorActivity", doc);
  }

  // Verify that the selection does not partially select any atomic
  // marked ranges.
  function reCheckSelection(doc) {
    setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, false));
  }

  // Return a selection that does not partially select any atomic
  // ranges.
  function skipAtomicInSelection(doc, sel, bias, mayClear) {
    var out;
    for (var i = 0; i < sel.ranges.length; i++) {
      var range = sel.ranges[i];
      var old = sel.ranges.length == doc.sel.ranges.length && doc.sel.ranges[i];
      var newAnchor = skipAtomic(doc, range.anchor, old && old.anchor, bias, mayClear);
      var newHead = skipAtomic(doc, range.head, old && old.head, bias, mayClear);
      if (out || newAnchor != range.anchor || newHead != range.head) {
        if (!out) { out = sel.ranges.slice(0, i); }
        out[i] = new Range(newAnchor, newHead);
      }
    }
    return out ? normalizeSelection(doc.cm, out, sel.primIndex) : sel
  }

  function skipAtomicInner(doc, pos, oldPos, dir, mayClear) {
    var line = getLine(doc, pos.line);
    if (line.markedSpans) { for (var i = 0; i < line.markedSpans.length; ++i) {
      var sp = line.markedSpans[i], m = sp.marker;

      // Determine if we should prevent the cursor being placed to the left/right of an atomic marker
      // Historically this was determined using the inclusiveLeft/Right option, but the new way to control it
      // is with selectLeft/Right
      var preventCursorLeft = ("selectLeft" in m) ? !m.selectLeft : m.inclusiveLeft;
      var preventCursorRight = ("selectRight" in m) ? !m.selectRight : m.inclusiveRight;

      if ((sp.from == null || (preventCursorLeft ? sp.from <= pos.ch : sp.from < pos.ch)) &&
          (sp.to == null || (preventCursorRight ? sp.to >= pos.ch : sp.to > pos.ch))) {
        if (mayClear) {
          signal(m, "beforeCursorEnter");
          if (m.explicitlyCleared) {
            if (!line.markedSpans) { break }
            else {--i; continue}
          }
        }
        if (!m.atomic) { continue }

        if (oldPos) {
          var near = m.find(dir < 0 ? 1 : -1), diff = (void 0);
          if (dir < 0 ? preventCursorRight : preventCursorLeft)
            { near = movePos(doc, near, -dir, near && near.line == pos.line ? line : null); }
          if (near && near.line == pos.line && (diff = cmp(near, oldPos)) && (dir < 0 ? diff < 0 : diff > 0))
            { return skipAtomicInner(doc, near, pos, dir, mayClear) }
        }

        var far = m.find(dir < 0 ? -1 : 1);
        if (dir < 0 ? preventCursorLeft : preventCursorRight)
          { far = movePos(doc, far, dir, far.line == pos.line ? line : null); }
        return far ? skipAtomicInner(doc, far, pos, dir, mayClear) : null
      }
    } }
    return pos
  }

  // Ensure a given position is not inside an atomic range.
  function skipAtomic(doc, pos, oldPos, bias, mayClear) {
    var dir = bias || 1;
    var found = skipAtomicInner(doc, pos, oldPos, dir, mayClear) ||
        (!mayClear && skipAtomicInner(doc, pos, oldPos, dir, true)) ||
        skipAtomicInner(doc, pos, oldPos, -dir, mayClear) ||
        (!mayClear && skipAtomicInner(doc, pos, oldPos, -dir, true));
    if (!found) {
      doc.cantEdit = true;
      return Pos(doc.first, 0)
    }
    return found
  }

  function movePos(doc, pos, dir, line) {
    if (dir < 0 && pos.ch == 0) {
      if (pos.line > doc.first) { return clipPos(doc, Pos(pos.line - 1)) }
      else { return null }
    } else if (dir > 0 && pos.ch == (line || getLine(doc, pos.line)).text.length) {
      if (pos.line < doc.first + doc.size - 1) { return Pos(pos.line + 1, 0) }
      else { return null }
    } else {
      return new Pos(pos.line, pos.ch + dir)
    }
  }

  function selectAll(cm) {
    cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll);
  }

  // UPDATING

  // Allow "beforeChange" event handlers to influence a change
  function filterChange(doc, change, update) {
    var obj = {
      canceled: false,
      from: change.from,
      to: change.to,
      text: change.text,
      origin: change.origin,
      cancel: function () { return obj.canceled = true; }
    };
    if (update) { obj.update = function (from, to, text, origin) {
      if (from) { obj.from = clipPos(doc, from); }
      if (to) { obj.to = clipPos(doc, to); }
      if (text) { obj.text = text; }
      if (origin !== undefined) { obj.origin = origin; }
    }; }
    signal(doc, "beforeChange", doc, obj);
    if (doc.cm) { signal(doc.cm, "beforeChange", doc.cm, obj); }

    if (obj.canceled) {
      if (doc.cm) { doc.cm.curOp.updateInput = 2; }
      return null
    }
    return {from: obj.from, to: obj.to, text: obj.text, origin: obj.origin}
  }

  // Apply a change to a document, and add it to the document's
  // history, and propagating it to all linked documents.
  function makeChange(doc, change, ignoreReadOnly) {
    if (doc.cm) {
      if (!doc.cm.curOp) { return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly) }
      if (doc.cm.state.suppressEdits) { return }
    }

    if (hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange")) {
      change = filterChange(doc, change, true);
      if (!change) { return }
    }

    // Possibly split or suppress the update based on the presence
    // of read-only spans in its range.
    var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);
    if (split) {
      for (var i = split.length - 1; i >= 0; --i)
        { makeChangeInner(doc, {from: split[i].from, to: split[i].to, text: i ? [""] : change.text, origin: change.origin}); }
    } else {
      makeChangeInner(doc, change);
    }
  }

  function makeChangeInner(doc, change) {
    if (change.text.length == 1 && change.text[0] == "" && cmp(change.from, change.to) == 0) { return }
    var selAfter = computeSelAfterChange(doc, change);
    addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);

    makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));
    var rebased = [];

    linkedDocs(doc, function (doc, sharedHist) {
      if (!sharedHist && indexOf(rebased, doc.history) == -1) {
        rebaseHist(doc.history, change);
        rebased.push(doc.history);
      }
      makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));
    });
  }

  // Revert a change stored in a document's history.
  function makeChangeFromHistory(doc, type, allowSelectionOnly) {
    var suppress = doc.cm && doc.cm.state.suppressEdits;
    if (suppress && !allowSelectionOnly) { return }

    var hist = doc.history, event, selAfter = doc.sel;
    var source = type == "undo" ? hist.done : hist.undone, dest = type == "undo" ? hist.undone : hist.done;

    // Verify that there is a useable event (so that ctrl-z won't
    // needlessly clear selection events)
    var i = 0;
    for (; i < source.length; i++) {
      event = source[i];
      if (allowSelectionOnly ? event.ranges && !event.equals(doc.sel) : !event.ranges)
        { break }
    }
    if (i == source.length) { return }
    hist.lastOrigin = hist.lastSelOrigin = null;

    for (;;) {
      event = source.pop();
      if (event.ranges) {
        pushSelectionToHistory(event, dest);
        if (allowSelectionOnly && !event.equals(doc.sel)) {
          setSelection(doc, event, {clearRedo: false});
          return
        }
        selAfter = event;
      } else if (suppress) {
        source.push(event);
        return
      } else { break }
    }

    // Build up a reverse change object to add to the opposite history
    // stack (redo when undoing, and vice versa).
    var antiChanges = [];
    pushSelectionToHistory(selAfter, dest);
    dest.push({changes: antiChanges, generation: hist.generation});
    hist.generation = event.generation || ++hist.maxGeneration;

    var filter = hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange");

    var loop = function ( i ) {
      var change = event.changes[i];
      change.origin = type;
      if (filter && !filterChange(doc, change, false)) {
        source.length = 0;
        return {}
      }

      antiChanges.push(historyChangeFromChange(doc, change));

      var after = i ? computeSelAfterChange(doc, change) : lst(source);
      makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));
      if (!i && doc.cm) { doc.cm.scrollIntoView({from: change.from, to: changeEnd(change)}); }
      var rebased = [];

      // Propagate to the linked documents
      linkedDocs(doc, function (doc, sharedHist) {
        if (!sharedHist && indexOf(rebased, doc.history) == -1) {
          rebaseHist(doc.history, change);
          rebased.push(doc.history);
        }
        makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));
      });
    };

    for (var i$1 = event.changes.length - 1; i$1 >= 0; --i$1) {
      var returned = loop( i$1 );

      if ( returned ) return returned.v;
    }
  }

  // Sub-views need their line numbers shifted when text is added
  // above or below them in the parent document.
  function shiftDoc(doc, distance) {
    if (distance == 0) { return }
    doc.first += distance;
    doc.sel = new Selection(map(doc.sel.ranges, function (range) { return new Range(
      Pos(range.anchor.line + distance, range.anchor.ch),
      Pos(range.head.line + distance, range.head.ch)
    ); }), doc.sel.primIndex);
    if (doc.cm) {
      regChange(doc.cm, doc.first, doc.first - distance, distance);
      for (var d = doc.cm.display, l = d.viewFrom; l < d.viewTo; l++)
        { regLineChange(doc.cm, l, "gutter"); }
    }
  }

  // More lower-level change function, handling only a single document
  // (not linked ones).
  function makeChangeSingleDoc(doc, change, selAfter, spans) {
    if (doc.cm && !doc.cm.curOp)
      { return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans) }

    if (change.to.line < doc.first) {
      shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));
      return
    }
    if (change.from.line > doc.lastLine()) { return }

    // Clip the change to the size of this doc
    if (change.from.line < doc.first) {
      var shift = change.text.length - 1 - (doc.first - change.from.line);
      shiftDoc(doc, shift);
      change = {from: Pos(doc.first, 0), to: Pos(change.to.line + shift, change.to.ch),
                text: [lst(change.text)], origin: change.origin};
    }
    var last = doc.lastLine();
    if (change.to.line > last) {
      change = {from: change.from, to: Pos(last, getLine(doc, last).text.length),
                text: [change.text[0]], origin: change.origin};
    }

    change.removed = getBetween(doc, change.from, change.to);

    if (!selAfter) { selAfter = computeSelAfterChange(doc, change); }
    if (doc.cm) { makeChangeSingleDocInEditor(doc.cm, change, spans); }
    else { updateDoc(doc, change, spans); }
    setSelectionNoUndo(doc, selAfter, sel_dontScroll);

    if (doc.cantEdit && skipAtomic(doc, Pos(doc.firstLine(), 0)))
      { doc.cantEdit = false; }
  }

  // Handle the interaction of a change to a document with the editor
  // that this document is part of.
  function makeChangeSingleDocInEditor(cm, change, spans) {
    var doc = cm.doc, display = cm.display, from = change.from, to = change.to;

    var recomputeMaxLength = false, checkWidthStart = from.line;
    if (!cm.options.lineWrapping) {
      checkWidthStart = lineNo(visualLine(getLine(doc, from.line)));
      doc.iter(checkWidthStart, to.line + 1, function (line) {
        if (line == display.maxLine) {
          recomputeMaxLength = true;
          return true
        }
      });
    }

    if (doc.sel.contains(change.from, change.to) > -1)
      { signalCursorActivity(cm); }

    updateDoc(doc, change, spans, estimateHeight(cm));

    if (!cm.options.lineWrapping) {
      doc.iter(checkWidthStart, from.line + change.text.length, function (line) {
        var len = lineLength(line);
        if (len > display.maxLineLength) {
          display.maxLine = line;
          display.maxLineLength = len;
          display.maxLineChanged = true;
          recomputeMaxLength = false;
        }
      });
      if (recomputeMaxLength) { cm.curOp.updateMaxLine = true; }
    }

    retreatFrontier(doc, from.line);
    startWorker(cm, 400);

    var lendiff = change.text.length - (to.line - from.line) - 1;
    // Remember that these lines changed, for updating the display
    if (change.full)
      { regChange(cm); }
    else if (from.line == to.line && change.text.length == 1 && !isWholeLineUpdate(cm.doc, change))
      { regLineChange(cm, from.line, "text"); }
    else
      { regChange(cm, from.line, to.line + 1, lendiff); }

    var changesHandler = hasHandler(cm, "changes"), changeHandler = hasHandler(cm, "change");
    if (changeHandler || changesHandler) {
      var obj = {
        from: from, to: to,
        text: change.text,
        removed: change.removed,
        origin: change.origin
      };
      if (changeHandler) { signalLater(cm, "change", cm, obj); }
      if (changesHandler) { (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj); }
    }
    cm.display.selForContextMenu = null;
  }

  function replaceRange(doc, code, from, to, origin) {
    var assign;

    if (!to) { to = from; }
    if (cmp(to, from) < 0) { (assign = [to, from], from = assign[0], to = assign[1]); }
    if (typeof code == "string") { code = doc.splitLines(code); }
    makeChange(doc, {from: from, to: to, text: code, origin: origin});
  }

  // Rebasing/resetting history to deal with externally-sourced changes

  function rebaseHistSelSingle(pos, from, to, diff) {
    if (to < pos.line) {
      pos.line += diff;
    } else if (from < pos.line) {
      pos.line = from;
      pos.ch = 0;
    }
  }

  // Tries to rebase an array of history events given a change in the
  // document. If the change touches the same lines as the event, the
  // event, and everything 'behind' it, is discarded. If the change is
  // before the event, the event's positions are updated. Uses a
  // copy-on-write scheme for the positions, to avoid having to
  // reallocate them all on every rebase, but also avoid problems with
  // shared position objects being unsafely updated.
  function rebaseHistArray(array, from, to, diff) {
    for (var i = 0; i < array.length; ++i) {
      var sub = array[i], ok = true;
      if (sub.ranges) {
        if (!sub.copied) { sub = array[i] = sub.deepCopy(); sub.copied = true; }
        for (var j = 0; j < sub.ranges.length; j++) {
          rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff);
          rebaseHistSelSingle(sub.ranges[j].head, from, to, diff);
        }
        continue
      }
      for (var j$1 = 0; j$1 < sub.changes.length; ++j$1) {
        var cur = sub.changes[j$1];
        if (to < cur.from.line) {
          cur.from = Pos(cur.from.line + diff, cur.from.ch);
          cur.to = Pos(cur.to.line + diff, cur.to.ch);
        } else if (from <= cur.to.line) {
          ok = false;
          break
        }
      }
      if (!ok) {
        array.splice(0, i + 1);
        i = 0;
      }
    }
  }

  function rebaseHist(hist, change) {
    var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;
    rebaseHistArray(hist.done, from, to, diff);
    rebaseHistArray(hist.undone, from, to, diff);
  }

  // Utility for applying a change to a line by handle or number,
  // returning the number and optionally registering the line as
  // changed.
  function changeLine(doc, handle, changeType, op) {
    var no = handle, line = handle;
    if (typeof handle == "number") { line = getLine(doc, clipLine(doc, handle)); }
    else { no = lineNo(handle); }
    if (no == null) { return null }
    if (op(line, no) && doc.cm) { regLineChange(doc.cm, no, changeType); }
    return line
  }

  // The document is represented as a BTree consisting of leaves, with
  // chunk of lines in them, and branches, with up to ten leaves or
  // other branch nodes below them. The top node is always a branch
  // node, and is the document object itself (meaning it has
  // additional methods and properties).
  //
  // All nodes have parent links. The tree is used both to go from
  // line numbers to line objects, and to go from objects to numbers.
  // It also indexes by height, and is used to convert between height
  // and line object, and to find the total height of the document.
  //
  // See also http://marijnhaverbeke.nl/blog/codemirror-line-tree.html

  function LeafChunk(lines) {
    this.lines = lines;
    this.parent = null;
    var height = 0;
    for (var i = 0; i < lines.length; ++i) {
      lines[i].parent = this;
      height += lines[i].height;
    }
    this.height = height;
  }

  LeafChunk.prototype = {
    chunkSize: function() { return this.lines.length },

    // Remove the n lines at offset 'at'.
    removeInner: function(at, n) {
      for (var i = at, e = at + n; i < e; ++i) {
        var line = this.lines[i];
        this.height -= line.height;
        cleanUpLine(line);
        signalLater(line, "delete");
      }
      this.lines.splice(at, n);
    },

    // Helper used to collapse a small branch into a single leaf.
    collapse: function(lines) {
      lines.push.apply(lines, this.lines);
    },

    // Insert the given array of lines at offset 'at', count them as
    // having the given height.
    insertInner: function(at, lines, height) {
      this.height += height;
      this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));
      for (var i = 0; i < lines.length; ++i) { lines[i].parent = this; }
    },

    // Used to iterate over a part of the tree.
    iterN: function(at, n, op) {
      for (var e = at + n; at < e; ++at)
        { if (op(this.lines[at])) { return true } }
    }
  };

  function BranchChunk(children) {
    this.children = children;
    var size = 0, height = 0;
    for (var i = 0; i < children.length; ++i) {
      var ch = children[i];
      size += ch.chunkSize(); height += ch.height;
      ch.parent = this;
    }
    this.size = size;
    this.height = height;
    this.parent = null;
  }

  BranchChunk.prototype = {
    chunkSize: function() { return this.size },

    removeInner: function(at, n) {
      this.size -= n;
      for (var i = 0; i < this.children.length; ++i) {
        var child = this.children[i], sz = child.chunkSize();
        if (at < sz) {
          var rm = Math.min(n, sz - at), oldHeight = child.height;
          child.removeInner(at, rm);
          this.height -= oldHeight - child.height;
          if (sz == rm) { this.children.splice(i--, 1); child.parent = null; }
          if ((n -= rm) == 0) { break }
          at = 0;
        } else { at -= sz; }
      }
      // If the result is smaller than 25 lines, ensure that it is a
      // single leaf node.
      if (this.size - n < 25 &&
          (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {
        var lines = [];
        this.collapse(lines);
        this.children = [new LeafChunk(lines)];
        this.children[0].parent = this;
      }
    },

    collapse: function(lines) {
      for (var i = 0; i < this.children.length; ++i) { this.children[i].collapse(lines); }
    },

    insertInner: function(at, lines, height) {
      this.size += lines.length;
      this.height += height;
      for (var i = 0; i < this.children.length; ++i) {
        var child = this.children[i], sz = child.chunkSize();
        if (at <= sz) {
          child.insertInner(at, lines, height);
          if (child.lines && child.lines.length > 50) {
            // To avoid memory thrashing when child.lines is huge (e.g. first view of a large file), it's never spliced.
            // Instead, small slices are taken. They're taken in order because sequential memory accesses are fastest.
            var remaining = child.lines.length % 25 + 25;
            for (var pos = remaining; pos < child.lines.length;) {
              var leaf = new LeafChunk(child.lines.slice(pos, pos += 25));
              child.height -= leaf.height;
              this.children.splice(++i, 0, leaf);
              leaf.parent = this;
            }
            child.lines = child.lines.slice(0, remaining);
            this.maybeSpill();
          }
          break
        }
        at -= sz;
      }
    },

    // When a node has grown, check whether it should be split.
    maybeSpill: function() {
      if (this.children.length <= 10) { return }
      var me = this;
      do {
        var spilled = me.children.splice(me.children.length - 5, 5);
        var sibling = new BranchChunk(spilled);
        if (!me.parent) { // Become the parent node
          var copy = new BranchChunk(me.children);
          copy.parent = me;
          me.children = [copy, sibling];
          me = copy;
       } else {
          me.size -= sibling.size;
          me.height -= sibling.height;
          var myIndex = indexOf(me.parent.children, me);
          me.parent.children.splice(myIndex + 1, 0, sibling);
        }
        sibling.parent = me.parent;
      } while (me.children.length > 10)
      me.parent.maybeSpill();
    },

    iterN: function(at, n, op) {
      for (var i = 0; i < this.children.length; ++i) {
        var child = this.children[i], sz = child.chunkSize();
        if (at < sz) {
          var used = Math.min(n, sz - at);
          if (child.iterN(at, used, op)) { return true }
          if ((n -= used) == 0) { break }
          at = 0;
        } else { at -= sz; }
      }
    }
  };

  // Line widgets are block elements displayed above or below a line.

  var LineWidget = function(doc, node, options) {
    if (options) { for (var opt in options) { if (options.hasOwnProperty(opt))
      { this[opt] = options[opt]; } } }
    this.doc = doc;
    this.node = node;
  };

  LineWidget.prototype.clear = function () {
    var cm = this.doc.cm, ws = this.line.widgets, line = this.line, no = lineNo(line);
    if (no == null || !ws) { return }
    for (var i = 0; i < ws.length; ++i) { if (ws[i] == this) { ws.splice(i--, 1); } }
    if (!ws.length) { line.widgets = null; }
    var height = widgetHeight(this);
    updateLineHeight(line, Math.max(0, line.height - height));
    if (cm) {
      runInOp(cm, function () {
        adjustScrollWhenAboveVisible(cm, line, -height);
        regLineChange(cm, no, "widget");
      });
      signalLater(cm, "lineWidgetCleared", cm, this, no);
    }
  };

  LineWidget.prototype.changed = function () {
      var this$1 = this;

    var oldH = this.height, cm = this.doc.cm, line = this.line;
    this.height = null;
    var diff = widgetHeight(this) - oldH;
    if (!diff) { return }
    if (!lineIsHidden(this.doc, line)) { updateLineHeight(line, line.height + diff); }
    if (cm) {
      runInOp(cm, function () {
        cm.curOp.forceUpdate = true;
        adjustScrollWhenAboveVisible(cm, line, diff);
        signalLater(cm, "lineWidgetChanged", cm, this$1, lineNo(line));
      });
    }
  };
  eventMixin(LineWidget);

  function adjustScrollWhenAboveVisible(cm, line, diff) {
    if (heightAtLine(line) < ((cm.curOp && cm.curOp.scrollTop) || cm.doc.scrollTop))
      { addToScrollTop(cm, diff); }
  }

  function addLineWidget(doc, handle, node, options) {
    var widget = new LineWidget(doc, node, options);
    var cm = doc.cm;
    if (cm && widget.noHScroll) { cm.display.alignWidgets = true; }
    changeLine(doc, handle, "widget", function (line) {
      var widgets = line.widgets || (line.widgets = []);
      if (widget.insertAt == null) { widgets.push(widget); }
      else { widgets.splice(Math.min(widgets.length - 1, Math.max(0, widget.insertAt)), 0, widget); }
      widget.line = line;
      if (cm && !lineIsHidden(doc, line)) {
        var aboveVisible = heightAtLine(line) < doc.scrollTop;
        updateLineHeight(line, line.height + widgetHeight(widget));
        if (aboveVisible) { addToScrollTop(cm, widget.height); }
        cm.curOp.forceUpdate = true;
      }
      return true
    });
    if (cm) { signalLater(cm, "lineWidgetAdded", cm, widget, typeof handle == "number" ? handle : lineNo(handle)); }
    return widget
  }

  // TEXTMARKERS

  // Created with markText and setBookmark methods. A TextMarker is a
  // handle that can be used to clear or find a marked position in the
  // document. Line objects hold arrays (markedSpans) containing
  // {from, to, marker} object pointing to such marker objects, and
  // indicating that such a marker is present on that line. Multiple
  // lines may point to the same marker when it spans across lines.
  // The spans will have null for their from/to properties when the
  // marker continues beyond the start/end of the line. Markers have
  // links back to the lines they currently touch.

  // Collapsed markers have unique ids, in order to be able to order
  // them, which is needed for uniquely determining an outer marker
  // when they overlap (they may nest, but not partially overlap).
  var nextMarkerId = 0;

  var TextMarker = function(doc, type) {
    this.lines = [];
    this.type = type;
    this.doc = doc;
    this.id = ++nextMarkerId;
  };

  // Clear the marker.
  TextMarker.prototype.clear = function () {
    if (this.explicitlyCleared) { return }
    var cm = this.doc.cm, withOp = cm && !cm.curOp;
    if (withOp) { startOperation(cm); }
    if (hasHandler(this, "clear")) {
      var found = this.find();
      if (found) { signalLater(this, "clear", found.from, found.to); }
    }
    var min = null, max = null;
    for (var i = 0; i < this.lines.length; ++i) {
      var line = this.lines[i];
      var span = getMarkedSpanFor(line.markedSpans, this);
      if (cm && !this.collapsed) { regLineChange(cm, lineNo(line), "text"); }
      else if (cm) {
        if (span.to != null) { max = lineNo(line); }
        if (span.from != null) { min = lineNo(line); }
      }
      line.markedSpans = removeMarkedSpan(line.markedSpans, span);
      if (span.from == null && this.collapsed && !lineIsHidden(this.doc, line) && cm)
        { updateLineHeight(line, textHeight(cm.display)); }
    }
    if (cm && this.collapsed && !cm.options.lineWrapping) { for (var i$1 = 0; i$1 < this.lines.length; ++i$1) {
      var visual = visualLine(this.lines[i$1]), len = lineLength(visual);
      if (len > cm.display.maxLineLength) {
        cm.display.maxLine = visual;
        cm.display.maxLineLength = len;
        cm.display.maxLineChanged = true;
      }
    } }

    if (min != null && cm && this.collapsed) { regChange(cm, min, max + 1); }
    this.lines.length = 0;
    this.explicitlyCleared = true;
    if (this.atomic && this.doc.cantEdit) {
      this.doc.cantEdit = false;
      if (cm) { reCheckSelection(cm.doc); }
    }
    if (cm) { signalLater(cm, "markerCleared", cm, this, min, max); }
    if (withOp) { endOperation(cm); }
    if (this.parent) { this.parent.clear(); }
  };

  // Find the position of the marker in the document. Returns a {from,
  // to} object by default. Side can be passed to get a specific side
  // -- 0 (both), -1 (left), or 1 (right). When lineObj is true, the
  // Pos objects returned contain a line object, rather than a line
  // number (used to prevent looking up the same line twice).
  TextMarker.prototype.find = function (side, lineObj) {
    if (side == null && this.type == "bookmark") { side = 1; }
    var from, to;
    for (var i = 0; i < this.lines.length; ++i) {
      var line = this.lines[i];
      var span = getMarkedSpanFor(line.markedSpans, this);
      if (span.from != null) {
        from = Pos(lineObj ? line : lineNo(line), span.from);
        if (side == -1) { return from }
      }
      if (span.to != null) {
        to = Pos(lineObj ? line : lineNo(line), span.to);
        if (side == 1) { return to }
      }
    }
    return from && {from: from, to: to}
  };

  // Signals that the marker's widget changed, and surrounding layout
  // should be recomputed.
  TextMarker.prototype.changed = function () {
      var this$1 = this;

    var pos = this.find(-1, true), widget = this, cm = this.doc.cm;
    if (!pos || !cm) { return }
    runInOp(cm, function () {
      var line = pos.line, lineN = lineNo(pos.line);
      var view = findViewForLine(cm, lineN);
      if (view) {
        clearLineMeasurementCacheFor(view);
        cm.curOp.selectionChanged = cm.curOp.forceUpdate = true;
      }
      cm.curOp.updateMaxLine = true;
      if (!lineIsHidden(widget.doc, line) && widget.height != null) {
        var oldHeight = widget.height;
        widget.height = null;
        var dHeight = widgetHeight(widget) - oldHeight;
        if (dHeight)
          { updateLineHeight(line, line.height + dHeight); }
      }
      signalLater(cm, "markerChanged", cm, this$1);
    });
  };

  TextMarker.prototype.attachLine = function (line) {
    if (!this.lines.length && this.doc.cm) {
      var op = this.doc.cm.curOp;
      if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1)
        { (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this); }
    }
    this.lines.push(line);
  };

  TextMarker.prototype.detachLine = function (line) {
    this.lines.splice(indexOf(this.lines, line), 1);
    if (!this.lines.length && this.doc.cm) {
      var op = this.doc.cm.curOp
      ;(op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);
    }
  };
  eventMixin(TextMarker);

  // Create a marker, wire it up to the right lines, and
  function markText(doc, from, to, options, type) {
    // Shared markers (across linked documents) are handled separately
    // (markTextShared will call out to this again, once per
    // document).
    if (options && options.shared) { return markTextShared(doc, from, to, options, type) }
    // Ensure we are in an operation.
    if (doc.cm && !doc.cm.curOp) { return operation(doc.cm, markText)(doc, from, to, options, type) }

    var marker = new TextMarker(doc, type), diff = cmp(from, to);
    if (options) { copyObj(options, marker, false); }
    // Don't connect empty markers unless clearWhenEmpty is false
    if (diff > 0 || diff == 0 && marker.clearWhenEmpty !== false)
      { return marker }
    if (marker.replacedWith) {
      // Showing up as a widget implies collapsed (widget replaces text)
      marker.collapsed = true;
      marker.widgetNode = eltP("span", [marker.replacedWith], "CodeMirror-widget");
      if (!options.handleMouseEvents) { marker.widgetNode.setAttribute("cm-ignore-events", "true"); }
      if (options.insertLeft) { marker.widgetNode.insertLeft = true; }
    }
    if (marker.collapsed) {
      if (conflictingCollapsedRange(doc, from.line, from, to, marker) ||
          from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker))
        { throw new Error("Inserting collapsed marker partially overlapping an existing one") }
      seeCollapsedSpans();
    }

    if (marker.addToHistory)
      { addChangeToHistory(doc, {from: from, to: to, origin: "markText"}, doc.sel, NaN); }

    var curLine = from.line, cm = doc.cm, updateMaxLine;
    doc.iter(curLine, to.line + 1, function (line) {
      if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine)
        { updateMaxLine = true; }
      if (marker.collapsed && curLine != from.line) { updateLineHeight(line, 0); }
      addMarkedSpan(line, new MarkedSpan(marker,
                                         curLine == from.line ? from.ch : null,
                                         curLine == to.line ? to.ch : null));
      ++curLine;
    });
    // lineIsHidden depends on the presence of the spans, so needs a second pass
    if (marker.collapsed) { doc.iter(from.line, to.line + 1, function (line) {
      if (lineIsHidden(doc, line)) { updateLineHeight(line, 0); }
    }); }

    if (marker.clearOnEnter) { on(marker, "beforeCursorEnter", function () { return marker.clear(); }); }

    if (marker.readOnly) {
      seeReadOnlySpans();
      if (doc.history.done.length || doc.history.undone.length)
        { doc.clearHistory(); }
    }
    if (marker.collapsed) {
      marker.id = ++nextMarkerId;
      marker.atomic = true;
    }
    if (cm) {
      // Sync editor state
      if (updateMaxLine) { cm.curOp.updateMaxLine = true; }
      if (marker.collapsed)
        { regChange(cm, from.line, to.line + 1); }
      else if (marker.className || marker.startStyle || marker.endStyle || marker.css ||
               marker.attributes || marker.title)
        { for (var i = from.line; i <= to.line; i++) { regLineChange(cm, i, "text"); } }
      if (marker.atomic) { reCheckSelection(cm.doc); }
      signalLater(cm, "markerAdded", cm, marker);
    }
    return marker
  }

  // SHARED TEXTMARKERS

  // A shared marker spans multiple linked documents. It is
  // implemented as a meta-marker-object controlling multiple normal
  // markers.
  var SharedTextMarker = function(markers, primary) {
    this.markers = markers;
    this.primary = primary;
    for (var i = 0; i < markers.length; ++i)
      { markers[i].parent = this; }
  };

  SharedTextMarker.prototype.clear = function () {
    if (this.explicitlyCleared) { return }
    this.explicitlyCleared = true;
    for (var i = 0; i < this.markers.length; ++i)
      { this.markers[i].clear(); }
    signalLater(this, "clear");
  };

  SharedTextMarker.prototype.find = function (side, lineObj) {
    return this.primary.find(side, lineObj)
  };
  eventMixin(SharedTextMarker);

  function markTextShared(doc, from, to, options, type) {
    options = copyObj(options);
    options.shared = false;
    var markers = [markText(doc, from, to, options, type)], primary = markers[0];
    var widget = options.widgetNode;
    linkedDocs(doc, function (doc) {
      if (widget) { options.widgetNode = widget.cloneNode(true); }
      markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type));
      for (var i = 0; i < doc.linked.length; ++i)
        { if (doc.linked[i].isParent) { return } }
      primary = lst(markers);
    });
    return new SharedTextMarker(markers, primary)
  }

  function findSharedMarkers(doc) {
    return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())), function (m) { return m.parent; })
  }

  function copySharedMarkers(doc, markers) {
    for (var i = 0; i < markers.length; i++) {
      var marker = markers[i], pos = marker.find();
      var mFrom = doc.clipPos(pos.from), mTo = doc.clipPos(pos.to);
      if (cmp(mFrom, mTo)) {
        var subMark = markText(doc, mFrom, mTo, marker.primary, marker.primary.type);
        marker.markers.push(subMark);
        subMark.parent = marker;
      }
    }
  }

  function detachSharedMarkers(markers) {
    var loop = function ( i ) {
      var marker = markers[i], linked = [marker.primary.doc];
      linkedDocs(marker.primary.doc, function (d) { return linked.push(d); });
      for (var j = 0; j < marker.markers.length; j++) {
        var subMarker = marker.markers[j];
        if (indexOf(linked, subMarker.doc) == -1) {
          subMarker.parent = null;
          marker.markers.splice(j--, 1);
        }
      }
    };

    for (var i = 0; i < markers.length; i++) loop( i );
  }

  var nextDocId = 0;
  var Doc = function(text, mode, firstLine, lineSep, direction) {
    if (!(this instanceof Doc)) { return new Doc(text, mode, firstLine, lineSep, direction) }
    if (firstLine == null) { firstLine = 0; }

    BranchChunk.call(this, [new LeafChunk([new Line("", null)])]);
    this.first = firstLine;
    this.scrollTop = this.scrollLeft = 0;
    this.cantEdit = false;
    this.cleanGeneration = 1;
    this.modeFrontier = this.highlightFrontier = firstLine;
    var start = Pos(firstLine, 0);
    this.sel = simpleSelection(start);
    this.history = new History(null);
    this.id = ++nextDocId;
    this.modeOption = mode;
    this.lineSep = lineSep;
    this.direction = (direction == "rtl") ? "rtl" : "ltr";
    this.extend = false;

    if (typeof text == "string") { text = this.splitLines(text); }
    updateDoc(this, {from: start, to: start, text: text});
    setSelection(this, simpleSelection(start), sel_dontScroll);
  };

  Doc.prototype = createObj(BranchChunk.prototype, {
    constructor: Doc,
    // Iterate over the document. Supports two forms -- with only one
    // argument, it calls that for each line in the document. With
    // three, it iterates over the range given by the first two (with
    // the second being non-inclusive).
    iter: function(from, to, op) {
      if (op) { this.iterN(from - this.first, to - from, op); }
      else { this.iterN(this.first, this.first + this.size, from); }
    },

    // Non-public interface for adding and removing lines.
    insert: function(at, lines) {
      var height = 0;
      for (var i = 0; i < lines.length; ++i) { height += lines[i].height; }
      this.insertInner(at - this.first, lines, height);
    },
    remove: function(at, n) { this.removeInner(at - this.first, n); },

    // From here, the methods are part of the public interface. Most
    // are also available from CodeMirror (editor) instances.

    getValue: function(lineSep) {
      var lines = getLines(this, this.first, this.first + this.size);
      if (lineSep === false) { return lines }
      return lines.join(lineSep || this.lineSeparator())
    },
    setValue: docMethodOp(function(code) {
      var top = Pos(this.first, 0), last = this.first + this.size - 1;
      makeChange(this, {from: top, to: Pos(last, getLine(this, last).text.length),
                        text: this.splitLines(code), origin: "setValue", full: true}, true);
      if (this.cm) { scrollToCoords(this.cm, 0, 0); }
      setSelection(this, simpleSelection(top), sel_dontScroll);
    }),
    replaceRange: function(code, from, to, origin) {
      from = clipPos(this, from);
      to = to ? clipPos(this, to) : from;
      replaceRange(this, code, from, to, origin);
    },
    getRange: function(from, to, lineSep) {
      var lines = getBetween(this, clipPos(this, from), clipPos(this, to));
      if (lineSep === false) { return lines }
      return lines.join(lineSep || this.lineSeparator())
    },

    getLine: function(line) {var l = this.getLineHandle(line); return l && l.text},

    getLineHandle: function(line) {if (isLine(this, line)) { return getLine(this, line) }},
    getLineNumber: function(line) {return lineNo(line)},

    getLineHandleVisualStart: function(line) {
      if (typeof line == "number") { line = getLine(this, line); }
      return visualLine(line)
    },

    lineCount: function() {return this.size},
    firstLine: function() {return this.first},
    lastLine: function() {return this.first + this.size - 1},

    clipPos: function(pos) {return clipPos(this, pos)},

    getCursor: function(start) {
      var range = this.sel.primary(), pos;
      if (start == null || start == "head") { pos = range.head; }
      else if (start == "anchor") { pos = range.anchor; }
      else if (start == "end" || start == "to" || start === false) { pos = range.to(); }
      else { pos = range.from(); }
      return pos
    },
    listSelections: function() { return this.sel.ranges },
    somethingSelected: function() {return this.sel.somethingSelected()},

    setCursor: docMethodOp(function(line, ch, options) {
      setSimpleSelection(this, clipPos(this, typeof line == "number" ? Pos(line, ch || 0) : line), null, options);
    }),
    setSelection: docMethodOp(function(anchor, head, options) {
      setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options);
    }),
    extendSelection: docMethodOp(function(head, other, options) {
      extendSelection(this, clipPos(this, head), other && clipPos(this, other), options);
    }),
    extendSelections: docMethodOp(function(heads, options) {
      extendSelections(this, clipPosArray(this, heads), options);
    }),
    extendSelectionsBy: docMethodOp(function(f, options) {
      var heads = map(this.sel.ranges, f);
      extendSelections(this, clipPosArray(this, heads), options);
    }),
    setSelections: docMethodOp(function(ranges, primary, options) {
      if (!ranges.length) { return }
      var out = [];
      for (var i = 0; i < ranges.length; i++)
        { out[i] = new Range(clipPos(this, ranges[i].anchor),
                           clipPos(this, ranges[i].head)); }
      if (primary == null) { primary = Math.min(ranges.length - 1, this.sel.primIndex); }
      setSelection(this, normalizeSelection(this.cm, out, primary), options);
    }),
    addSelection: docMethodOp(function(anchor, head, options) {
      var ranges = this.sel.ranges.slice(0);
      ranges.push(new Range(clipPos(this, anchor), clipPos(this, head || anchor)));
      setSelection(this, normalizeSelection(this.cm, ranges, ranges.length - 1), options);
    }),

    getSelection: function(lineSep) {
      var ranges = this.sel.ranges, lines;
      for (var i = 0; i < ranges.length; i++) {
        var sel = getBetween(this, ranges[i].from(), ranges[i].to());
        lines = lines ? lines.concat(sel) : sel;
      }
      if (lineSep === false) { return lines }
      else { return lines.join(lineSep || this.lineSeparator()) }
    },
    getSelections: function(lineSep) {
      var parts = [], ranges = this.sel.ranges;
      for (var i = 0; i < ranges.length; i++) {
        var sel = getBetween(this, ranges[i].from(), ranges[i].to());
        if (lineSep !== false) { sel = sel.join(lineSep || this.lineSeparator()); }
        parts[i] = sel;
      }
      return parts
    },
    replaceSelection: function(code, collapse, origin) {
      var dup = [];
      for (var i = 0; i < this.sel.ranges.length; i++)
        { dup[i] = code; }
      this.replaceSelections(dup, collapse, origin || "+input");
    },
    replaceSelections: docMethodOp(function(code, collapse, origin) {
      var changes = [], sel = this.sel;
      for (var i = 0; i < sel.ranges.length; i++) {
        var range = sel.ranges[i];
        changes[i] = {from: range.from(), to: range.to(), text: this.splitLines(code[i]), origin: origin};
      }
      var newSel = collapse && collapse != "end" && computeReplacedSel(this, changes, collapse);
      for (var i$1 = changes.length - 1; i$1 >= 0; i$1--)
        { makeChange(this, changes[i$1]); }
      if (newSel) { setSelectionReplaceHistory(this, newSel); }
      else if (this.cm) { ensureCursorVisible(this.cm); }
    }),
    undo: docMethodOp(function() {makeChangeFromHistory(this, "undo");}),
    redo: docMethodOp(function() {makeChangeFromHistory(this, "redo");}),
    undoSelection: docMethodOp(function() {makeChangeFromHistory(this, "undo", true);}),
    redoSelection: docMethodOp(function() {makeChangeFromHistory(this, "redo", true);}),

    setExtending: function(val) {this.extend = val;},
    getExtending: function() {return this.extend},

    historySize: function() {
      var hist = this.history, done = 0, undone = 0;
      for (var i = 0; i < hist.done.length; i++) { if (!hist.done[i].ranges) { ++done; } }
      for (var i$1 = 0; i$1 < hist.undone.length; i$1++) { if (!hist.undone[i$1].ranges) { ++undone; } }
      return {undo: done, redo: undone}
    },
    clearHistory: function() {
      var this$1 = this;

      this.history = new History(this.history.maxGeneration);
      linkedDocs(this, function (doc) { return doc.history = this$1.history; }, true);
    },

    markClean: function() {
      this.cleanGeneration = this.changeGeneration(true);
    },
    changeGeneration: function(forceSplit) {
      if (forceSplit)
        { this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null; }
      return this.history.generation
    },
    isClean: function (gen) {
      return this.history.generation == (gen || this.cleanGeneration)
    },

    getHistory: function() {
      return {done: copyHistoryArray(this.history.done),
              undone: copyHistoryArray(this.history.undone)}
    },
    setHistory: function(histData) {
      var hist = this.history = new History(this.history.maxGeneration);
      hist.done = copyHistoryArray(histData.done.slice(0), null, true);
      hist.undone = copyHistoryArray(histData.undone.slice(0), null, true);
    },

    setGutterMarker: docMethodOp(function(line, gutterID, value) {
      return changeLine(this, line, "gutter", function (line) {
        var markers = line.gutterMarkers || (line.gutterMarkers = {});
        markers[gutterID] = value;
        if (!value && isEmpty(markers)) { line.gutterMarkers = null; }
        return true
      })
    }),

    clearGutter: docMethodOp(function(gutterID) {
      var this$1 = this;

      this.iter(function (line) {
        if (line.gutterMarkers && line.gutterMarkers[gutterID]) {
          changeLine(this$1, line, "gutter", function () {
            line.gutterMarkers[gutterID] = null;
            if (isEmpty(line.gutterMarkers)) { line.gutterMarkers = null; }
            return true
          });
        }
      });
    }),

    lineInfo: function(line) {
      var n;
      if (typeof line == "number") {
        if (!isLine(this, line)) { return null }
        n = line;
        line = getLine(this, line);
        if (!line) { return null }
      } else {
        n = lineNo(line);
        if (n == null) { return null }
      }
      return {line: n, handle: line, text: line.text, gutterMarkers: line.gutterMarkers,
              textClass: line.textClass, bgClass: line.bgClass, wrapClass: line.wrapClass,
              widgets: line.widgets}
    },

    addLineClass: docMethodOp(function(handle, where, cls) {
      return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function (line) {
        var prop = where == "text" ? "textClass"
                 : where == "background" ? "bgClass"
                 : where == "gutter" ? "gutterClass" : "wrapClass";
        if (!line[prop]) { line[prop] = cls; }
        else if (classTest(cls).test(line[prop])) { return false }
        else { line[prop] += " " + cls; }
        return true
      })
    }),
    removeLineClass: docMethodOp(function(handle, where, cls) {
      return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function (line) {
        var prop = where == "text" ? "textClass"
                 : where == "background" ? "bgClass"
                 : where == "gutter" ? "gutterClass" : "wrapClass";
        var cur = line[prop];
        if (!cur) { return false }
        else if (cls == null) { line[prop] = null; }
        else {
          var found = cur.match(classTest(cls));
          if (!found) { return false }
          var end = found.index + found[0].length;
          line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? "" : " ") + cur.slice(end) || null;
        }
        return true
      })
    }),

    addLineWidget: docMethodOp(function(handle, node, options) {
      return addLineWidget(this, handle, node, options)
    }),
    removeLineWidget: function(widget) { widget.clear(); },

    markText: function(from, to, options) {
      return markText(this, clipPos(this, from), clipPos(this, to), options, options && options.type || "range")
    },
    setBookmark: function(pos, options) {
      var realOpts = {replacedWith: options && (options.nodeType == null ? options.widget : options),
                      insertLeft: options && options.insertLeft,
                      clearWhenEmpty: false, shared: options && options.shared,
                      handleMouseEvents: options && options.handleMouseEvents};
      pos = clipPos(this, pos);
      return markText(this, pos, pos, realOpts, "bookmark")
    },
    findMarksAt: function(pos) {
      pos = clipPos(this, pos);
      var markers = [], spans = getLine(this, pos.line).markedSpans;
      if (spans) { for (var i = 0; i < spans.length; ++i) {
        var span = spans[i];
        if ((span.from == null || span.from <= pos.ch) &&
            (span.to == null || span.to >= pos.ch))
          { markers.push(span.marker.parent || span.marker); }
      } }
      return markers
    },
    findMarks: function(from, to, filter) {
      from = clipPos(this, from); to = clipPos(this, to);
      var found = [], lineNo = from.line;
      this.iter(from.line, to.line + 1, function (line) {
        var spans = line.markedSpans;
        if (spans) { for (var i = 0; i < spans.length; i++) {
          var span = spans[i];
          if (!(span.to != null && lineNo == from.line && from.ch >= span.to ||
                span.from == null && lineNo != from.line ||
                span.from != null && lineNo == to.line && span.from >= to.ch) &&
              (!filter || filter(span.marker)))
            { found.push(span.marker.parent || span.marker); }
        } }
        ++lineNo;
      });
      return found
    },
    getAllMarks: function() {
      var markers = [];
      this.iter(function (line) {
        var sps = line.markedSpans;
        if (sps) { for (var i = 0; i < sps.length; ++i)
          { if (sps[i].from != null) { markers.push(sps[i].marker); } } }
      });
      return markers
    },

    posFromIndex: function(off) {
      var ch, lineNo = this.first, sepSize = this.lineSeparator().length;
      this.iter(function (line) {
        var sz = line.text.length + sepSize;
        if (sz > off) { ch = off; return true }
        off -= sz;
        ++lineNo;
      });
      return clipPos(this, Pos(lineNo, ch))
    },
    indexFromPos: function (coords) {
      coords = clipPos(this, coords);
      var index = coords.ch;
      if (coords.line < this.first || coords.ch < 0) { return 0 }
      var sepSize = this.lineSeparator().length;
      this.iter(this.first, coords.line, function (line) { // iter aborts when callback returns a truthy value
        index += line.text.length + sepSize;
      });
      return index
    },

    copy: function(copyHistory) {
      var doc = new Doc(getLines(this, this.first, this.first + this.size),
                        this.modeOption, this.first, this.lineSep, this.direction);
      doc.scrollTop = this.scrollTop; doc.scrollLeft = this.scrollLeft;
      doc.sel = this.sel;
      doc.extend = false;
      if (copyHistory) {
        doc.history.undoDepth = this.history.undoDepth;
        doc.setHistory(this.getHistory());
      }
      return doc
    },

    linkedDoc: function(options) {
      if (!options) { options = {}; }
      var from = this.first, to = this.first + this.size;
      if (options.from != null && options.from > from) { from = options.from; }
      if (options.to != null && options.to < to) { to = options.to; }
      var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from, this.lineSep, this.direction);
      if (options.sharedHist) { copy.history = this.history
      ; }(this.linked || (this.linked = [])).push({doc: copy, sharedHist: options.sharedHist});
      copy.linked = [{doc: this, isParent: true, sharedHist: options.sharedHist}];
      copySharedMarkers(copy, findSharedMarkers(this));
      return copy
    },
    unlinkDoc: function(other) {
      if (other instanceof CodeMirror) { other = other.doc; }
      if (this.linked) { for (var i = 0; i < this.linked.length; ++i) {
        var link = this.linked[i];
        if (link.doc != other) { continue }
        this.linked.splice(i, 1);
        other.unlinkDoc(this);
        detachSharedMarkers(findSharedMarkers(this));
        break
      } }
      // If the histories were shared, split them again
      if (other.history == this.history) {
        var splitIds = [other.id];
        linkedDocs(other, function (doc) { return splitIds.push(doc.id); }, true);
        other.history = new History(null);
        other.history.done = copyHistoryArray(this.history.done, splitIds);
        other.history.undone = copyHistoryArray(this.history.undone, splitIds);
      }
    },
    iterLinkedDocs: function(f) {linkedDocs(this, f);},

    getMode: function() {return this.mode},
    getEditor: function() {return this.cm},

    splitLines: function(str) {
      if (this.lineSep) { return str.split(this.lineSep) }
      return splitLinesAuto(str)
    },
    lineSeparator: function() { return this.lineSep || "\n" },

    setDirection: docMethodOp(function (dir) {
      if (dir != "rtl") { dir = "ltr"; }
      if (dir == this.direction) { return }
      this.direction = dir;
      this.iter(function (line) { return line.order = null; });
      if (this.cm) { directionChanged(this.cm); }
    })
  });

  // Public alias.
  Doc.prototype.eachLine = Doc.prototype.iter;

  // Kludge to work around strange IE behavior where it'll sometimes
  // re-fire a series of drag-related events right after the drop (#1551)
  var lastDrop = 0;

  function onDrop(e) {
    var cm = this;
    clearDragCursor(cm);
    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e))
      { return }
    e_preventDefault(e);
    if (ie) { lastDrop = +new Date; }
    var pos = posFromMouse(cm, e, true), files = e.dataTransfer.files;
    if (!pos || cm.isReadOnly()) { return }
    // Might be a file drop, in which case we simply extract the text
    // and insert it.
    if (files && files.length && window.FileReader && window.File) {
      var n = files.length, text = Array(n), read = 0;
      var markAsReadAndPasteIfAllFilesAreRead = function () {
        if (++read == n) {
          operation(cm, function () {
            pos = clipPos(cm.doc, pos);
            var change = {from: pos, to: pos,
                          text: cm.doc.splitLines(
                              text.filter(function (t) { return t != null; }).join(cm.doc.lineSeparator())),
                          origin: "paste"};
            makeChange(cm.doc, change);
            setSelectionReplaceHistory(cm.doc, simpleSelection(clipPos(cm.doc, pos), clipPos(cm.doc, changeEnd(change))));
          })();
        }
      };
      var readTextFromFile = function (file, i) {
        if (cm.options.allowDropFileTypes &&
            indexOf(cm.options.allowDropFileTypes, file.type) == -1) {
          markAsReadAndPasteIfAllFilesAreRead();
          return
        }
        var reader = new FileReader;
        reader.onerror = function () { return markAsReadAndPasteIfAllFilesAreRead(); };
        reader.onload = function () {
          var content = reader.result;
          if (/[\x00-\x08\x0e-\x1f]{2}/.test(content)) {
            markAsReadAndPasteIfAllFilesAreRead();
            return
          }
          text[i] = content;
          markAsReadAndPasteIfAllFilesAreRead();
        };
        reader.readAsText(file);
      };
      for (var i = 0; i < files.length; i++) { readTextFromFile(files[i], i); }
    } else { // Normal drop
      // Don't do a replace if the drop happened inside of the selected text.
      if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {
        cm.state.draggingText(e);
        // Ensure the editor is re-focused
        setTimeout(function () { return cm.display.input.focus(); }, 20);
        return
      }
      try {
        var text$1 = e.dataTransfer.getData("Text");
        if (text$1) {
          var selected;
          if (cm.state.draggingText && !cm.state.draggingText.copy)
            { selected = cm.listSelections(); }
          setSelectionNoUndo(cm.doc, simpleSelection(pos, pos));
          if (selected) { for (var i$1 = 0; i$1 < selected.length; ++i$1)
            { replaceRange(cm.doc, "", selected[i$1].anchor, selected[i$1].head, "drag"); } }
          cm.replaceSelection(text$1, "around", "paste");
          cm.display.input.focus();
        }
      }
      catch(e$1){}
    }
  }

  function onDragStart(cm, e) {
    if (ie && (!cm.state.draggingText || +new Date - lastDrop < 100)) { e_stop(e); return }
    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) { return }

    e.dataTransfer.setData("Text", cm.getSelection());
    e.dataTransfer.effectAllowed = "copyMove";

    // Use dummy image instead of default browsers image.
    // Recent Safari (~6.0.2) have a tendency to segfault when this happens, so we don't do it there.
    if (e.dataTransfer.setDragImage && !safari) {
      var img = elt("img", null, null, "position: fixed; left: 0; top: 0;");
      img.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";
      if (presto) {
        img.width = img.height = 1;
        cm.display.wrapper.appendChild(img);
        // Force a relayout, or Opera won't use our image for some obscure reason
        img._top = img.offsetTop;
      }
      e.dataTransfer.setDragImage(img, 0, 0);
      if (presto) { img.parentNode.removeChild(img); }
    }
  }

  function onDragOver(cm, e) {
    var pos = posFromMouse(cm, e);
    if (!pos) { return }
    var frag = document.createDocumentFragment();
    drawSelectionCursor(cm, pos, frag);
    if (!cm.display.dragCursor) {
      cm.display.dragCursor = elt("div", null, "CodeMirror-cursors CodeMirror-dragcursors");
      cm.display.lineSpace.insertBefore(cm.display.dragCursor, cm.display.cursorDiv);
    }
    removeChildrenAndAdd(cm.display.dragCursor, frag);
  }

  function clearDragCursor(cm) {
    if (cm.display.dragCursor) {
      cm.display.lineSpace.removeChild(cm.display.dragCursor);
      cm.display.dragCursor = null;
    }
  }

  // These must be handled carefully, because naively registering a
  // handler for each editor will cause the editors to never be
  // garbage collected.

  function forEachCodeMirror(f) {
    if (!document.getElementsByClassName) { return }
    var byClass = document.getElementsByClassName("CodeMirror"), editors = [];
    for (var i = 0; i < byClass.length; i++) {
      var cm = byClass[i].CodeMirror;
      if (cm) { editors.push(cm); }
    }
    if (editors.length) { editors[0].operation(function () {
      for (var i = 0; i < editors.length; i++) { f(editors[i]); }
    }); }
  }

  var globalsRegistered = false;
  function ensureGlobalHandlers() {
    if (globalsRegistered) { return }
    registerGlobalHandlers();
    globalsRegistered = true;
  }
  function registerGlobalHandlers() {
    // When the window resizes, we need to refresh active editors.
    var resizeTimer;
    on(window, "resize", function () {
      if (resizeTimer == null) { resizeTimer = setTimeout(function () {
        resizeTimer = null;
        forEachCodeMirror(onResize);
      }, 100); }
    });
    // When the window loses focus, we want to show the editor as blurred
    on(window, "blur", function () { return forEachCodeMirror(onBlur); });
  }
  // Called when the window resizes
  function onResize(cm) {
    var d = cm.display;
    // Might be a text scaling operation, clear size caches.
    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;
    d.scrollbarsClipped = false;
    cm.setSize();
  }

  var keyNames = {
    3: "Pause", 8: "Backspace", 9: "Tab", 13: "Enter", 16: "Shift", 17: "Ctrl", 18: "Alt",
    19: "Pause", 20: "CapsLock", 27: "Esc", 32: "Space", 33: "PageUp", 34: "PageDown", 35: "End",
    36: "Home", 37: "Left", 38: "Up", 39: "Right", 40: "Down", 44: "PrintScrn", 45: "Insert",
    46: "Delete", 59: ";", 61: "=", 91: "Mod", 92: "Mod", 93: "Mod",
    106: "*", 107: "=", 109: "-", 110: ".", 111: "/", 145: "ScrollLock",
    173: "-", 186: ";", 187: "=", 188: ",", 189: "-", 190: ".", 191: "/", 192: "`", 219: "[", 220: "\\",
    221: "]", 222: "'", 224: "Mod", 63232: "Up", 63233: "Down", 63234: "Left", 63235: "Right", 63272: "Delete",
    63273: "Home", 63275: "End", 63276: "PageUp", 63277: "PageDown", 63302: "Insert"
  };

  // Number keys
  for (var i = 0; i < 10; i++) { keyNames[i + 48] = keyNames[i + 96] = String(i); }
  // Alphabetic keys
  for (var i$1 = 65; i$1 <= 90; i$1++) { keyNames[i$1] = String.fromCharCode(i$1); }
  // Function keys
  for (var i$2 = 1; i$2 <= 12; i$2++) { keyNames[i$2 + 111] = keyNames[i$2 + 63235] = "F" + i$2; }

  var keyMap = {};

  keyMap.basic = {
    "Left": "goCharLeft", "Right": "goCharRight", "Up": "goLineUp", "Down": "goLineDown",
    "End": "goLineEnd", "Home": "goLineStartSmart", "PageUp": "goPageUp", "PageDown": "goPageDown",
    "Delete": "delCharAfter", "Backspace": "delCharBefore", "Shift-Backspace": "delCharBefore",
    "Tab": "defaultTab", "Shift-Tab": "indentAuto",
    "Enter": "newlineAndIndent", "Insert": "toggleOverwrite",
    "Esc": "singleSelection"
  };
  // Note that the save and find-related commands aren't defined by
  // default. User code or addons can define them. Unknown commands
  // are simply ignored.
  keyMap.pcDefault = {
    "Ctrl-A": "selectAll", "Ctrl-D": "deleteLine", "Ctrl-Z": "undo", "Shift-Ctrl-Z": "redo", "Ctrl-Y": "redo",
    "Ctrl-Home": "goDocStart", "Ctrl-End": "goDocEnd", "Ctrl-Up": "goLineUp", "Ctrl-Down": "goLineDown",
    "Ctrl-Left": "goGroupLeft", "Ctrl-Right": "goGroupRight", "Alt-Left": "goLineStart", "Alt-Right": "goLineEnd",
    "Ctrl-Backspace": "delGroupBefore", "Ctrl-Delete": "delGroupAfter", "Ctrl-S": "save", "Ctrl-F": "find",
    "Ctrl-G": "findNext", "Shift-Ctrl-G": "findPrev", "Shift-Ctrl-F": "replace", "Shift-Ctrl-R": "replaceAll",
    "Ctrl-[": "indentLess", "Ctrl-]": "indentMore",
    "Ctrl-U": "undoSelection", "Shift-Ctrl-U": "redoSelection", "Alt-U": "redoSelection",
    "fallthrough": "basic"
  };
  // Very basic readline/emacs-style bindings, which are standard on Mac.
  keyMap.emacsy = {
    "Ctrl-F": "goCharRight", "Ctrl-B": "goCharLeft", "Ctrl-P": "goLineUp", "Ctrl-N": "goLineDown",
    "Alt-F": "goWordRight", "Alt-B": "goWordLeft", "Ctrl-A": "goLineStart", "Ctrl-E": "goLineEnd",
    "Ctrl-V": "goPageDown", "Shift-Ctrl-V": "goPageUp", "Ctrl-D": "delCharAfter", "Ctrl-H": "delCharBefore",
    "Alt-D": "delWordAfter", "Alt-Backspace": "delWordBefore", "Ctrl-K": "killLine", "Ctrl-T": "transposeChars",
    "Ctrl-O": "openLine"
  };
  keyMap.macDefault = {
    "Cmd-A": "selectAll", "Cmd-D": "deleteLine", "Cmd-Z": "undo", "Shift-Cmd-Z": "redo", "Cmd-Y": "redo",
    "Cmd-Home": "goDocStart", "Cmd-Up": "goDocStart", "Cmd-End": "goDocEnd", "Cmd-Down": "goDocEnd", "Alt-Left": "goGroupLeft",
    "Alt-Right": "goGroupRight", "Cmd-Left": "goLineLeft", "Cmd-Right": "goLineRight", "Alt-Backspace": "delGroupBefore",
    "Ctrl-Alt-Backspace": "delGroupAfter", "Alt-Delete": "delGroupAfter", "Cmd-S": "save", "Cmd-F": "find",
    "Cmd-G": "findNext", "Shift-Cmd-G": "findPrev", "Cmd-Alt-F": "replace", "Shift-Cmd-Alt-F": "replaceAll",
    "Cmd-[": "indentLess", "Cmd-]": "indentMore", "Cmd-Backspace": "delWrappedLineLeft", "Cmd-Delete": "delWrappedLineRight",
    "Cmd-U": "undoSelection", "Shift-Cmd-U": "redoSelection", "Ctrl-Up": "goDocStart", "Ctrl-Down": "goDocEnd",
    "fallthrough": ["basic", "emacsy"]
  };
  keyMap["default"] = mac ? keyMap.macDefault : keyMap.pcDefault;

  // KEYMAP DISPATCH

  function normalizeKeyName(name) {
    var parts = name.split(/-(?!$)/);
    name = parts[parts.length - 1];
    var alt, ctrl, shift, cmd;
    for (var i = 0; i < parts.length - 1; i++) {
      var mod = parts[i];
      if (/^(cmd|meta|m)$/i.test(mod)) { cmd = true; }
      else if (/^a(lt)?$/i.test(mod)) { alt = true; }
      else if (/^(c|ctrl|control)$/i.test(mod)) { ctrl = true; }
      else if (/^s(hift)?$/i.test(mod)) { shift = true; }
      else { throw new Error("Unrecognized modifier name: " + mod) }
    }
    if (alt) { name = "Alt-" + name; }
    if (ctrl) { name = "Ctrl-" + name; }
    if (cmd) { name = "Cmd-" + name; }
    if (shift) { name = "Shift-" + name; }
    return name
  }

  // This is a kludge to keep keymaps mostly working as raw objects
  // (backwards compatibility) while at the same time support features
  // like normalization and multi-stroke key bindings. It compiles a
  // new normalized keymap, and then updates the old object to reflect
  // this.
  function normalizeKeyMap(keymap) {
    var copy = {};
    for (var keyname in keymap) { if (keymap.hasOwnProperty(keyname)) {
      var value = keymap[keyname];
      if (/^(name|fallthrough|(de|at)tach)$/.test(keyname)) { continue }
      if (value == "...") { delete keymap[keyname]; continue }

      var keys = map(keyname.split(" "), normalizeKeyName);
      for (var i = 0; i < keys.length; i++) {
        var val = (void 0), name = (void 0);
        if (i == keys.length - 1) {
          name = keys.join(" ");
          val = value;
        } else {
          name = keys.slice(0, i + 1).join(" ");
          val = "...";
        }
        var prev = copy[name];
        if (!prev) { copy[name] = val; }
        else if (prev != val) { throw new Error("Inconsistent bindings for " + name) }
      }
      delete keymap[keyname];
    } }
    for (var prop in copy) { keymap[prop] = copy[prop]; }
    return keymap
  }

  function lookupKey(key, map, handle, context) {
    map = getKeyMap(map);
    var found = map.call ? map.call(key, context) : map[key];
    if (found === false) { return "nothing" }
    if (found === "...") { return "multi" }
    if (found != null && handle(found)) { return "handled" }

    if (map.fallthrough) {
      if (Object.prototype.toString.call(map.fallthrough) != "[object Array]")
        { return lookupKey(key, map.fallthrough, handle, context) }
      for (var i = 0; i < map.fallthrough.length; i++) {
        var result = lookupKey(key, map.fallthrough[i], handle, context);
        if (result) { return result }
      }
    }
  }

  // Modifier key presses don't count as 'real' key presses for the
  // purpose of keymap fallthrough.
  function isModifierKey(value) {
    var name = typeof value == "string" ? value : keyNames[value.keyCode];
    return name == "Ctrl" || name == "Alt" || name == "Shift" || name == "Mod"
  }

  function addModifierNames(name, event, noShift) {
    var base = name;
    if (event.altKey && base != "Alt") { name = "Alt-" + name; }
    if ((flipCtrlCmd ? event.metaKey : event.ctrlKey) && base != "Ctrl") { name = "Ctrl-" + name; }
    if ((flipCtrlCmd ? event.ctrlKey : event.metaKey) && base != "Mod") { name = "Cmd-" + name; }
    if (!noShift && event.shiftKey && base != "Shift") { name = "Shift-" + name; }
    return name
  }

  // Look up the name of a key as indicated by an event object.
  function keyName(event, noShift) {
    if (presto && event.keyCode == 34 && event["char"]) { return false }
    var name = keyNames[event.keyCode];
    if (name == null || event.altGraphKey) { return false }
    // Ctrl-ScrollLock has keyCode 3, same as Ctrl-Pause,
    // so we'll use event.code when available (Chrome 48+, FF 38+, Safari 10.1+)
    if (event.keyCode == 3 && event.code) { name = event.code; }
    return addModifierNames(name, event, noShift)
  }

  function getKeyMap(val) {
    return typeof val == "string" ? keyMap[val] : val
  }

  // Helper for deleting text near the selection(s), used to implement
  // backspace, delete, and similar functionality.
  function deleteNearSelection(cm, compute) {
    var ranges = cm.doc.sel.ranges, kill = [];
    // Build up a set of ranges to kill first, merging overlapping
    // ranges.
    for (var i = 0; i < ranges.length; i++) {
      var toKill = compute(ranges[i]);
      while (kill.length && cmp(toKill.from, lst(kill).to) <= 0) {
        var replaced = kill.pop();
        if (cmp(replaced.from, toKill.from) < 0) {
          toKill.from = replaced.from;
          break
        }
      }
      kill.push(toKill);
    }
    // Next, remove those actual ranges.
    runInOp(cm, function () {
      for (var i = kill.length - 1; i >= 0; i--)
        { replaceRange(cm.doc, "", kill[i].from, kill[i].to, "+delete"); }
      ensureCursorVisible(cm);
    });
  }

  function moveCharLogically(line, ch, dir) {
    var target = skipExtendingChars(line.text, ch + dir, dir);
    return target < 0 || target > line.text.length ? null : target
  }

  function moveLogically(line, start, dir) {
    var ch = moveCharLogically(line, start.ch, dir);
    return ch == null ? null : new Pos(start.line, ch, dir < 0 ? "after" : "before")
  }

  function endOfLine(visually, cm, lineObj, lineNo, dir) {
    if (visually) {
      if (cm.doc.direction == "rtl") { dir = -dir; }
      var order = getOrder(lineObj, cm.doc.direction);
      if (order) {
        var part = dir < 0 ? lst(order) : order[0];
        var moveInStorageOrder = (dir < 0) == (part.level == 1);
        var sticky = moveInStorageOrder ? "after" : "before";
        var ch;
        // With a wrapped rtl chunk (possibly spanning multiple bidi parts),
        // it could be that the last bidi part is not on the last visual line,
        // since visual lines contain content order-consecutive chunks.
        // Thus, in rtl, we are looking for the first (content-order) character
        // in the rtl chunk that is on the last line (that is, the same line
        // as the last (content-order) character).
        if (part.level > 0 || cm.doc.direction == "rtl") {
          var prep = prepareMeasureForLine(cm, lineObj);
          ch = dir < 0 ? lineObj.text.length - 1 : 0;
          var targetTop = measureCharPrepared(cm, prep, ch).top;
          ch = findFirst(function (ch) { return measureCharPrepared(cm, prep, ch).top == targetTop; }, (dir < 0) == (part.level == 1) ? part.from : part.to - 1, ch);
          if (sticky == "before") { ch = moveCharLogically(lineObj, ch, 1); }
        } else { ch = dir < 0 ? part.to : part.from; }
        return new Pos(lineNo, ch, sticky)
      }
    }
    return new Pos(lineNo, dir < 0 ? lineObj.text.length : 0, dir < 0 ? "before" : "after")
  }

  function moveVisually(cm, line, start, dir) {
    var bidi = getOrder(line, cm.doc.direction);
    if (!bidi) { return moveLogically(line, start, dir) }
    if (start.ch >= line.text.length) {
      start.ch = line.text.length;
      start.sticky = "before";
    } else if (start.ch <= 0) {
      start.ch = 0;
      start.sticky = "after";
    }
    var partPos = getBidiPartAt(bidi, start.ch, start.sticky), part = bidi[partPos];
    if (cm.doc.direction == "ltr" && part.level % 2 == 0 && (dir > 0 ? part.to > start.ch : part.from < start.ch)) {
      // Case 1: We move within an ltr part in an ltr editor. Even with wrapped lines,
      // nothing interesting happens.
      return moveLogically(line, start, dir)
    }

    var mv = function (pos, dir) { return moveCharLogically(line, pos instanceof Pos ? pos.ch : pos, dir); };
    var prep;
    var getWrappedLineExtent = function (ch) {
      if (!cm.options.lineWrapping) { return {begin: 0, end: line.text.length} }
      prep = prep || prepareMeasureForLine(cm, line);
      return wrappedLineExtentChar(cm, line, prep, ch)
    };
    var wrappedLineExtent = getWrappedLineExtent(start.sticky == "before" ? mv(start, -1) : start.ch);

    if (cm.doc.direction == "rtl" || part.level == 1) {
      var moveInStorageOrder = (part.level == 1) == (dir < 0);
      var ch = mv(start, moveInStorageOrder ? 1 : -1);
      if (ch != null && (!moveInStorageOrder ? ch >= part.from && ch >= wrappedLineExtent.begin : ch <= part.to && ch <= wrappedLineExtent.end)) {
        // Case 2: We move within an rtl part or in an rtl editor on the same visual line
        var sticky = moveInStorageOrder ? "before" : "after";
        return new Pos(start.line, ch, sticky)
      }
    }

    // Case 3: Could not move within this bidi part in this visual line, so leave
    // the current bidi part

    var searchInVisualLine = function (partPos, dir, wrappedLineExtent) {
      var getRes = function (ch, moveInStorageOrder) { return moveInStorageOrder
        ? new Pos(start.line, mv(ch, 1), "before")
        : new Pos(start.line, ch, "after"); };

      for (; partPos >= 0 && partPos < bidi.length; partPos += dir) {
        var part = bidi[partPos];
        var moveInStorageOrder = (dir > 0) == (part.level != 1);
        var ch = moveInStorageOrder ? wrappedLineExtent.begin : mv(wrappedLineExtent.end, -1);
        if (part.from <= ch && ch < part.to) { return getRes(ch, moveInStorageOrder) }
        ch = moveInStorageOrder ? part.from : mv(part.to, -1);
        if (wrappedLineExtent.begin <= ch && ch < wrappedLineExtent.end) { return getRes(ch, moveInStorageOrder) }
      }
    };

    // Case 3a: Look for other bidi parts on the same visual line
    var res = searchInVisualLine(partPos + dir, dir, wrappedLineExtent);
    if (res) { return res }

    // Case 3b: Look for other bidi parts on the next visual line
    var nextCh = dir > 0 ? wrappedLineExtent.end : mv(wrappedLineExtent.begin, -1);
    if (nextCh != null && !(dir > 0 && nextCh == line.text.length)) {
      res = searchInVisualLine(dir > 0 ? 0 : bidi.length - 1, dir, getWrappedLineExtent(nextCh));
      if (res) { return res }
    }

    // Case 4: Nowhere to move
    return null
  }

  // Commands are parameter-less actions that can be performed on an
  // editor, mostly used for keybindings.
  var commands = {
    selectAll: selectAll,
    singleSelection: function (cm) { return cm.setSelection(cm.getCursor("anchor"), cm.getCursor("head"), sel_dontScroll); },
    killLine: function (cm) { return deleteNearSelection(cm, function (range) {
      if (range.empty()) {
        var len = getLine(cm.doc, range.head.line).text.length;
        if (range.head.ch == len && range.head.line < cm.lastLine())
          { return {from: range.head, to: Pos(range.head.line + 1, 0)} }
        else
          { return {from: range.head, to: Pos(range.head.line, len)} }
      } else {
        return {from: range.from(), to: range.to()}
      }
    }); },
    deleteLine: function (cm) { return deleteNearSelection(cm, function (range) { return ({
      from: Pos(range.from().line, 0),
      to: clipPos(cm.doc, Pos(range.to().line + 1, 0))
    }); }); },
    delLineLeft: function (cm) { return deleteNearSelection(cm, function (range) { return ({
      from: Pos(range.from().line, 0), to: range.from()
    }); }); },
    delWrappedLineLeft: function (cm) { return deleteNearSelection(cm, function (range) {
      var top = cm.charCoords(range.head, "div").top + 5;
      var leftPos = cm.coordsChar({left: 0, top: top}, "div");
      return {from: leftPos, to: range.from()}
    }); },
    delWrappedLineRight: function (cm) { return deleteNearSelection(cm, function (range) {
      var top = cm.charCoords(range.head, "div").top + 5;
      var rightPos = cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, "div");
      return {from: range.from(), to: rightPos }
    }); },
    undo: function (cm) { return cm.undo(); },
    redo: function (cm) { return cm.redo(); },
    undoSelection: function (cm) { return cm.undoSelection(); },
    redoSelection: function (cm) { return cm.redoSelection(); },
    goDocStart: function (cm) { return cm.extendSelection(Pos(cm.firstLine(), 0)); },
    goDocEnd: function (cm) { return cm.extendSelection(Pos(cm.lastLine())); },
    goLineStart: function (cm) { return cm.extendSelectionsBy(function (range) { return lineStart(cm, range.head.line); },
      {origin: "+move", bias: 1}
    ); },
    goLineStartSmart: function (cm) { return cm.extendSelectionsBy(function (range) { return lineStartSmart(cm, range.head); },
      {origin: "+move", bias: 1}
    ); },
    goLineEnd: function (cm) { return cm.extendSelectionsBy(function (range) { return lineEnd(cm, range.head.line); },
      {origin: "+move", bias: -1}
    ); },
    goLineRight: function (cm) { return cm.extendSelectionsBy(function (range) {
      var top = cm.cursorCoords(range.head, "div").top + 5;
      return cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, "div")
    }, sel_move); },
    goLineLeft: function (cm) { return cm.extendSelectionsBy(function (range) {
      var top = cm.cursorCoords(range.head, "div").top + 5;
      return cm.coordsChar({left: 0, top: top}, "div")
    }, sel_move); },
    goLineLeftSmart: function (cm) { return cm.extendSelectionsBy(function (range) {
      var top = cm.cursorCoords(range.head, "div").top + 5;
      var pos = cm.coordsChar({left: 0, top: top}, "div");
      if (pos.ch < cm.getLine(pos.line).search(/\S/)) { return lineStartSmart(cm, range.head) }
      return pos
    }, sel_move); },
    goLineUp: function (cm) { return cm.moveV(-1, "line"); },
    goLineDown: function (cm) { return cm.moveV(1, "line"); },
    goPageUp: function (cm) { return cm.moveV(-1, "page"); },
    goPageDown: function (cm) { return cm.moveV(1, "page"); },
    goCharLeft: function (cm) { return cm.moveH(-1, "char"); },
    goCharRight: function (cm) { return cm.moveH(1, "char"); },
    goColumnLeft: function (cm) { return cm.moveH(-1, "column"); },
    goColumnRight: function (cm) { return cm.moveH(1, "column"); },
    goWordLeft: function (cm) { return cm.moveH(-1, "word"); },
    goGroupRight: function (cm) { return cm.moveH(1, "group"); },
    goGroupLeft: function (cm) { return cm.moveH(-1, "group"); },
    goWordRight: function (cm) { return cm.moveH(1, "word"); },
    delCharBefore: function (cm) { return cm.deleteH(-1, "codepoint"); },
    delCharAfter: function (cm) { return cm.deleteH(1, "char"); },
    delWordBefore: function (cm) { return cm.deleteH(-1, "word"); },
    delWordAfter: function (cm) { return cm.deleteH(1, "word"); },
    delGroupBefore: function (cm) { return cm.deleteH(-1, "group"); },
    delGroupAfter: function (cm) { return cm.deleteH(1, "group"); },
    indentAuto: function (cm) { return cm.indentSelection("smart"); },
    indentMore: function (cm) { return cm.indentSelection("add"); },
    indentLess: function (cm) { return cm.indentSelection("subtract"); },
    insertTab: function (cm) { return cm.replaceSelection("\t"); },
    insertSoftTab: function (cm) {
      var spaces = [], ranges = cm.listSelections(), tabSize = cm.options.tabSize;
      for (var i = 0; i < ranges.length; i++) {
        var pos = ranges[i].from();
        var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);
        spaces.push(spaceStr(tabSize - col % tabSize));
      }
      cm.replaceSelections(spaces);
    },
    defaultTab: function (cm) {
      if (cm.somethingSelected()) { cm.indentSelection("add"); }
      else { cm.execCommand("insertTab"); }
    },
    // Swap the two chars left and right of each selection's head.
    // Move cursor behind the two swapped characters afterwards.
    //
    // Doesn't consider line feeds a character.
    // Doesn't scan more than one line above to find a character.
    // Doesn't do anything on an empty line.
    // Doesn't do anything with non-empty selections.
    transposeChars: function (cm) { return runInOp(cm, function () {
      var ranges = cm.listSelections(), newSel = [];
      for (var i = 0; i < ranges.length; i++) {
        if (!ranges[i].empty()) { continue }
        var cur = ranges[i].head, line = getLine(cm.doc, cur.line).text;
        if (line) {
          if (cur.ch == line.length) { cur = new Pos(cur.line, cur.ch - 1); }
          if (cur.ch > 0) {
            cur = new Pos(cur.line, cur.ch + 1);
            cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2),
                            Pos(cur.line, cur.ch - 2), cur, "+transpose");
          } else if (cur.line > cm.doc.first) {
            var prev = getLine(cm.doc, cur.line - 1).text;
            if (prev) {
              cur = new Pos(cur.line, 1);
              cm.replaceRange(line.charAt(0) + cm.doc.lineSeparator() +
                              prev.charAt(prev.length - 1),
                              Pos(cur.line - 1, prev.length - 1), cur, "+transpose");
            }
          }
        }
        newSel.push(new Range(cur, cur));
      }
      cm.setSelections(newSel);
    }); },
    newlineAndIndent: function (cm) { return runInOp(cm, function () {
      var sels = cm.listSelections();
      for (var i = sels.length - 1; i >= 0; i--)
        { cm.replaceRange(cm.doc.lineSeparator(), sels[i].anchor, sels[i].head, "+input"); }
      sels = cm.listSelections();
      for (var i$1 = 0; i$1 < sels.length; i$1++)
        { cm.indentLine(sels[i$1].from().line, null, true); }
      ensureCursorVisible(cm);
    }); },
    openLine: function (cm) { return cm.replaceSelection("\n", "start"); },
    toggleOverwrite: function (cm) { return cm.toggleOverwrite(); }
  };


  function lineStart(cm, lineN) {
    var line = getLine(cm.doc, lineN);
    var visual = visualLine(line);
    if (visual != line) { lineN = lineNo(visual); }
    return endOfLine(true, cm, visual, lineN, 1)
  }
  function lineEnd(cm, lineN) {
    var line = getLine(cm.doc, lineN);
    var visual = visualLineEnd(line);
    if (visual != line) { lineN = lineNo(visual); }
    return endOfLine(true, cm, line, lineN, -1)
  }
  function lineStartSmart(cm, pos) {
    var start = lineStart(cm, pos.line);
    var line = getLine(cm.doc, start.line);
    var order = getOrder(line, cm.doc.direction);
    if (!order || order[0].level == 0) {
      var firstNonWS = Math.max(start.ch, line.text.search(/\S/));
      var inWS = pos.line == start.line && pos.ch <= firstNonWS && pos.ch;
      return Pos(start.line, inWS ? 0 : firstNonWS, start.sticky)
    }
    return start
  }

  // Run a handler that was bound to a key.
  function doHandleBinding(cm, bound, dropShift) {
    if (typeof bound == "string") {
      bound = commands[bound];
      if (!bound) { return false }
    }
    // Ensure previous input has been read, so that the handler sees a
    // consistent view of the document
    cm.display.input.ensurePolled();
    var prevShift = cm.display.shift, done = false;
    try {
      if (cm.isReadOnly()) { cm.state.suppressEdits = true; }
      if (dropShift) { cm.display.shift = false; }
      done = bound(cm) != Pass;
    } finally {
      cm.display.shift = prevShift;
      cm.state.suppressEdits = false;
    }
    return done
  }

  function lookupKeyForEditor(cm, name, handle) {
    for (var i = 0; i < cm.state.keyMaps.length; i++) {
      var result = lookupKey(name, cm.state.keyMaps[i], handle, cm);
      if (result) { return result }
    }
    return (cm.options.extraKeys && lookupKey(name, cm.options.extraKeys, handle, cm))
      || lookupKey(name, cm.options.keyMap, handle, cm)
  }

  // Note that, despite the name, this function is also used to check
  // for bound mouse clicks.

  var stopSeq = new Delayed;

  function dispatchKey(cm, name, e, handle) {
    var seq = cm.state.keySeq;
    if (seq) {
      if (isModifierKey(name)) { return "handled" }
      if (/\'$/.test(name))
        { cm.state.keySeq = null; }
      else
        { stopSeq.set(50, function () {
          if (cm.state.keySeq == seq) {
            cm.state.keySeq = null;
            cm.display.input.reset();
          }
        }); }
      if (dispatchKeyInner(cm, seq + " " + name, e, handle)) { return true }
    }
    return dispatchKeyInner(cm, name, e, handle)
  }

  function dispatchKeyInner(cm, name, e, handle) {
    var result = lookupKeyForEditor(cm, name, handle);

    if (result == "multi")
      { cm.state.keySeq = name; }
    if (result == "handled")
      { signalLater(cm, "keyHandled", cm, name, e); }

    if (result == "handled" || result == "multi") {
      e_preventDefault(e);
      restartBlink(cm);
    }

    return !!result
  }

  // Handle a key from the keydown event.
  function handleKeyBinding(cm, e) {
    var name = keyName(e, true);
    if (!name) { return false }

    if (e.shiftKey && !cm.state.keySeq) {
      // First try to resolve full name (including 'Shift-'). Failing
      // that, see if there is a cursor-motion command (starting with
      // 'go') bound to the keyname without 'Shift-'.
      return dispatchKey(cm, "Shift-" + name, e, function (b) { return doHandleBinding(cm, b, true); })
          || dispatchKey(cm, name, e, function (b) {
               if (typeof b == "string" ? /^go[A-Z]/.test(b) : b.motion)
                 { return doHandleBinding(cm, b) }
             })
    } else {
      return dispatchKey(cm, name, e, function (b) { return doHandleBinding(cm, b); })
    }
  }

  // Handle a key from the keypress event
  function handleCharBinding(cm, e, ch) {
    return dispatchKey(cm, "'" + ch + "'", e, function (b) { return doHandleBinding(cm, b, true); })
  }

  var lastStoppedKey = null;
  function onKeyDown(e) {
    var cm = this;
    if (e.target && e.target != cm.display.input.getField()) { return }
    cm.curOp.focus = activeElt();
    if (signalDOMEvent(cm, e)) { return }
    // IE does strange things with escape.
    if (ie && ie_version < 11 && e.keyCode == 27) { e.returnValue = false; }
    var code = e.keyCode;
    cm.display.shift = code == 16 || e.shiftKey;
    var handled = handleKeyBinding(cm, e);
    if (presto) {
      lastStoppedKey = handled ? code : null;
      // Opera has no cut event... we try to at least catch the key combo
      if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey))
        { cm.replaceSelection("", null, "cut"); }
    }
    if (gecko && !mac && !handled && code == 46 && e.shiftKey && !e.ctrlKey && document.execCommand)
      { document.execCommand("cut"); }

    // Turn mouse into crosshair when Alt is held on Mac.
    if (code == 18 && !/\bCodeMirror-crosshair\b/.test(cm.display.lineDiv.className))
      { showCrossHair(cm); }
  }

  function showCrossHair(cm) {
    var lineDiv = cm.display.lineDiv;
    addClass(lineDiv, "CodeMirror-crosshair");

    function up(e) {
      if (e.keyCode == 18 || !e.altKey) {
        rmClass(lineDiv, "CodeMirror-crosshair");
        off(document, "keyup", up);
        off(document, "mouseover", up);
      }
    }
    on(document, "keyup", up);
    on(document, "mouseover", up);
  }

  function onKeyUp(e) {
    if (e.keyCode == 16) { this.doc.sel.shift = false; }
    signalDOMEvent(this, e);
  }

  function onKeyPress(e) {
    var cm = this;
    if (e.target && e.target != cm.display.input.getField()) { return }
    if (eventInWidget(cm.display, e) || signalDOMEvent(cm, e) || e.ctrlKey && !e.altKey || mac && e.metaKey) { return }
    var keyCode = e.keyCode, charCode = e.charCode;
    if (presto && keyCode == lastStoppedKey) {lastStoppedKey = null; e_preventDefault(e); return}
    if ((presto && (!e.which || e.which < 10)) && handleKeyBinding(cm, e)) { return }
    var ch = String.fromCharCode(charCode == null ? keyCode : charCode);
    // Some browsers fire keypress events for backspace
    if (ch == "\x08") { return }
    if (handleCharBinding(cm, e, ch)) { return }
    cm.display.input.onKeyPress(e);
  }

  var DOUBLECLICK_DELAY = 400;

  var PastClick = function(time, pos, button) {
    this.time = time;
    this.pos = pos;
    this.button = button;
  };

  PastClick.prototype.compare = function (time, pos, button) {
    return this.time + DOUBLECLICK_DELAY > time &&
      cmp(pos, this.pos) == 0 && button == this.button
  };

  var lastClick, lastDoubleClick;
  function clickRepeat(pos, button) {
    var now = +new Date;
    if (lastDoubleClick && lastDoubleClick.compare(now, pos, button)) {
      lastClick = lastDoubleClick = null;
      return "triple"
    } else if (lastClick && lastClick.compare(now, pos, button)) {
      lastDoubleClick = new PastClick(now, pos, button);
      lastClick = null;
      return "double"
    } else {
      lastClick = new PastClick(now, pos, button);
      lastDoubleClick = null;
      return "single"
    }
  }

  // A mouse down can be a single click, double click, triple click,
  // start of selection drag, start of text drag, new cursor
  // (ctrl-click), rectangle drag (alt-drag), or xwin
  // middle-click-paste. Or it might be a click on something we should
  // not interfere with, such as a scrollbar or widget.
  function onMouseDown(e) {
    var cm = this, display = cm.display;
    if (signalDOMEvent(cm, e) || display.activeTouch && display.input.supportsTouch()) { return }
    display.input.ensurePolled();
    display.shift = e.shiftKey;

    if (eventInWidget(display, e)) {
      if (!webkit) {
        // Briefly turn off draggability, to allow widgets to do
        // normal dragging things.
        display.scroller.draggable = false;
        setTimeout(function () { return display.scroller.draggable = true; }, 100);
      }
      return
    }
    if (clickInGutter(cm, e)) { return }
    var pos = posFromMouse(cm, e), button = e_button(e), repeat = pos ? clickRepeat(pos, button) : "single";
    window.focus();

    // #3261: make sure, that we're not starting a second selection
    if (button == 1 && cm.state.selectingText)
      { cm.state.selectingText(e); }

    if (pos && handleMappedButton(cm, button, pos, repeat, e)) { return }

    if (button == 1) {
      if (pos) { leftButtonDown(cm, pos, repeat, e); }
      else if (e_target(e) == display.scroller) { e_preventDefault(e); }
    } else if (button == 2) {
      if (pos) { extendSelection(cm.doc, pos); }
      setTimeout(function () { return display.input.focus(); }, 20);
    } else if (button == 3) {
      if (captureRightClick) { cm.display.input.onContextMenu(e); }
      else { delayBlurEvent(cm); }
    }
  }

  function handleMappedButton(cm, button, pos, repeat, event) {
    var name = "Click";
    if (repeat == "double") { name = "Double" + name; }
    else if (repeat == "triple") { name = "Triple" + name; }
    name = (button == 1 ? "Left" : button == 2 ? "Middle" : "Right") + name;

    return dispatchKey(cm,  addModifierNames(name, event), event, function (bound) {
      if (typeof bound == "string") { bound = commands[bound]; }
      if (!bound) { return false }
      var done = false;
      try {
        if (cm.isReadOnly()) { cm.state.suppressEdits = true; }
        done = bound(cm, pos) != Pass;
      } finally {
        cm.state.suppressEdits = false;
      }
      return done
    })
  }

  function configureMouse(cm, repeat, event) {
    var option = cm.getOption("configureMouse");
    var value = option ? option(cm, repeat, event) : {};
    if (value.unit == null) {
      var rect = chromeOS ? event.shiftKey && event.metaKey : event.altKey;
      value.unit = rect ? "rectangle" : repeat == "single" ? "char" : repeat == "double" ? "word" : "line";
    }
    if (value.extend == null || cm.doc.extend) { value.extend = cm.doc.extend || event.shiftKey; }
    if (value.addNew == null) { value.addNew = mac ? event.metaKey : event.ctrlKey; }
    if (value.moveOnDrag == null) { value.moveOnDrag = !(mac ? event.altKey : event.ctrlKey); }
    return value
  }

  function leftButtonDown(cm, pos, repeat, event) {
    if (ie) { setTimeout(bind(ensureFocus, cm), 0); }
    else { cm.curOp.focus = activeElt(); }

    var behavior = configureMouse(cm, repeat, event);

    var sel = cm.doc.sel, contained;
    if (cm.options.dragDrop && dragAndDrop && !cm.isReadOnly() &&
        repeat == "single" && (contained = sel.contains(pos)) > -1 &&
        (cmp((contained = sel.ranges[contained]).from(), pos) < 0 || pos.xRel > 0) &&
        (cmp(contained.to(), pos) > 0 || pos.xRel < 0))
      { leftButtonStartDrag(cm, event, pos, behavior); }
    else
      { leftButtonSelect(cm, event, pos, behavior); }
  }

  // Start a text drag. When it ends, see if any dragging actually
  // happen, and treat as a click if it didn't.
  function leftButtonStartDrag(cm, event, pos, behavior) {
    var display = cm.display, moved = false;
    var dragEnd = operation(cm, function (e) {
      if (webkit) { display.scroller.draggable = false; }
      cm.state.draggingText = false;
      off(display.wrapper.ownerDocument, "mouseup", dragEnd);
      off(display.wrapper.ownerDocument, "mousemove", mouseMove);
      off(display.scroller, "dragstart", dragStart);
      off(display.scroller, "drop", dragEnd);
      if (!moved) {
        e_preventDefault(e);
        if (!behavior.addNew)
          { extendSelection(cm.doc, pos, null, null, behavior.extend); }
        // Work around unexplainable focus problem in IE9 (#2127) and Chrome (#3081)
        if ((webkit && !safari) || ie && ie_version == 9)
          { setTimeout(function () {display.wrapper.ownerDocument.body.focus({preventScroll: true}); display.input.focus();}, 20); }
        else
          { display.input.focus(); }
      }
    });
    var mouseMove = function(e2) {
      moved = moved || Math.abs(event.clientX - e2.clientX) + Math.abs(event.clientY - e2.clientY) >= 10;
    };
    var dragStart = function () { return moved = true; };
    // Let the drag handler handle this.
    if (webkit) { display.scroller.draggable = true; }
    cm.state.draggingText = dragEnd;
    dragEnd.copy = !behavior.moveOnDrag;
    // IE's approach to draggable
    if (display.scroller.dragDrop) { display.scroller.dragDrop(); }
    on(display.wrapper.ownerDocument, "mouseup", dragEnd);
    on(display.wrapper.ownerDocument, "mousemove", mouseMove);
    on(display.scroller, "dragstart", dragStart);
    on(display.scroller, "drop", dragEnd);

    delayBlurEvent(cm);
    setTimeout(function () { return display.input.focus(); }, 20);
  }

  function rangeForUnit(cm, pos, unit) {
    if (unit == "char") { return new Range(pos, pos) }
    if (unit == "word") { return cm.findWordAt(pos) }
    if (unit == "line") { return new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0))) }
    var result = unit(cm, pos);
    return new Range(result.from, result.to)
  }

  // Normal selection, as opposed to text dragging.
  function leftButtonSelect(cm, event, start, behavior) {
    var display = cm.display, doc = cm.doc;
    e_preventDefault(event);

    var ourRange, ourIndex, startSel = doc.sel, ranges = startSel.ranges;
    if (behavior.addNew && !behavior.extend) {
      ourIndex = doc.sel.contains(start);
      if (ourIndex > -1)
        { ourRange = ranges[ourIndex]; }
      else
        { ourRange = new Range(start, start); }
    } else {
      ourRange = doc.sel.primary();
      ourIndex = doc.sel.primIndex;
    }

    if (behavior.unit == "rectangle") {
      if (!behavior.addNew) { ourRange = new Range(start, start); }
      start = posFromMouse(cm, event, true, true);
      ourIndex = -1;
    } else {
      var range = rangeForUnit(cm, start, behavior.unit);
      if (behavior.extend)
        { ourRange = extendRange(ourRange, range.anchor, range.head, behavior.extend); }
      else
        { ourRange = range; }
    }

    if (!behavior.addNew) {
      ourIndex = 0;
      setSelection(doc, new Selection([ourRange], 0), sel_mouse);
      startSel = doc.sel;
    } else if (ourIndex == -1) {
      ourIndex = ranges.length;
      setSelection(doc, normalizeSelection(cm, ranges.concat([ourRange]), ourIndex),
                   {scroll: false, origin: "*mouse"});
    } else if (ranges.length > 1 && ranges[ourIndex].empty() && behavior.unit == "char" && !behavior.extend) {
      setSelection(doc, normalizeSelection(cm, ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0),
                   {scroll: false, origin: "*mouse"});
      startSel = doc.sel;
    } else {
      replaceOneSelection(doc, ourIndex, ourRange, sel_mouse);
    }

    var lastPos = start;
    function extendTo(pos) {
      if (cmp(lastPos, pos) == 0) { return }
      lastPos = pos;

      if (behavior.unit == "rectangle") {
        var ranges = [], tabSize = cm.options.tabSize;
        var startCol = countColumn(getLine(doc, start.line).text, start.ch, tabSize);
        var posCol = countColumn(getLine(doc, pos.line).text, pos.ch, tabSize);
        var left = Math.min(startCol, posCol), right = Math.max(startCol, posCol);
        for (var line = Math.min(start.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start.line, pos.line));
             line <= end; line++) {
          var text = getLine(doc, line).text, leftPos = findColumn(text, left, tabSize);
          if (left == right)
            { ranges.push(new Range(Pos(line, leftPos), Pos(line, leftPos))); }
          else if (text.length > leftPos)
            { ranges.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize)))); }
        }
        if (!ranges.length) { ranges.push(new Range(start, start)); }
        setSelection(doc, normalizeSelection(cm, startSel.ranges.slice(0, ourIndex).concat(ranges), ourIndex),
                     {origin: "*mouse", scroll: false});
        cm.scrollIntoView(pos);
      } else {
        var oldRange = ourRange;
        var range = rangeForUnit(cm, pos, behavior.unit);
        var anchor = oldRange.anchor, head;
        if (cmp(range.anchor, anchor) > 0) {
          head = range.head;
          anchor = minPos(oldRange.from(), range.anchor);
        } else {
          head = range.anchor;
          anchor = maxPos(oldRange.to(), range.head);
        }
        var ranges$1 = startSel.ranges.slice(0);
        ranges$1[ourIndex] = bidiSimplify(cm, new Range(clipPos(doc, anchor), head));
        setSelection(doc, normalizeSelection(cm, ranges$1, ourIndex), sel_mouse);
      }
    }

    var editorSize = display.wrapper.getBoundingClientRect();
    // Used to ensure timeout re-tries don't fire when another extend
    // happened in the meantime (clearTimeout isn't reliable -- at
    // least on Chrome, the timeouts still happen even when cleared,
    // if the clear happens after their scheduled firing time).
    var counter = 0;

    function extend(e) {
      var curCount = ++counter;
      var cur = posFromMouse(cm, e, true, behavior.unit == "rectangle");
      if (!cur) { return }
      if (cmp(cur, lastPos) != 0) {
        cm.curOp.focus = activeElt();
        extendTo(cur);
        var visible = visibleLines(display, doc);
        if (cur.line >= visible.to || cur.line < visible.from)
          { setTimeout(operation(cm, function () {if (counter == curCount) { extend(e); }}), 150); }
      } else {
        var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;
        if (outside) { setTimeout(operation(cm, function () {
          if (counter != curCount) { return }
          display.scroller.scrollTop += outside;
          extend(e);
        }), 50); }
      }
    }

    function done(e) {
      cm.state.selectingText = false;
      counter = Infinity;
      // If e is null or undefined we interpret this as someone trying
      // to explicitly cancel the selection rather than the user
      // letting go of the mouse button.
      if (e) {
        e_preventDefault(e);
        display.input.focus();
      }
      off(display.wrapper.ownerDocument, "mousemove", move);
      off(display.wrapper.ownerDocument, "mouseup", up);
      doc.history.lastSelOrigin = null;
    }

    var move = operation(cm, function (e) {
      if (e.buttons === 0 || !e_button(e)) { done(e); }
      else { extend(e); }
    });
    var up = operation(cm, done);
    cm.state.selectingText = up;
    on(display.wrapper.ownerDocument, "mousemove", move);
    on(display.wrapper.ownerDocument, "mouseup", up);
  }

  // Used when mouse-selecting to adjust the anchor to the proper side
  // of a bidi jump depending on the visual position of the head.
  function bidiSimplify(cm, range) {
    var anchor = range.anchor;
    var head = range.head;
    var anchorLine = getLine(cm.doc, anchor.line);
    if (cmp(anchor, head) == 0 && anchor.sticky == head.sticky) { return range }
    var order = getOrder(anchorLine);
    if (!order) { return range }
    var index = getBidiPartAt(order, anchor.ch, anchor.sticky), part = order[index];
    if (part.from != anchor.ch && part.to != anchor.ch) { return range }
    var boundary = index + ((part.from == anchor.ch) == (part.level != 1) ? 0 : 1);
    if (boundary == 0 || boundary == order.length) { return range }

    // Compute the relative visual position of the head compared to the
    // anchor (<0 is to the left, >0 to the right)
    var leftSide;
    if (head.line != anchor.line) {
      leftSide = (head.line - anchor.line) * (cm.doc.direction == "ltr" ? 1 : -1) > 0;
    } else {
      var headIndex = getBidiPartAt(order, head.ch, head.sticky);
      var dir = headIndex - index || (head.ch - anchor.ch) * (part.level == 1 ? -1 : 1);
      if (headIndex == boundary - 1 || headIndex == boundary)
        { leftSide = dir < 0; }
      else
        { leftSide = dir > 0; }
    }

    var usePart = order[boundary + (leftSide ? -1 : 0)];
    var from = leftSide == (usePart.level == 1);
    var ch = from ? usePart.from : usePart.to, sticky = from ? "after" : "before";
    return anchor.ch == ch && anchor.sticky == sticky ? range : new Range(new Pos(anchor.line, ch, sticky), head)
  }


  // Determines whether an event happened in the gutter, and fires the
  // handlers for the corresponding event.
  function gutterEvent(cm, e, type, prevent) {
    var mX, mY;
    if (e.touches) {
      mX = e.touches[0].clientX;
      mY = e.touches[0].clientY;
    } else {
      try { mX = e.clientX; mY = e.clientY; }
      catch(e$1) { return false }
    }
    if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right)) { return false }
    if (prevent) { e_preventDefault(e); }

    var display = cm.display;
    var lineBox = display.lineDiv.getBoundingClientRect();

    if (mY > lineBox.bottom || !hasHandler(cm, type)) { return e_defaultPrevented(e) }
    mY -= lineBox.top - display.viewOffset;

    for (var i = 0; i < cm.display.gutterSpecs.length; ++i) {
      var g = display.gutters.childNodes[i];
      if (g && g.getBoundingClientRect().right >= mX) {
        var line = lineAtHeight(cm.doc, mY);
        var gutter = cm.display.gutterSpecs[i];
        signal(cm, type, cm, line, gutter.className, e);
        return e_defaultPrevented(e)
      }
    }
  }

  function clickInGutter(cm, e) {
    return gutterEvent(cm, e, "gutterClick", true)
  }

  // CONTEXT MENU HANDLING

  // To make the context menu work, we need to briefly unhide the
  // textarea (making it as unobtrusive as possible) to let the
  // right-click take effect on it.
  function onContextMenu(cm, e) {
    if (eventInWidget(cm.display, e) || contextMenuInGutter(cm, e)) { return }
    if (signalDOMEvent(cm, e, "contextmenu")) { return }
    if (!captureRightClick) { cm.display.input.onContextMenu(e); }
  }

  function contextMenuInGutter(cm, e) {
    if (!hasHandler(cm, "gutterContextMenu")) { return false }
    return gutterEvent(cm, e, "gutterContextMenu", false)
  }

  function themeChanged(cm) {
    cm.display.wrapper.className = cm.display.wrapper.className.replace(/\s*cm-s-\S+/g, "") +
      cm.options.theme.replace(/(^|\s)\s*/g, " cm-s-");
    clearCaches(cm);
  }

  var Init = {toString: function(){return "CodeMirror.Init"}};

  var defaults = {};
  var optionHandlers = {};

  function defineOptions(CodeMirror) {
    var optionHandlers = CodeMirror.optionHandlers;

    function option(name, deflt, handle, notOnInit) {
      CodeMirror.defaults[name] = deflt;
      if (handle) { optionHandlers[name] =
        notOnInit ? function (cm, val, old) {if (old != Init) { handle(cm, val, old); }} : handle; }
    }

    CodeMirror.defineOption = option;

    // Passed to option handlers when there is no old value.
    CodeMirror.Init = Init;

    // These two are, on init, called from the constructor because they
    // have to be initialized before the editor can start at all.
    option("value", "", function (cm, val) { return cm.setValue(val); }, true);
    option("mode", null, function (cm, val) {
      cm.doc.modeOption = val;
      loadMode(cm);
    }, true);

    option("indentUnit", 2, loadMode, true);
    option("indentWithTabs", false);
    option("smartIndent", true);
    option("tabSize", 4, function (cm) {
      resetModeState(cm);
      clearCaches(cm);
      regChange(cm);
    }, true);

    option("lineSeparator", null, function (cm, val) {
      cm.doc.lineSep = val;
      if (!val) { return }
      var newBreaks = [], lineNo = cm.doc.first;
      cm.doc.iter(function (line) {
        for (var pos = 0;;) {
          var found = line.text.indexOf(val, pos);
          if (found == -1) { break }
          pos = found + val.length;
          newBreaks.push(Pos(lineNo, found));
        }
        lineNo++;
      });
      for (var i = newBreaks.length - 1; i >= 0; i--)
        { replaceRange(cm.doc, val, newBreaks[i], Pos(newBreaks[i].line, newBreaks[i].ch + val.length)); }
    });
    option("specialChars", /[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200c\u200e\u200f\u2028\u2029\ufeff\ufff9-\ufffc]/g, function (cm, val, old) {
      cm.state.specialChars = new RegExp(val.source + (val.test("\t") ? "" : "|\t"), "g");
      if (old != Init) { cm.refresh(); }
    });
    option("specialCharPlaceholder", defaultSpecialCharPlaceholder, function (cm) { return cm.refresh(); }, true);
    option("electricChars", true);
    option("inputStyle", mobile ? "contenteditable" : "textarea", function () {
      throw new Error("inputStyle can not (yet) be changed in a running editor") // FIXME
    }, true);
    option("spellcheck", false, function (cm, val) { return cm.getInputField().spellcheck = val; }, true);
    option("autocorrect", false, function (cm, val) { return cm.getInputField().autocorrect = val; }, true);
    option("autocapitalize", false, function (cm, val) { return cm.getInputField().autocapitalize = val; }, true);
    option("rtlMoveVisually", !windows);
    option("wholeLineUpdateBefore", true);

    option("theme", "default", function (cm) {
      themeChanged(cm);
      updateGutters(cm);
    }, true);
    option("keyMap", "default", function (cm, val, old) {
      var next = getKeyMap(val);
      var prev = old != Init && getKeyMap(old);
      if (prev && prev.detach) { prev.detach(cm, next); }
      if (next.attach) { next.attach(cm, prev || null); }
    });
    option("extraKeys", null);
    option("configureMouse", null);

    option("lineWrapping", false, wrappingChanged, true);
    option("gutters", [], function (cm, val) {
      cm.display.gutterSpecs = getGutters(val, cm.options.lineNumbers);
      updateGutters(cm);
    }, true);
    option("fixedGutter", true, function (cm, val) {
      cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + "px" : "0";
      cm.refresh();
    }, true);
    option("coverGutterNextToScrollbar", false, function (cm) { return updateScrollbars(cm); }, true);
    option("scrollbarStyle", "native", function (cm) {
      initScrollbars(cm);
      updateScrollbars(cm);
      cm.display.scrollbars.setScrollTop(cm.doc.scrollTop);
      cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft);
    }, true);
    option("lineNumbers", false, function (cm, val) {
      cm.display.gutterSpecs = getGutters(cm.options.gutters, val);
      updateGutters(cm);
    }, true);
    option("firstLineNumber", 1, updateGutters, true);
    option("lineNumberFormatter", function (integer) { return integer; }, updateGutters, true);
    option("showCursorWhenSelecting", false, updateSelection, true);

    option("resetSelectionOnContextMenu", true);
    option("lineWiseCopyCut", true);
    option("pasteLinesPerSelection", true);
    option("selectionsMayTouch", false);

    option("readOnly", false, function (cm, val) {
      if (val == "nocursor") {
        onBlur(cm);
        cm.display.input.blur();
      }
      cm.display.input.readOnlyChanged(val);
    });

    option("screenReaderLabel", null, function (cm, val) {
      val = (val === '') ? null : val;
      cm.display.input.screenReaderLabelChanged(val);
    });

    option("disableInput", false, function (cm, val) {if (!val) { cm.display.input.reset(); }}, true);
    option("dragDrop", true, dragDropChanged);
    option("allowDropFileTypes", null);

    option("cursorBlinkRate", 530);
    option("cursorScrollMargin", 0);
    option("cursorHeight", 1, updateSelection, true);
    option("singleCursorHeightPerLine", true, updateSelection, true);
    option("workTime", 100);
    option("workDelay", 100);
    option("flattenSpans", true, resetModeState, true);
    option("addModeClass", false, resetModeState, true);
    option("pollInterval", 100);
    option("undoDepth", 200, function (cm, val) { return cm.doc.history.undoDepth = val; });
    option("historyEventDelay", 1250);
    option("viewportMargin", 10, function (cm) { return cm.refresh(); }, true);
    option("maxHighlightLength", 10000, resetModeState, true);
    option("moveInputWithCursor", true, function (cm, val) {
      if (!val) { cm.display.input.resetPosition(); }
    });

    option("tabindex", null, function (cm, val) { return cm.display.input.getField().tabIndex = val || ""; });
    option("autofocus", null);
    option("direction", "ltr", function (cm, val) { return cm.doc.setDirection(val); }, true);
    option("phrases", null);
  }

  function dragDropChanged(cm, value, old) {
    var wasOn = old && old != Init;
    if (!value != !wasOn) {
      var funcs = cm.display.dragFunctions;
      var toggle = value ? on : off;
      toggle(cm.display.scroller, "dragstart", funcs.start);
      toggle(cm.display.scroller, "dragenter", funcs.enter);
      toggle(cm.display.scroller, "dragover", funcs.over);
      toggle(cm.display.scroller, "dragleave", funcs.leave);
      toggle(cm.display.scroller, "drop", funcs.drop);
    }
  }

  function wrappingChanged(cm) {
    if (cm.options.lineWrapping) {
      addClass(cm.display.wrapper, "CodeMirror-wrap");
      cm.display.sizer.style.minWidth = "";
      cm.display.sizerWidth = null;
    } else {
      rmClass(cm.display.wrapper, "CodeMirror-wrap");
      findMaxLine(cm);
    }
    estimateLineHeights(cm);
    regChange(cm);
    clearCaches(cm);
    setTimeout(function () { return updateScrollbars(cm); }, 100);
  }

  // A CodeMirror instance represents an editor. This is the object
  // that user code is usually dealing with.

  function CodeMirror(place, options) {
    var this$1 = this;

    if (!(this instanceof CodeMirror)) { return new CodeMirror(place, options) }

    this.options = options = options ? copyObj(options) : {};
    // Determine effective options based on given values and defaults.
    copyObj(defaults, options, false);

    var doc = options.value;
    if (typeof doc == "string") { doc = new Doc(doc, options.mode, null, options.lineSeparator, options.direction); }
    else if (options.mode) { doc.modeOption = options.mode; }
    this.doc = doc;

    var input = new CodeMirror.inputStyles[options.inputStyle](this);
    var display = this.display = new Display(place, doc, input, options);
    display.wrapper.CodeMirror = this;
    themeChanged(this);
    if (options.lineWrapping)
      { this.display.wrapper.className += " CodeMirror-wrap"; }
    initScrollbars(this);

    this.state = {
      keyMaps: [],  // stores maps added by addKeyMap
      overlays: [], // highlighting overlays, as added by addOverlay
      modeGen: 0,   // bumped when mode/overlay changes, used to invalidate highlighting info
      overwrite: false,
      delayingBlurEvent: false,
      focused: false,
      suppressEdits: false, // used to disable editing during key handlers when in readOnly mode
      pasteIncoming: -1, cutIncoming: -1, // help recognize paste/cut edits in input.poll
      selectingText: false,
      draggingText: false,
      highlight: new Delayed(), // stores highlight worker timeout
      keySeq: null,  // Unfinished key sequence
      specialChars: null
    };

    if (options.autofocus && !mobile) { display.input.focus(); }

    // Override magic textarea content restore that IE sometimes does
    // on our hidden textarea on reload
    if (ie && ie_version < 11) { setTimeout(function () { return this$1.display.input.reset(true); }, 20); }

    registerEventHandlers(this);
    ensureGlobalHandlers();

    startOperation(this);
    this.curOp.forceUpdate = true;
    attachDoc(this, doc);

    if ((options.autofocus && !mobile) || this.hasFocus())
      { setTimeout(function () {
        if (this$1.hasFocus() && !this$1.state.focused) { onFocus(this$1); }
      }, 20); }
    else
      { onBlur(this); }

    for (var opt in optionHandlers) { if (optionHandlers.hasOwnProperty(opt))
      { optionHandlers[opt](this, options[opt], Init); } }
    maybeUpdateLineNumberWidth(this);
    if (options.finishInit) { options.finishInit(this); }
    for (var i = 0; i < initHooks.length; ++i) { initHooks[i](this); }
    endOperation(this);
    // Suppress optimizelegibility in Webkit, since it breaks text
    // measuring on line wrapping boundaries.
    if (webkit && options.lineWrapping &&
        getComputedStyle(display.lineDiv).textRendering == "optimizelegibility")
      { display.lineDiv.style.textRendering = "auto"; }
  }

  // The default configuration options.
  CodeMirror.defaults = defaults;
  // Functions to run when options are changed.
  CodeMirror.optionHandlers = optionHandlers;

  // Attach the necessary event handlers when initializing the editor
  function registerEventHandlers(cm) {
    var d = cm.display;
    on(d.scroller, "mousedown", operation(cm, onMouseDown));
    // Older IE's will not fire a second mousedown for a double click
    if (ie && ie_version < 11)
      { on(d.scroller, "dblclick", operation(cm, function (e) {
        if (signalDOMEvent(cm, e)) { return }
        var pos = posFromMouse(cm, e);
        if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) { return }
        e_preventDefault(e);
        var word = cm.findWordAt(pos);
        extendSelection(cm.doc, word.anchor, word.head);
      })); }
    else
      { on(d.scroller, "dblclick", function (e) { return signalDOMEvent(cm, e) || e_preventDefault(e); }); }
    // Some browsers fire contextmenu *after* opening the menu, at
    // which point we can't mess with it anymore. Context menu is
    // handled in onMouseDown for these browsers.
    on(d.scroller, "contextmenu", function (e) { return onContextMenu(cm, e); });
    on(d.input.getField(), "contextmenu", function (e) {
      if (!d.scroller.contains(e.target)) { onContextMenu(cm, e); }
    });

    // Used to suppress mouse event handling when a touch happens
    var touchFinished, prevTouch = {end: 0};
    function finishTouch() {
      if (d.activeTouch) {
        touchFinished = setTimeout(function () { return d.activeTouch = null; }, 1000);
        prevTouch = d.activeTouch;
        prevTouch.end = +new Date;
      }
    }
    function isMouseLikeTouchEvent(e) {
      if (e.touches.length != 1) { return false }
      var touch = e.touches[0];
      return touch.radiusX <= 1 && touch.radiusY <= 1
    }
    function farAway(touch, other) {
      if (other.left == null) { return true }
      var dx = other.left - touch.left, dy = other.top - touch.top;
      return dx * dx + dy * dy > 20 * 20
    }
    on(d.scroller, "touchstart", function (e) {
      if (!signalDOMEvent(cm, e) && !isMouseLikeTouchEvent(e) && !clickInGutter(cm, e)) {
        d.input.ensurePolled();
        clearTimeout(touchFinished);
        var now = +new Date;
        d.activeTouch = {start: now, moved: false,
                         prev: now - prevTouch.end <= 300 ? prevTouch : null};
        if (e.touches.length == 1) {
          d.activeTouch.left = e.touches[0].pageX;
          d.activeTouch.top = e.touches[0].pageY;
        }
      }
    });
    on(d.scroller, "touchmove", function () {
      if (d.activeTouch) { d.activeTouch.moved = true; }
    });
    on(d.scroller, "touchend", function (e) {
      var touch = d.activeTouch;
      if (touch && !eventInWidget(d, e) && touch.left != null &&
          !touch.moved && new Date - touch.start < 300) {
        var pos = cm.coordsChar(d.activeTouch, "page"), range;
        if (!touch.prev || farAway(touch, touch.prev)) // Single tap
          { range = new Range(pos, pos); }
        else if (!touch.prev.prev || farAway(touch, touch.prev.prev)) // Double tap
          { range = cm.findWordAt(pos); }
        else // Triple tap
          { range = new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0))); }
        cm.setSelection(range.anchor, range.head);
        cm.focus();
        e_preventDefault(e);
      }
      finishTouch();
    });
    on(d.scroller, "touchcancel", finishTouch);

    // Sync scrolling between fake scrollbars and real scrollable
    // area, ensure viewport is updated when scrolling.
    on(d.scroller, "scroll", function () {
      if (d.scroller.clientHeight) {
        updateScrollTop(cm, d.scroller.scrollTop);
        setScrollLeft(cm, d.scroller.scrollLeft, true);
        signal(cm, "scroll", cm);
      }
    });

    // Listen to wheel events in order to try and update the viewport on time.
    on(d.scroller, "mousewheel", function (e) { return onScrollWheel(cm, e); });
    on(d.scroller, "DOMMouseScroll", function (e) { return onScrollWheel(cm, e); });

    // Prevent wrapper from ever scrolling
    on(d.wrapper, "scroll", function () { return d.wrapper.scrollTop = d.wrapper.scrollLeft = 0; });

    d.dragFunctions = {
      enter: function (e) {if (!signalDOMEvent(cm, e)) { e_stop(e); }},
      over: function (e) {if (!signalDOMEvent(cm, e)) { onDragOver(cm, e); e_stop(e); }},
      start: function (e) { return onDragStart(cm, e); },
      drop: operation(cm, onDrop),
      leave: function (e) {if (!signalDOMEvent(cm, e)) { clearDragCursor(cm); }}
    };

    var inp = d.input.getField();
    on(inp, "keyup", function (e) { return onKeyUp.call(cm, e); });
    on(inp, "keydown", operation(cm, onKeyDown));
    on(inp, "keypress", operation(cm, onKeyPress));
    on(inp, "focus", function (e) { return onFocus(cm, e); });
    on(inp, "blur", function (e) { return onBlur(cm, e); });
  }

  var initHooks = [];
  CodeMirror.defineInitHook = function (f) { return initHooks.push(f); };

  // Indent the given line. The how parameter can be "smart",
  // "add"/null, "subtract", or "prev". When aggressive is false
  // (typically set to true for forced single-line indents), empty
  // lines are not indented, and places where the mode returns Pass
  // are left alone.
  function indentLine(cm, n, how, aggressive) {
    var doc = cm.doc, state;
    if (how == null) { how = "add"; }
    if (how == "smart") {
      // Fall back to "prev" when the mode doesn't have an indentation
      // method.
      if (!doc.mode.indent) { how = "prev"; }
      else { state = getContextBefore(cm, n).state; }
    }

    var tabSize = cm.options.tabSize;
    var line = getLine(doc, n), curSpace = countColumn(line.text, null, tabSize);
    if (line.stateAfter) { line.stateAfter = null; }
    var curSpaceString = line.text.match(/^\s*/)[0], indentation;
    if (!aggressive && !/\S/.test(line.text)) {
      indentation = 0;
      how = "not";
    } else if (how == "smart") {
      indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);
      if (indentation == Pass || indentation > 150) {
        if (!aggressive) { return }
        how = "prev";
      }
    }
    if (how == "prev") {
      if (n > doc.first) { indentation = countColumn(getLine(doc, n-1).text, null, tabSize); }
      else { indentation = 0; }
    } else if (how == "add") {
      indentation = curSpace + cm.options.indentUnit;
    } else if (how == "subtract") {
      indentation = curSpace - cm.options.indentUnit;
    } else if (typeof how == "number") {
      indentation = curSpace + how;
    }
    indentation = Math.max(0, indentation);

    var indentString = "", pos = 0;
    if (cm.options.indentWithTabs)
      { for (var i = Math.floor(indentation / tabSize); i; --i) {pos += tabSize; indentString += "\t";} }
    if (pos < indentation) { indentString += spaceStr(indentation - pos); }

    if (indentString != curSpaceString) {
      replaceRange(doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), "+input");
      line.stateAfter = null;
      return true
    } else {
      // Ensure that, if the cursor was in the whitespace at the start
      // of the line, it is moved to the end of that space.
      for (var i$1 = 0; i$1 < doc.sel.ranges.length; i$1++) {
        var range = doc.sel.ranges[i$1];
        if (range.head.line == n && range.head.ch < curSpaceString.length) {
          var pos$1 = Pos(n, curSpaceString.length);
          replaceOneSelection(doc, i$1, new Range(pos$1, pos$1));
          break
        }
      }
    }
  }

  // This will be set to a {lineWise: bool, text: [string]} object, so
  // that, when pasting, we know what kind of selections the copied
  // text was made out of.
  var lastCopied = null;

  function setLastCopied(newLastCopied) {
    lastCopied = newLastCopied;
  }

  function applyTextInput(cm, inserted, deleted, sel, origin) {
    var doc = cm.doc;
    cm.display.shift = false;
    if (!sel) { sel = doc.sel; }

    var recent = +new Date - 200;
    var paste = origin == "paste" || cm.state.pasteIncoming > recent;
    var textLines = splitLinesAuto(inserted), multiPaste = null;
    // When pasting N lines into N selections, insert one line per selection
    if (paste && sel.ranges.length > 1) {
      if (lastCopied && lastCopied.text.join("\n") == inserted) {
        if (sel.ranges.length % lastCopied.text.length == 0) {
          multiPaste = [];
          for (var i = 0; i < lastCopied.text.length; i++)
            { multiPaste.push(doc.splitLines(lastCopied.text[i])); }
        }
      } else if (textLines.length == sel.ranges.length && cm.options.pasteLinesPerSelection) {
        multiPaste = map(textLines, function (l) { return [l]; });
      }
    }

    var updateInput = cm.curOp.updateInput;
    // Normal behavior is to insert the new text into every selection
    for (var i$1 = sel.ranges.length - 1; i$1 >= 0; i$1--) {
      var range = sel.ranges[i$1];
      var from = range.from(), to = range.to();
      if (range.empty()) {
        if (deleted && deleted > 0) // Handle deletion
          { from = Pos(from.line, from.ch - deleted); }
        else if (cm.state.overwrite && !paste) // Handle overwrite
          { to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length)); }
        else if (paste && lastCopied && lastCopied.lineWise && lastCopied.text.join("\n") == textLines.join("\n"))
          { from = to = Pos(from.line, 0); }
      }
      var changeEvent = {from: from, to: to, text: multiPaste ? multiPaste[i$1 % multiPaste.length] : textLines,
                         origin: origin || (paste ? "paste" : cm.state.cutIncoming > recent ? "cut" : "+input")};
      makeChange(cm.doc, changeEvent);
      signalLater(cm, "inputRead", cm, changeEvent);
    }
    if (inserted && !paste)
      { triggerElectric(cm, inserted); }

    ensureCursorVisible(cm);
    if (cm.curOp.updateInput < 2) { cm.curOp.updateInput = updateInput; }
    cm.curOp.typing = true;
    cm.state.pasteIncoming = cm.state.cutIncoming = -1;
  }

  function handlePaste(e, cm) {
    var pasted = e.clipboardData && e.clipboardData.getData("Text");
    if (pasted) {
      e.preventDefault();
      if (!cm.isReadOnly() && !cm.options.disableInput)
        { runInOp(cm, function () { return applyTextInput(cm, pasted, 0, null, "paste"); }); }
      return true
    }
  }

  function triggerElectric(cm, inserted) {
    // When an 'electric' character is inserted, immediately trigger a reindent
    if (!cm.options.electricChars || !cm.options.smartIndent) { return }
    var sel = cm.doc.sel;

    for (var i = sel.ranges.length - 1; i >= 0; i--) {
      var range = sel.ranges[i];
      if (range.head.ch > 100 || (i && sel.ranges[i - 1].head.line == range.head.line)) { continue }
      var mode = cm.getModeAt(range.head);
      var indented = false;
      if (mode.electricChars) {
        for (var j = 0; j < mode.electricChars.length; j++)
          { if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {
            indented = indentLine(cm, range.head.line, "smart");
            break
          } }
      } else if (mode.electricInput) {
        if (mode.electricInput.test(getLine(cm.doc, range.head.line).text.slice(0, range.head.ch)))
          { indented = indentLine(cm, range.head.line, "smart"); }
      }
      if (indented) { signalLater(cm, "electricInput", cm, range.head.line); }
    }
  }

  function copyableRanges(cm) {
    var text = [], ranges = [];
    for (var i = 0; i < cm.doc.sel.ranges.length; i++) {
      var line = cm.doc.sel.ranges[i].head.line;
      var lineRange = {anchor: Pos(line, 0), head: Pos(line + 1, 0)};
      ranges.push(lineRange);
      text.push(cm.getRange(lineRange.anchor, lineRange.head));
    }
    return {text: text, ranges: ranges}
  }

  function disableBrowserMagic(field, spellcheck, autocorrect, autocapitalize) {
    field.setAttribute("autocorrect", autocorrect ? "" : "off");
    field.setAttribute("autocapitalize", autocapitalize ? "" : "off");
    field.setAttribute("spellcheck", !!spellcheck);
  }

  function hiddenTextarea() {
    var te = elt("textarea", null, null, "position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none");
    var div = elt("div", [te], null, "overflow: hidden; position: relative; width: 3px; height: 0px;");
    // The textarea is kept positioned near the cursor to prevent the
    // fact that it'll be scrolled into view on input from scrolling
    // our fake cursor out of view. On webkit, when wrap=off, paste is
    // very slow. So make the area wide instead.
    if (webkit) { te.style.width = "1000px"; }
    else { te.setAttribute("wrap", "off"); }
    // If border: 0; -- iOS fails to open keyboard (issue #1287)
    if (ios) { te.style.border = "1px solid black"; }
    disableBrowserMagic(te);
    return div
  }

  // The publicly visible API. Note that methodOp(f) means
  // 'wrap f in an operation, performed on its `this` parameter'.

  // This is not the complete set of editor methods. Most of the
  // methods defined on the Doc type are also injected into
  // CodeMirror.prototype, for backwards compatibility and
  // convenience.

  function addEditorMethods(CodeMirror) {
    var optionHandlers = CodeMirror.optionHandlers;

    var helpers = CodeMirror.helpers = {};

    CodeMirror.prototype = {
      constructor: CodeMirror,
      focus: function(){window.focus(); this.display.input.focus();},

      setOption: function(option, value) {
        var options = this.options, old = options[option];
        if (options[option] == value && option != "mode") { return }
        options[option] = value;
        if (optionHandlers.hasOwnProperty(option))
          { operation(this, optionHandlers[option])(this, value, old); }
        signal(this, "optionChange", this, option);
      },

      getOption: function(option) {return this.options[option]},
      getDoc: function() {return this.doc},

      addKeyMap: function(map, bottom) {
        this.state.keyMaps[bottom ? "push" : "unshift"](getKeyMap(map));
      },
      removeKeyMap: function(map) {
        var maps = this.state.keyMaps;
        for (var i = 0; i < maps.length; ++i)
          { if (maps[i] == map || maps[i].name == map) {
            maps.splice(i, 1);
            return true
          } }
      },

      addOverlay: methodOp(function(spec, options) {
        var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);
        if (mode.startState) { throw new Error("Overlays may not be stateful.") }
        insertSorted(this.state.overlays,
                     {mode: mode, modeSpec: spec, opaque: options && options.opaque,
                      priority: (options && options.priority) || 0},
                     function (overlay) { return overlay.priority; });
        this.state.modeGen++;
        regChange(this);
      }),
      removeOverlay: methodOp(function(spec) {
        var overlays = this.state.overlays;
        for (var i = 0; i < overlays.length; ++i) {
          var cur = overlays[i].modeSpec;
          if (cur == spec || typeof spec == "string" && cur.name == spec) {
            overlays.splice(i, 1);
            this.state.modeGen++;
            regChange(this);
            return
          }
        }
      }),

      indentLine: methodOp(function(n, dir, aggressive) {
        if (typeof dir != "string" && typeof dir != "number") {
          if (dir == null) { dir = this.options.smartIndent ? "smart" : "prev"; }
          else { dir = dir ? "add" : "subtract"; }
        }
        if (isLine(this.doc, n)) { indentLine(this, n, dir, aggressive); }
      }),
      indentSelection: methodOp(function(how) {
        var ranges = this.doc.sel.ranges, end = -1;
        for (var i = 0; i < ranges.length; i++) {
          var range = ranges[i];
          if (!range.empty()) {
            var from = range.from(), to = range.to();
            var start = Math.max(end, from.line);
            end = Math.min(this.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;
            for (var j = start; j < end; ++j)
              { indentLine(this, j, how); }
            var newRanges = this.doc.sel.ranges;
            if (from.ch == 0 && ranges.length == newRanges.length && newRanges[i].from().ch > 0)
              { replaceOneSelection(this.doc, i, new Range(from, newRanges[i].to()), sel_dontScroll); }
          } else if (range.head.line > end) {
            indentLine(this, range.head.line, how, true);
            end = range.head.line;
            if (i == this.doc.sel.primIndex) { ensureCursorVisible(this); }
          }
        }
      }),

      // Fetch the parser token for a given character. Useful for hacks
      // that want to inspect the mode state (say, for completion).
      getTokenAt: function(pos, precise) {
        return takeToken(this, pos, precise)
      },

      getLineTokens: function(line, precise) {
        return takeToken(this, Pos(line), precise, true)
      },

      getTokenTypeAt: function(pos) {
        pos = clipPos(this.doc, pos);
        var styles = getLineStyles(this, getLine(this.doc, pos.line));
        var before = 0, after = (styles.length - 1) / 2, ch = pos.ch;
        var type;
        if (ch == 0) { type = styles[2]; }
        else { for (;;) {
          var mid = (before + after) >> 1;
          if ((mid ? styles[mid * 2 - 1] : 0) >= ch) { after = mid; }
          else if (styles[mid * 2 + 1] < ch) { before = mid + 1; }
          else { type = styles[mid * 2 + 2]; break }
        } }
        var cut = type ? type.indexOf("overlay ") : -1;
        return cut < 0 ? type : cut == 0 ? null : type.slice(0, cut - 1)
      },

      getModeAt: function(pos) {
        var mode = this.doc.mode;
        if (!mode.innerMode) { return mode }
        return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode
      },

      getHelper: function(pos, type) {
        return this.getHelpers(pos, type)[0]
      },

      getHelpers: function(pos, type) {
        var found = [];
        if (!helpers.hasOwnProperty(type)) { return found }
        var help = helpers[type], mode = this.getModeAt(pos);
        if (typeof mode[type] == "string") {
          if (help[mode[type]]) { found.push(help[mode[type]]); }
        } else if (mode[type]) {
          for (var i = 0; i < mode[type].length; i++) {
            var val = help[mode[type][i]];
            if (val) { found.push(val); }
          }
        } else if (mode.helperType && help[mode.helperType]) {
          found.push(help[mode.helperType]);
        } else if (help[mode.name]) {
          found.push(help[mode.name]);
        }
        for (var i$1 = 0; i$1 < help._global.length; i$1++) {
          var cur = help._global[i$1];
          if (cur.pred(mode, this) && indexOf(found, cur.val) == -1)
            { found.push(cur.val); }
        }
        return found
      },

      getStateAfter: function(line, precise) {
        var doc = this.doc;
        line = clipLine(doc, line == null ? doc.first + doc.size - 1: line);
        return getContextBefore(this, line + 1, precise).state
      },

      cursorCoords: function(start, mode) {
        var pos, range = this.doc.sel.primary();
        if (start == null) { pos = range.head; }
        else if (typeof start == "object") { pos = clipPos(this.doc, start); }
        else { pos = start ? range.from() : range.to(); }
        return cursorCoords(this, pos, mode || "page")
      },

      charCoords: function(pos, mode) {
        return charCoords(this, clipPos(this.doc, pos), mode || "page")
      },

      coordsChar: function(coords, mode) {
        coords = fromCoordSystem(this, coords, mode || "page");
        return coordsChar(this, coords.left, coords.top)
      },

      lineAtHeight: function(height, mode) {
        height = fromCoordSystem(this, {top: height, left: 0}, mode || "page").top;
        return lineAtHeight(this.doc, height + this.display.viewOffset)
      },
      heightAtLine: function(line, mode, includeWidgets) {
        var end = false, lineObj;
        if (typeof line == "number") {
          var last = this.doc.first + this.doc.size - 1;
          if (line < this.doc.first) { line = this.doc.first; }
          else if (line > last) { line = last; end = true; }
          lineObj = getLine(this.doc, line);
        } else {
          lineObj = line;
        }
        return intoCoordSystem(this, lineObj, {top: 0, left: 0}, mode || "page", includeWidgets || end).top +
          (end ? this.doc.height - heightAtLine(lineObj) : 0)
      },

      defaultTextHeight: function() { return textHeight(this.display) },
      defaultCharWidth: function() { return charWidth(this.display) },

      getViewport: function() { return {from: this.display.viewFrom, to: this.display.viewTo}},

      addWidget: function(pos, node, scroll, vert, horiz) {
        var display = this.display;
        pos = cursorCoords(this, clipPos(this.doc, pos));
        var top = pos.bottom, left = pos.left;
        node.style.position = "absolute";
        node.setAttribute("cm-ignore-events", "true");
        this.display.input.setUneditable(node);
        display.sizer.appendChild(node);
        if (vert == "over") {
          top = pos.top;
        } else if (vert == "above" || vert == "near") {
          var vspace = Math.max(display.wrapper.clientHeight, this.doc.height),
          hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);
          // Default to positioning above (if specified and possible); otherwise default to positioning below
          if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight)
            { top = pos.top - node.offsetHeight; }
          else if (pos.bottom + node.offsetHeight <= vspace)
            { top = pos.bottom; }
          if (left + node.offsetWidth > hspace)
            { left = hspace - node.offsetWidth; }
        }
        node.style.top = top + "px";
        node.style.left = node.style.right = "";
        if (horiz == "right") {
          left = display.sizer.clientWidth - node.offsetWidth;
          node.style.right = "0px";
        } else {
          if (horiz == "left") { left = 0; }
          else if (horiz == "middle") { left = (display.sizer.clientWidth - node.offsetWidth) / 2; }
          node.style.left = left + "px";
        }
        if (scroll)
          { scrollIntoView(this, {left: left, top: top, right: left + node.offsetWidth, bottom: top + node.offsetHeight}); }
      },

      triggerOnKeyDown: methodOp(onKeyDown),
      triggerOnKeyPress: methodOp(onKeyPress),
      triggerOnKeyUp: onKeyUp,
      triggerOnMouseDown: methodOp(onMouseDown),

      execCommand: function(cmd) {
        if (commands.hasOwnProperty(cmd))
          { return commands[cmd].call(null, this) }
      },

      triggerElectric: methodOp(function(text) { triggerElectric(this, text); }),

      findPosH: function(from, amount, unit, visually) {
        var dir = 1;
        if (amount < 0) { dir = -1; amount = -amount; }
        var cur = clipPos(this.doc, from);
        for (var i = 0; i < amount; ++i) {
          cur = findPosH(this.doc, cur, dir, unit, visually);
          if (cur.hitSide) { break }
        }
        return cur
      },

      moveH: methodOp(function(dir, unit) {
        var this$1 = this;

        this.extendSelectionsBy(function (range) {
          if (this$1.display.shift || this$1.doc.extend || range.empty())
            { return findPosH(this$1.doc, range.head, dir, unit, this$1.options.rtlMoveVisually) }
          else
            { return dir < 0 ? range.from() : range.to() }
        }, sel_move);
      }),

      deleteH: methodOp(function(dir, unit) {
        var sel = this.doc.sel, doc = this.doc;
        if (sel.somethingSelected())
          { doc.replaceSelection("", null, "+delete"); }
        else
          { deleteNearSelection(this, function (range) {
            var other = findPosH(doc, range.head, dir, unit, false);
            return dir < 0 ? {from: other, to: range.head} : {from: range.head, to: other}
          }); }
      }),

      findPosV: function(from, amount, unit, goalColumn) {
        var dir = 1, x = goalColumn;
        if (amount < 0) { dir = -1; amount = -amount; }
        var cur = clipPos(this.doc, from);
        for (var i = 0; i < amount; ++i) {
          var coords = cursorCoords(this, cur, "div");
          if (x == null) { x = coords.left; }
          else { coords.left = x; }
          cur = findPosV(this, coords, dir, unit);
          if (cur.hitSide) { break }
        }
        return cur
      },

      moveV: methodOp(function(dir, unit) {
        var this$1 = this;

        var doc = this.doc, goals = [];
        var collapse = !this.display.shift && !doc.extend && doc.sel.somethingSelected();
        doc.extendSelectionsBy(function (range) {
          if (collapse)
            { return dir < 0 ? range.from() : range.to() }
          var headPos = cursorCoords(this$1, range.head, "div");
          if (range.goalColumn != null) { headPos.left = range.goalColumn; }
          goals.push(headPos.left);
          var pos = findPosV(this$1, headPos, dir, unit);
          if (unit == "page" && range == doc.sel.primary())
            { addToScrollTop(this$1, charCoords(this$1, pos, "div").top - headPos.top); }
          return pos
        }, sel_move);
        if (goals.length) { for (var i = 0; i < doc.sel.ranges.length; i++)
          { doc.sel.ranges[i].goalColumn = goals[i]; } }
      }),

      // Find the word at the given position (as returned by coordsChar).
      findWordAt: function(pos) {
        var doc = this.doc, line = getLine(doc, pos.line).text;
        var start = pos.ch, end = pos.ch;
        if (line) {
          var helper = this.getHelper(pos, "wordChars");
          if ((pos.sticky == "before" || end == line.length) && start) { --start; } else { ++end; }
          var startChar = line.charAt(start);
          var check = isWordChar(startChar, helper)
            ? function (ch) { return isWordChar(ch, helper); }
            : /\s/.test(startChar) ? function (ch) { return /\s/.test(ch); }
            : function (ch) { return (!/\s/.test(ch) && !isWordChar(ch)); };
          while (start > 0 && check(line.charAt(start - 1))) { --start; }
          while (end < line.length && check(line.charAt(end))) { ++end; }
        }
        return new Range(Pos(pos.line, start), Pos(pos.line, end))
      },

      toggleOverwrite: function(value) {
        if (value != null && value == this.state.overwrite) { return }
        if (this.state.overwrite = !this.state.overwrite)
          { addClass(this.display.cursorDiv, "CodeMirror-overwrite"); }
        else
          { rmClass(this.display.cursorDiv, "CodeMirror-overwrite"); }

        signal(this, "overwriteToggle", this, this.state.overwrite);
      },
      hasFocus: function() { return this.display.input.getField() == activeElt() },
      isReadOnly: function() { return !!(this.options.readOnly || this.doc.cantEdit) },

      scrollTo: methodOp(function (x, y) { scrollToCoords(this, x, y); }),
      getScrollInfo: function() {
        var scroller = this.display.scroller;
        return {left: scroller.scrollLeft, top: scroller.scrollTop,
                height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,
                width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,
                clientHeight: displayHeight(this), clientWidth: displayWidth(this)}
      },

      scrollIntoView: methodOp(function(range, margin) {
        if (range == null) {
          range = {from: this.doc.sel.primary().head, to: null};
          if (margin == null) { margin = this.options.cursorScrollMargin; }
        } else if (typeof range == "number") {
          range = {from: Pos(range, 0), to: null};
        } else if (range.from == null) {
          range = {from: range, to: null};
        }
        if (!range.to) { range.to = range.from; }
        range.margin = margin || 0;

        if (range.from.line != null) {
          scrollToRange(this, range);
        } else {
          scrollToCoordsRange(this, range.from, range.to, range.margin);
        }
      }),

      setSize: methodOp(function(width, height) {
        var this$1 = this;

        var interpret = function (val) { return typeof val == "number" || /^\d+$/.test(String(val)) ? val + "px" : val; };
        if (width != null) { this.display.wrapper.style.width = interpret(width); }
        if (height != null) { this.display.wrapper.style.height = interpret(height); }
        if (this.options.lineWrapping) { clearLineMeasurementCache(this); }
        var lineNo = this.display.viewFrom;
        this.doc.iter(lineNo, this.display.viewTo, function (line) {
          if (line.widgets) { for (var i = 0; i < line.widgets.length; i++)
            { if (line.widgets[i].noHScroll) { regLineChange(this$1, lineNo, "widget"); break } } }
          ++lineNo;
        });
        this.curOp.forceUpdate = true;
        signal(this, "refresh", this);
      }),

      operation: function(f){return runInOp(this, f)},
      startOperation: function(){return startOperation(this)},
      endOperation: function(){return endOperation(this)},

      refresh: methodOp(function() {
        var oldHeight = this.display.cachedTextHeight;
        regChange(this);
        this.curOp.forceUpdate = true;
        clearCaches(this);
        scrollToCoords(this, this.doc.scrollLeft, this.doc.scrollTop);
        updateGutterSpace(this.display);
        if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) > .5 || this.options.lineWrapping)
          { estimateLineHeights(this); }
        signal(this, "refresh", this);
      }),

      swapDoc: methodOp(function(doc) {
        var old = this.doc;
        old.cm = null;
        // Cancel the current text selection if any (#5821)
        if (this.state.selectingText) { this.state.selectingText(); }
        attachDoc(this, doc);
        clearCaches(this);
        this.display.input.reset();
        scrollToCoords(this, doc.scrollLeft, doc.scrollTop);
        this.curOp.forceScroll = true;
        signalLater(this, "swapDoc", this, old);
        return old
      }),

      phrase: function(phraseText) {
        var phrases = this.options.phrases;
        return phrases && Object.prototype.hasOwnProperty.call(phrases, phraseText) ? phrases[phraseText] : phraseText
      },

      getInputField: function(){return this.display.input.getField()},
      getWrapperElement: function(){return this.display.wrapper},
      getScrollerElement: function(){return this.display.scroller},
      getGutterElement: function(){return this.display.gutters}
    };
    eventMixin(CodeMirror);

    CodeMirror.registerHelper = function(type, name, value) {
      if (!helpers.hasOwnProperty(type)) { helpers[type] = CodeMirror[type] = {_global: []}; }
      helpers[type][name] = value;
    };
    CodeMirror.registerGlobalHelper = function(type, name, predicate, value) {
      CodeMirror.registerHelper(type, name, value);
      helpers[type]._global.push({pred: predicate, val: value});
    };
  }

  // Used for horizontal relative motion. Dir is -1 or 1 (left or
  // right), unit can be "codepoint", "char", "column" (like char, but
  // doesn't cross line boundaries), "word" (across next word), or
  // "group" (to the start of next group of word or
  // non-word-non-whitespace chars). The visually param controls
  // whether, in right-to-left text, direction 1 means to move towards
  // the next index in the string, or towards the character to the right
  // of the current position. The resulting position will have a
  // hitSide=true property if it reached the end of the document.
  function findPosH(doc, pos, dir, unit, visually) {
    var oldPos = pos;
    var origDir = dir;
    var lineObj = getLine(doc, pos.line);
    var lineDir = visually && doc.direction == "rtl" ? -dir : dir;
    function findNextLine() {
      var l = pos.line + lineDir;
      if (l < doc.first || l >= doc.first + doc.size) { return false }
      pos = new Pos(l, pos.ch, pos.sticky);
      return lineObj = getLine(doc, l)
    }
    function moveOnce(boundToLine) {
      var next;
      if (unit == "codepoint") {
        var ch = lineObj.text.charCodeAt(pos.ch + (unit > 0 ? 0 : -1));
        if (isNaN(ch)) { next = null; }
        else { next = new Pos(pos.line, Math.max(0, Math.min(lineObj.text.length, pos.ch + dir * (ch >= 0xD800 && ch < 0xDC00 ? 2 : 1))),
                            -dir); }
      } else if (visually) {
        next = moveVisually(doc.cm, lineObj, pos, dir);
      } else {
        next = moveLogically(lineObj, pos, dir);
      }
      if (next == null) {
        if (!boundToLine && findNextLine())
          { pos = endOfLine(visually, doc.cm, lineObj, pos.line, lineDir); }
        else
          { return false }
      } else {
        pos = next;
      }
      return true
    }

    if (unit == "char" || unit == "codepoint") {
      moveOnce();
    } else if (unit == "column") {
      moveOnce(true);
    } else if (unit == "word" || unit == "group") {
      var sawType = null, group = unit == "group";
      var helper = doc.cm && doc.cm.getHelper(pos, "wordChars");
      for (var first = true;; first = false) {
        if (dir < 0 && !moveOnce(!first)) { break }
        var cur = lineObj.text.charAt(pos.ch) || "\n";
        var type = isWordChar(cur, helper) ? "w"
          : group && cur == "\n" ? "n"
          : !group || /\s/.test(cur) ? null
          : "p";
        if (group && !first && !type) { type = "s"; }
        if (sawType && sawType != type) {
          if (dir < 0) {dir = 1; moveOnce(); pos.sticky = "after";}
          break
        }

        if (type) { sawType = type; }
        if (dir > 0 && !moveOnce(!first)) { break }
      }
    }
    var result = skipAtomic(doc, pos, oldPos, origDir, true);
    if (equalCursorPos(oldPos, result)) { result.hitSide = true; }
    return result
  }

  // For relative vertical movement. Dir may be -1 or 1. Unit can be
  // "page" or "line". The resulting position will have a hitSide=true
  // property if it reached the end of the document.
  function findPosV(cm, pos, dir, unit) {
    var doc = cm.doc, x = pos.left, y;
    if (unit == "page") {
      var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);
      var moveAmount = Math.max(pageSize - .5 * textHeight(cm.display), 3);
      y = (dir > 0 ? pos.bottom : pos.top) + dir * moveAmount;

    } else if (unit == "line") {
      y = dir > 0 ? pos.bottom + 3 : pos.top - 3;
    }
    var target;
    for (;;) {
      target = coordsChar(cm, x, y);
      if (!target.outside) { break }
      if (dir < 0 ? y <= 0 : y >= doc.height) { target.hitSide = true; break }
      y += dir * 5;
    }
    return target
  }

  // CONTENTEDITABLE INPUT STYLE

  var ContentEditableInput = function(cm) {
    this.cm = cm;
    this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null;
    this.polling = new Delayed();
    this.composing = null;
    this.gracePeriod = false;
    this.readDOMTimeout = null;
  };

  ContentEditableInput.prototype.init = function (display) {
      var this$1 = this;

    var input = this, cm = input.cm;
    var div = input.div = display.lineDiv;
    disableBrowserMagic(div, cm.options.spellcheck, cm.options.autocorrect, cm.options.autocapitalize);

    function belongsToInput(e) {
      for (var t = e.target; t; t = t.parentNode) {
        if (t == div) { return true }
        if (/\bCodeMirror-(?:line)?widget\b/.test(t.className)) { break }
      }
      return false
    }

    on(div, "paste", function (e) {
      if (!belongsToInput(e) || signalDOMEvent(cm, e) || handlePaste(e, cm)) { return }
      // IE doesn't fire input events, so we schedule a read for the pasted content in this way
      if (ie_version <= 11) { setTimeout(operation(cm, function () { return this$1.updateFromDOM(); }), 20); }
    });

    on(div, "compositionstart", function (e) {
      this$1.composing = {data: e.data, done: false};
    });
    on(div, "compositionupdate", function (e) {
      if (!this$1.composing) { this$1.composing = {data: e.data, done: false}; }
    });
    on(div, "compositionend", function (e) {
      if (this$1.composing) {
        if (e.data != this$1.composing.data) { this$1.readFromDOMSoon(); }
        this$1.composing.done = true;
      }
    });

    on(div, "touchstart", function () { return input.forceCompositionEnd(); });

    on(div, "input", function () {
      if (!this$1.composing) { this$1.readFromDOMSoon(); }
    });

    function onCopyCut(e) {
      if (!belongsToInput(e) || signalDOMEvent(cm, e)) { return }
      if (cm.somethingSelected()) {
        setLastCopied({lineWise: false, text: cm.getSelections()});
        if (e.type == "cut") { cm.replaceSelection("", null, "cut"); }
      } else if (!cm.options.lineWiseCopyCut) {
        return
      } else {
        var ranges = copyableRanges(cm);
        setLastCopied({lineWise: true, text: ranges.text});
        if (e.type == "cut") {
          cm.operation(function () {
            cm.setSelections(ranges.ranges, 0, sel_dontScroll);
            cm.replaceSelection("", null, "cut");
          });
        }
      }
      if (e.clipboardData) {
        e.clipboardData.clearData();
        var content = lastCopied.text.join("\n");
        // iOS exposes the clipboard API, but seems to discard content inserted into it
        e.clipboardData.setData("Text", content);
        if (e.clipboardData.getData("Text") == content) {
          e.preventDefault();
          return
        }
      }
      // Old-fashioned briefly-focus-a-textarea hack
      var kludge = hiddenTextarea(), te = kludge.firstChild;
      cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild);
      te.value = lastCopied.text.join("\n");
      var hadFocus = document.activeElement;
      selectInput(te);
      setTimeout(function () {
        cm.display.lineSpace.removeChild(kludge);
        hadFocus.focus();
        if (hadFocus == div) { input.showPrimarySelection(); }
      }, 50);
    }
    on(div, "copy", onCopyCut);
    on(div, "cut", onCopyCut);
  };

  ContentEditableInput.prototype.screenReaderLabelChanged = function (label) {
    // Label for screenreaders, accessibility
    if(label) {
      this.div.setAttribute('aria-label', label);
    } else {
      this.div.removeAttribute('aria-label');
    }
  };

  ContentEditableInput.prototype.prepareSelection = function () {
    var result = prepareSelection(this.cm, false);
    result.focus = document.activeElement == this.div;
    return result
  };

  ContentEditableInput.prototype.showSelection = function (info, takeFocus) {
    if (!info || !this.cm.display.view.length) { return }
    if (info.focus || takeFocus) { this.showPrimarySelection(); }
    this.showMultipleSelections(info);
  };

  ContentEditableInput.prototype.getSelection = function () {
    return this.cm.display.wrapper.ownerDocument.getSelection()
  };

  ContentEditableInput.prototype.showPrimarySelection = function () {
    var sel = this.getSelection(), cm = this.cm, prim = cm.doc.sel.primary();
    var from = prim.from(), to = prim.to();

    if (cm.display.viewTo == cm.display.viewFrom || from.line >= cm.display.viewTo || to.line < cm.display.viewFrom) {
      sel.removeAllRanges();
      return
    }

    var curAnchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);
    var curFocus = domToPos(cm, sel.focusNode, sel.focusOffset);
    if (curAnchor && !curAnchor.bad && curFocus && !curFocus.bad &&
        cmp(minPos(curAnchor, curFocus), from) == 0 &&
        cmp(maxPos(curAnchor, curFocus), to) == 0)
      { return }

    var view = cm.display.view;
    var start = (from.line >= cm.display.viewFrom && posToDOM(cm, from)) ||
        {node: view[0].measure.map[2], offset: 0};
    var end = to.line < cm.display.viewTo && posToDOM(cm, to);
    if (!end) {
      var measure = view[view.length - 1].measure;
      var map = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map;
      end = {node: map[map.length - 1], offset: map[map.length - 2] - map[map.length - 3]};
    }

    if (!start || !end) {
      sel.removeAllRanges();
      return
    }

    var old = sel.rangeCount && sel.getRangeAt(0), rng;
    try { rng = range(start.node, start.offset, end.offset, end.node); }
    catch(e) {} // Our model of the DOM might be outdated, in which case the range we try to set can be impossible
    if (rng) {
      if (!gecko && cm.state.focused) {
        sel.collapse(start.node, start.offset);
        if (!rng.collapsed) {
          sel.removeAllRanges();
          sel.addRange(rng);
        }
      } else {
        sel.removeAllRanges();
        sel.addRange(rng);
      }
      if (old && sel.anchorNode == null) { sel.addRange(old); }
      else if (gecko) { this.startGracePeriod(); }
    }
    this.rememberSelection();
  };

  ContentEditableInput.prototype.startGracePeriod = function () {
      var this$1 = this;

    clearTimeout(this.gracePeriod);
    this.gracePeriod = setTimeout(function () {
      this$1.gracePeriod = false;
      if (this$1.selectionChanged())
        { this$1.cm.operation(function () { return this$1.cm.curOp.selectionChanged = true; }); }
    }, 20);
  };

  ContentEditableInput.prototype.showMultipleSelections = function (info) {
    removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors);
    removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection);
  };

  ContentEditableInput.prototype.rememberSelection = function () {
    var sel = this.getSelection();
    this.lastAnchorNode = sel.anchorNode; this.lastAnchorOffset = sel.anchorOffset;
    this.lastFocusNode = sel.focusNode; this.lastFocusOffset = sel.focusOffset;
  };

  ContentEditableInput.prototype.selectionInEditor = function () {
    var sel = this.getSelection();
    if (!sel.rangeCount) { return false }
    var node = sel.getRangeAt(0).commonAncestorContainer;
    return contains(this.div, node)
  };

  ContentEditableInput.prototype.focus = function () {
    if (this.cm.options.readOnly != "nocursor") {
      if (!this.selectionInEditor() || document.activeElement != this.div)
        { this.showSelection(this.prepareSelection(), true); }
      this.div.focus();
    }
  };
  ContentEditableInput.prototype.blur = function () { this.div.blur(); };
  ContentEditableInput.prototype.getField = function () { return this.div };

  ContentEditableInput.prototype.supportsTouch = function () { return true };

  ContentEditableInput.prototype.receivedFocus = function () {
    var input = this;
    if (this.selectionInEditor())
      { this.pollSelection(); }
    else
      { runInOp(this.cm, function () { return input.cm.curOp.selectionChanged = true; }); }

    function poll() {
      if (input.cm.state.focused) {
        input.pollSelection();
        input.polling.set(input.cm.options.pollInterval, poll);
      }
    }
    this.polling.set(this.cm.options.pollInterval, poll);
  };

  ContentEditableInput.prototype.selectionChanged = function () {
    var sel = this.getSelection();
    return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset ||
      sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset
  };

  ContentEditableInput.prototype.pollSelection = function () {
    if (this.readDOMTimeout != null || this.gracePeriod || !this.selectionChanged()) { return }
    var sel = this.getSelection(), cm = this.cm;
    // On Android Chrome (version 56, at least), backspacing into an
    // uneditable block element will put the cursor in that element,
    // and then, because it's not editable, hide the virtual keyboard.
    // Because Android doesn't allow us to actually detect backspace
    // presses in a sane way, this code checks for when that happens
    // and simulates a backspace press in this case.
    if (android && chrome && this.cm.display.gutterSpecs.length && isInGutter(sel.anchorNode)) {
      this.cm.triggerOnKeyDown({type: "keydown", keyCode: 8, preventDefault: Math.abs});
      this.blur();
      this.focus();
      return
    }
    if (this.composing) { return }
    this.rememberSelection();
    var anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);
    var head = domToPos(cm, sel.focusNode, sel.focusOffset);
    if (anchor && head) { runInOp(cm, function () {
      setSelection(cm.doc, simpleSelection(anchor, head), sel_dontScroll);
      if (anchor.bad || head.bad) { cm.curOp.selectionChanged = true; }
    }); }
  };

  ContentEditableInput.prototype.pollContent = function () {
    if (this.readDOMTimeout != null) {
      clearTimeout(this.readDOMTimeout);
      this.readDOMTimeout = null;
    }

    var cm = this.cm, display = cm.display, sel = cm.doc.sel.primary();
    var from = sel.from(), to = sel.to();
    if (from.ch == 0 && from.line > cm.firstLine())
      { from = Pos(from.line - 1, getLine(cm.doc, from.line - 1).length); }
    if (to.ch == getLine(cm.doc, to.line).text.length && to.line < cm.lastLine())
      { to = Pos(to.line + 1, 0); }
    if (from.line < display.viewFrom || to.line > display.viewTo - 1) { return false }

    var fromIndex, fromLine, fromNode;
    if (from.line == display.viewFrom || (fromIndex = findViewIndex(cm, from.line)) == 0) {
      fromLine = lineNo(display.view[0].line);
      fromNode = display.view[0].node;
    } else {
      fromLine = lineNo(display.view[fromIndex].line);
      fromNode = display.view[fromIndex - 1].node.nextSibling;
    }
    var toIndex = findViewIndex(cm, to.line);
    var toLine, toNode;
    if (toIndex == display.view.length - 1) {
      toLine = display.viewTo - 1;
      toNode = display.lineDiv.lastChild;
    } else {
      toLine = lineNo(display.view[toIndex + 1].line) - 1;
      toNode = display.view[toIndex + 1].node.previousSibling;
    }

    if (!fromNode) { return false }
    var newText = cm.doc.splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine));
    var oldText = getBetween(cm.doc, Pos(fromLine, 0), Pos(toLine, getLine(cm.doc, toLine).text.length));
    while (newText.length > 1 && oldText.length > 1) {
      if (lst(newText) == lst(oldText)) { newText.pop(); oldText.pop(); toLine--; }
      else if (newText[0] == oldText[0]) { newText.shift(); oldText.shift(); fromLine++; }
      else { break }
    }

    var cutFront = 0, cutEnd = 0;
    var newTop = newText[0], oldTop = oldText[0], maxCutFront = Math.min(newTop.length, oldTop.length);
    while (cutFront < maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront))
      { ++cutFront; }
    var newBot = lst(newText), oldBot = lst(oldText);
    var maxCutEnd = Math.min(newBot.length - (newText.length == 1 ? cutFront : 0),
                             oldBot.length - (oldText.length == 1 ? cutFront : 0));
    while (cutEnd < maxCutEnd &&
           newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1))
      { ++cutEnd; }
    // Try to move start of change to start of selection if ambiguous
    if (newText.length == 1 && oldText.length == 1 && fromLine == from.line) {
      while (cutFront && cutFront > from.ch &&
             newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1)) {
        cutFront--;
        cutEnd++;
      }
    }

    newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd).replace(/^\u200b+/, "");
    newText[0] = newText[0].slice(cutFront).replace(/\u200b+$/, "");

    var chFrom = Pos(fromLine, cutFront);
    var chTo = Pos(toLine, oldText.length ? lst(oldText).length - cutEnd : 0);
    if (newText.length > 1 || newText[0] || cmp(chFrom, chTo)) {
      replaceRange(cm.doc, newText, chFrom, chTo, "+input");
      return true
    }
  };

  ContentEditableInput.prototype.ensurePolled = function () {
    this.forceCompositionEnd();
  };
  ContentEditableInput.prototype.reset = function () {
    this.forceCompositionEnd();
  };
  ContentEditableInput.prototype.forceCompositionEnd = function () {
    if (!this.composing) { return }
    clearTimeout(this.readDOMTimeout);
    this.composing = null;
    this.updateFromDOM();
    this.div.blur();
    this.div.focus();
  };
  ContentEditableInput.prototype.readFromDOMSoon = function () {
      var this$1 = this;

    if (this.readDOMTimeout != null) { return }
    this.readDOMTimeout = setTimeout(function () {
      this$1.readDOMTimeout = null;
      if (this$1.composing) {
        if (this$1.composing.done) { this$1.composing = null; }
        else { return }
      }
      this$1.updateFromDOM();
    }, 80);
  };

  ContentEditableInput.prototype.updateFromDOM = function () {
      var this$1 = this;

    if (this.cm.isReadOnly() || !this.pollContent())
      { runInOp(this.cm, function () { return regChange(this$1.cm); }); }
  };

  ContentEditableInput.prototype.setUneditable = function (node) {
    node.contentEditable = "false";
  };

  ContentEditableInput.prototype.onKeyPress = function (e) {
    if (e.charCode == 0 || this.composing) { return }
    e.preventDefault();
    if (!this.cm.isReadOnly())
      { operation(this.cm, applyTextInput)(this.cm, String.fromCharCode(e.charCode == null ? e.keyCode : e.charCode), 0); }
  };

  ContentEditableInput.prototype.readOnlyChanged = function (val) {
    this.div.contentEditable = String(val != "nocursor");
  };

  ContentEditableInput.prototype.onContextMenu = function () {};
  ContentEditableInput.prototype.resetPosition = function () {};

  ContentEditableInput.prototype.needsContentAttribute = true;

  function posToDOM(cm, pos) {
    var view = findViewForLine(cm, pos.line);
    if (!view || view.hidden) { return null }
    var line = getLine(cm.doc, pos.line);
    var info = mapFromLineView(view, line, pos.line);

    var order = getOrder(line, cm.doc.direction), side = "left";
    if (order) {
      var partPos = getBidiPartAt(order, pos.ch);
      side = partPos % 2 ? "right" : "left";
    }
    var result = nodeAndOffsetInLineMap(info.map, pos.ch, side);
    result.offset = result.collapse == "right" ? result.end : result.start;
    return result
  }

  function isInGutter(node) {
    for (var scan = node; scan; scan = scan.parentNode)
      { if (/CodeMirror-gutter-wrapper/.test(scan.className)) { return true } }
    return false
  }

  function badPos(pos, bad) { if (bad) { pos.bad = true; } return pos }

  function domTextBetween(cm, from, to, fromLine, toLine) {
    var text = "", closing = false, lineSep = cm.doc.lineSeparator(), extraLinebreak = false;
    function recognizeMarker(id) { return function (marker) { return marker.id == id; } }
    function close() {
      if (closing) {
        text += lineSep;
        if (extraLinebreak) { text += lineSep; }
        closing = extraLinebreak = false;
      }
    }
    function addText(str) {
      if (str) {
        close();
        text += str;
      }
    }
    function walk(node) {
      if (node.nodeType == 1) {
        var cmText = node.getAttribute("cm-text");
        if (cmText) {
          addText(cmText);
          return
        }
        var markerID = node.getAttribute("cm-marker"), range;
        if (markerID) {
          var found = cm.findMarks(Pos(fromLine, 0), Pos(toLine + 1, 0), recognizeMarker(+markerID));
          if (found.length && (range = found[0].find(0)))
            { addText(getBetween(cm.doc, range.from, range.to).join(lineSep)); }
          return
        }
        if (node.getAttribute("contenteditable") == "false") { return }
        var isBlock = /^(pre|div|p|li|table|br)$/i.test(node.nodeName);
        if (!/^br$/i.test(node.nodeName) && node.textContent.length == 0) { return }

        if (isBlock) { close(); }
        for (var i = 0; i < node.childNodes.length; i++)
          { walk(node.childNodes[i]); }

        if (/^(pre|p)$/i.test(node.nodeName)) { extraLinebreak = true; }
        if (isBlock) { closing = true; }
      } else if (node.nodeType == 3) {
        addText(node.nodeValue.replace(/\u200b/g, "").replace(/\u00a0/g, " "));
      }
    }
    for (;;) {
      walk(from);
      if (from == to) { break }
      from = from.nextSibling;
      extraLinebreak = false;
    }
    return text
  }

  function domToPos(cm, node, offset) {
    var lineNode;
    if (node == cm.display.lineDiv) {
      lineNode = cm.display.lineDiv.childNodes[offset];
      if (!lineNode) { return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), true) }
      node = null; offset = 0;
    } else {
      for (lineNode = node;; lineNode = lineNode.parentNode) {
        if (!lineNode || lineNode == cm.display.lineDiv) { return null }
        if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv) { break }
      }
    }
    for (var i = 0; i < cm.display.view.length; i++) {
      var lineView = cm.display.view[i];
      if (lineView.node == lineNode)
        { return locateNodeInLineView(lineView, node, offset) }
    }
  }

  function locateNodeInLineView(lineView, node, offset) {
    var wrapper = lineView.text.firstChild, bad = false;
    if (!node || !contains(wrapper, node)) { return badPos(Pos(lineNo(lineView.line), 0), true) }
    if (node == wrapper) {
      bad = true;
      node = wrapper.childNodes[offset];
      offset = 0;
      if (!node) {
        var line = lineView.rest ? lst(lineView.rest) : lineView.line;
        return badPos(Pos(lineNo(line), line.text.length), bad)
      }
    }

    var textNode = node.nodeType == 3 ? node : null, topNode = node;
    if (!textNode && node.childNodes.length == 1 && node.firstChild.nodeType == 3) {
      textNode = node.firstChild;
      if (offset) { offset = textNode.nodeValue.length; }
    }
    while (topNode.parentNode != wrapper) { topNode = topNode.parentNode; }
    var measure = lineView.measure, maps = measure.maps;

    function find(textNode, topNode, offset) {
      for (var i = -1; i < (maps ? maps.length : 0); i++) {
        var map = i < 0 ? measure.map : maps[i];
        for (var j = 0; j < map.length; j += 3) {
          var curNode = map[j + 2];
          if (curNode == textNode || curNode == topNode) {
            var line = lineNo(i < 0 ? lineView.line : lineView.rest[i]);
            var ch = map[j] + offset;
            if (offset < 0 || curNode != textNode) { ch = map[j + (offset ? 1 : 0)]; }
            return Pos(line, ch)
          }
        }
      }
    }
    var found = find(textNode, topNode, offset);
    if (found) { return badPos(found, bad) }

    // FIXME this is all really shaky. might handle the few cases it needs to handle, but likely to cause problems
    for (var after = topNode.nextSibling, dist = textNode ? textNode.nodeValue.length - offset : 0; after; after = after.nextSibling) {
      found = find(after, after.firstChild, 0);
      if (found)
        { return badPos(Pos(found.line, found.ch - dist), bad) }
      else
        { dist += after.textContent.length; }
    }
    for (var before = topNode.previousSibling, dist$1 = offset; before; before = before.previousSibling) {
      found = find(before, before.firstChild, -1);
      if (found)
        { return badPos(Pos(found.line, found.ch + dist$1), bad) }
      else
        { dist$1 += before.textContent.length; }
    }
  }

  // TEXTAREA INPUT STYLE

  var TextareaInput = function(cm) {
    this.cm = cm;
    // See input.poll and input.reset
    this.prevInput = "";

    // Flag that indicates whether we expect input to appear real soon
    // now (after some event like 'keypress' or 'input') and are
    // polling intensively.
    this.pollingFast = false;
    // Self-resetting timeout for the poller
    this.polling = new Delayed();
    // Used to work around IE issue with selection being forgotten when focus moves away from textarea
    this.hasSelection = false;
    this.composing = null;
  };

  TextareaInput.prototype.init = function (display) {
      var this$1 = this;

    var input = this, cm = this.cm;
    this.createField(display);
    var te = this.textarea;

    display.wrapper.insertBefore(this.wrapper, display.wrapper.firstChild);

    // Needed to hide big blue blinking cursor on Mobile Safari (doesn't seem to work in iOS 8 anymore)
    if (ios) { te.style.width = "0px"; }

    on(te, "input", function () {
      if (ie && ie_version >= 9 && this$1.hasSelection) { this$1.hasSelection = null; }
      input.poll();
    });

    on(te, "paste", function (e) {
      if (signalDOMEvent(cm, e) || handlePaste(e, cm)) { return }

      cm.state.pasteIncoming = +new Date;
      input.fastPoll();
    });

    function prepareCopyCut(e) {
      if (signalDOMEvent(cm, e)) { return }
      if (cm.somethingSelected()) {
        setLastCopied({lineWise: false, text: cm.getSelections()});
      } else if (!cm.options.lineWiseCopyCut) {
        return
      } else {
        var ranges = copyableRanges(cm);
        setLastCopied({lineWise: true, text: ranges.text});
        if (e.type == "cut") {
          cm.setSelections(ranges.ranges, null, sel_dontScroll);
        } else {
          input.prevInput = "";
          te.value = ranges.text.join("\n");
          selectInput(te);
        }
      }
      if (e.type == "cut") { cm.state.cutIncoming = +new Date; }
    }
    on(te, "cut", prepareCopyCut);
    on(te, "copy", prepareCopyCut);

    on(display.scroller, "paste", function (e) {
      if (eventInWidget(display, e) || signalDOMEvent(cm, e)) { return }
      if (!te.dispatchEvent) {
        cm.state.pasteIncoming = +new Date;
        input.focus();
        return
      }

      // Pass the `paste` event to the textarea so it's handled by its event listener.
      var event = new Event("paste");
      event.clipboardData = e.clipboardData;
      te.dispatchEvent(event);
    });

    // Prevent normal selection in the editor (we handle our own)
    on(display.lineSpace, "selectstart", function (e) {
      if (!eventInWidget(display, e)) { e_preventDefault(e); }
    });

    on(te, "compositionstart", function () {
      var start = cm.getCursor("from");
      if (input.composing) { input.composing.range.clear(); }
      input.composing = {
        start: start,
        range: cm.markText(start, cm.getCursor("to"), {className: "CodeMirror-composing"})
      };
    });
    on(te, "compositionend", function () {
      if (input.composing) {
        input.poll();
        input.composing.range.clear();
        input.composing = null;
      }
    });
  };

  TextareaInput.prototype.createField = function (_display) {
    // Wraps and hides input textarea
    this.wrapper = hiddenTextarea();
    // The semihidden textarea that is focused when the editor is
    // focused, and receives input.
    this.textarea = this.wrapper.firstChild;
  };

  TextareaInput.prototype.screenReaderLabelChanged = function (label) {
    // Label for screenreaders, accessibility
    if(label) {
      this.textarea.setAttribute('aria-label', label);
    } else {
      this.textarea.removeAttribute('aria-label');
    }
  };

  TextareaInput.prototype.prepareSelection = function () {
    // Redraw the selection and/or cursor
    var cm = this.cm, display = cm.display, doc = cm.doc;
    var result = prepareSelection(cm);

    // Move the hidden textarea near the cursor to prevent scrolling artifacts
    if (cm.options.moveInputWithCursor) {
      var headPos = cursorCoords(cm, doc.sel.primary().head, "div");
      var wrapOff = display.wrapper.getBoundingClientRect(), lineOff = display.lineDiv.getBoundingClientRect();
      result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10,
                                          headPos.top + lineOff.top - wrapOff.top));
      result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10,
                                           headPos.left + lineOff.left - wrapOff.left));
    }

    return result
  };

  TextareaInput.prototype.showSelection = function (drawn) {
    var cm = this.cm, display = cm.display;
    removeChildrenAndAdd(display.cursorDiv, drawn.cursors);
    removeChildrenAndAdd(display.selectionDiv, drawn.selection);
    if (drawn.teTop != null) {
      this.wrapper.style.top = drawn.teTop + "px";
      this.wrapper.style.left = drawn.teLeft + "px";
    }
  };

  // Reset the input to correspond to the selection (or to be empty,
  // when not typing and nothing is selected)
  TextareaInput.prototype.reset = function (typing) {
    if (this.contextMenuPending || this.composing) { return }
    var cm = this.cm;
    if (cm.somethingSelected()) {
      this.prevInput = "";
      var content = cm.getSelection();
      this.textarea.value = content;
      if (cm.state.focused) { selectInput(this.textarea); }
      if (ie && ie_version >= 9) { this.hasSelection = content; }
    } else if (!typing) {
      this.prevInput = this.textarea.value = "";
      if (ie && ie_version >= 9) { this.hasSelection = null; }
    }
  };

  TextareaInput.prototype.getField = function () { return this.textarea };

  TextareaInput.prototype.supportsTouch = function () { return false };

  TextareaInput.prototype.focus = function () {
    if (this.cm.options.readOnly != "nocursor" && (!mobile || activeElt() != this.textarea)) {
      try { this.textarea.focus(); }
      catch (e) {} // IE8 will throw if the textarea is display: none or not in DOM
    }
  };

  TextareaInput.prototype.blur = function () { this.textarea.blur(); };

  TextareaInput.prototype.resetPosition = function () {
    this.wrapper.style.top = this.wrapper.style.left = 0;
  };

  TextareaInput.prototype.receivedFocus = function () { this.slowPoll(); };

  // Poll for input changes, using the normal rate of polling. This
  // runs as long as the editor is focused.
  TextareaInput.prototype.slowPoll = function () {
      var this$1 = this;

    if (this.pollingFast) { return }
    this.polling.set(this.cm.options.pollInterval, function () {
      this$1.poll();
      if (this$1.cm.state.focused) { this$1.slowPoll(); }
    });
  };

  // When an event has just come in that is likely to add or change
  // something in the input textarea, we poll faster, to ensure that
  // the change appears on the screen quickly.
  TextareaInput.prototype.fastPoll = function () {
    var missed = false, input = this;
    input.pollingFast = true;
    function p() {
      var changed = input.poll();
      if (!changed && !missed) {missed = true; input.polling.set(60, p);}
      else {input.pollingFast = false; input.slowPoll();}
    }
    input.polling.set(20, p);
  };

  // Read input from the textarea, and update the document to match.
  // When something is selected, it is present in the textarea, and
  // selected (unless it is huge, in which case a placeholder is
  // used). When nothing is selected, the cursor sits after previously
  // seen text (can be empty), which is stored in prevInput (we must
  // not reset the textarea when typing, because that breaks IME).
  TextareaInput.prototype.poll = function () {
      var this$1 = this;

    var cm = this.cm, input = this.textarea, prevInput = this.prevInput;
    // Since this is called a *lot*, try to bail out as cheaply as
    // possible when it is clear that nothing happened. hasSelection
    // will be the case when there is a lot of text in the textarea,
    // in which case reading its value would be expensive.
    if (this.contextMenuPending || !cm.state.focused ||
        (hasSelection(input) && !prevInput && !this.composing) ||
        cm.isReadOnly() || cm.options.disableInput || cm.state.keySeq)
      { return false }

    var text = input.value;
    // If nothing changed, bail.
    if (text == prevInput && !cm.somethingSelected()) { return false }
    // Work around nonsensical selection resetting in IE9/10, and
    // inexplicable appearance of private area unicode characters on
    // some key combos in Mac (#2689).
    if (ie && ie_version >= 9 && this.hasSelection === text ||
        mac && /[\uf700-\uf7ff]/.test(text)) {
      cm.display.input.reset();
      return false
    }

    if (cm.doc.sel == cm.display.selForContextMenu) {
      var first = text.charCodeAt(0);
      if (first == 0x200b && !prevInput) { prevInput = "\u200b"; }
      if (first == 0x21da) { this.reset(); return this.cm.execCommand("undo") }
    }
    // Find the part of the input that is actually new
    var same = 0, l = Math.min(prevInput.length, text.length);
    while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same)) { ++same; }

    runInOp(cm, function () {
      applyTextInput(cm, text.slice(same), prevInput.length - same,
                     null, this$1.composing ? "*compose" : null);

      // Don't leave long text in the textarea, since it makes further polling slow
      if (text.length > 1000 || text.indexOf("\n") > -1) { input.value = this$1.prevInput = ""; }
      else { this$1.prevInput = text; }

      if (this$1.composing) {
        this$1.composing.range.clear();
        this$1.composing.range = cm.markText(this$1.composing.start, cm.getCursor("to"),
                                           {className: "CodeMirror-composing"});
      }
    });
    return true
  };

  TextareaInput.prototype.ensurePolled = function () {
    if (this.pollingFast && this.poll()) { this.pollingFast = false; }
  };

  TextareaInput.prototype.onKeyPress = function () {
    if (ie && ie_version >= 9) { this.hasSelection = null; }
    this.fastPoll();
  };

  TextareaInput.prototype.onContextMenu = function (e) {
    var input = this, cm = input.cm, display = cm.display, te = input.textarea;
    if (input.contextMenuPending) { input.contextMenuPending(); }
    var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;
    if (!pos || presto) { return } // Opera is difficult.

    // Reset the current text selection only if the click is done outside of the selection
    // and 'resetSelectionOnContextMenu' option is true.
    var reset = cm.options.resetSelectionOnContextMenu;
    if (reset && cm.doc.sel.contains(pos) == -1)
      { operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll); }

    var oldCSS = te.style.cssText, oldWrapperCSS = input.wrapper.style.cssText;
    var wrapperBox = input.wrapper.offsetParent.getBoundingClientRect();
    input.wrapper.style.cssText = "position: static";
    te.style.cssText = "position: absolute; width: 30px; height: 30px;\n      top: " + (e.clientY - wrapperBox.top - 5) + "px; left: " + (e.clientX - wrapperBox.left - 5) + "px;\n      z-index: 1000; background: " + (ie ? "rgba(255, 255, 255, .05)" : "transparent") + ";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";
    var oldScrollY;
    if (webkit) { oldScrollY = window.scrollY; } // Work around Chrome issue (#2712)
    display.input.focus();
    if (webkit) { window.scrollTo(null, oldScrollY); }
    display.input.reset();
    // Adds "Select all" to context menu in FF
    if (!cm.somethingSelected()) { te.value = input.prevInput = " "; }
    input.contextMenuPending = rehide;
    display.selForContextMenu = cm.doc.sel;
    clearTimeout(display.detectingSelectAll);

    // Select-all will be greyed out if there's nothing to select, so
    // this adds a zero-width space so that we can later check whether
    // it got selected.
    function prepareSelectAllHack() {
      if (te.selectionStart != null) {
        var selected = cm.somethingSelected();
        var extval = "\u200b" + (selected ? te.value : "");
        te.value = "\u21da"; // Used to catch context-menu undo
        te.value = extval;
        input.prevInput = selected ? "" : "\u200b";
        te.selectionStart = 1; te.selectionEnd = extval.length;
        // Re-set this, in case some other handler touched the
        // selection in the meantime.
        display.selForContextMenu = cm.doc.sel;
      }
    }
    function rehide() {
      if (input.contextMenuPending != rehide) { return }
      input.contextMenuPending = false;
      input.wrapper.style.cssText = oldWrapperCSS;
      te.style.cssText = oldCSS;
      if (ie && ie_version < 9) { display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos); }

      // Try to detect the user choosing select-all
      if (te.selectionStart != null) {
        if (!ie || (ie && ie_version < 9)) { prepareSelectAllHack(); }
        var i = 0, poll = function () {
          if (display.selForContextMenu == cm.doc.sel && te.selectionStart == 0 &&
              te.selectionEnd > 0 && input.prevInput == "\u200b") {
            operation(cm, selectAll)(cm);
          } else if (i++ < 10) {
            display.detectingSelectAll = setTimeout(poll, 500);
          } else {
            display.selForContextMenu = null;
            display.input.reset();
          }
        };
        display.detectingSelectAll = setTimeout(poll, 200);
      }
    }

    if (ie && ie_version >= 9) { prepareSelectAllHack(); }
    if (captureRightClick) {
      e_stop(e);
      var mouseup = function () {
        off(window, "mouseup", mouseup);
        setTimeout(rehide, 20);
      };
      on(window, "mouseup", mouseup);
    } else {
      setTimeout(rehide, 50);
    }
  };

  TextareaInput.prototype.readOnlyChanged = function (val) {
    if (!val) { this.reset(); }
    this.textarea.disabled = val == "nocursor";
    this.textarea.readOnly = !!val;
  };

  TextareaInput.prototype.setUneditable = function () {};

  TextareaInput.prototype.needsContentAttribute = false;

  function fromTextArea(textarea, options) {
    options = options ? copyObj(options) : {};
    options.value = textarea.value;
    if (!options.tabindex && textarea.tabIndex)
      { options.tabindex = textarea.tabIndex; }
    if (!options.placeholder && textarea.placeholder)
      { options.placeholder = textarea.placeholder; }
    // Set autofocus to true if this textarea is focused, or if it has
    // autofocus and no other element is focused.
    if (options.autofocus == null) {
      var hasFocus = activeElt();
      options.autofocus = hasFocus == textarea ||
        textarea.getAttribute("autofocus") != null && hasFocus == document.body;
    }

    function save() {textarea.value = cm.getValue();}

    var realSubmit;
    if (textarea.form) {
      on(textarea.form, "submit", save);
      // Deplorable hack to make the submit method do the right thing.
      if (!options.leaveSubmitMethodAlone) {
        var form = textarea.form;
        realSubmit = form.submit;
        try {
          var wrappedSubmit = form.submit = function () {
            save();
            form.submit = realSubmit;
            form.submit();
            form.submit = wrappedSubmit;
          };
        } catch(e) {}
      }
    }

    options.finishInit = function (cm) {
      cm.save = save;
      cm.getTextArea = function () { return textarea; };
      cm.toTextArea = function () {
        cm.toTextArea = isNaN; // Prevent this from being ran twice
        save();
        textarea.parentNode.removeChild(cm.getWrapperElement());
        textarea.style.display = "";
        if (textarea.form) {
          off(textarea.form, "submit", save);
          if (!options.leaveSubmitMethodAlone && typeof textarea.form.submit == "function")
            { textarea.form.submit = realSubmit; }
        }
      };
    };

    textarea.style.display = "none";
    var cm = CodeMirror(function (node) { return textarea.parentNode.insertBefore(node, textarea.nextSibling); },
      options);
    return cm
  }

  function addLegacyProps(CodeMirror) {
    CodeMirror.off = off;
    CodeMirror.on = on;
    CodeMirror.wheelEventPixels = wheelEventPixels;
    CodeMirror.Doc = Doc;
    CodeMirror.splitLines = splitLinesAuto;
    CodeMirror.countColumn = countColumn;
    CodeMirror.findColumn = findColumn;
    CodeMirror.isWordChar = isWordCharBasic;
    CodeMirror.Pass = Pass;
    CodeMirror.signal = signal;
    CodeMirror.Line = Line;
    CodeMirror.changeEnd = changeEnd;
    CodeMirror.scrollbarModel = scrollbarModel;
    CodeMirror.Pos = Pos;
    CodeMirror.cmpPos = cmp;
    CodeMirror.modes = modes;
    CodeMirror.mimeModes = mimeModes;
    CodeMirror.resolveMode = resolveMode;
    CodeMirror.getMode = getMode;
    CodeMirror.modeExtensions = modeExtensions;
    CodeMirror.extendMode = extendMode;
    CodeMirror.copyState = copyState;
    CodeMirror.startState = startState;
    CodeMirror.innerMode = innerMode;
    CodeMirror.commands = commands;
    CodeMirror.keyMap = keyMap;
    CodeMirror.keyName = keyName;
    CodeMirror.isModifierKey = isModifierKey;
    CodeMirror.lookupKey = lookupKey;
    CodeMirror.normalizeKeyMap = normalizeKeyMap;
    CodeMirror.StringStream = StringStream;
    CodeMirror.SharedTextMarker = SharedTextMarker;
    CodeMirror.TextMarker = TextMarker;
    CodeMirror.LineWidget = LineWidget;
    CodeMirror.e_preventDefault = e_preventDefault;
    CodeMirror.e_stopPropagation = e_stopPropagation;
    CodeMirror.e_stop = e_stop;
    CodeMirror.addClass = addClass;
    CodeMirror.contains = contains;
    CodeMirror.rmClass = rmClass;
    CodeMirror.keyNames = keyNames;
  }

  // EDITOR CONSTRUCTOR

  defineOptions(CodeMirror);

  addEditorMethods(CodeMirror);

  // Set up methods on CodeMirror's prototype to redirect to the editor's document.
  var dontDelegate = "iter insert remove copy getEditor constructor".split(" ");
  for (var prop in Doc.prototype) { if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0)
    { CodeMirror.prototype[prop] = (function(method) {
      return function() {return method.apply(this.doc, arguments)}
    })(Doc.prototype[prop]); } }

  eventMixin(Doc);
  CodeMirror.inputStyles = {"textarea": TextareaInput, "contenteditable": ContentEditableInput};

  // Extra arguments are stored as the mode's dependencies, which is
  // used by (legacy) mechanisms like loadmode.js to automatically
  // load a mode. (Preferred mechanism is the require/define calls.)
  CodeMirror.defineMode = function(name/*, mode, */) {
    if (!CodeMirror.defaults.mode && name != "null") { CodeMirror.defaults.mode = name; }
    defineMode.apply(this, arguments);
  };

  CodeMirror.defineMIME = defineMIME;

  // Minimal default mode.
  CodeMirror.defineMode("null", function () { return ({token: function (stream) { return stream.skipToEnd(); }}); });
  CodeMirror.defineMIME("text/plain", "null");

  // EXTENSIONS

  CodeMirror.defineExtension = function (name, func) {
    CodeMirror.prototype[name] = func;
  };
  CodeMirror.defineDocExtension = function (name, func) {
    Doc.prototype[name] = func;
  };

  CodeMirror.fromTextArea = fromTextArea;

  addLegacyProps(CodeMirror);

  CodeMirror.version = "5.58.1";

  return CodeMirror;

})));

},{}],102:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var antlr_parser_factory_1 = require("./parser-factory/antlr-parser-factory");
var template_reader_1 = require("./template-reader/template-reader");
var template_expression_1 = require("./template-expression/template-expression");
function renderTemplateExpressions(template, onExpressionRender) {
    var parser = (new antlr_parser_factory_1.AntlrParserFactory()).createParser();
    var reader = new template_reader_1.TemplateReader(parser);
    reader.readTemplate(template);
    var expressions = reader.getExpressions();
    var templateExprs = expressions.map(function (expr) { return new template_expression_1.TemplateExpression(expr, onExpressionRender); });
    templateExprs.forEach(function (expr) {
        expr.renderVariable();
    });
    return {
        text: parser.getText(),
        expressions: templateExprs
    };
}
exports.renderTemplateExpressions = renderTemplateExpressions;
function renderTemplateExpressionsWithContext(template, context) {
    var onRender = function (varName) { return context[varName]; };
    var results = renderTemplateExpressions(template, onRender);
    return results;
}
exports.renderTemplateExpressionsWithContext = renderTemplateExpressionsWithContext;
function renderTemplate(template, context) {
    return renderTemplateExpressionsWithContext(template, context).text;
}
exports.renderTemplate = renderTemplate;

},{"./parser-factory/antlr-parser-factory":103,"./template-expression/template-expression":108,"./template-reader/template-reader":109}],103:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var antlr4_helper_1 = require("antlr4-helper");
var ExpressiveTemplateLexer_1 = require("../parser/ExpressiveTemplateLexer");
var ExpressiveTemplateParser_1 = require("../parser/ExpressiveTemplateParser");
var AntlrParserFactory = /** @class */ (function () {
    function AntlrParserFactory() {
        this.factory = antlr4_helper_1.createFactoryBuilder()
            .lexer(function (stream) { return new ExpressiveTemplateLexer_1.ExpressiveTemplateLexer(stream); })
            .parser(function (tokenStream) { return new ExpressiveTemplateParser_1.ExpressiveTemplateParser(tokenStream); })
            .rootRule(function (parser) { return parser.template(); })
            .build();
    }
    AntlrParserFactory.prototype.createParser = function () {
        return antlr4_helper_1.createParser(this.factory);
    };
    return AntlrParserFactory;
}());
exports.AntlrParserFactory = AntlrParserFactory;

},{"../parser/ExpressiveTemplateLexer":104,"../parser/ExpressiveTemplateParser":105,"antlr4-helper":20}],104:[function(require,module,exports){
// Generated from ExpressiveTemplateLexer.g4 by ANTLR 4.7
// jshint ignore: start
var antlr4 = require('antlr4/index');


var serializedATN = ["\u0003\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964",
    "\u0002\u0007(\b\u0001\b\u0001\u0004\u0002\t\u0002\u0004\u0003\t\u0003",
    "\u0004\u0004\t\u0004\u0004\u0005\t\u0005\u0004\u0006\t\u0006\u0003\u0002",
    "\u0003\u0002\u0003\u0002\u0003\u0002\u0003\u0002\u0003\u0003\u0006\u0003",
    "\u0015\n\u0003\r\u0003\u000e\u0003\u0016\u0003\u0004\u0003\u0004\u0003",
    "\u0004\u0003\u0004\u0003\u0004\u0003\u0005\u0003\u0005\u0007\u0005 ",
    "\n\u0005\f\u0005\u000e\u0005#\u000b\u0005\u0003\u0006\u0003\u0006\u0003",
    "\u0006\u0003\u0006\u0002\u0002\u0007\u0004\u0003\u0006\u0004\b\u0005",
    "\n\u0006\f\u0007\u0004\u0002\u0003\u0006\u0004\u0002}}\u007f\u007f\u0005",
    "\u0002C\\aac|\u0006\u00022;C\\aac|\u0004\u0002\f\f\"\"\u0002(\u0002",
    "\u0004\u0003\u0002\u0002\u0002\u0002\u0006\u0003\u0002\u0002\u0002\u0003",
    "\b\u0003\u0002\u0002\u0002\u0003\n\u0003\u0002\u0002\u0002\u0003\f\u0003",
    "\u0002\u0002\u0002\u0004\u000e\u0003\u0002\u0002\u0002\u0006\u0014\u0003",
    "\u0002\u0002\u0002\b\u0018\u0003\u0002\u0002\u0002\n\u001d\u0003\u0002",
    "\u0002\u0002\f$\u0003\u0002\u0002\u0002\u000e\u000f\u0007}\u0002\u0002",
    "\u000f\u0010\u0007}\u0002\u0002\u0010\u0011\u0003\u0002\u0002\u0002",
    "\u0011\u0012\b\u0002\u0002\u0002\u0012\u0005\u0003\u0002\u0002\u0002",
    "\u0013\u0015\n\u0002\u0002\u0002\u0014\u0013\u0003\u0002\u0002\u0002",
    "\u0015\u0016\u0003\u0002\u0002\u0002\u0016\u0014\u0003\u0002\u0002\u0002",
    "\u0016\u0017\u0003\u0002\u0002\u0002\u0017\u0007\u0003\u0002\u0002\u0002",
    "\u0018\u0019\u0007\u007f\u0002\u0002\u0019\u001a\u0007\u007f\u0002\u0002",
    "\u001a\u001b\u0003\u0002\u0002\u0002\u001b\u001c\b\u0004\u0003\u0002",
    "\u001c\t\u0003\u0002\u0002\u0002\u001d!\t\u0003\u0002\u0002\u001e \t",
    "\u0004\u0002\u0002\u001f\u001e\u0003\u0002\u0002\u0002 #\u0003\u0002",
    "\u0002\u0002!\u001f\u0003\u0002\u0002\u0002!\"\u0003\u0002\u0002\u0002",
    "\"\u000b\u0003\u0002\u0002\u0002#!\u0003\u0002\u0002\u0002$%\t\u0005",
    "\u0002\u0002%&\u0003\u0002\u0002\u0002&\'\b\u0006\u0004\u0002\'\r\u0003",
    "\u0002\u0002\u0002\u0006\u0002\u0003\u0016!\u0005\u0004\u0003\u0002",
    "\u0004\u0002\u0002\b\u0002\u0002"].join("");


var atn = new antlr4.atn.ATNDeserializer().deserialize(serializedATN);

var decisionsToDFA = atn.decisionToState.map( function(ds, index) { return new antlr4.dfa.DFA(ds, index); });

function ExpressiveTemplateLexer(input) {
	antlr4.Lexer.call(this, input);
    this._interp = new antlr4.atn.LexerATNSimulator(this, atn, decisionsToDFA, new antlr4.PredictionContextCache());
    return this;
}

ExpressiveTemplateLexer.prototype = Object.create(antlr4.Lexer.prototype);
ExpressiveTemplateLexer.prototype.constructor = ExpressiveTemplateLexer;

ExpressiveTemplateLexer.EOF = antlr4.Token.EOF;
ExpressiveTemplateLexer.EXPR_OPEN = 1;
ExpressiveTemplateLexer.TEXT = 2;
ExpressiveTemplateLexer.EXPR_CLOSE = 3;
ExpressiveTemplateLexer.ID = 4;
ExpressiveTemplateLexer.WS = 5;

ExpressiveTemplateLexer.JINJA_EXPR_ISLAND = 1;

ExpressiveTemplateLexer.prototype.channelNames = [ "DEFAULT_TOKEN_CHANNEL", "HIDDEN" ];

ExpressiveTemplateLexer.prototype.modeNames = [ "DEFAULT_MODE", "JINJA_EXPR_ISLAND" ];

ExpressiveTemplateLexer.prototype.literalNames = [ null, "'{{'", null, "'}}'" ];

ExpressiveTemplateLexer.prototype.symbolicNames = [ null, "EXPR_OPEN", "TEXT", 
                                                    "EXPR_CLOSE", "ID", 
                                                    "WS" ];

ExpressiveTemplateLexer.prototype.ruleNames = [ "EXPR_OPEN", "TEXT", "EXPR_CLOSE", 
                                                "ID", "WS" ];

ExpressiveTemplateLexer.prototype.grammarFileName = "ExpressiveTemplateLexer.g4";



exports.ExpressiveTemplateLexer = ExpressiveTemplateLexer;


},{"antlr4/index":84}],105:[function(require,module,exports){
// Generated from ExpressiveTemplateParser.g4 by ANTLR 4.7
// jshint ignore: start
var antlr4 = require('antlr4/index');
var ExpressiveTemplateParserListener = require('./ExpressiveTemplateParserListener').ExpressiveTemplateParserListener;
var ExpressiveTemplateParserVisitor = require('./ExpressiveTemplateParserVisitor').ExpressiveTemplateParserVisitor;

var grammarFileName = "ExpressiveTemplateParser.g4";

var serializedATN = ["\u0003\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964",
    "\u0003\u0007\u0012\u0004\u0002\t\u0002\u0004\u0003\t\u0003\u0003\u0002",
    "\u0003\u0002\u0007\u0002\t\n\u0002\f\u0002\u000e\u0002\f\u000b\u0002",
    "\u0003\u0003\u0003\u0003\u0003\u0003\u0003\u0003\u0003\u0003\u0002\u0002",
    "\u0004\u0002\u0004\u0002\u0002\u0002\u0011\u0002\n\u0003\u0002\u0002",
    "\u0002\u0004\r\u0003\u0002\u0002\u0002\u0006\t\u0005\u0004\u0003\u0002",
    "\u0007\t\u0007\u0004\u0002\u0002\b\u0006\u0003\u0002\u0002\u0002\b\u0007",
    "\u0003\u0002\u0002\u0002\t\f\u0003\u0002\u0002\u0002\n\b\u0003\u0002",
    "\u0002\u0002\n\u000b\u0003\u0002\u0002\u0002\u000b\u0003\u0003\u0002",
    "\u0002\u0002\f\n\u0003\u0002\u0002\u0002\r\u000e\u0007\u0003\u0002\u0002",
    "\u000e\u000f\u0007\u0006\u0002\u0002\u000f\u0010\u0007\u0005\u0002\u0002",
    "\u0010\u0005\u0003\u0002\u0002\u0002\u0004\b\n"].join("");


var atn = new antlr4.atn.ATNDeserializer().deserialize(serializedATN);

var decisionsToDFA = atn.decisionToState.map( function(ds, index) { return new antlr4.dfa.DFA(ds, index); });

var sharedContextCache = new antlr4.PredictionContextCache();

var literalNames = [ null, "'{{'", null, "'}}'" ];

var symbolicNames = [ null, "EXPR_OPEN", "TEXT", "EXPR_CLOSE", "ID", "WS" ];

var ruleNames =  [ "template", "expression" ];

function ExpressiveTemplateParser (input) {
	antlr4.Parser.call(this, input);
    this._interp = new antlr4.atn.ParserATNSimulator(this, atn, decisionsToDFA, sharedContextCache);
    this.ruleNames = ruleNames;
    this.literalNames = literalNames;
    this.symbolicNames = symbolicNames;
    return this;
}

ExpressiveTemplateParser.prototype = Object.create(antlr4.Parser.prototype);
ExpressiveTemplateParser.prototype.constructor = ExpressiveTemplateParser;

Object.defineProperty(ExpressiveTemplateParser.prototype, "atn", {
	get : function() {
		return atn;
	}
});

ExpressiveTemplateParser.EOF = antlr4.Token.EOF;
ExpressiveTemplateParser.EXPR_OPEN = 1;
ExpressiveTemplateParser.TEXT = 2;
ExpressiveTemplateParser.EXPR_CLOSE = 3;
ExpressiveTemplateParser.ID = 4;
ExpressiveTemplateParser.WS = 5;

ExpressiveTemplateParser.RULE_template = 0;
ExpressiveTemplateParser.RULE_expression = 1;

function TemplateContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ExpressiveTemplateParser.RULE_template;
    this.text = null; // Token
    return this;
}

TemplateContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
TemplateContext.prototype.constructor = TemplateContext;

TemplateContext.prototype.expression = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(ExpressionContext);
    } else {
        return this.getTypedRuleContext(ExpressionContext,i);
    }
};

TemplateContext.prototype.TEXT = function(i) {
	if(i===undefined) {
		i = null;
	}
    if(i===null) {
        return this.getTokens(ExpressiveTemplateParser.TEXT);
    } else {
        return this.getToken(ExpressiveTemplateParser.TEXT, i);
    }
};


TemplateContext.prototype.enterRule = function(listener) {
    if(listener instanceof ExpressiveTemplateParserListener ) {
        listener.enterTemplate(this);
	}
};

TemplateContext.prototype.exitRule = function(listener) {
    if(listener instanceof ExpressiveTemplateParserListener ) {
        listener.exitTemplate(this);
	}
};

TemplateContext.prototype.accept = function(visitor) {
    if ( visitor instanceof ExpressiveTemplateParserVisitor ) {
        return visitor.visitTemplate(this);
    } else {
        return visitor.visitChildren(this);
    }
};




ExpressiveTemplateParser.TemplateContext = TemplateContext;

ExpressiveTemplateParser.prototype.template = function() {

    var localctx = new TemplateContext(this, this._ctx, this.state);
    this.enterRule(localctx, 0, ExpressiveTemplateParser.RULE_template);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 8;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while(_la===ExpressiveTemplateParser.EXPR_OPEN || _la===ExpressiveTemplateParser.TEXT) {
            this.state = 6;
            this._errHandler.sync(this);
            switch(this._input.LA(1)) {
            case ExpressiveTemplateParser.EXPR_OPEN:
                this.state = 4;
                this.expression();
                break;
            case ExpressiveTemplateParser.TEXT:
                this.state = 5;
                localctx.text = this.match(ExpressiveTemplateParser.TEXT);
                break;
            default:
                throw new antlr4.error.NoViableAltException(this);
            }
            this.state = 10;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function ExpressionContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ExpressiveTemplateParser.RULE_expression;
    return this;
}

ExpressionContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ExpressionContext.prototype.constructor = ExpressionContext;

ExpressionContext.prototype.EXPR_OPEN = function() {
    return this.getToken(ExpressiveTemplateParser.EXPR_OPEN, 0);
};

ExpressionContext.prototype.ID = function() {
    return this.getToken(ExpressiveTemplateParser.ID, 0);
};

ExpressionContext.prototype.EXPR_CLOSE = function() {
    return this.getToken(ExpressiveTemplateParser.EXPR_CLOSE, 0);
};

ExpressionContext.prototype.enterRule = function(listener) {
    if(listener instanceof ExpressiveTemplateParserListener ) {
        listener.enterExpression(this);
	}
};

ExpressionContext.prototype.exitRule = function(listener) {
    if(listener instanceof ExpressiveTemplateParserListener ) {
        listener.exitExpression(this);
	}
};

ExpressionContext.prototype.accept = function(visitor) {
    if ( visitor instanceof ExpressiveTemplateParserVisitor ) {
        return visitor.visitExpression(this);
    } else {
        return visitor.visitChildren(this);
    }
};




ExpressiveTemplateParser.ExpressionContext = ExpressionContext;

ExpressiveTemplateParser.prototype.expression = function() {

    var localctx = new ExpressionContext(this, this._ctx, this.state);
    this.enterRule(localctx, 2, ExpressiveTemplateParser.RULE_expression);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 11;
        this.match(ExpressiveTemplateParser.EXPR_OPEN);
        this.state = 12;
        this.match(ExpressiveTemplateParser.ID);
        this.state = 13;
        this.match(ExpressiveTemplateParser.EXPR_CLOSE);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


exports.ExpressiveTemplateParser = ExpressiveTemplateParser;
exports.TemplateContext = TemplateContext;
ExpressiveTemplateParser.TemplateContext = TemplateContext;
exports.ExpressionContext = ExpressionContext;
ExpressiveTemplateParser.ExpressionContext = ExpressionContext;

},{"./ExpressiveTemplateParserListener":106,"./ExpressiveTemplateParserVisitor":107,"antlr4/index":84}],106:[function(require,module,exports){
// Generated from ExpressiveTemplateParser.g4 by ANTLR 4.7
// jshint ignore: start
var antlr4 = require('antlr4/index');

// This class defines a complete listener for a parse tree produced by ExpressiveTemplateParser.
function ExpressiveTemplateParserListener() {
	antlr4.tree.ParseTreeListener.call(this);
	return this;
}

ExpressiveTemplateParserListener.prototype = Object.create(antlr4.tree.ParseTreeListener.prototype);
ExpressiveTemplateParserListener.prototype.constructor = ExpressiveTemplateParserListener;

// Enter a parse tree produced by ExpressiveTemplateParser#template.
ExpressiveTemplateParserListener.prototype.enterTemplate = function(ctx) {
};

// Exit a parse tree produced by ExpressiveTemplateParser#template.
ExpressiveTemplateParserListener.prototype.exitTemplate = function(ctx) {
};


// Enter a parse tree produced by ExpressiveTemplateParser#expression.
ExpressiveTemplateParserListener.prototype.enterExpression = function(ctx) {
};

// Exit a parse tree produced by ExpressiveTemplateParser#expression.
ExpressiveTemplateParserListener.prototype.exitExpression = function(ctx) {
};



exports.ExpressiveTemplateParserListener = ExpressiveTemplateParserListener;
},{"antlr4/index":84}],107:[function(require,module,exports){
// Generated from ExpressiveTemplateParser.g4 by ANTLR 4.7
// jshint ignore: start
var antlr4 = require('antlr4/index');

// This class defines a complete generic visitor for a parse tree produced by ExpressiveTemplateParser.

function ExpressiveTemplateParserVisitor() {
	antlr4.tree.ParseTreeVisitor.call(this);
	return this;
}

ExpressiveTemplateParserVisitor.prototype = Object.create(antlr4.tree.ParseTreeVisitor.prototype);
ExpressiveTemplateParserVisitor.prototype.constructor = ExpressiveTemplateParserVisitor;

// Visit a parse tree produced by ExpressiveTemplateParser#template.
ExpressiveTemplateParserVisitor.prototype.visitTemplate = function(ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by ExpressiveTemplateParser#expression.
ExpressiveTemplateParserVisitor.prototype.visitExpression = function(ctx) {
  return this.visitChildren(ctx);
};



exports.ExpressiveTemplateParserVisitor = ExpressiveTemplateParserVisitor;
},{"antlr4/index":84}],108:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var TemplateExpression = /** @class */ (function () {
    function TemplateExpression(rule, onRender) {
        this.rule = rule;
        this.onRender = onRender;
        this.variableRendered = false;
        this.varName = rule.getToken('ID').getText();
        this.originalText = rule.getText();
    }
    TemplateExpression.prototype.renderVariable = function () {
        if (!this.variableRendered) {
            var text = this.onRender(this.getVariableName());
            this.setCurrentText(text);
            this.variableRendered = true;
        }
    };
    TemplateExpression.prototype.getVariableName = function () {
        return this.varName;
    };
    TemplateExpression.prototype.getOriginalExpressionText = function () {
        return this.originalText;
    };
    TemplateExpression.prototype.getCurrentText = function () {
        return this.rule.getText();
    };
    TemplateExpression.prototype.setCurrentText = function (text) {
        this.rule.setText(text);
    };
    TemplateExpression.prototype.getCurrentRange = function () {
        return this.rule.getRange();
    };
    return TemplateExpression;
}());
exports.TemplateExpression = TemplateExpression;

},{}],109:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var TemplateReader = /** @class */ (function () {
    function TemplateReader(parser) {
        this.parser = parser;
    }
    TemplateReader.prototype.readTemplate = function (template) {
        this.parser.parse(template);
        this.parser.checkForErrors();
    };
    TemplateReader.prototype.getExpressions = function () {
        return this.parser.findRulesByName('expression');
    };
    return TemplateReader;
}());
exports.TemplateReader = TemplateReader;

},{}],110:[function(require,module,exports){
(function (global){(function (){
/**
 * Lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used to detect hot functions by number of calls within a span of milliseconds. */
var HOT_COUNT = 800,
    HOT_SPAN = 16;

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    asyncTag = '[object AsyncFunction]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    nullTag = '[object Null]',
    objectTag = '[object Object]',
    proxyTag = '[object Proxy]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    undefinedTag = '[object Undefined]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
typedArrayTags[errorTag] = typedArrayTags[funcTag] =
typedArrayTags[mapTag] = typedArrayTags[numberTag] =
typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
typedArrayTags[setTag] = typedArrayTags[stringTag] =
typedArrayTags[weakMapTag] = false;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports && freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = (function() {
  try {
    // Use `util.types` for Node.js 10+.
    var types = freeModule && freeModule.require && freeModule.require('util').types;

    if (types) {
      return types;
    }

    // Legacy `process.binding('util')` for Node.js < 10.
    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}());

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0: return func.call(thisArg);
    case 1: return func.call(thisArg, args[0]);
    case 2: return func.call(thisArg, args[0], args[1]);
    case 3: return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

/** Used for built-in method references. */
var arrayProto = Array.prototype,
    funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Used to infer the `Object` constructor. */
var objectCtorString = funcToString.call(Object);

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined,
    Symbol = root.Symbol,
    Uint8Array = root.Uint8Array,
    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined,
    getPrototype = overArg(Object.getPrototypeOf, Object),
    objectCreate = Object.create,
    propertyIsEnumerable = objectProto.propertyIsEnumerable,
    splice = arrayProto.splice,
    symToStringTag = Symbol ? Symbol.toStringTag : undefined;

var defineProperty = (function() {
  try {
    var func = getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}());

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,
    nativeMax = Math.max,
    nativeNow = Date.now;

/* Built-in method references that are verified to be native. */
var Map = getNative(root, 'Map'),
    nativeCreate = getNative(Object, 'create');

/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} proto The object to inherit from.
 * @returns {Object} Returns the new object.
 */
var baseCreate = (function() {
  function object() {}
  return function(proto) {
    if (!isObject(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object;
    object.prototype = undefined;
    return result;
  };
}());

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
}

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  var result = getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  var data = getMapData(this, key),
      size = data.size;

  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new ListCache;
  this.size = 0;
}

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);

  this.size = data.size;
  return result;
}

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache) {
    var pairs = data.__data__;
    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}

// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) &&
        !(skipIndexes && (
           // Safari 9 has enumerable `arguments.length` in strict mode.
           key == 'length' ||
           // Node.js 0.10 has enumerable non-index properties on buffers.
           (isBuff && (key == 'offset' || key == 'parent')) ||
           // PhantomJS 2 has enumerable non-index properties on typed arrays.
           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
           // Skip index properties.
           isIndex(key, length)
        ))) {
      result.push(key);
    }
  }
  return result;
}

/**
 * This function is like `assignValue` except that it doesn't assign
 * `undefined` values.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignMergeValue(object, key, value) {
  if ((value !== undefined && !eq(object[key], value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue(object, key, value);
  }
}

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue(object, key, value);
  }
}

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function baseAssignValue(object, key, value) {
  if (key == '__proto__' && defineProperty) {
    defineProperty(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

/**
 * The base implementation of `baseForOwn` which iterates over `object`
 * properties returned by `keysFunc` and invokes `iteratee` for each property.
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */
var baseFor = createBaseFor();

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? getRawTag(value)
    : objectToString(value);
}

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag;
}

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return isObjectLike(value) &&
    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeysIn(object) {
  if (!isObject(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

/**
 * The base implementation of `_.merge` without support for multiple sources.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} [customizer] The function to customize merged values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */
function baseMerge(object, source, srcIndex, customizer, stack) {
  if (object === source) {
    return;
  }
  baseFor(source, function(srcValue, key) {
    stack || (stack = new Stack);
    if (isObject(srcValue)) {
      baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
    }
    else {
      var newValue = customizer
        ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)
        : undefined;

      if (newValue === undefined) {
        newValue = srcValue;
      }
      assignMergeValue(object, key, newValue);
    }
  }, keysIn);
}

/**
 * A specialized version of `baseMerge` for arrays and objects which performs
 * deep merges and tracks traversed objects enabling objects with circular
 * references to be merged.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {string} key The key of the value to merge.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} mergeFunc The function to merge values.
 * @param {Function} [customizer] The function to customize assigned values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */
function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
  var objValue = safeGet(object, key),
      srcValue = safeGet(source, key),
      stacked = stack.get(srcValue);

  if (stacked) {
    assignMergeValue(object, key, stacked);
    return;
  }
  var newValue = customizer
    ? customizer(objValue, srcValue, (key + ''), object, source, stack)
    : undefined;

  var isCommon = newValue === undefined;

  if (isCommon) {
    var isArr = isArray(srcValue),
        isBuff = !isArr && isBuffer(srcValue),
        isTyped = !isArr && !isBuff && isTypedArray(srcValue);

    newValue = srcValue;
    if (isArr || isBuff || isTyped) {
      if (isArray(objValue)) {
        newValue = objValue;
      }
      else if (isArrayLikeObject(objValue)) {
        newValue = copyArray(objValue);
      }
      else if (isBuff) {
        isCommon = false;
        newValue = cloneBuffer(srcValue, true);
      }
      else if (isTyped) {
        isCommon = false;
        newValue = cloneTypedArray(srcValue, true);
      }
      else {
        newValue = [];
      }
    }
    else if (isPlainObject(srcValue) || isArguments(srcValue)) {
      newValue = objValue;
      if (isArguments(objValue)) {
        newValue = toPlainObject(objValue);
      }
      else if (!isObject(objValue) || isFunction(objValue)) {
        newValue = initCloneObject(srcValue);
      }
    }
    else {
      isCommon = false;
    }
  }
  if (isCommon) {
    // Recursively merge objects and arrays (susceptible to call stack limits).
    stack.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
    stack['delete'](srcValue);
  }
  assignMergeValue(object, key, newValue);
}

/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */
function baseRest(func, start) {
  return setToString(overRest(func, start, identity), func + '');
}

/**
 * The base implementation of `setToString` without support for hot loop shorting.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var baseSetToString = !defineProperty ? identity : function(func, string) {
  return defineProperty(func, 'toString', {
    'configurable': true,
    'enumerable': false,
    'value': constant(string),
    'writable': true
  });
};

/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var length = buffer.length,
      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

  buffer.copy(result);
  return result;
}

/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array(result).set(new Uint8Array(arrayBuffer));
  return result;
}

/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;

  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}

/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */
function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];

    var newValue = customizer
      ? customizer(object[key], source[key], key, object, source)
      : undefined;

    if (newValue === undefined) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue(object, key, newValue);
    }
  }
  return object;
}

/**
 * Creates a function like `_.assign`.
 *
 * @private
 * @param {Function} assigner The function to assign values.
 * @returns {Function} Returns the new assigner function.
 */
function createAssigner(assigner) {
  return baseRest(function(object, sources) {
    var index = -1,
        length = sources.length,
        customizer = length > 1 ? sources[length - 1] : undefined,
        guard = length > 2 ? sources[2] : undefined;

    customizer = (assigner.length > 3 && typeof customizer == 'function')
      ? (length--, customizer)
      : undefined;

    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? undefined : customizer;
      length = 1;
    }
    object = Object(object);
    while (++index < length) {
      var source = sources[index];
      if (source) {
        assigner(object, source, index, customizer);
      }
    }
    return object;
  });
}

/**
 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseFor(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index = -1,
        iterable = Object(object),
        props = keysFunc(object),
        length = props.length;

    while (length--) {
      var key = props[fromRight ? length : ++index];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneObject(object) {
  return (typeof object.constructor == 'function' && !isPrototype(object))
    ? baseCreate(getPrototype(object))
    : {};
}

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER : length;

  return !!length &&
    (type == 'number' ||
      (type != 'symbol' && reIsUint.test(value))) &&
        (value > -1 && value % 1 == 0 && value < length);
}

/**
 * Checks if the given arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
 *  else `false`.
 */
function isIterateeCall(value, index, object) {
  if (!isObject(object)) {
    return false;
  }
  var type = typeof index;
  if (type == 'number'
        ? (isArrayLike(object) && isIndex(index, object.length))
        : (type == 'string' && index in object)
      ) {
    return eq(object[index], value);
  }
  return false;
}

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  return value === proto;
}

/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

/**
 * A specialized version of `baseRest` which transforms the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @param {Function} transform The rest array transform.
 * @returns {Function} Returns the new function.
 */
function overRest(func, start, transform) {
  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
  return function() {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = transform(array);
    return apply(func, this, otherArgs);
  };
}

/**
 * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function safeGet(object, key) {
  if (key === 'constructor' && typeof object[key] === 'function') {
    return;
  }

  if (key == '__proto__') {
    return;
  }

  return object[key];
}

/**
 * Sets the `toString` method of `func` to return `string`.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var setToString = shortOut(baseSetToString);

/**
 * Creates a function that'll short out and invoke `identity` instead
 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
 * milliseconds.
 *
 * @private
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new shortable function.
 */
function shortOut(func) {
  var count = 0,
      lastCalled = 0;

  return function() {
    var stamp = nativeNow(),
        remaining = HOT_SPAN - (stamp - lastCalled);

    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(undefined, arguments);
  };
}

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
    !propertyIsEnumerable.call(value, 'callee');
};

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse;

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  if (!isObject(value)) {
    return false;
  }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */
function isPlainObject(value) {
  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
    return false;
  }
  var proto = getPrototype(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
  return typeof Ctor == 'function' && Ctor instanceof Ctor &&
    funcToString.call(Ctor) == objectCtorString;
}

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

/**
 * Converts `value` to a plain object flattening inherited enumerable string
 * keyed properties of `value` to own properties of the plain object.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {Object} Returns the converted plain object.
 * @example
 *
 * function Foo() {
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.assign({ 'a': 1 }, new Foo);
 * // => { 'a': 1, 'b': 2 }
 *
 * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
 * // => { 'a': 1, 'b': 2, 'c': 3 }
 */
function toPlainObject(value) {
  return copyObject(value, keysIn(value));
}

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}

/**
 * This method is like `_.assign` except that it recursively merges own and
 * inherited enumerable string keyed properties of source objects into the
 * destination object. Source properties that resolve to `undefined` are
 * skipped if a destination value exists. Array and plain object properties
 * are merged recursively. Other objects and value types are overridden by
 * assignment. Source objects are applied from left to right. Subsequent
 * sources overwrite property assignments of previous sources.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 0.5.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @example
 *
 * var object = {
 *   'a': [{ 'b': 2 }, { 'd': 4 }]
 * };
 *
 * var other = {
 *   'a': [{ 'c': 3 }, { 'e': 5 }]
 * };
 *
 * _.merge(object, other);
 * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
 */
var merge = createAssigner(function(object, source, srcIndex) {
  baseMerge(object, source, srcIndex);
});

/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */
function constant(value) {
  return function() {
    return value;
  };
}

/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = merge;

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],111:[function(require,module,exports){
(function (global){(function (){
/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
;(function() {

  /** Used as a safe reference for `undefined` in pre-ES5 environments. */
  var undefined;

  /** Used as the semantic version number. */
  var VERSION = '4.17.20';

  /** Used as the size to enable large array optimizations. */
  var LARGE_ARRAY_SIZE = 200;

  /** Error message constants. */
  var CORE_ERROR_TEXT = 'Unsupported core-js use. Try https://npms.io/search?q=ponyfill.',
      FUNC_ERROR_TEXT = 'Expected a function';

  /** Used to stand-in for `undefined` hash values. */
  var HASH_UNDEFINED = '__lodash_hash_undefined__';

  /** Used as the maximum memoize cache size. */
  var MAX_MEMOIZE_SIZE = 500;

  /** Used as the internal argument placeholder. */
  var PLACEHOLDER = '__lodash_placeholder__';

  /** Used to compose bitmasks for cloning. */
  var CLONE_DEEP_FLAG = 1,
      CLONE_FLAT_FLAG = 2,
      CLONE_SYMBOLS_FLAG = 4;

  /** Used to compose bitmasks for value comparisons. */
  var COMPARE_PARTIAL_FLAG = 1,
      COMPARE_UNORDERED_FLAG = 2;

  /** Used to compose bitmasks for function metadata. */
  var WRAP_BIND_FLAG = 1,
      WRAP_BIND_KEY_FLAG = 2,
      WRAP_CURRY_BOUND_FLAG = 4,
      WRAP_CURRY_FLAG = 8,
      WRAP_CURRY_RIGHT_FLAG = 16,
      WRAP_PARTIAL_FLAG = 32,
      WRAP_PARTIAL_RIGHT_FLAG = 64,
      WRAP_ARY_FLAG = 128,
      WRAP_REARG_FLAG = 256,
      WRAP_FLIP_FLAG = 512;

  /** Used as default options for `_.truncate`. */
  var DEFAULT_TRUNC_LENGTH = 30,
      DEFAULT_TRUNC_OMISSION = '...';

  /** Used to detect hot functions by number of calls within a span of milliseconds. */
  var HOT_COUNT = 800,
      HOT_SPAN = 16;

  /** Used to indicate the type of lazy iteratees. */
  var LAZY_FILTER_FLAG = 1,
      LAZY_MAP_FLAG = 2,
      LAZY_WHILE_FLAG = 3;

  /** Used as references for various `Number` constants. */
  var INFINITY = 1 / 0,
      MAX_SAFE_INTEGER = 9007199254740991,
      MAX_INTEGER = 1.7976931348623157e+308,
      NAN = 0 / 0;

  /** Used as references for the maximum length and index of an array. */
  var MAX_ARRAY_LENGTH = 4294967295,
      MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,
      HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;

  /** Used to associate wrap methods with their bit flags. */
  var wrapFlags = [
    ['ary', WRAP_ARY_FLAG],
    ['bind', WRAP_BIND_FLAG],
    ['bindKey', WRAP_BIND_KEY_FLAG],
    ['curry', WRAP_CURRY_FLAG],
    ['curryRight', WRAP_CURRY_RIGHT_FLAG],
    ['flip', WRAP_FLIP_FLAG],
    ['partial', WRAP_PARTIAL_FLAG],
    ['partialRight', WRAP_PARTIAL_RIGHT_FLAG],
    ['rearg', WRAP_REARG_FLAG]
  ];

  /** `Object#toString` result references. */
  var argsTag = '[object Arguments]',
      arrayTag = '[object Array]',
      asyncTag = '[object AsyncFunction]',
      boolTag = '[object Boolean]',
      dateTag = '[object Date]',
      domExcTag = '[object DOMException]',
      errorTag = '[object Error]',
      funcTag = '[object Function]',
      genTag = '[object GeneratorFunction]',
      mapTag = '[object Map]',
      numberTag = '[object Number]',
      nullTag = '[object Null]',
      objectTag = '[object Object]',
      promiseTag = '[object Promise]',
      proxyTag = '[object Proxy]',
      regexpTag = '[object RegExp]',
      setTag = '[object Set]',
      stringTag = '[object String]',
      symbolTag = '[object Symbol]',
      undefinedTag = '[object Undefined]',
      weakMapTag = '[object WeakMap]',
      weakSetTag = '[object WeakSet]';

  var arrayBufferTag = '[object ArrayBuffer]',
      dataViewTag = '[object DataView]',
      float32Tag = '[object Float32Array]',
      float64Tag = '[object Float64Array]',
      int8Tag = '[object Int8Array]',
      int16Tag = '[object Int16Array]',
      int32Tag = '[object Int32Array]',
      uint8Tag = '[object Uint8Array]',
      uint8ClampedTag = '[object Uint8ClampedArray]',
      uint16Tag = '[object Uint16Array]',
      uint32Tag = '[object Uint32Array]';

  /** Used to match empty string literals in compiled template source. */
  var reEmptyStringLeading = /\b__p \+= '';/g,
      reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
      reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

  /** Used to match HTML entities and HTML characters. */
  var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g,
      reUnescapedHtml = /[&<>"']/g,
      reHasEscapedHtml = RegExp(reEscapedHtml.source),
      reHasUnescapedHtml = RegExp(reUnescapedHtml.source);

  /** Used to match template delimiters. */
  var reEscape = /<%-([\s\S]+?)%>/g,
      reEvaluate = /<%([\s\S]+?)%>/g,
      reInterpolate = /<%=([\s\S]+?)%>/g;

  /** Used to match property names within property paths. */
  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
      reIsPlainProp = /^\w*$/,
      rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

  /**
   * Used to match `RegExp`
   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
   */
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g,
      reHasRegExpChar = RegExp(reRegExpChar.source);

  /** Used to match leading and trailing whitespace. */
  var reTrim = /^\s+|\s+$/g,
      reTrimStart = /^\s+/,
      reTrimEnd = /\s+$/;

  /** Used to match wrap detail comments. */
  var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,
      reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/,
      reSplitDetails = /,? & /;

  /** Used to match words composed of alphanumeric characters. */
  var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;

  /** Used to match backslashes in property paths. */
  var reEscapeChar = /\\(\\)?/g;

  /**
   * Used to match
   * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).
   */
  var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;

  /** Used to match `RegExp` flags from their coerced string values. */
  var reFlags = /\w*$/;

  /** Used to detect bad signed hexadecimal string values. */
  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

  /** Used to detect binary string values. */
  var reIsBinary = /^0b[01]+$/i;

  /** Used to detect host constructors (Safari). */
  var reIsHostCtor = /^\[object .+?Constructor\]$/;

  /** Used to detect octal string values. */
  var reIsOctal = /^0o[0-7]+$/i;

  /** Used to detect unsigned integer values. */
  var reIsUint = /^(?:0|[1-9]\d*)$/;

  /** Used to match Latin Unicode letters (excluding mathematical operators). */
  var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;

  /** Used to ensure capturing order of template delimiters. */
  var reNoMatch = /($^)/;

  /** Used to match unescaped characters in compiled string literals. */
  var reUnescapedString = /['\n\r\u2028\u2029\\]/g;

  /** Used to compose unicode character classes. */
  var rsAstralRange = '\\ud800-\\udfff',
      rsComboMarksRange = '\\u0300-\\u036f',
      reComboHalfMarksRange = '\\ufe20-\\ufe2f',
      rsComboSymbolsRange = '\\u20d0-\\u20ff',
      rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
      rsDingbatRange = '\\u2700-\\u27bf',
      rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff',
      rsMathOpRange = '\\xac\\xb1\\xd7\\xf7',
      rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',
      rsPunctuationRange = '\\u2000-\\u206f',
      rsSpaceRange = ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',
      rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde',
      rsVarRange = '\\ufe0e\\ufe0f',
      rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;

  /** Used to compose unicode capture groups. */
  var rsApos = "['\u2019]",
      rsAstral = '[' + rsAstralRange + ']',
      rsBreak = '[' + rsBreakRange + ']',
      rsCombo = '[' + rsComboRange + ']',
      rsDigits = '\\d+',
      rsDingbat = '[' + rsDingbatRange + ']',
      rsLower = '[' + rsLowerRange + ']',
      rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',
      rsFitz = '\\ud83c[\\udffb-\\udfff]',
      rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
      rsNonAstral = '[^' + rsAstralRange + ']',
      rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
      rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
      rsUpper = '[' + rsUpperRange + ']',
      rsZWJ = '\\u200d';

  /** Used to compose unicode regexes. */
  var rsMiscLower = '(?:' + rsLower + '|' + rsMisc + ')',
      rsMiscUpper = '(?:' + rsUpper + '|' + rsMisc + ')',
      rsOptContrLower = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?',
      rsOptContrUpper = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?',
      reOptMod = rsModifier + '?',
      rsOptVar = '[' + rsVarRange + ']?',
      rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
      rsOrdLower = '\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])',
      rsOrdUpper = '\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])',
      rsSeq = rsOptVar + reOptMod + rsOptJoin,
      rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq,
      rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';

  /** Used to match apostrophes. */
  var reApos = RegExp(rsApos, 'g');

  /**
   * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
   * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
   */
  var reComboMark = RegExp(rsCombo, 'g');

  /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
  var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');

  /** Used to match complex or compound words. */
  var reUnicodeWord = RegExp([
    rsUpper + '?' + rsLower + '+' + rsOptContrLower + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')',
    rsMiscUpper + '+' + rsOptContrUpper + '(?=' + [rsBreak, rsUpper + rsMiscLower, '$'].join('|') + ')',
    rsUpper + '?' + rsMiscLower + '+' + rsOptContrLower,
    rsUpper + '+' + rsOptContrUpper,
    rsOrdUpper,
    rsOrdLower,
    rsDigits,
    rsEmoji
  ].join('|'), 'g');

  /** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
  var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboRange + rsVarRange + ']');

  /** Used to detect strings that need a more robust regexp to match words. */
  var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;

  /** Used to assign default `context` object properties. */
  var contextProps = [
    'Array', 'Buffer', 'DataView', 'Date', 'Error', 'Float32Array', 'Float64Array',
    'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Map', 'Math', 'Object',
    'Promise', 'RegExp', 'Set', 'String', 'Symbol', 'TypeError', 'Uint8Array',
    'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap',
    '_', 'clearTimeout', 'isFinite', 'parseInt', 'setTimeout'
  ];

  /** Used to make template sourceURLs easier to identify. */
  var templateCounter = -1;

  /** Used to identify `toStringTag` values of typed arrays. */
  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
  typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
  typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
  typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
  typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
  typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
  typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
  typedArrayTags[errorTag] = typedArrayTags[funcTag] =
  typedArrayTags[mapTag] = typedArrayTags[numberTag] =
  typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
  typedArrayTags[setTag] = typedArrayTags[stringTag] =
  typedArrayTags[weakMapTag] = false;

  /** Used to identify `toStringTag` values supported by `_.clone`. */
  var cloneableTags = {};
  cloneableTags[argsTag] = cloneableTags[arrayTag] =
  cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
  cloneableTags[boolTag] = cloneableTags[dateTag] =
  cloneableTags[float32Tag] = cloneableTags[float64Tag] =
  cloneableTags[int8Tag] = cloneableTags[int16Tag] =
  cloneableTags[int32Tag] = cloneableTags[mapTag] =
  cloneableTags[numberTag] = cloneableTags[objectTag] =
  cloneableTags[regexpTag] = cloneableTags[setTag] =
  cloneableTags[stringTag] = cloneableTags[symbolTag] =
  cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
  cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
  cloneableTags[errorTag] = cloneableTags[funcTag] =
  cloneableTags[weakMapTag] = false;

  /** Used to map Latin Unicode letters to basic Latin letters. */
  var deburredLetters = {
    // Latin-1 Supplement block.
    '\xc0': 'A',  '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
    '\xe0': 'a',  '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
    '\xc7': 'C',  '\xe7': 'c',
    '\xd0': 'D',  '\xf0': 'd',
    '\xc8': 'E',  '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
    '\xe8': 'e',  '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
    '\xcc': 'I',  '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
    '\xec': 'i',  '\xed': 'i', '\xee': 'i', '\xef': 'i',
    '\xd1': 'N',  '\xf1': 'n',
    '\xd2': 'O',  '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
    '\xf2': 'o',  '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
    '\xd9': 'U',  '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
    '\xf9': 'u',  '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
    '\xdd': 'Y',  '\xfd': 'y', '\xff': 'y',
    '\xc6': 'Ae', '\xe6': 'ae',
    '\xde': 'Th', '\xfe': 'th',
    '\xdf': 'ss',
    // Latin Extended-A block.
    '\u0100': 'A',  '\u0102': 'A', '\u0104': 'A',
    '\u0101': 'a',  '\u0103': 'a', '\u0105': 'a',
    '\u0106': 'C',  '\u0108': 'C', '\u010a': 'C', '\u010c': 'C',
    '\u0107': 'c',  '\u0109': 'c', '\u010b': 'c', '\u010d': 'c',
    '\u010e': 'D',  '\u0110': 'D', '\u010f': 'd', '\u0111': 'd',
    '\u0112': 'E',  '\u0114': 'E', '\u0116': 'E', '\u0118': 'E', '\u011a': 'E',
    '\u0113': 'e',  '\u0115': 'e', '\u0117': 'e', '\u0119': 'e', '\u011b': 'e',
    '\u011c': 'G',  '\u011e': 'G', '\u0120': 'G', '\u0122': 'G',
    '\u011d': 'g',  '\u011f': 'g', '\u0121': 'g', '\u0123': 'g',
    '\u0124': 'H',  '\u0126': 'H', '\u0125': 'h', '\u0127': 'h',
    '\u0128': 'I',  '\u012a': 'I', '\u012c': 'I', '\u012e': 'I', '\u0130': 'I',
    '\u0129': 'i',  '\u012b': 'i', '\u012d': 'i', '\u012f': 'i', '\u0131': 'i',
    '\u0134': 'J',  '\u0135': 'j',
    '\u0136': 'K',  '\u0137': 'k', '\u0138': 'k',
    '\u0139': 'L',  '\u013b': 'L', '\u013d': 'L', '\u013f': 'L', '\u0141': 'L',
    '\u013a': 'l',  '\u013c': 'l', '\u013e': 'l', '\u0140': 'l', '\u0142': 'l',
    '\u0143': 'N',  '\u0145': 'N', '\u0147': 'N', '\u014a': 'N',
    '\u0144': 'n',  '\u0146': 'n', '\u0148': 'n', '\u014b': 'n',
    '\u014c': 'O',  '\u014e': 'O', '\u0150': 'O',
    '\u014d': 'o',  '\u014f': 'o', '\u0151': 'o',
    '\u0154': 'R',  '\u0156': 'R', '\u0158': 'R',
    '\u0155': 'r',  '\u0157': 'r', '\u0159': 'r',
    '\u015a': 'S',  '\u015c': 'S', '\u015e': 'S', '\u0160': 'S',
    '\u015b': 's',  '\u015d': 's', '\u015f': 's', '\u0161': 's',
    '\u0162': 'T',  '\u0164': 'T', '\u0166': 'T',
    '\u0163': 't',  '\u0165': 't', '\u0167': 't',
    '\u0168': 'U',  '\u016a': 'U', '\u016c': 'U', '\u016e': 'U', '\u0170': 'U', '\u0172': 'U',
    '\u0169': 'u',  '\u016b': 'u', '\u016d': 'u', '\u016f': 'u', '\u0171': 'u', '\u0173': 'u',
    '\u0174': 'W',  '\u0175': 'w',
    '\u0176': 'Y',  '\u0177': 'y', '\u0178': 'Y',
    '\u0179': 'Z',  '\u017b': 'Z', '\u017d': 'Z',
    '\u017a': 'z',  '\u017c': 'z', '\u017e': 'z',
    '\u0132': 'IJ', '\u0133': 'ij',
    '\u0152': 'Oe', '\u0153': 'oe',
    '\u0149': "'n", '\u017f': 's'
  };

  /** Used to map characters to HTML entities. */
  var htmlEscapes = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#39;'
  };

  /** Used to map HTML entities to characters. */
  var htmlUnescapes = {
    '&amp;': '&',
    '&lt;': '<',
    '&gt;': '>',
    '&quot;': '"',
    '&#39;': "'"
  };

  /** Used to escape characters for inclusion in compiled string literals. */
  var stringEscapes = {
    '\\': '\\',
    "'": "'",
    '\n': 'n',
    '\r': 'r',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  /** Built-in method references without a dependency on `root`. */
  var freeParseFloat = parseFloat,
      freeParseInt = parseInt;

  /** Detect free variable `global` from Node.js. */
  var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

  /** Detect free variable `self`. */
  var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

  /** Used as a reference to the global object. */
  var root = freeGlobal || freeSelf || Function('return this')();

  /** Detect free variable `exports`. */
  var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

  /** Detect free variable `module`. */
  var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

  /** Detect the popular CommonJS extension `module.exports`. */
  var moduleExports = freeModule && freeModule.exports === freeExports;

  /** Detect free variable `process` from Node.js. */
  var freeProcess = moduleExports && freeGlobal.process;

  /** Used to access faster Node.js helpers. */
  var nodeUtil = (function() {
    try {
      // Use `util.types` for Node.js 10+.
      var types = freeModule && freeModule.require && freeModule.require('util').types;

      if (types) {
        return types;
      }

      // Legacy `process.binding('util')` for Node.js < 10.
      return freeProcess && freeProcess.binding && freeProcess.binding('util');
    } catch (e) {}
  }());

  /* Node.js helper references. */
  var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer,
      nodeIsDate = nodeUtil && nodeUtil.isDate,
      nodeIsMap = nodeUtil && nodeUtil.isMap,
      nodeIsRegExp = nodeUtil && nodeUtil.isRegExp,
      nodeIsSet = nodeUtil && nodeUtil.isSet,
      nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

  /*--------------------------------------------------------------------------*/

  /**
   * A faster alternative to `Function#apply`, this function invokes `func`
   * with the `this` binding of `thisArg` and the arguments of `args`.
   *
   * @private
   * @param {Function} func The function to invoke.
   * @param {*} thisArg The `this` binding of `func`.
   * @param {Array} args The arguments to invoke `func` with.
   * @returns {*} Returns the result of `func`.
   */
  function apply(func, thisArg, args) {
    switch (args.length) {
      case 0: return func.call(thisArg);
      case 1: return func.call(thisArg, args[0]);
      case 2: return func.call(thisArg, args[0], args[1]);
      case 3: return func.call(thisArg, args[0], args[1], args[2]);
    }
    return func.apply(thisArg, args);
  }

  /**
   * A specialized version of `baseAggregator` for arrays.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} setter The function to set `accumulator` values.
   * @param {Function} iteratee The iteratee to transform keys.
   * @param {Object} accumulator The initial aggregated object.
   * @returns {Function} Returns `accumulator`.
   */
  function arrayAggregator(array, setter, iteratee, accumulator) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      var value = array[index];
      setter(accumulator, value, iteratee(value), array);
    }
    return accumulator;
  }

  /**
   * A specialized version of `_.forEach` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns `array`.
   */
  function arrayEach(array, iteratee) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (iteratee(array[index], index, array) === false) {
        break;
      }
    }
    return array;
  }

  /**
   * A specialized version of `_.forEachRight` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns `array`.
   */
  function arrayEachRight(array, iteratee) {
    var length = array == null ? 0 : array.length;

    while (length--) {
      if (iteratee(array[length], length, array) === false) {
        break;
      }
    }
    return array;
  }

  /**
   * A specialized version of `_.every` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if all elements pass the predicate check,
   *  else `false`.
   */
  function arrayEvery(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (!predicate(array[index], index, array)) {
        return false;
      }
    }
    return true;
  }

  /**
   * A specialized version of `_.filter` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {Array} Returns the new filtered array.
   */
  function arrayFilter(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length,
        resIndex = 0,
        result = [];

    while (++index < length) {
      var value = array[index];
      if (predicate(value, index, array)) {
        result[resIndex++] = value;
      }
    }
    return result;
  }

  /**
   * A specialized version of `_.includes` for arrays without support for
   * specifying an index to search from.
   *
   * @private
   * @param {Array} [array] The array to inspect.
   * @param {*} target The value to search for.
   * @returns {boolean} Returns `true` if `target` is found, else `false`.
   */
  function arrayIncludes(array, value) {
    var length = array == null ? 0 : array.length;
    return !!length && baseIndexOf(array, value, 0) > -1;
  }

  /**
   * This function is like `arrayIncludes` except that it accepts a comparator.
   *
   * @private
   * @param {Array} [array] The array to inspect.
   * @param {*} target The value to search for.
   * @param {Function} comparator The comparator invoked per element.
   * @returns {boolean} Returns `true` if `target` is found, else `false`.
   */
  function arrayIncludesWith(array, value, comparator) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (comparator(value, array[index])) {
        return true;
      }
    }
    return false;
  }

  /**
   * A specialized version of `_.map` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the new mapped array.
   */
  function arrayMap(array, iteratee) {
    var index = -1,
        length = array == null ? 0 : array.length,
        result = Array(length);

    while (++index < length) {
      result[index] = iteratee(array[index], index, array);
    }
    return result;
  }

  /**
   * Appends the elements of `values` to `array`.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {Array} values The values to append.
   * @returns {Array} Returns `array`.
   */
  function arrayPush(array, values) {
    var index = -1,
        length = values.length,
        offset = array.length;

    while (++index < length) {
      array[offset + index] = values[index];
    }
    return array;
  }

  /**
   * A specialized version of `_.reduce` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} [accumulator] The initial value.
   * @param {boolean} [initAccum] Specify using the first element of `array` as
   *  the initial value.
   * @returns {*} Returns the accumulated value.
   */
  function arrayReduce(array, iteratee, accumulator, initAccum) {
    var index = -1,
        length = array == null ? 0 : array.length;

    if (initAccum && length) {
      accumulator = array[++index];
    }
    while (++index < length) {
      accumulator = iteratee(accumulator, array[index], index, array);
    }
    return accumulator;
  }

  /**
   * A specialized version of `_.reduceRight` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} [accumulator] The initial value.
   * @param {boolean} [initAccum] Specify using the last element of `array` as
   *  the initial value.
   * @returns {*} Returns the accumulated value.
   */
  function arrayReduceRight(array, iteratee, accumulator, initAccum) {
    var length = array == null ? 0 : array.length;
    if (initAccum && length) {
      accumulator = array[--length];
    }
    while (length--) {
      accumulator = iteratee(accumulator, array[length], length, array);
    }
    return accumulator;
  }

  /**
   * A specialized version of `_.some` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if any element passes the predicate check,
   *  else `false`.
   */
  function arraySome(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (predicate(array[index], index, array)) {
        return true;
      }
    }
    return false;
  }

  /**
   * Gets the size of an ASCII `string`.
   *
   * @private
   * @param {string} string The string inspect.
   * @returns {number} Returns the string size.
   */
  var asciiSize = baseProperty('length');

  /**
   * Converts an ASCII `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */
  function asciiToArray(string) {
    return string.split('');
  }

  /**
   * Splits an ASCII `string` into an array of its words.
   *
   * @private
   * @param {string} The string to inspect.
   * @returns {Array} Returns the words of `string`.
   */
  function asciiWords(string) {
    return string.match(reAsciiWord) || [];
  }

  /**
   * The base implementation of methods like `_.findKey` and `_.findLastKey`,
   * without support for iteratee shorthands, which iterates over `collection`
   * using `eachFunc`.
   *
   * @private
   * @param {Array|Object} collection The collection to inspect.
   * @param {Function} predicate The function invoked per iteration.
   * @param {Function} eachFunc The function to iterate over `collection`.
   * @returns {*} Returns the found element or its key, else `undefined`.
   */
  function baseFindKey(collection, predicate, eachFunc) {
    var result;
    eachFunc(collection, function(value, key, collection) {
      if (predicate(value, key, collection)) {
        result = key;
        return false;
      }
    });
    return result;
  }

  /**
   * The base implementation of `_.findIndex` and `_.findLastIndex` without
   * support for iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {Function} predicate The function invoked per iteration.
   * @param {number} fromIndex The index to search from.
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseFindIndex(array, predicate, fromIndex, fromRight) {
    var length = array.length,
        index = fromIndex + (fromRight ? 1 : -1);

    while ((fromRight ? index-- : ++index < length)) {
      if (predicate(array[index], index, array)) {
        return index;
      }
    }
    return -1;
  }

  /**
   * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseIndexOf(array, value, fromIndex) {
    return value === value
      ? strictIndexOf(array, value, fromIndex)
      : baseFindIndex(array, baseIsNaN, fromIndex);
  }

  /**
   * This function is like `baseIndexOf` except that it accepts a comparator.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @param {Function} comparator The comparator invoked per element.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseIndexOfWith(array, value, fromIndex, comparator) {
    var index = fromIndex - 1,
        length = array.length;

    while (++index < length) {
      if (comparator(array[index], value)) {
        return index;
      }
    }
    return -1;
  }

  /**
   * The base implementation of `_.isNaN` without support for number objects.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
   */
  function baseIsNaN(value) {
    return value !== value;
  }

  /**
   * The base implementation of `_.mean` and `_.meanBy` without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {number} Returns the mean.
   */
  function baseMean(array, iteratee) {
    var length = array == null ? 0 : array.length;
    return length ? (baseSum(array, iteratee) / length) : NAN;
  }

  /**
   * The base implementation of `_.property` without support for deep paths.
   *
   * @private
   * @param {string} key The key of the property to get.
   * @returns {Function} Returns the new accessor function.
   */
  function baseProperty(key) {
    return function(object) {
      return object == null ? undefined : object[key];
    };
  }

  /**
   * The base implementation of `_.propertyOf` without support for deep paths.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Function} Returns the new accessor function.
   */
  function basePropertyOf(object) {
    return function(key) {
      return object == null ? undefined : object[key];
    };
  }

  /**
   * The base implementation of `_.reduce` and `_.reduceRight`, without support
   * for iteratee shorthands, which iterates over `collection` using `eachFunc`.
   *
   * @private
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} accumulator The initial value.
   * @param {boolean} initAccum Specify using the first or last element of
   *  `collection` as the initial value.
   * @param {Function} eachFunc The function to iterate over `collection`.
   * @returns {*} Returns the accumulated value.
   */
  function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
    eachFunc(collection, function(value, index, collection) {
      accumulator = initAccum
        ? (initAccum = false, value)
        : iteratee(accumulator, value, index, collection);
    });
    return accumulator;
  }

  /**
   * The base implementation of `_.sortBy` which uses `comparer` to define the
   * sort order of `array` and replaces criteria objects with their corresponding
   * values.
   *
   * @private
   * @param {Array} array The array to sort.
   * @param {Function} comparer The function to define sort order.
   * @returns {Array} Returns `array`.
   */
  function baseSortBy(array, comparer) {
    var length = array.length;

    array.sort(comparer);
    while (length--) {
      array[length] = array[length].value;
    }
    return array;
  }

  /**
   * The base implementation of `_.sum` and `_.sumBy` without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {number} Returns the sum.
   */
  function baseSum(array, iteratee) {
    var result,
        index = -1,
        length = array.length;

    while (++index < length) {
      var current = iteratee(array[index]);
      if (current !== undefined) {
        result = result === undefined ? current : (result + current);
      }
    }
    return result;
  }

  /**
   * The base implementation of `_.times` without support for iteratee shorthands
   * or max array length checks.
   *
   * @private
   * @param {number} n The number of times to invoke `iteratee`.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the array of results.
   */
  function baseTimes(n, iteratee) {
    var index = -1,
        result = Array(n);

    while (++index < n) {
      result[index] = iteratee(index);
    }
    return result;
  }

  /**
   * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array
   * of key-value pairs for `object` corresponding to the property names of `props`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array} props The property names to get values for.
   * @returns {Object} Returns the key-value pairs.
   */
  function baseToPairs(object, props) {
    return arrayMap(props, function(key) {
      return [key, object[key]];
    });
  }

  /**
   * The base implementation of `_.unary` without support for storing metadata.
   *
   * @private
   * @param {Function} func The function to cap arguments for.
   * @returns {Function} Returns the new capped function.
   */
  function baseUnary(func) {
    return function(value) {
      return func(value);
    };
  }

  /**
   * The base implementation of `_.values` and `_.valuesIn` which creates an
   * array of `object` property values corresponding to the property names
   * of `props`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array} props The property names to get values for.
   * @returns {Object} Returns the array of property values.
   */
  function baseValues(object, props) {
    return arrayMap(props, function(key) {
      return object[key];
    });
  }

  /**
   * Checks if a `cache` value for `key` exists.
   *
   * @private
   * @param {Object} cache The cache to query.
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function cacheHas(cache, key) {
    return cache.has(key);
  }

  /**
   * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol
   * that is not found in the character symbols.
   *
   * @private
   * @param {Array} strSymbols The string symbols to inspect.
   * @param {Array} chrSymbols The character symbols to find.
   * @returns {number} Returns the index of the first unmatched string symbol.
   */
  function charsStartIndex(strSymbols, chrSymbols) {
    var index = -1,
        length = strSymbols.length;

    while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
    return index;
  }

  /**
   * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol
   * that is not found in the character symbols.
   *
   * @private
   * @param {Array} strSymbols The string symbols to inspect.
   * @param {Array} chrSymbols The character symbols to find.
   * @returns {number} Returns the index of the last unmatched string symbol.
   */
  function charsEndIndex(strSymbols, chrSymbols) {
    var index = strSymbols.length;

    while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
    return index;
  }

  /**
   * Gets the number of `placeholder` occurrences in `array`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} placeholder The placeholder to search for.
   * @returns {number} Returns the placeholder count.
   */
  function countHolders(array, placeholder) {
    var length = array.length,
        result = 0;

    while (length--) {
      if (array[length] === placeholder) {
        ++result;
      }
    }
    return result;
  }

  /**
   * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
   * letters to basic Latin letters.
   *
   * @private
   * @param {string} letter The matched letter to deburr.
   * @returns {string} Returns the deburred letter.
   */
  var deburrLetter = basePropertyOf(deburredLetters);

  /**
   * Used by `_.escape` to convert characters to HTML entities.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */
  var escapeHtmlChar = basePropertyOf(htmlEscapes);

  /**
   * Used by `_.template` to escape characters for inclusion in compiled string literals.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */
  function escapeStringChar(chr) {
    return '\\' + stringEscapes[chr];
  }

  /**
   * Gets the value at `key` of `object`.
   *
   * @private
   * @param {Object} [object] The object to query.
   * @param {string} key The key of the property to get.
   * @returns {*} Returns the property value.
   */
  function getValue(object, key) {
    return object == null ? undefined : object[key];
  }

  /**
   * Checks if `string` contains Unicode symbols.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {boolean} Returns `true` if a symbol is found, else `false`.
   */
  function hasUnicode(string) {
    return reHasUnicode.test(string);
  }

  /**
   * Checks if `string` contains a word composed of Unicode symbols.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {boolean} Returns `true` if a word is found, else `false`.
   */
  function hasUnicodeWord(string) {
    return reHasUnicodeWord.test(string);
  }

  /**
   * Converts `iterator` to an array.
   *
   * @private
   * @param {Object} iterator The iterator to convert.
   * @returns {Array} Returns the converted array.
   */
  function iteratorToArray(iterator) {
    var data,
        result = [];

    while (!(data = iterator.next()).done) {
      result.push(data.value);
    }
    return result;
  }

  /**
   * Converts `map` to its key-value pairs.
   *
   * @private
   * @param {Object} map The map to convert.
   * @returns {Array} Returns the key-value pairs.
   */
  function mapToArray(map) {
    var index = -1,
        result = Array(map.size);

    map.forEach(function(value, key) {
      result[++index] = [key, value];
    });
    return result;
  }

  /**
   * Creates a unary function that invokes `func` with its argument transformed.
   *
   * @private
   * @param {Function} func The function to wrap.
   * @param {Function} transform The argument transform.
   * @returns {Function} Returns the new function.
   */
  function overArg(func, transform) {
    return function(arg) {
      return func(transform(arg));
    };
  }

  /**
   * Replaces all `placeholder` elements in `array` with an internal placeholder
   * and returns an array of their indexes.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {*} placeholder The placeholder to replace.
   * @returns {Array} Returns the new array of placeholder indexes.
   */
  function replaceHolders(array, placeholder) {
    var index = -1,
        length = array.length,
        resIndex = 0,
        result = [];

    while (++index < length) {
      var value = array[index];
      if (value === placeholder || value === PLACEHOLDER) {
        array[index] = PLACEHOLDER;
        result[resIndex++] = index;
      }
    }
    return result;
  }

  /**
   * Converts `set` to an array of its values.
   *
   * @private
   * @param {Object} set The set to convert.
   * @returns {Array} Returns the values.
   */
  function setToArray(set) {
    var index = -1,
        result = Array(set.size);

    set.forEach(function(value) {
      result[++index] = value;
    });
    return result;
  }

  /**
   * Converts `set` to its value-value pairs.
   *
   * @private
   * @param {Object} set The set to convert.
   * @returns {Array} Returns the value-value pairs.
   */
  function setToPairs(set) {
    var index = -1,
        result = Array(set.size);

    set.forEach(function(value) {
      result[++index] = [value, value];
    });
    return result;
  }

  /**
   * A specialized version of `_.indexOf` which performs strict equality
   * comparisons of values, i.e. `===`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function strictIndexOf(array, value, fromIndex) {
    var index = fromIndex - 1,
        length = array.length;

    while (++index < length) {
      if (array[index] === value) {
        return index;
      }
    }
    return -1;
  }

  /**
   * A specialized version of `_.lastIndexOf` which performs strict equality
   * comparisons of values, i.e. `===`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function strictLastIndexOf(array, value, fromIndex) {
    var index = fromIndex + 1;
    while (index--) {
      if (array[index] === value) {
        return index;
      }
    }
    return index;
  }

  /**
   * Gets the number of symbols in `string`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {number} Returns the string size.
   */
  function stringSize(string) {
    return hasUnicode(string)
      ? unicodeSize(string)
      : asciiSize(string);
  }

  /**
   * Converts `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */
  function stringToArray(string) {
    return hasUnicode(string)
      ? unicodeToArray(string)
      : asciiToArray(string);
  }

  /**
   * Used by `_.unescape` to convert HTML entities to characters.
   *
   * @private
   * @param {string} chr The matched character to unescape.
   * @returns {string} Returns the unescaped character.
   */
  var unescapeHtmlChar = basePropertyOf(htmlUnescapes);

  /**
   * Gets the size of a Unicode `string`.
   *
   * @private
   * @param {string} string The string inspect.
   * @returns {number} Returns the string size.
   */
  function unicodeSize(string) {
    var result = reUnicode.lastIndex = 0;
    while (reUnicode.test(string)) {
      ++result;
    }
    return result;
  }

  /**
   * Converts a Unicode `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */
  function unicodeToArray(string) {
    return string.match(reUnicode) || [];
  }

  /**
   * Splits a Unicode `string` into an array of its words.
   *
   * @private
   * @param {string} The string to inspect.
   * @returns {Array} Returns the words of `string`.
   */
  function unicodeWords(string) {
    return string.match(reUnicodeWord) || [];
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Create a new pristine `lodash` function using the `context` object.
   *
   * @static
   * @memberOf _
   * @since 1.1.0
   * @category Util
   * @param {Object} [context=root] The context object.
   * @returns {Function} Returns a new `lodash` function.
   * @example
   *
   * _.mixin({ 'foo': _.constant('foo') });
   *
   * var lodash = _.runInContext();
   * lodash.mixin({ 'bar': lodash.constant('bar') });
   *
   * _.isFunction(_.foo);
   * // => true
   * _.isFunction(_.bar);
   * // => false
   *
   * lodash.isFunction(lodash.foo);
   * // => false
   * lodash.isFunction(lodash.bar);
   * // => true
   *
   * // Create a suped-up `defer` in Node.js.
   * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;
   */
  var runInContext = (function runInContext(context) {
    context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));

    /** Built-in constructor references. */
    var Array = context.Array,
        Date = context.Date,
        Error = context.Error,
        Function = context.Function,
        Math = context.Math,
        Object = context.Object,
        RegExp = context.RegExp,
        String = context.String,
        TypeError = context.TypeError;

    /** Used for built-in method references. */
    var arrayProto = Array.prototype,
        funcProto = Function.prototype,
        objectProto = Object.prototype;

    /** Used to detect overreaching core-js shims. */
    var coreJsData = context['__core-js_shared__'];

    /** Used to resolve the decompiled source of functions. */
    var funcToString = funcProto.toString;

    /** Used to check objects for own properties. */
    var hasOwnProperty = objectProto.hasOwnProperty;

    /** Used to generate unique IDs. */
    var idCounter = 0;

    /** Used to detect methods masquerading as native. */
    var maskSrcKey = (function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
      return uid ? ('Symbol(src)_1.' + uid) : '';
    }());

    /**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
     * of values.
     */
    var nativeObjectToString = objectProto.toString;

    /** Used to infer the `Object` constructor. */
    var objectCtorString = funcToString.call(Object);

    /** Used to restore the original `_` reference in `_.noConflict`. */
    var oldDash = root._;

    /** Used to detect if a method is native. */
    var reIsNative = RegExp('^' +
      funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
      .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
    );

    /** Built-in value references. */
    var Buffer = moduleExports ? context.Buffer : undefined,
        Symbol = context.Symbol,
        Uint8Array = context.Uint8Array,
        allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined,
        getPrototype = overArg(Object.getPrototypeOf, Object),
        objectCreate = Object.create,
        propertyIsEnumerable = objectProto.propertyIsEnumerable,
        splice = arrayProto.splice,
        spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined,
        symIterator = Symbol ? Symbol.iterator : undefined,
        symToStringTag = Symbol ? Symbol.toStringTag : undefined;

    var defineProperty = (function() {
      try {
        var func = getNative(Object, 'defineProperty');
        func({}, '', {});
        return func;
      } catch (e) {}
    }());

    /** Mocked built-ins. */
    var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout,
        ctxNow = Date && Date.now !== root.Date.now && Date.now,
        ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeCeil = Math.ceil,
        nativeFloor = Math.floor,
        nativeGetSymbols = Object.getOwnPropertySymbols,
        nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,
        nativeIsFinite = context.isFinite,
        nativeJoin = arrayProto.join,
        nativeKeys = overArg(Object.keys, Object),
        nativeMax = Math.max,
        nativeMin = Math.min,
        nativeNow = Date.now,
        nativeParseInt = context.parseInt,
        nativeRandom = Math.random,
        nativeReverse = arrayProto.reverse;

    /* Built-in method references that are verified to be native. */
    var DataView = getNative(context, 'DataView'),
        Map = getNative(context, 'Map'),
        Promise = getNative(context, 'Promise'),
        Set = getNative(context, 'Set'),
        WeakMap = getNative(context, 'WeakMap'),
        nativeCreate = getNative(Object, 'create');

    /** Used to store function metadata. */
    var metaMap = WeakMap && new WeakMap;

    /** Used to lookup unminified function names. */
    var realNames = {};

    /** Used to detect maps, sets, and weakmaps. */
    var dataViewCtorString = toSource(DataView),
        mapCtorString = toSource(Map),
        promiseCtorString = toSource(Promise),
        setCtorString = toSource(Set),
        weakMapCtorString = toSource(WeakMap);

    /** Used to convert symbols to primitives and strings. */
    var symbolProto = Symbol ? Symbol.prototype : undefined,
        symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,
        symbolToString = symbolProto ? symbolProto.toString : undefined;

    /*------------------------------------------------------------------------*/

    /**
     * Creates a `lodash` object which wraps `value` to enable implicit method
     * chain sequences. Methods that operate on and return arrays, collections,
     * and functions can be chained together. Methods that retrieve a single value
     * or may return a primitive value will automatically end the chain sequence
     * and return the unwrapped value. Otherwise, the value must be unwrapped
     * with `_#value`.
     *
     * Explicit chain sequences, which must be unwrapped with `_#value`, may be
     * enabled using `_.chain`.
     *
     * The execution of chained methods is lazy, that is, it's deferred until
     * `_#value` is implicitly or explicitly called.
     *
     * Lazy evaluation allows several methods to support shortcut fusion.
     * Shortcut fusion is an optimization to merge iteratee calls; this avoids
     * the creation of intermediate arrays and can greatly reduce the number of
     * iteratee executions. Sections of a chain sequence qualify for shortcut
     * fusion if the section is applied to an array and iteratees accept only
     * one argument. The heuristic for whether a section qualifies for shortcut
     * fusion is subject to change.
     *
     * Chaining is supported in custom builds as long as the `_#value` method is
     * directly or indirectly included in the build.
     *
     * In addition to lodash methods, wrappers have `Array` and `String` methods.
     *
     * The wrapper `Array` methods are:
     * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`
     *
     * The wrapper `String` methods are:
     * `replace` and `split`
     *
     * The wrapper methods that support shortcut fusion are:
     * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,
     * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,
     * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`
     *
     * The chainable wrapper methods are:
     * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,
     * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,
     * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,
     * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,
     * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,
     * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,
     * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,
     * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,
     * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,
     * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,
     * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,
     * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,
     * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,
     * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,
     * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,
     * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,
     * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,
     * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,
     * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,
     * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,
     * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,
     * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,
     * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,
     * `zipObject`, `zipObjectDeep`, and `zipWith`
     *
     * The wrapper methods that are **not** chainable by default are:
     * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,
     * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,
     * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,
     * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,
     * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,
     * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,
     * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,
     * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,
     * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,
     * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,
     * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,
     * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,
     * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,
     * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,
     * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,
     * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,
     * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,
     * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,
     * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,
     * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,
     * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,
     * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,
     * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,
     * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,
     * `upperFirst`, `value`, and `words`
     *
     * @name _
     * @constructor
     * @category Seq
     * @param {*} value The value to wrap in a `lodash` instance.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var wrapped = _([1, 2, 3]);
     *
     * // Returns an unwrapped value.
     * wrapped.reduce(_.add);
     * // => 6
     *
     * // Returns a wrapped value.
     * var squares = wrapped.map(square);
     *
     * _.isArray(squares);
     * // => false
     *
     * _.isArray(squares.value());
     * // => true
     */
    function lodash(value) {
      if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
        if (value instanceof LodashWrapper) {
          return value;
        }
        if (hasOwnProperty.call(value, '__wrapped__')) {
          return wrapperClone(value);
        }
      }
      return new LodashWrapper(value);
    }

    /**
     * The base implementation of `_.create` without support for assigning
     * properties to the created object.
     *
     * @private
     * @param {Object} proto The object to inherit from.
     * @returns {Object} Returns the new object.
     */
    var baseCreate = (function() {
      function object() {}
      return function(proto) {
        if (!isObject(proto)) {
          return {};
        }
        if (objectCreate) {
          return objectCreate(proto);
        }
        object.prototype = proto;
        var result = new object;
        object.prototype = undefined;
        return result;
      };
    }());

    /**
     * The function whose prototype chain sequence wrappers inherit from.
     *
     * @private
     */
    function baseLodash() {
      // No operation performed.
    }

    /**
     * The base constructor for creating `lodash` wrapper objects.
     *
     * @private
     * @param {*} value The value to wrap.
     * @param {boolean} [chainAll] Enable explicit method chain sequences.
     */
    function LodashWrapper(value, chainAll) {
      this.__wrapped__ = value;
      this.__actions__ = [];
      this.__chain__ = !!chainAll;
      this.__index__ = 0;
      this.__values__ = undefined;
    }

    /**
     * By default, the template delimiters used by lodash are like those in
     * embedded Ruby (ERB) as well as ES2015 template strings. Change the
     * following template settings to use alternative delimiters.
     *
     * @static
     * @memberOf _
     * @type {Object}
     */
    lodash.templateSettings = {

      /**
       * Used to detect `data` property values to be HTML-escaped.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */
      'escape': reEscape,

      /**
       * Used to detect code to be evaluated.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */
      'evaluate': reEvaluate,

      /**
       * Used to detect `data` property values to inject.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */
      'interpolate': reInterpolate,

      /**
       * Used to reference the data object in the template text.
       *
       * @memberOf _.templateSettings
       * @type {string}
       */
      'variable': '',

      /**
       * Used to import variables into the compiled template.
       *
       * @memberOf _.templateSettings
       * @type {Object}
       */
      'imports': {

        /**
         * A reference to the `lodash` function.
         *
         * @memberOf _.templateSettings.imports
         * @type {Function}
         */
        '_': lodash
      }
    };

    // Ensure wrappers are instances of `baseLodash`.
    lodash.prototype = baseLodash.prototype;
    lodash.prototype.constructor = lodash;

    LodashWrapper.prototype = baseCreate(baseLodash.prototype);
    LodashWrapper.prototype.constructor = LodashWrapper;

    /*------------------------------------------------------------------------*/

    /**
     * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
     *
     * @private
     * @constructor
     * @param {*} value The value to wrap.
     */
    function LazyWrapper(value) {
      this.__wrapped__ = value;
      this.__actions__ = [];
      this.__dir__ = 1;
      this.__filtered__ = false;
      this.__iteratees__ = [];
      this.__takeCount__ = MAX_ARRAY_LENGTH;
      this.__views__ = [];
    }

    /**
     * Creates a clone of the lazy wrapper object.
     *
     * @private
     * @name clone
     * @memberOf LazyWrapper
     * @returns {Object} Returns the cloned `LazyWrapper` object.
     */
    function lazyClone() {
      var result = new LazyWrapper(this.__wrapped__);
      result.__actions__ = copyArray(this.__actions__);
      result.__dir__ = this.__dir__;
      result.__filtered__ = this.__filtered__;
      result.__iteratees__ = copyArray(this.__iteratees__);
      result.__takeCount__ = this.__takeCount__;
      result.__views__ = copyArray(this.__views__);
      return result;
    }

    /**
     * Reverses the direction of lazy iteration.
     *
     * @private
     * @name reverse
     * @memberOf LazyWrapper
     * @returns {Object} Returns the new reversed `LazyWrapper` object.
     */
    function lazyReverse() {
      if (this.__filtered__) {
        var result = new LazyWrapper(this);
        result.__dir__ = -1;
        result.__filtered__ = true;
      } else {
        result = this.clone();
        result.__dir__ *= -1;
      }
      return result;
    }

    /**
     * Extracts the unwrapped value from its lazy wrapper.
     *
     * @private
     * @name value
     * @memberOf LazyWrapper
     * @returns {*} Returns the unwrapped value.
     */
    function lazyValue() {
      var array = this.__wrapped__.value(),
          dir = this.__dir__,
          isArr = isArray(array),
          isRight = dir < 0,
          arrLength = isArr ? array.length : 0,
          view = getView(0, arrLength, this.__views__),
          start = view.start,
          end = view.end,
          length = end - start,
          index = isRight ? end : (start - 1),
          iteratees = this.__iteratees__,
          iterLength = iteratees.length,
          resIndex = 0,
          takeCount = nativeMin(length, this.__takeCount__);

      if (!isArr || (!isRight && arrLength == length && takeCount == length)) {
        return baseWrapperValue(array, this.__actions__);
      }
      var result = [];

      outer:
      while (length-- && resIndex < takeCount) {
        index += dir;

        var iterIndex = -1,
            value = array[index];

        while (++iterIndex < iterLength) {
          var data = iteratees[iterIndex],
              iteratee = data.iteratee,
              type = data.type,
              computed = iteratee(value);

          if (type == LAZY_MAP_FLAG) {
            value = computed;
          } else if (!computed) {
            if (type == LAZY_FILTER_FLAG) {
              continue outer;
            } else {
              break outer;
            }
          }
        }
        result[resIndex++] = value;
      }
      return result;
    }

    // Ensure `LazyWrapper` is an instance of `baseLodash`.
    LazyWrapper.prototype = baseCreate(baseLodash.prototype);
    LazyWrapper.prototype.constructor = LazyWrapper;

    /*------------------------------------------------------------------------*/

    /**
     * Creates a hash object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function Hash(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;

      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }

    /**
     * Removes all key-value entries from the hash.
     *
     * @private
     * @name clear
     * @memberOf Hash
     */
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }

    /**
     * Removes `key` and its value from the hash.
     *
     * @private
     * @name delete
     * @memberOf Hash
     * @param {Object} hash The hash to modify.
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }

    /**
     * Gets the hash value for `key`.
     *
     * @private
     * @name get
     * @memberOf Hash
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? undefined : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : undefined;
    }

    /**
     * Checks if a hash value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Hash
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
    }

    /**
     * Sets the hash `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Hash
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the hash instance.
     */
    function hashSet(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
      return this;
    }

    // Add methods to `Hash`.
    Hash.prototype.clear = hashClear;
    Hash.prototype['delete'] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;

    /*------------------------------------------------------------------------*/

    /**
     * Creates an list cache object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function ListCache(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;

      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }

    /**
     * Removes all key-value entries from the list cache.
     *
     * @private
     * @name clear
     * @memberOf ListCache
     */
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }

    /**
     * Removes `key` and its value from the list cache.
     *
     * @private
     * @name delete
     * @memberOf ListCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function listCacheDelete(key) {
      var data = this.__data__,
          index = assocIndexOf(data, key);

      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      --this.size;
      return true;
    }

    /**
     * Gets the list cache value for `key`.
     *
     * @private
     * @name get
     * @memberOf ListCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function listCacheGet(key) {
      var data = this.__data__,
          index = assocIndexOf(data, key);

      return index < 0 ? undefined : data[index][1];
    }

    /**
     * Checks if a list cache value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf ListCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }

    /**
     * Sets the list cache `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf ListCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the list cache instance.
     */
    function listCacheSet(key, value) {
      var data = this.__data__,
          index = assocIndexOf(data, key);

      if (index < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }

    // Add methods to `ListCache`.
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype['delete'] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;

    /*------------------------------------------------------------------------*/

    /**
     * Creates a map cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function MapCache(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;

      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }

    /**
     * Removes all key-value entries from the map.
     *
     * @private
     * @name clear
     * @memberOf MapCache
     */
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        'hash': new Hash,
        'map': new (Map || ListCache),
        'string': new Hash
      };
    }

    /**
     * Removes `key` and its value from the map.
     *
     * @private
     * @name delete
     * @memberOf MapCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function mapCacheDelete(key) {
      var result = getMapData(this, key)['delete'](key);
      this.size -= result ? 1 : 0;
      return result;
    }

    /**
     * Gets the map value for `key`.
     *
     * @private
     * @name get
     * @memberOf MapCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }

    /**
     * Checks if a map value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf MapCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }

    /**
     * Sets the map `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf MapCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the map cache instance.
     */
    function mapCacheSet(key, value) {
      var data = getMapData(this, key),
          size = data.size;

      data.set(key, value);
      this.size += data.size == size ? 0 : 1;
      return this;
    }

    // Add methods to `MapCache`.
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype['delete'] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;

    /*------------------------------------------------------------------------*/

    /**
     *
     * Creates an array cache object to store unique values.
     *
     * @private
     * @constructor
     * @param {Array} [values] The values to cache.
     */
    function SetCache(values) {
      var index = -1,
          length = values == null ? 0 : values.length;

      this.__data__ = new MapCache;
      while (++index < length) {
        this.add(values[index]);
      }
    }

    /**
     * Adds `value` to the array cache.
     *
     * @private
     * @name add
     * @memberOf SetCache
     * @alias push
     * @param {*} value The value to cache.
     * @returns {Object} Returns the cache instance.
     */
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }

    /**
     * Checks if `value` is in the array cache.
     *
     * @private
     * @name has
     * @memberOf SetCache
     * @param {*} value The value to search for.
     * @returns {number} Returns `true` if `value` is found, else `false`.
     */
    function setCacheHas(value) {
      return this.__data__.has(value);
    }

    // Add methods to `SetCache`.
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;

    /*------------------------------------------------------------------------*/

    /**
     * Creates a stack cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function Stack(entries) {
      var data = this.__data__ = new ListCache(entries);
      this.size = data.size;
    }

    /**
     * Removes all key-value entries from the stack.
     *
     * @private
     * @name clear
     * @memberOf Stack
     */
    function stackClear() {
      this.__data__ = new ListCache;
      this.size = 0;
    }

    /**
     * Removes `key` and its value from the stack.
     *
     * @private
     * @name delete
     * @memberOf Stack
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function stackDelete(key) {
      var data = this.__data__,
          result = data['delete'](key);

      this.size = data.size;
      return result;
    }

    /**
     * Gets the stack value for `key`.
     *
     * @private
     * @name get
     * @memberOf Stack
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function stackGet(key) {
      return this.__data__.get(key);
    }

    /**
     * Checks if a stack value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Stack
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function stackHas(key) {
      return this.__data__.has(key);
    }

    /**
     * Sets the stack `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Stack
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the stack cache instance.
     */
    function stackSet(key, value) {
      var data = this.__data__;
      if (data instanceof ListCache) {
        var pairs = data.__data__;
        if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
          pairs.push([key, value]);
          this.size = ++data.size;
          return this;
        }
        data = this.__data__ = new MapCache(pairs);
      }
      data.set(key, value);
      this.size = data.size;
      return this;
    }

    // Add methods to `Stack`.
    Stack.prototype.clear = stackClear;
    Stack.prototype['delete'] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;

    /*------------------------------------------------------------------------*/

    /**
     * Creates an array of the enumerable property names of the array-like `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @param {boolean} inherited Specify returning inherited property names.
     * @returns {Array} Returns the array of property names.
     */
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray(value),
          isArg = !isArr && isArguments(value),
          isBuff = !isArr && !isArg && isBuffer(value),
          isType = !isArr && !isArg && !isBuff && isTypedArray(value),
          skipIndexes = isArr || isArg || isBuff || isType,
          result = skipIndexes ? baseTimes(value.length, String) : [],
          length = result.length;

      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) &&
            !(skipIndexes && (
               // Safari 9 has enumerable `arguments.length` in strict mode.
               key == 'length' ||
               // Node.js 0.10 has enumerable non-index properties on buffers.
               (isBuff && (key == 'offset' || key == 'parent')) ||
               // PhantomJS 2 has enumerable non-index properties on typed arrays.
               (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
               // Skip index properties.
               isIndex(key, length)
            ))) {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * A specialized version of `_.sample` for arrays.
     *
     * @private
     * @param {Array} array The array to sample.
     * @returns {*} Returns the random element.
     */
    function arraySample(array) {
      var length = array.length;
      return length ? array[baseRandom(0, length - 1)] : undefined;
    }

    /**
     * A specialized version of `_.sampleSize` for arrays.
     *
     * @private
     * @param {Array} array The array to sample.
     * @param {number} n The number of elements to sample.
     * @returns {Array} Returns the random elements.
     */
    function arraySampleSize(array, n) {
      return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
    }

    /**
     * A specialized version of `_.shuffle` for arrays.
     *
     * @private
     * @param {Array} array The array to shuffle.
     * @returns {Array} Returns the new shuffled array.
     */
    function arrayShuffle(array) {
      return shuffleSelf(copyArray(array));
    }

    /**
     * This function is like `assignValue` except that it doesn't assign
     * `undefined` values.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */
    function assignMergeValue(object, key, value) {
      if ((value !== undefined && !eq(object[key], value)) ||
          (value === undefined && !(key in object))) {
        baseAssignValue(object, key, value);
      }
    }

    /**
     * Assigns `value` to `key` of `object` if the existing value is not equivalent
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */
    function assignValue(object, key, value) {
      var objValue = object[key];
      if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
          (value === undefined && !(key in object))) {
        baseAssignValue(object, key, value);
      }
    }

    /**
     * Gets the index at which the `key` is found in `array` of key-value pairs.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {*} key The key to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }

    /**
     * Aggregates elements of `collection` on `accumulator` with keys transformed
     * by `iteratee` and values set by `setter`.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} setter The function to set `accumulator` values.
     * @param {Function} iteratee The iteratee to transform keys.
     * @param {Object} accumulator The initial aggregated object.
     * @returns {Function} Returns `accumulator`.
     */
    function baseAggregator(collection, setter, iteratee, accumulator) {
      baseEach(collection, function(value, key, collection) {
        setter(accumulator, value, iteratee(value), collection);
      });
      return accumulator;
    }

    /**
     * The base implementation of `_.assign` without support for multiple sources
     * or `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @returns {Object} Returns `object`.
     */
    function baseAssign(object, source) {
      return object && copyObject(source, keys(source), object);
    }

    /**
     * The base implementation of `_.assignIn` without support for multiple sources
     * or `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @returns {Object} Returns `object`.
     */
    function baseAssignIn(object, source) {
      return object && copyObject(source, keysIn(source), object);
    }

    /**
     * The base implementation of `assignValue` and `assignMergeValue` without
     * value checks.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */
    function baseAssignValue(object, key, value) {
      if (key == '__proto__' && defineProperty) {
        defineProperty(object, key, {
          'configurable': true,
          'enumerable': true,
          'value': value,
          'writable': true
        });
      } else {
        object[key] = value;
      }
    }

    /**
     * The base implementation of `_.at` without support for individual paths.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {string[]} paths The property paths to pick.
     * @returns {Array} Returns the picked elements.
     */
    function baseAt(object, paths) {
      var index = -1,
          length = paths.length,
          result = Array(length),
          skip = object == null;

      while (++index < length) {
        result[index] = skip ? undefined : get(object, paths[index]);
      }
      return result;
    }

    /**
     * The base implementation of `_.clamp` which doesn't coerce arguments.
     *
     * @private
     * @param {number} number The number to clamp.
     * @param {number} [lower] The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the clamped number.
     */
    function baseClamp(number, lower, upper) {
      if (number === number) {
        if (upper !== undefined) {
          number = number <= upper ? number : upper;
        }
        if (lower !== undefined) {
          number = number >= lower ? number : lower;
        }
      }
      return number;
    }

    /**
     * The base implementation of `_.clone` and `_.cloneDeep` which tracks
     * traversed objects.
     *
     * @private
     * @param {*} value The value to clone.
     * @param {boolean} bitmask The bitmask flags.
     *  1 - Deep clone
     *  2 - Flatten inherited properties
     *  4 - Clone symbols
     * @param {Function} [customizer] The function to customize cloning.
     * @param {string} [key] The key of `value`.
     * @param {Object} [object] The parent object of `value`.
     * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
     * @returns {*} Returns the cloned value.
     */
    function baseClone(value, bitmask, customizer, key, object, stack) {
      var result,
          isDeep = bitmask & CLONE_DEEP_FLAG,
          isFlat = bitmask & CLONE_FLAT_FLAG,
          isFull = bitmask & CLONE_SYMBOLS_FLAG;

      if (customizer) {
        result = object ? customizer(value, key, object, stack) : customizer(value);
      }
      if (result !== undefined) {
        return result;
      }
      if (!isObject(value)) {
        return value;
      }
      var isArr = isArray(value);
      if (isArr) {
        result = initCloneArray(value);
        if (!isDeep) {
          return copyArray(value, result);
        }
      } else {
        var tag = getTag(value),
            isFunc = tag == funcTag || tag == genTag;

        if (isBuffer(value)) {
          return cloneBuffer(value, isDeep);
        }
        if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
          result = (isFlat || isFunc) ? {} : initCloneObject(value);
          if (!isDeep) {
            return isFlat
              ? copySymbolsIn(value, baseAssignIn(result, value))
              : copySymbols(value, baseAssign(result, value));
          }
        } else {
          if (!cloneableTags[tag]) {
            return object ? value : {};
          }
          result = initCloneByTag(value, tag, isDeep);
        }
      }
      // Check for circular references and return its corresponding clone.
      stack || (stack = new Stack);
      var stacked = stack.get(value);
      if (stacked) {
        return stacked;
      }
      stack.set(value, result);

      if (isSet(value)) {
        value.forEach(function(subValue) {
          result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
        });
      } else if (isMap(value)) {
        value.forEach(function(subValue, key) {
          result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
        });
      }

      var keysFunc = isFull
        ? (isFlat ? getAllKeysIn : getAllKeys)
        : (isFlat ? keysIn : keys);

      var props = isArr ? undefined : keysFunc(value);
      arrayEach(props || value, function(subValue, key) {
        if (props) {
          key = subValue;
          subValue = value[key];
        }
        // Recursively populate clone (susceptible to call stack limits).
        assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
      });
      return result;
    }

    /**
     * The base implementation of `_.conforms` which doesn't clone `source`.
     *
     * @private
     * @param {Object} source The object of property predicates to conform to.
     * @returns {Function} Returns the new spec function.
     */
    function baseConforms(source) {
      var props = keys(source);
      return function(object) {
        return baseConformsTo(object, source, props);
      };
    }

    /**
     * The base implementation of `_.conformsTo` which accepts `props` to check.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property predicates to conform to.
     * @returns {boolean} Returns `true` if `object` conforms, else `false`.
     */
    function baseConformsTo(object, source, props) {
      var length = props.length;
      if (object == null) {
        return !length;
      }
      object = Object(object);
      while (length--) {
        var key = props[length],
            predicate = source[key],
            value = object[key];

        if ((value === undefined && !(key in object)) || !predicate(value)) {
          return false;
        }
      }
      return true;
    }

    /**
     * The base implementation of `_.delay` and `_.defer` which accepts `args`
     * to provide to `func`.
     *
     * @private
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @param {Array} args The arguments to provide to `func`.
     * @returns {number|Object} Returns the timer id or timeout object.
     */
    function baseDelay(func, wait, args) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      return setTimeout(function() { func.apply(undefined, args); }, wait);
    }

    /**
     * The base implementation of methods like `_.difference` without support
     * for excluding multiple arrays or iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Array} values The values to exclude.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     */
    function baseDifference(array, values, iteratee, comparator) {
      var index = -1,
          includes = arrayIncludes,
          isCommon = true,
          length = array.length,
          result = [],
          valuesLength = values.length;

      if (!length) {
        return result;
      }
      if (iteratee) {
        values = arrayMap(values, baseUnary(iteratee));
      }
      if (comparator) {
        includes = arrayIncludesWith;
        isCommon = false;
      }
      else if (values.length >= LARGE_ARRAY_SIZE) {
        includes = cacheHas;
        isCommon = false;
        values = new SetCache(values);
      }
      outer:
      while (++index < length) {
        var value = array[index],
            computed = iteratee == null ? value : iteratee(value);

        value = (comparator || value !== 0) ? value : 0;
        if (isCommon && computed === computed) {
          var valuesIndex = valuesLength;
          while (valuesIndex--) {
            if (values[valuesIndex] === computed) {
              continue outer;
            }
          }
          result.push(value);
        }
        else if (!includes(values, computed, comparator)) {
          result.push(value);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.forEach` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     */
    var baseEach = createBaseEach(baseForOwn);

    /**
     * The base implementation of `_.forEachRight` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     */
    var baseEachRight = createBaseEach(baseForOwnRight, true);

    /**
     * The base implementation of `_.every` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`
     */
    function baseEvery(collection, predicate) {
      var result = true;
      baseEach(collection, function(value, index, collection) {
        result = !!predicate(value, index, collection);
        return result;
      });
      return result;
    }

    /**
     * The base implementation of methods like `_.max` and `_.min` which accepts a
     * `comparator` to determine the extremum value.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The iteratee invoked per iteration.
     * @param {Function} comparator The comparator used to compare values.
     * @returns {*} Returns the extremum value.
     */
    function baseExtremum(array, iteratee, comparator) {
      var index = -1,
          length = array.length;

      while (++index < length) {
        var value = array[index],
            current = iteratee(value);

        if (current != null && (computed === undefined
              ? (current === current && !isSymbol(current))
              : comparator(current, computed)
            )) {
          var computed = current,
              result = value;
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.fill` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to fill.
     * @param {*} value The value to fill `array` with.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns `array`.
     */
    function baseFill(array, value, start, end) {
      var length = array.length;

      start = toInteger(start);
      if (start < 0) {
        start = -start > length ? 0 : (length + start);
      }
      end = (end === undefined || end > length) ? length : toInteger(end);
      if (end < 0) {
        end += length;
      }
      end = start > end ? 0 : toLength(end);
      while (start < end) {
        array[start++] = value;
      }
      return array;
    }

    /**
     * The base implementation of `_.filter` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     */
    function baseFilter(collection, predicate) {
      var result = [];
      baseEach(collection, function(value, index, collection) {
        if (predicate(value, index, collection)) {
          result.push(value);
        }
      });
      return result;
    }

    /**
     * The base implementation of `_.flatten` with support for restricting flattening.
     *
     * @private
     * @param {Array} array The array to flatten.
     * @param {number} depth The maximum recursion depth.
     * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
     * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
     * @param {Array} [result=[]] The initial result value.
     * @returns {Array} Returns the new flattened array.
     */
    function baseFlatten(array, depth, predicate, isStrict, result) {
      var index = -1,
          length = array.length;

      predicate || (predicate = isFlattenable);
      result || (result = []);

      while (++index < length) {
        var value = array[index];
        if (depth > 0 && predicate(value)) {
          if (depth > 1) {
            // Recursively flatten arrays (susceptible to call stack limits).
            baseFlatten(value, depth - 1, predicate, isStrict, result);
          } else {
            arrayPush(result, value);
          }
        } else if (!isStrict) {
          result[result.length] = value;
        }
      }
      return result;
    }

    /**
     * The base implementation of `baseForOwn` which iterates over `object`
     * properties returned by `keysFunc` and invokes `iteratee` for each property.
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */
    var baseFor = createBaseFor();

    /**
     * This function is like `baseFor` except that it iterates over properties
     * in the opposite order.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */
    var baseForRight = createBaseFor(true);

    /**
     * The base implementation of `_.forOwn` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */
    function baseForOwn(object, iteratee) {
      return object && baseFor(object, iteratee, keys);
    }

    /**
     * The base implementation of `_.forOwnRight` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */
    function baseForOwnRight(object, iteratee) {
      return object && baseForRight(object, iteratee, keys);
    }

    /**
     * The base implementation of `_.functions` which creates an array of
     * `object` function property names filtered from `props`.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Array} props The property names to filter.
     * @returns {Array} Returns the function names.
     */
    function baseFunctions(object, props) {
      return arrayFilter(props, function(key) {
        return isFunction(object[key]);
      });
    }

    /**
     * The base implementation of `_.get` without support for default values.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @returns {*} Returns the resolved value.
     */
    function baseGet(object, path) {
      path = castPath(path, object);

      var index = 0,
          length = path.length;

      while (object != null && index < length) {
        object = object[toKey(path[index++])];
      }
      return (index && index == length) ? object : undefined;
    }

    /**
     * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
     * `keysFunc` and `symbolsFunc` to get the enumerable property names and
     * symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @param {Function} symbolsFunc The function to get the symbols of `object`.
     * @returns {Array} Returns the array of property names and symbols.
     */
    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
      var result = keysFunc(object);
      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
    }

    /**
     * The base implementation of `getTag` without fallbacks for buggy environments.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */
    function baseGetTag(value) {
      if (value == null) {
        return value === undefined ? undefinedTag : nullTag;
      }
      return (symToStringTag && symToStringTag in Object(value))
        ? getRawTag(value)
        : objectToString(value);
    }

    /**
     * The base implementation of `_.gt` which doesn't coerce arguments.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than `other`,
     *  else `false`.
     */
    function baseGt(value, other) {
      return value > other;
    }

    /**
     * The base implementation of `_.has` without support for deep paths.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {Array|string} key The key to check.
     * @returns {boolean} Returns `true` if `key` exists, else `false`.
     */
    function baseHas(object, key) {
      return object != null && hasOwnProperty.call(object, key);
    }

    /**
     * The base implementation of `_.hasIn` without support for deep paths.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {Array|string} key The key to check.
     * @returns {boolean} Returns `true` if `key` exists, else `false`.
     */
    function baseHasIn(object, key) {
      return object != null && key in Object(object);
    }

    /**
     * The base implementation of `_.inRange` which doesn't coerce arguments.
     *
     * @private
     * @param {number} number The number to check.
     * @param {number} start The start of the range.
     * @param {number} end The end of the range.
     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
     */
    function baseInRange(number, start, end) {
      return number >= nativeMin(start, end) && number < nativeMax(start, end);
    }

    /**
     * The base implementation of methods like `_.intersection`, without support
     * for iteratee shorthands, that accepts an array of arrays to inspect.
     *
     * @private
     * @param {Array} arrays The arrays to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of shared values.
     */
    function baseIntersection(arrays, iteratee, comparator) {
      var includes = comparator ? arrayIncludesWith : arrayIncludes,
          length = arrays[0].length,
          othLength = arrays.length,
          othIndex = othLength,
          caches = Array(othLength),
          maxLength = Infinity,
          result = [];

      while (othIndex--) {
        var array = arrays[othIndex];
        if (othIndex && iteratee) {
          array = arrayMap(array, baseUnary(iteratee));
        }
        maxLength = nativeMin(array.length, maxLength);
        caches[othIndex] = !comparator && (iteratee || (length >= 120 && array.length >= 120))
          ? new SetCache(othIndex && array)
          : undefined;
      }
      array = arrays[0];

      var index = -1,
          seen = caches[0];

      outer:
      while (++index < length && result.length < maxLength) {
        var value = array[index],
            computed = iteratee ? iteratee(value) : value;

        value = (comparator || value !== 0) ? value : 0;
        if (!(seen
              ? cacheHas(seen, computed)
              : includes(result, computed, comparator)
            )) {
          othIndex = othLength;
          while (--othIndex) {
            var cache = caches[othIndex];
            if (!(cache
                  ? cacheHas(cache, computed)
                  : includes(arrays[othIndex], computed, comparator))
                ) {
              continue outer;
            }
          }
          if (seen) {
            seen.push(computed);
          }
          result.push(value);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.invert` and `_.invertBy` which inverts
     * `object` with values transformed by `iteratee` and set by `setter`.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} setter The function to set `accumulator` values.
     * @param {Function} iteratee The iteratee to transform values.
     * @param {Object} accumulator The initial inverted object.
     * @returns {Function} Returns `accumulator`.
     */
    function baseInverter(object, setter, iteratee, accumulator) {
      baseForOwn(object, function(value, key, object) {
        setter(accumulator, iteratee(value), key, object);
      });
      return accumulator;
    }

    /**
     * The base implementation of `_.invoke` without support for individual
     * method arguments.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the method to invoke.
     * @param {Array} args The arguments to invoke the method with.
     * @returns {*} Returns the result of the invoked method.
     */
    function baseInvoke(object, path, args) {
      path = castPath(path, object);
      object = parent(object, path);
      var func = object == null ? object : object[toKey(last(path))];
      return func == null ? undefined : apply(func, object, args);
    }

    /**
     * The base implementation of `_.isArguments`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     */
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag;
    }

    /**
     * The base implementation of `_.isArrayBuffer` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
     */
    function baseIsArrayBuffer(value) {
      return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
    }

    /**
     * The base implementation of `_.isDate` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
     */
    function baseIsDate(value) {
      return isObjectLike(value) && baseGetTag(value) == dateTag;
    }

    /**
     * The base implementation of `_.isEqual` which supports partial comparisons
     * and tracks traversed objects.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {boolean} bitmask The bitmask flags.
     *  1 - Unordered comparison
     *  2 - Partial comparison
     * @param {Function} [customizer] The function to customize comparisons.
     * @param {Object} [stack] Tracks traversed `value` and `other` objects.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     */
    function baseIsEqual(value, other, bitmask, customizer, stack) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
    }

    /**
     * A specialized version of `baseIsEqual` for arrays and objects which performs
     * deep comparisons and tracks traversed objects enabling objects with circular
     * references to be compared.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} [stack] Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
      var objIsArr = isArray(object),
          othIsArr = isArray(other),
          objTag = objIsArr ? arrayTag : getTag(object),
          othTag = othIsArr ? arrayTag : getTag(other);

      objTag = objTag == argsTag ? objectTag : objTag;
      othTag = othTag == argsTag ? objectTag : othTag;

      var objIsObj = objTag == objectTag,
          othIsObj = othTag == objectTag,
          isSameTag = objTag == othTag;

      if (isSameTag && isBuffer(object)) {
        if (!isBuffer(other)) {
          return false;
        }
        objIsArr = true;
        objIsObj = false;
      }
      if (isSameTag && !objIsObj) {
        stack || (stack = new Stack);
        return (objIsArr || isTypedArray(object))
          ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
          : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
      }
      if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
            othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object.value() : object,
              othUnwrapped = othIsWrapped ? other.value() : other;

          stack || (stack = new Stack);
          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack || (stack = new Stack);
      return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
    }

    /**
     * The base implementation of `_.isMap` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
     */
    function baseIsMap(value) {
      return isObjectLike(value) && getTag(value) == mapTag;
    }

    /**
     * The base implementation of `_.isMatch` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @param {Array} matchData The property names, values, and compare flags to match.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     */
    function baseIsMatch(object, source, matchData, customizer) {
      var index = matchData.length,
          length = index,
          noCustomizer = !customizer;

      if (object == null) {
        return !length;
      }
      object = Object(object);
      while (index--) {
        var data = matchData[index];
        if ((noCustomizer && data[2])
              ? data[1] !== object[data[0]]
              : !(data[0] in object)
            ) {
          return false;
        }
      }
      while (++index < length) {
        data = matchData[index];
        var key = data[0],
            objValue = object[key],
            srcValue = data[1];

        if (noCustomizer && data[2]) {
          if (objValue === undefined && !(key in object)) {
            return false;
          }
        } else {
          var stack = new Stack;
          if (customizer) {
            var result = customizer(objValue, srcValue, key, object, source, stack);
          }
          if (!(result === undefined
                ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)
                : result
              )) {
            return false;
          }
        }
      }
      return true;
    }

    /**
     * The base implementation of `_.isNative` without bad shim checks.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function,
     *  else `false`.
     */
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }

    /**
     * The base implementation of `_.isRegExp` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
     */
    function baseIsRegExp(value) {
      return isObjectLike(value) && baseGetTag(value) == regexpTag;
    }

    /**
     * The base implementation of `_.isSet` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
     */
    function baseIsSet(value) {
      return isObjectLike(value) && getTag(value) == setTag;
    }

    /**
     * The base implementation of `_.isTypedArray` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     */
    function baseIsTypedArray(value) {
      return isObjectLike(value) &&
        isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }

    /**
     * The base implementation of `_.iteratee`.
     *
     * @private
     * @param {*} [value=_.identity] The value to convert to an iteratee.
     * @returns {Function} Returns the iteratee.
     */
    function baseIteratee(value) {
      // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
      // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
      if (typeof value == 'function') {
        return value;
      }
      if (value == null) {
        return identity;
      }
      if (typeof value == 'object') {
        return isArray(value)
          ? baseMatchesProperty(value[0], value[1])
          : baseMatches(value);
      }
      return property(value);
    }

    /**
     * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != 'constructor') {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
    function baseKeysIn(object) {
      if (!isObject(object)) {
        return nativeKeysIn(object);
      }
      var isProto = isPrototype(object),
          result = [];

      for (var key in object) {
        if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.lt` which doesn't coerce arguments.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than `other`,
     *  else `false`.
     */
    function baseLt(value, other) {
      return value < other;
    }

    /**
     * The base implementation of `_.map` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     */
    function baseMap(collection, iteratee) {
      var index = -1,
          result = isArrayLike(collection) ? Array(collection.length) : [];

      baseEach(collection, function(value, key, collection) {
        result[++index] = iteratee(value, key, collection);
      });
      return result;
    }

    /**
     * The base implementation of `_.matches` which doesn't clone `source`.
     *
     * @private
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new spec function.
     */
    function baseMatches(source) {
      var matchData = getMatchData(source);
      if (matchData.length == 1 && matchData[0][2]) {
        return matchesStrictComparable(matchData[0][0], matchData[0][1]);
      }
      return function(object) {
        return object === source || baseIsMatch(object, source, matchData);
      };
    }

    /**
     * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
     *
     * @private
     * @param {string} path The path of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     */
    function baseMatchesProperty(path, srcValue) {
      if (isKey(path) && isStrictComparable(srcValue)) {
        return matchesStrictComparable(toKey(path), srcValue);
      }
      return function(object) {
        var objValue = get(object, path);
        return (objValue === undefined && objValue === srcValue)
          ? hasIn(object, path)
          : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
      };
    }

    /**
     * The base implementation of `_.merge` without support for multiple sources.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {number} srcIndex The index of `source`.
     * @param {Function} [customizer] The function to customize merged values.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     */
    function baseMerge(object, source, srcIndex, customizer, stack) {
      if (object === source) {
        return;
      }
      baseFor(source, function(srcValue, key) {
        stack || (stack = new Stack);
        if (isObject(srcValue)) {
          baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
        }
        else {
          var newValue = customizer
            ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)
            : undefined;

          if (newValue === undefined) {
            newValue = srcValue;
          }
          assignMergeValue(object, key, newValue);
        }
      }, keysIn);
    }

    /**
     * A specialized version of `baseMerge` for arrays and objects which performs
     * deep merges and tracks traversed objects enabling objects with circular
     * references to be merged.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {string} key The key of the value to merge.
     * @param {number} srcIndex The index of `source`.
     * @param {Function} mergeFunc The function to merge values.
     * @param {Function} [customizer] The function to customize assigned values.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     */
    function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
      var objValue = safeGet(object, key),
          srcValue = safeGet(source, key),
          stacked = stack.get(srcValue);

      if (stacked) {
        assignMergeValue(object, key, stacked);
        return;
      }
      var newValue = customizer
        ? customizer(objValue, srcValue, (key + ''), object, source, stack)
        : undefined;

      var isCommon = newValue === undefined;

      if (isCommon) {
        var isArr = isArray(srcValue),
            isBuff = !isArr && isBuffer(srcValue),
            isTyped = !isArr && !isBuff && isTypedArray(srcValue);

        newValue = srcValue;
        if (isArr || isBuff || isTyped) {
          if (isArray(objValue)) {
            newValue = objValue;
          }
          else if (isArrayLikeObject(objValue)) {
            newValue = copyArray(objValue);
          }
          else if (isBuff) {
            isCommon = false;
            newValue = cloneBuffer(srcValue, true);
          }
          else if (isTyped) {
            isCommon = false;
            newValue = cloneTypedArray(srcValue, true);
          }
          else {
            newValue = [];
          }
        }
        else if (isPlainObject(srcValue) || isArguments(srcValue)) {
          newValue = objValue;
          if (isArguments(objValue)) {
            newValue = toPlainObject(objValue);
          }
          else if (!isObject(objValue) || isFunction(objValue)) {
            newValue = initCloneObject(srcValue);
          }
        }
        else {
          isCommon = false;
        }
      }
      if (isCommon) {
        // Recursively merge objects and arrays (susceptible to call stack limits).
        stack.set(srcValue, newValue);
        mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
        stack['delete'](srcValue);
      }
      assignMergeValue(object, key, newValue);
    }

    /**
     * The base implementation of `_.nth` which doesn't coerce arguments.
     *
     * @private
     * @param {Array} array The array to query.
     * @param {number} n The index of the element to return.
     * @returns {*} Returns the nth element of `array`.
     */
    function baseNth(array, n) {
      var length = array.length;
      if (!length) {
        return;
      }
      n += n < 0 ? length : 0;
      return isIndex(n, length) ? array[n] : undefined;
    }

    /**
     * The base implementation of `_.orderBy` without param guards.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
     * @param {string[]} orders The sort orders of `iteratees`.
     * @returns {Array} Returns the new sorted array.
     */
    function baseOrderBy(collection, iteratees, orders) {
      if (iteratees.length) {
        iteratees = arrayMap(iteratees, function(iteratee) {
          if (isArray(iteratee)) {
            return function(value) {
              return baseGet(value, iteratee.length === 1 ? iteratee[0] : iteratee);
            }
          }
          return iteratee;
        });
      } else {
        iteratees = [identity];
      }

      var index = -1;
      iteratees = arrayMap(iteratees, baseUnary(getIteratee()));

      var result = baseMap(collection, function(value, key, collection) {
        var criteria = arrayMap(iteratees, function(iteratee) {
          return iteratee(value);
        });
        return { 'criteria': criteria, 'index': ++index, 'value': value };
      });

      return baseSortBy(result, function(object, other) {
        return compareMultiple(object, other, orders);
      });
    }

    /**
     * The base implementation of `_.pick` without support for individual
     * property identifiers.
     *
     * @private
     * @param {Object} object The source object.
     * @param {string[]} paths The property paths to pick.
     * @returns {Object} Returns the new object.
     */
    function basePick(object, paths) {
      return basePickBy(object, paths, function(value, path) {
        return hasIn(object, path);
      });
    }

    /**
     * The base implementation of  `_.pickBy` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The source object.
     * @param {string[]} paths The property paths to pick.
     * @param {Function} predicate The function invoked per property.
     * @returns {Object} Returns the new object.
     */
    function basePickBy(object, paths, predicate) {
      var index = -1,
          length = paths.length,
          result = {};

      while (++index < length) {
        var path = paths[index],
            value = baseGet(object, path);

        if (predicate(value, path)) {
          baseSet(result, castPath(path, object), value);
        }
      }
      return result;
    }

    /**
     * A specialized version of `baseProperty` which supports deep paths.
     *
     * @private
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new accessor function.
     */
    function basePropertyDeep(path) {
      return function(object) {
        return baseGet(object, path);
      };
    }

    /**
     * The base implementation of `_.pullAllBy` without support for iteratee
     * shorthands.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns `array`.
     */
    function basePullAll(array, values, iteratee, comparator) {
      var indexOf = comparator ? baseIndexOfWith : baseIndexOf,
          index = -1,
          length = values.length,
          seen = array;

      if (array === values) {
        values = copyArray(values);
      }
      if (iteratee) {
        seen = arrayMap(array, baseUnary(iteratee));
      }
      while (++index < length) {
        var fromIndex = 0,
            value = values[index],
            computed = iteratee ? iteratee(value) : value;

        while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1) {
          if (seen !== array) {
            splice.call(seen, fromIndex, 1);
          }
          splice.call(array, fromIndex, 1);
        }
      }
      return array;
    }

    /**
     * The base implementation of `_.pullAt` without support for individual
     * indexes or capturing the removed elements.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {number[]} indexes The indexes of elements to remove.
     * @returns {Array} Returns `array`.
     */
    function basePullAt(array, indexes) {
      var length = array ? indexes.length : 0,
          lastIndex = length - 1;

      while (length--) {
        var index = indexes[length];
        if (length == lastIndex || index !== previous) {
          var previous = index;
          if (isIndex(index)) {
            splice.call(array, index, 1);
          } else {
            baseUnset(array, index);
          }
        }
      }
      return array;
    }

    /**
     * The base implementation of `_.random` without support for returning
     * floating-point numbers.
     *
     * @private
     * @param {number} lower The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the random number.
     */
    function baseRandom(lower, upper) {
      return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
    }

    /**
     * The base implementation of `_.range` and `_.rangeRight` which doesn't
     * coerce arguments.
     *
     * @private
     * @param {number} start The start of the range.
     * @param {number} end The end of the range.
     * @param {number} step The value to increment or decrement by.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Array} Returns the range of numbers.
     */
    function baseRange(start, end, step, fromRight) {
      var index = -1,
          length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),
          result = Array(length);

      while (length--) {
        result[fromRight ? length : ++index] = start;
        start += step;
      }
      return result;
    }

    /**
     * The base implementation of `_.repeat` which doesn't coerce arguments.
     *
     * @private
     * @param {string} string The string to repeat.
     * @param {number} n The number of times to repeat the string.
     * @returns {string} Returns the repeated string.
     */
    function baseRepeat(string, n) {
      var result = '';
      if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
        return result;
      }
      // Leverage the exponentiation by squaring algorithm for a faster repeat.
      // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
      do {
        if (n % 2) {
          result += string;
        }
        n = nativeFloor(n / 2);
        if (n) {
          string += string;
        }
      } while (n);

      return result;
    }

    /**
     * The base implementation of `_.rest` which doesn't validate or coerce arguments.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @returns {Function} Returns the new function.
     */
    function baseRest(func, start) {
      return setToString(overRest(func, start, identity), func + '');
    }

    /**
     * The base implementation of `_.sample`.
     *
     * @private
     * @param {Array|Object} collection The collection to sample.
     * @returns {*} Returns the random element.
     */
    function baseSample(collection) {
      return arraySample(values(collection));
    }

    /**
     * The base implementation of `_.sampleSize` without param guards.
     *
     * @private
     * @param {Array|Object} collection The collection to sample.
     * @param {number} n The number of elements to sample.
     * @returns {Array} Returns the random elements.
     */
    function baseSampleSize(collection, n) {
      var array = values(collection);
      return shuffleSelf(array, baseClamp(n, 0, array.length));
    }

    /**
     * The base implementation of `_.set`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @param {Function} [customizer] The function to customize path creation.
     * @returns {Object} Returns `object`.
     */
    function baseSet(object, path, value, customizer) {
      if (!isObject(object)) {
        return object;
      }
      path = castPath(path, object);

      var index = -1,
          length = path.length,
          lastIndex = length - 1,
          nested = object;

      while (nested != null && ++index < length) {
        var key = toKey(path[index]),
            newValue = value;

        if (key === '__proto__' || key === 'constructor' || key === 'prototype') {
          return object;
        }

        if (index != lastIndex) {
          var objValue = nested[key];
          newValue = customizer ? customizer(objValue, key, nested) : undefined;
          if (newValue === undefined) {
            newValue = isObject(objValue)
              ? objValue
              : (isIndex(path[index + 1]) ? [] : {});
          }
        }
        assignValue(nested, key, newValue);
        nested = nested[key];
      }
      return object;
    }

    /**
     * The base implementation of `setData` without support for hot loop shorting.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */
    var baseSetData = !metaMap ? identity : function(func, data) {
      metaMap.set(func, data);
      return func;
    };

    /**
     * The base implementation of `setToString` without support for hot loop shorting.
     *
     * @private
     * @param {Function} func The function to modify.
     * @param {Function} string The `toString` result.
     * @returns {Function} Returns `func`.
     */
    var baseSetToString = !defineProperty ? identity : function(func, string) {
      return defineProperty(func, 'toString', {
        'configurable': true,
        'enumerable': false,
        'value': constant(string),
        'writable': true
      });
    };

    /**
     * The base implementation of `_.shuffle`.
     *
     * @private
     * @param {Array|Object} collection The collection to shuffle.
     * @returns {Array} Returns the new shuffled array.
     */
    function baseShuffle(collection) {
      return shuffleSelf(values(collection));
    }

    /**
     * The base implementation of `_.slice` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */
    function baseSlice(array, start, end) {
      var index = -1,
          length = array.length;

      if (start < 0) {
        start = -start > length ? 0 : (length + start);
      }
      end = end > length ? length : end;
      if (end < 0) {
        end += length;
      }
      length = start > end ? 0 : ((end - start) >>> 0);
      start >>>= 0;

      var result = Array(length);
      while (++index < length) {
        result[index] = array[index + start];
      }
      return result;
    }

    /**
     * The base implementation of `_.some` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     */
    function baseSome(collection, predicate) {
      var result;

      baseEach(collection, function(value, index, collection) {
        result = predicate(value, index, collection);
        return !result;
      });
      return !!result;
    }

    /**
     * The base implementation of `_.sortedIndex` and `_.sortedLastIndex` which
     * performs a binary search of `array` to determine the index at which `value`
     * should be inserted into `array` in order to maintain its sort order.
     *
     * @private
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {boolean} [retHighest] Specify returning the highest qualified index.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     */
    function baseSortedIndex(array, value, retHighest) {
      var low = 0,
          high = array == null ? low : array.length;

      if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
        while (low < high) {
          var mid = (low + high) >>> 1,
              computed = array[mid];

          if (computed !== null && !isSymbol(computed) &&
              (retHighest ? (computed <= value) : (computed < value))) {
            low = mid + 1;
          } else {
            high = mid;
          }
        }
        return high;
      }
      return baseSortedIndexBy(array, value, identity, retHighest);
    }

    /**
     * The base implementation of `_.sortedIndexBy` and `_.sortedLastIndexBy`
     * which invokes `iteratee` for `value` and each element of `array` to compute
     * their sort ranking. The iteratee is invoked with one argument; (value).
     *
     * @private
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} iteratee The iteratee invoked per element.
     * @param {boolean} [retHighest] Specify returning the highest qualified index.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     */
    function baseSortedIndexBy(array, value, iteratee, retHighest) {
      var low = 0,
          high = array == null ? 0 : array.length;
      if (high === 0) {
        return 0;
      }

      value = iteratee(value);
      var valIsNaN = value !== value,
          valIsNull = value === null,
          valIsSymbol = isSymbol(value),
          valIsUndefined = value === undefined;

      while (low < high) {
        var mid = nativeFloor((low + high) / 2),
            computed = iteratee(array[mid]),
            othIsDefined = computed !== undefined,
            othIsNull = computed === null,
            othIsReflexive = computed === computed,
            othIsSymbol = isSymbol(computed);

        if (valIsNaN) {
          var setLow = retHighest || othIsReflexive;
        } else if (valIsUndefined) {
          setLow = othIsReflexive && (retHighest || othIsDefined);
        } else if (valIsNull) {
          setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
        } else if (valIsSymbol) {
          setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
        } else if (othIsNull || othIsSymbol) {
          setLow = false;
        } else {
          setLow = retHighest ? (computed <= value) : (computed < value);
        }
        if (setLow) {
          low = mid + 1;
        } else {
          high = mid;
        }
      }
      return nativeMin(high, MAX_ARRAY_INDEX);
    }

    /**
     * The base implementation of `_.sortedUniq` and `_.sortedUniqBy` without
     * support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     */
    function baseSortedUniq(array, iteratee) {
      var index = -1,
          length = array.length,
          resIndex = 0,
          result = [];

      while (++index < length) {
        var value = array[index],
            computed = iteratee ? iteratee(value) : value;

        if (!index || !eq(computed, seen)) {
          var seen = computed;
          result[resIndex++] = value === 0 ? 0 : value;
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.toNumber` which doesn't ensure correct
     * conversions of binary, hexadecimal, or octal string values.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {number} Returns the number.
     */
    function baseToNumber(value) {
      if (typeof value == 'number') {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      return +value;
    }

    /**
     * The base implementation of `_.toString` which doesn't convert nullish
     * values to empty strings.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {string} Returns the string.
     */
    function baseToString(value) {
      // Exit early for strings to avoid a performance hit in some environments.
      if (typeof value == 'string') {
        return value;
      }
      if (isArray(value)) {
        // Recursively convert values (susceptible to call stack limits).
        return arrayMap(value, baseToString) + '';
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : '';
      }
      var result = (value + '');
      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
    }

    /**
     * The base implementation of `_.uniqBy` without support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     */
    function baseUniq(array, iteratee, comparator) {
      var index = -1,
          includes = arrayIncludes,
          length = array.length,
          isCommon = true,
          result = [],
          seen = result;

      if (comparator) {
        isCommon = false;
        includes = arrayIncludesWith;
      }
      else if (length >= LARGE_ARRAY_SIZE) {
        var set = iteratee ? null : createSet(array);
        if (set) {
          return setToArray(set);
        }
        isCommon = false;
        includes = cacheHas;
        seen = new SetCache;
      }
      else {
        seen = iteratee ? [] : result;
      }
      outer:
      while (++index < length) {
        var value = array[index],
            computed = iteratee ? iteratee(value) : value;

        value = (comparator || value !== 0) ? value : 0;
        if (isCommon && computed === computed) {
          var seenIndex = seen.length;
          while (seenIndex--) {
            if (seen[seenIndex] === computed) {
              continue outer;
            }
          }
          if (iteratee) {
            seen.push(computed);
          }
          result.push(value);
        }
        else if (!includes(seen, computed, comparator)) {
          if (seen !== result) {
            seen.push(computed);
          }
          result.push(value);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.unset`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The property path to unset.
     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
     */
    function baseUnset(object, path) {
      path = castPath(path, object);
      object = parent(object, path);
      return object == null || delete object[toKey(last(path))];
    }

    /**
     * The base implementation of `_.update`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to update.
     * @param {Function} updater The function to produce the updated value.
     * @param {Function} [customizer] The function to customize path creation.
     * @returns {Object} Returns `object`.
     */
    function baseUpdate(object, path, updater, customizer) {
      return baseSet(object, path, updater(baseGet(object, path)), customizer);
    }

    /**
     * The base implementation of methods like `_.dropWhile` and `_.takeWhile`
     * without support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to query.
     * @param {Function} predicate The function invoked per iteration.
     * @param {boolean} [isDrop] Specify dropping elements instead of taking them.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Array} Returns the slice of `array`.
     */
    function baseWhile(array, predicate, isDrop, fromRight) {
      var length = array.length,
          index = fromRight ? length : -1;

      while ((fromRight ? index-- : ++index < length) &&
        predicate(array[index], index, array)) {}

      return isDrop
        ? baseSlice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length))
        : baseSlice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index));
    }

    /**
     * The base implementation of `wrapperValue` which returns the result of
     * performing a sequence of actions on the unwrapped `value`, where each
     * successive action is supplied the return value of the previous.
     *
     * @private
     * @param {*} value The unwrapped value.
     * @param {Array} actions Actions to perform to resolve the unwrapped value.
     * @returns {*} Returns the resolved value.
     */
    function baseWrapperValue(value, actions) {
      var result = value;
      if (result instanceof LazyWrapper) {
        result = result.value();
      }
      return arrayReduce(actions, function(result, action) {
        return action.func.apply(action.thisArg, arrayPush([result], action.args));
      }, result);
    }

    /**
     * The base implementation of methods like `_.xor`, without support for
     * iteratee shorthands, that accepts an array of arrays to inspect.
     *
     * @private
     * @param {Array} arrays The arrays to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of values.
     */
    function baseXor(arrays, iteratee, comparator) {
      var length = arrays.length;
      if (length < 2) {
        return length ? baseUniq(arrays[0]) : [];
      }
      var index = -1,
          result = Array(length);

      while (++index < length) {
        var array = arrays[index],
            othIndex = -1;

        while (++othIndex < length) {
          if (othIndex != index) {
            result[index] = baseDifference(result[index] || array, arrays[othIndex], iteratee, comparator);
          }
        }
      }
      return baseUniq(baseFlatten(result, 1), iteratee, comparator);
    }

    /**
     * This base implementation of `_.zipObject` which assigns values using `assignFunc`.
     *
     * @private
     * @param {Array} props The property identifiers.
     * @param {Array} values The property values.
     * @param {Function} assignFunc The function to assign values.
     * @returns {Object} Returns the new object.
     */
    function baseZipObject(props, values, assignFunc) {
      var index = -1,
          length = props.length,
          valsLength = values.length,
          result = {};

      while (++index < length) {
        var value = index < valsLength ? values[index] : undefined;
        assignFunc(result, props[index], value);
      }
      return result;
    }

    /**
     * Casts `value` to an empty array if it's not an array like object.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {Array|Object} Returns the cast array-like object.
     */
    function castArrayLikeObject(value) {
      return isArrayLikeObject(value) ? value : [];
    }

    /**
     * Casts `value` to `identity` if it's not a function.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {Function} Returns cast function.
     */
    function castFunction(value) {
      return typeof value == 'function' ? value : identity;
    }

    /**
     * Casts `value` to a path array if it's not one.
     *
     * @private
     * @param {*} value The value to inspect.
     * @param {Object} [object] The object to query keys on.
     * @returns {Array} Returns the cast property path array.
     */
    function castPath(value, object) {
      if (isArray(value)) {
        return value;
      }
      return isKey(value, object) ? [value] : stringToPath(toString(value));
    }

    /**
     * A `baseRest` alias which can be replaced with `identity` by module
     * replacement plugins.
     *
     * @private
     * @type {Function}
     * @param {Function} func The function to apply a rest parameter to.
     * @returns {Function} Returns the new function.
     */
    var castRest = baseRest;

    /**
     * Casts `array` to a slice if it's needed.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {number} start The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the cast slice.
     */
    function castSlice(array, start, end) {
      var length = array.length;
      end = end === undefined ? length : end;
      return (!start && end >= length) ? array : baseSlice(array, start, end);
    }

    /**
     * A simple wrapper around the global [`clearTimeout`](https://mdn.io/clearTimeout).
     *
     * @private
     * @param {number|Object} id The timer id or timeout object of the timer to clear.
     */
    var clearTimeout = ctxClearTimeout || function(id) {
      return root.clearTimeout(id);
    };

    /**
     * Creates a clone of  `buffer`.
     *
     * @private
     * @param {Buffer} buffer The buffer to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Buffer} Returns the cloned buffer.
     */
    function cloneBuffer(buffer, isDeep) {
      if (isDeep) {
        return buffer.slice();
      }
      var length = buffer.length,
          result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

      buffer.copy(result);
      return result;
    }

    /**
     * Creates a clone of `arrayBuffer`.
     *
     * @private
     * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
     * @returns {ArrayBuffer} Returns the cloned array buffer.
     */
    function cloneArrayBuffer(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array(result).set(new Uint8Array(arrayBuffer));
      return result;
    }

    /**
     * Creates a clone of `dataView`.
     *
     * @private
     * @param {Object} dataView The data view to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned data view.
     */
    function cloneDataView(dataView, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
    }

    /**
     * Creates a clone of `regexp`.
     *
     * @private
     * @param {Object} regexp The regexp to clone.
     * @returns {Object} Returns the cloned regexp.
     */
    function cloneRegExp(regexp) {
      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
      result.lastIndex = regexp.lastIndex;
      return result;
    }

    /**
     * Creates a clone of the `symbol` object.
     *
     * @private
     * @param {Object} symbol The symbol object to clone.
     * @returns {Object} Returns the cloned symbol object.
     */
    function cloneSymbol(symbol) {
      return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
    }

    /**
     * Creates a clone of `typedArray`.
     *
     * @private
     * @param {Object} typedArray The typed array to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned typed array.
     */
    function cloneTypedArray(typedArray, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
    }

    /**
     * Compares values to sort them in ascending order.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {number} Returns the sort order indicator for `value`.
     */
    function compareAscending(value, other) {
      if (value !== other) {
        var valIsDefined = value !== undefined,
            valIsNull = value === null,
            valIsReflexive = value === value,
            valIsSymbol = isSymbol(value);

        var othIsDefined = other !== undefined,
            othIsNull = other === null,
            othIsReflexive = other === other,
            othIsSymbol = isSymbol(other);

        if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||
            (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||
            (valIsNull && othIsDefined && othIsReflexive) ||
            (!valIsDefined && othIsReflexive) ||
            !valIsReflexive) {
          return 1;
        }
        if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||
            (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||
            (othIsNull && valIsDefined && valIsReflexive) ||
            (!othIsDefined && valIsReflexive) ||
            !othIsReflexive) {
          return -1;
        }
      }
      return 0;
    }

    /**
     * Used by `_.orderBy` to compare multiple properties of a value to another
     * and stable sort them.
     *
     * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
     * specify an order of "desc" for descending or "asc" for ascending sort order
     * of corresponding values.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {boolean[]|string[]} orders The order to sort by for each property.
     * @returns {number} Returns the sort order indicator for `object`.
     */
    function compareMultiple(object, other, orders) {
      var index = -1,
          objCriteria = object.criteria,
          othCriteria = other.criteria,
          length = objCriteria.length,
          ordersLength = orders.length;

      while (++index < length) {
        var result = compareAscending(objCriteria[index], othCriteria[index]);
        if (result) {
          if (index >= ordersLength) {
            return result;
          }
          var order = orders[index];
          return result * (order == 'desc' ? -1 : 1);
        }
      }
      // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
      // that causes it, under certain circumstances, to provide the same value for
      // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
      // for more details.
      //
      // This also ensures a stable sort in V8 and other engines.
      // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.
      return object.index - other.index;
    }

    /**
     * Creates an array that is the composition of partially applied arguments,
     * placeholders, and provided arguments into a single array of arguments.
     *
     * @private
     * @param {Array} args The provided arguments.
     * @param {Array} partials The arguments to prepend to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @params {boolean} [isCurried] Specify composing for a curried function.
     * @returns {Array} Returns the new array of composed arguments.
     */
    function composeArgs(args, partials, holders, isCurried) {
      var argsIndex = -1,
          argsLength = args.length,
          holdersLength = holders.length,
          leftIndex = -1,
          leftLength = partials.length,
          rangeLength = nativeMax(argsLength - holdersLength, 0),
          result = Array(leftLength + rangeLength),
          isUncurried = !isCurried;

      while (++leftIndex < leftLength) {
        result[leftIndex] = partials[leftIndex];
      }
      while (++argsIndex < holdersLength) {
        if (isUncurried || argsIndex < argsLength) {
          result[holders[argsIndex]] = args[argsIndex];
        }
      }
      while (rangeLength--) {
        result[leftIndex++] = args[argsIndex++];
      }
      return result;
    }

    /**
     * This function is like `composeArgs` except that the arguments composition
     * is tailored for `_.partialRight`.
     *
     * @private
     * @param {Array} args The provided arguments.
     * @param {Array} partials The arguments to append to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @params {boolean} [isCurried] Specify composing for a curried function.
     * @returns {Array} Returns the new array of composed arguments.
     */
    function composeArgsRight(args, partials, holders, isCurried) {
      var argsIndex = -1,
          argsLength = args.length,
          holdersIndex = -1,
          holdersLength = holders.length,
          rightIndex = -1,
          rightLength = partials.length,
          rangeLength = nativeMax(argsLength - holdersLength, 0),
          result = Array(rangeLength + rightLength),
          isUncurried = !isCurried;

      while (++argsIndex < rangeLength) {
        result[argsIndex] = args[argsIndex];
      }
      var offset = argsIndex;
      while (++rightIndex < rightLength) {
        result[offset + rightIndex] = partials[rightIndex];
      }
      while (++holdersIndex < holdersLength) {
        if (isUncurried || argsIndex < argsLength) {
          result[offset + holders[holdersIndex]] = args[argsIndex++];
        }
      }
      return result;
    }

    /**
     * Copies the values of `source` to `array`.
     *
     * @private
     * @param {Array} source The array to copy values from.
     * @param {Array} [array=[]] The array to copy values to.
     * @returns {Array} Returns `array`.
     */
    function copyArray(source, array) {
      var index = -1,
          length = source.length;

      array || (array = Array(length));
      while (++index < length) {
        array[index] = source[index];
      }
      return array;
    }

    /**
     * Copies properties of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy properties from.
     * @param {Array} props The property identifiers to copy.
     * @param {Object} [object={}] The object to copy properties to.
     * @param {Function} [customizer] The function to customize copied values.
     * @returns {Object} Returns `object`.
     */
    function copyObject(source, props, object, customizer) {
      var isNew = !object;
      object || (object = {});

      var index = -1,
          length = props.length;

      while (++index < length) {
        var key = props[index];

        var newValue = customizer
          ? customizer(object[key], source[key], key, object, source)
          : undefined;

        if (newValue === undefined) {
          newValue = source[key];
        }
        if (isNew) {
          baseAssignValue(object, key, newValue);
        } else {
          assignValue(object, key, newValue);
        }
      }
      return object;
    }

    /**
     * Copies own symbols of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy symbols from.
     * @param {Object} [object={}] The object to copy symbols to.
     * @returns {Object} Returns `object`.
     */
    function copySymbols(source, object) {
      return copyObject(source, getSymbols(source), object);
    }

    /**
     * Copies own and inherited symbols of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy symbols from.
     * @param {Object} [object={}] The object to copy symbols to.
     * @returns {Object} Returns `object`.
     */
    function copySymbolsIn(source, object) {
      return copyObject(source, getSymbolsIn(source), object);
    }

    /**
     * Creates a function like `_.groupBy`.
     *
     * @private
     * @param {Function} setter The function to set accumulator values.
     * @param {Function} [initializer] The accumulator object initializer.
     * @returns {Function} Returns the new aggregator function.
     */
    function createAggregator(setter, initializer) {
      return function(collection, iteratee) {
        var func = isArray(collection) ? arrayAggregator : baseAggregator,
            accumulator = initializer ? initializer() : {};

        return func(collection, setter, getIteratee(iteratee, 2), accumulator);
      };
    }

    /**
     * Creates a function like `_.assign`.
     *
     * @private
     * @param {Function} assigner The function to assign values.
     * @returns {Function} Returns the new assigner function.
     */
    function createAssigner(assigner) {
      return baseRest(function(object, sources) {
        var index = -1,
            length = sources.length,
            customizer = length > 1 ? sources[length - 1] : undefined,
            guard = length > 2 ? sources[2] : undefined;

        customizer = (assigner.length > 3 && typeof customizer == 'function')
          ? (length--, customizer)
          : undefined;

        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          customizer = length < 3 ? undefined : customizer;
          length = 1;
        }
        object = Object(object);
        while (++index < length) {
          var source = sources[index];
          if (source) {
            assigner(object, source, index, customizer);
          }
        }
        return object;
      });
    }

    /**
     * Creates a `baseEach` or `baseEachRight` function.
     *
     * @private
     * @param {Function} eachFunc The function to iterate over a collection.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */
    function createBaseEach(eachFunc, fromRight) {
      return function(collection, iteratee) {
        if (collection == null) {
          return collection;
        }
        if (!isArrayLike(collection)) {
          return eachFunc(collection, iteratee);
        }
        var length = collection.length,
            index = fromRight ? length : -1,
            iterable = Object(collection);

        while ((fromRight ? index-- : ++index < length)) {
          if (iteratee(iterable[index], index, iterable) === false) {
            break;
          }
        }
        return collection;
      };
    }

    /**
     * Creates a base function for methods like `_.forIn` and `_.forOwn`.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */
    function createBaseFor(fromRight) {
      return function(object, iteratee, keysFunc) {
        var index = -1,
            iterable = Object(object),
            props = keysFunc(object),
            length = props.length;

        while (length--) {
          var key = props[fromRight ? length : ++index];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object;
      };
    }

    /**
     * Creates a function that wraps `func` to invoke it with the optional `this`
     * binding of `thisArg`.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createBind(func, bitmask, thisArg) {
      var isBind = bitmask & WRAP_BIND_FLAG,
          Ctor = createCtor(func);

      function wrapper() {
        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
        return fn.apply(isBind ? thisArg : this, arguments);
      }
      return wrapper;
    }

    /**
     * Creates a function like `_.lowerFirst`.
     *
     * @private
     * @param {string} methodName The name of the `String` case method to use.
     * @returns {Function} Returns the new case function.
     */
    function createCaseFirst(methodName) {
      return function(string) {
        string = toString(string);

        var strSymbols = hasUnicode(string)
          ? stringToArray(string)
          : undefined;

        var chr = strSymbols
          ? strSymbols[0]
          : string.charAt(0);

        var trailing = strSymbols
          ? castSlice(strSymbols, 1).join('')
          : string.slice(1);

        return chr[methodName]() + trailing;
      };
    }

    /**
     * Creates a function like `_.camelCase`.
     *
     * @private
     * @param {Function} callback The function to combine each word.
     * @returns {Function} Returns the new compounder function.
     */
    function createCompounder(callback) {
      return function(string) {
        return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');
      };
    }

    /**
     * Creates a function that produces an instance of `Ctor` regardless of
     * whether it was invoked as part of a `new` expression or by `call` or `apply`.
     *
     * @private
     * @param {Function} Ctor The constructor to wrap.
     * @returns {Function} Returns the new wrapped function.
     */
    function createCtor(Ctor) {
      return function() {
        // Use a `switch` statement to work with class constructors. See
        // http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
        // for more details.
        var args = arguments;
        switch (args.length) {
          case 0: return new Ctor;
          case 1: return new Ctor(args[0]);
          case 2: return new Ctor(args[0], args[1]);
          case 3: return new Ctor(args[0], args[1], args[2]);
          case 4: return new Ctor(args[0], args[1], args[2], args[3]);
          case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);
          case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
          case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
        }
        var thisBinding = baseCreate(Ctor.prototype),
            result = Ctor.apply(thisBinding, args);

        // Mimic the constructor's `return` behavior.
        // See https://es5.github.io/#x13.2.2 for more details.
        return isObject(result) ? result : thisBinding;
      };
    }

    /**
     * Creates a function that wraps `func` to enable currying.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {number} arity The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createCurry(func, bitmask, arity) {
      var Ctor = createCtor(func);

      function wrapper() {
        var length = arguments.length,
            args = Array(length),
            index = length,
            placeholder = getHolder(wrapper);

        while (index--) {
          args[index] = arguments[index];
        }
        var holders = (length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder)
          ? []
          : replaceHolders(args, placeholder);

        length -= holders.length;
        if (length < arity) {
          return createRecurry(
            func, bitmask, createHybrid, wrapper.placeholder, undefined,
            args, holders, undefined, undefined, arity - length);
        }
        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
        return apply(fn, this, args);
      }
      return wrapper;
    }

    /**
     * Creates a `_.find` or `_.findLast` function.
     *
     * @private
     * @param {Function} findIndexFunc The function to find the collection index.
     * @returns {Function} Returns the new find function.
     */
    function createFind(findIndexFunc) {
      return function(collection, predicate, fromIndex) {
        var iterable = Object(collection);
        if (!isArrayLike(collection)) {
          var iteratee = getIteratee(predicate, 3);
          collection = keys(collection);
          predicate = function(key) { return iteratee(iterable[key], key, iterable); };
        }
        var index = findIndexFunc(collection, predicate, fromIndex);
        return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;
      };
    }

    /**
     * Creates a `_.flow` or `_.flowRight` function.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new flow function.
     */
    function createFlow(fromRight) {
      return flatRest(function(funcs) {
        var length = funcs.length,
            index = length,
            prereq = LodashWrapper.prototype.thru;

        if (fromRight) {
          funcs.reverse();
        }
        while (index--) {
          var func = funcs[index];
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          if (prereq && !wrapper && getFuncName(func) == 'wrapper') {
            var wrapper = new LodashWrapper([], true);
          }
        }
        index = wrapper ? index : length;
        while (++index < length) {
          func = funcs[index];

          var funcName = getFuncName(func),
              data = funcName == 'wrapper' ? getData(func) : undefined;

          if (data && isLaziable(data[0]) &&
                data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) &&
                !data[4].length && data[9] == 1
              ) {
            wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
          } else {
            wrapper = (func.length == 1 && isLaziable(func))
              ? wrapper[funcName]()
              : wrapper.thru(func);
          }
        }
        return function() {
          var args = arguments,
              value = args[0];

          if (wrapper && args.length == 1 && isArray(value)) {
            return wrapper.plant(value).value();
          }
          var index = 0,
              result = length ? funcs[index].apply(this, args) : value;

          while (++index < length) {
            result = funcs[index].call(this, result);
          }
          return result;
        };
      });
    }

    /**
     * Creates a function that wraps `func` to invoke it with optional `this`
     * binding of `thisArg`, partial application, and currying.
     *
     * @private
     * @param {Function|string} func The function or method name to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to prepend to those provided to
     *  the new function.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [partialsRight] The arguments to append to those provided
     *  to the new function.
     * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
      var isAry = bitmask & WRAP_ARY_FLAG,
          isBind = bitmask & WRAP_BIND_FLAG,
          isBindKey = bitmask & WRAP_BIND_KEY_FLAG,
          isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG),
          isFlip = bitmask & WRAP_FLIP_FLAG,
          Ctor = isBindKey ? undefined : createCtor(func);

      function wrapper() {
        var length = arguments.length,
            args = Array(length),
            index = length;

        while (index--) {
          args[index] = arguments[index];
        }
        if (isCurried) {
          var placeholder = getHolder(wrapper),
              holdersCount = countHolders(args, placeholder);
        }
        if (partials) {
          args = composeArgs(args, partials, holders, isCurried);
        }
        if (partialsRight) {
          args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
        }
        length -= holdersCount;
        if (isCurried && length < arity) {
          var newHolders = replaceHolders(args, placeholder);
          return createRecurry(
            func, bitmask, createHybrid, wrapper.placeholder, thisArg,
            args, newHolders, argPos, ary, arity - length
          );
        }
        var thisBinding = isBind ? thisArg : this,
            fn = isBindKey ? thisBinding[func] : func;

        length = args.length;
        if (argPos) {
          args = reorder(args, argPos);
        } else if (isFlip && length > 1) {
          args.reverse();
        }
        if (isAry && ary < length) {
          args.length = ary;
        }
        if (this && this !== root && this instanceof wrapper) {
          fn = Ctor || createCtor(fn);
        }
        return fn.apply(thisBinding, args);
      }
      return wrapper;
    }

    /**
     * Creates a function like `_.invertBy`.
     *
     * @private
     * @param {Function} setter The function to set accumulator values.
     * @param {Function} toIteratee The function to resolve iteratees.
     * @returns {Function} Returns the new inverter function.
     */
    function createInverter(setter, toIteratee) {
      return function(object, iteratee) {
        return baseInverter(object, setter, toIteratee(iteratee), {});
      };
    }

    /**
     * Creates a function that performs a mathematical operation on two values.
     *
     * @private
     * @param {Function} operator The function to perform the operation.
     * @param {number} [defaultValue] The value used for `undefined` arguments.
     * @returns {Function} Returns the new mathematical operation function.
     */
    function createMathOperation(operator, defaultValue) {
      return function(value, other) {
        var result;
        if (value === undefined && other === undefined) {
          return defaultValue;
        }
        if (value !== undefined) {
          result = value;
        }
        if (other !== undefined) {
          if (result === undefined) {
            return other;
          }
          if (typeof value == 'string' || typeof other == 'string') {
            value = baseToString(value);
            other = baseToString(other);
          } else {
            value = baseToNumber(value);
            other = baseToNumber(other);
          }
          result = operator(value, other);
        }
        return result;
      };
    }

    /**
     * Creates a function like `_.over`.
     *
     * @private
     * @param {Function} arrayFunc The function to iterate over iteratees.
     * @returns {Function} Returns the new over function.
     */
    function createOver(arrayFunc) {
      return flatRest(function(iteratees) {
        iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
        return baseRest(function(args) {
          var thisArg = this;
          return arrayFunc(iteratees, function(iteratee) {
            return apply(iteratee, thisArg, args);
          });
        });
      });
    }

    /**
     * Creates the padding for `string` based on `length`. The `chars` string
     * is truncated if the number of characters exceeds `length`.
     *
     * @private
     * @param {number} length The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padding for `string`.
     */
    function createPadding(length, chars) {
      chars = chars === undefined ? ' ' : baseToString(chars);

      var charsLength = chars.length;
      if (charsLength < 2) {
        return charsLength ? baseRepeat(chars, length) : chars;
      }
      var result = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
      return hasUnicode(chars)
        ? castSlice(stringToArray(result), 0, length).join('')
        : result.slice(0, length);
    }

    /**
     * Creates a function that wraps `func` to invoke it with the `this` binding
     * of `thisArg` and `partials` prepended to the arguments it receives.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {Array} partials The arguments to prepend to those provided to
     *  the new function.
     * @returns {Function} Returns the new wrapped function.
     */
    function createPartial(func, bitmask, thisArg, partials) {
      var isBind = bitmask & WRAP_BIND_FLAG,
          Ctor = createCtor(func);

      function wrapper() {
        var argsIndex = -1,
            argsLength = arguments.length,
            leftIndex = -1,
            leftLength = partials.length,
            args = Array(leftLength + argsLength),
            fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;

        while (++leftIndex < leftLength) {
          args[leftIndex] = partials[leftIndex];
        }
        while (argsLength--) {
          args[leftIndex++] = arguments[++argsIndex];
        }
        return apply(fn, isBind ? thisArg : this, args);
      }
      return wrapper;
    }

    /**
     * Creates a `_.range` or `_.rangeRight` function.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new range function.
     */
    function createRange(fromRight) {
      return function(start, end, step) {
        if (step && typeof step != 'number' && isIterateeCall(start, end, step)) {
          end = step = undefined;
        }
        // Ensure the sign of `-0` is preserved.
        start = toFinite(start);
        if (end === undefined) {
          end = start;
          start = 0;
        } else {
          end = toFinite(end);
        }
        step = step === undefined ? (start < end ? 1 : -1) : toFinite(step);
        return baseRange(start, end, step, fromRight);
      };
    }

    /**
     * Creates a function that performs a relational operation on two values.
     *
     * @private
     * @param {Function} operator The function to perform the operation.
     * @returns {Function} Returns the new relational operation function.
     */
    function createRelationalOperation(operator) {
      return function(value, other) {
        if (!(typeof value == 'string' && typeof other == 'string')) {
          value = toNumber(value);
          other = toNumber(other);
        }
        return operator(value, other);
      };
    }

    /**
     * Creates a function that wraps `func` to continue currying.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {Function} wrapFunc The function to create the `func` wrapper.
     * @param {*} placeholder The placeholder value.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to prepend to those provided to
     *  the new function.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {
      var isCurry = bitmask & WRAP_CURRY_FLAG,
          newHolders = isCurry ? holders : undefined,
          newHoldersRight = isCurry ? undefined : holders,
          newPartials = isCurry ? partials : undefined,
          newPartialsRight = isCurry ? undefined : partials;

      bitmask |= (isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG);
      bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);

      if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
        bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
      }
      var newData = [
        func, bitmask, thisArg, newPartials, newHolders, newPartialsRight,
        newHoldersRight, argPos, ary, arity
      ];

      var result = wrapFunc.apply(undefined, newData);
      if (isLaziable(func)) {
        setData(result, newData);
      }
      result.placeholder = placeholder;
      return setWrapToString(result, func, bitmask);
    }

    /**
     * Creates a function like `_.round`.
     *
     * @private
     * @param {string} methodName The name of the `Math` method to use when rounding.
     * @returns {Function} Returns the new round function.
     */
    function createRound(methodName) {
      var func = Math[methodName];
      return function(number, precision) {
        number = toNumber(number);
        precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
        if (precision && nativeIsFinite(number)) {
          // Shift with exponential notation to avoid floating-point issues.
          // See [MDN](https://mdn.io/round#Examples) for more details.
          var pair = (toString(number) + 'e').split('e'),
              value = func(pair[0] + 'e' + (+pair[1] + precision));

          pair = (toString(value) + 'e').split('e');
          return +(pair[0] + 'e' + (+pair[1] - precision));
        }
        return func(number);
      };
    }

    /**
     * Creates a set object of `values`.
     *
     * @private
     * @param {Array} values The values to add to the set.
     * @returns {Object} Returns the new set.
     */
    var createSet = !(Set && (1 / setToArray(new Set([,-0]))[1]) == INFINITY) ? noop : function(values) {
      return new Set(values);
    };

    /**
     * Creates a `_.toPairs` or `_.toPairsIn` function.
     *
     * @private
     * @param {Function} keysFunc The function to get the keys of a given object.
     * @returns {Function} Returns the new pairs function.
     */
    function createToPairs(keysFunc) {
      return function(object) {
        var tag = getTag(object);
        if (tag == mapTag) {
          return mapToArray(object);
        }
        if (tag == setTag) {
          return setToPairs(object);
        }
        return baseToPairs(object, keysFunc(object));
      };
    }

    /**
     * Creates a function that either curries or invokes `func` with optional
     * `this` binding and partially applied arguments.
     *
     * @private
     * @param {Function|string} func The function or method name to wrap.
     * @param {number} bitmask The bitmask flags.
     *    1 - `_.bind`
     *    2 - `_.bindKey`
     *    4 - `_.curry` or `_.curryRight` of a bound function
     *    8 - `_.curry`
     *   16 - `_.curryRight`
     *   32 - `_.partial`
     *   64 - `_.partialRight`
     *  128 - `_.rearg`
     *  256 - `_.ary`
     *  512 - `_.flip`
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to be partially applied.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
      var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
      if (!isBindKey && typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var length = partials ? partials.length : 0;
      if (!length) {
        bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
        partials = holders = undefined;
      }
      ary = ary === undefined ? ary : nativeMax(toInteger(ary), 0);
      arity = arity === undefined ? arity : toInteger(arity);
      length -= holders ? holders.length : 0;

      if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
        var partialsRight = partials,
            holdersRight = holders;

        partials = holders = undefined;
      }
      var data = isBindKey ? undefined : getData(func);

      var newData = [
        func, bitmask, thisArg, partials, holders, partialsRight, holdersRight,
        argPos, ary, arity
      ];

      if (data) {
        mergeData(newData, data);
      }
      func = newData[0];
      bitmask = newData[1];
      thisArg = newData[2];
      partials = newData[3];
      holders = newData[4];
      arity = newData[9] = newData[9] === undefined
        ? (isBindKey ? 0 : func.length)
        : nativeMax(newData[9] - length, 0);

      if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
        bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
      }
      if (!bitmask || bitmask == WRAP_BIND_FLAG) {
        var result = createBind(func, bitmask, thisArg);
      } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
        result = createCurry(func, bitmask, arity);
      } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
        result = createPartial(func, bitmask, thisArg, partials);
      } else {
        result = createHybrid.apply(undefined, newData);
      }
      var setter = data ? baseSetData : setData;
      return setWrapToString(setter(result, newData), func, bitmask);
    }

    /**
     * Used by `_.defaults` to customize its `_.assignIn` use to assign properties
     * of source objects to the destination object for all destination properties
     * that resolve to `undefined`.
     *
     * @private
     * @param {*} objValue The destination value.
     * @param {*} srcValue The source value.
     * @param {string} key The key of the property to assign.
     * @param {Object} object The parent object of `objValue`.
     * @returns {*} Returns the value to assign.
     */
    function customDefaultsAssignIn(objValue, srcValue, key, object) {
      if (objValue === undefined ||
          (eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key))) {
        return srcValue;
      }
      return objValue;
    }

    /**
     * Used by `_.defaultsDeep` to customize its `_.merge` use to merge source
     * objects into destination objects that are passed thru.
     *
     * @private
     * @param {*} objValue The destination value.
     * @param {*} srcValue The source value.
     * @param {string} key The key of the property to merge.
     * @param {Object} object The parent object of `objValue`.
     * @param {Object} source The parent object of `srcValue`.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     * @returns {*} Returns the value to assign.
     */
    function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
      if (isObject(objValue) && isObject(srcValue)) {
        // Recursively merge objects and arrays (susceptible to call stack limits).
        stack.set(srcValue, objValue);
        baseMerge(objValue, srcValue, undefined, customDefaultsMerge, stack);
        stack['delete'](srcValue);
      }
      return objValue;
    }

    /**
     * Used by `_.omit` to customize its `_.cloneDeep` use to only clone plain
     * objects.
     *
     * @private
     * @param {*} value The value to inspect.
     * @param {string} key The key of the property to inspect.
     * @returns {*} Returns the uncloned value or `undefined` to defer cloning to `_.cloneDeep`.
     */
    function customOmitClone(value) {
      return isPlainObject(value) ? undefined : value;
    }

    /**
     * A specialized version of `baseIsEqualDeep` for arrays with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Array} array The array to compare.
     * @param {Array} other The other array to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `array` and `other` objects.
     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
     */
    function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
          arrLength = array.length,
          othLength = other.length;

      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      // Check that cyclic values are equal.
      var arrStacked = stack.get(array);
      var othStacked = stack.get(other);
      if (arrStacked && othStacked) {
        return arrStacked == other && othStacked == array;
      }
      var index = -1,
          result = true,
          seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;

      stack.set(array, other);
      stack.set(other, array);

      // Ignore non-index properties.
      while (++index < arrLength) {
        var arrValue = array[index],
            othValue = other[index];

        if (customizer) {
          var compared = isPartial
            ? customizer(othValue, arrValue, index, other, array, stack)
            : customizer(arrValue, othValue, index, array, other, stack);
        }
        if (compared !== undefined) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        // Recursively compare arrays (susceptible to call stack limits).
        if (seen) {
          if (!arraySome(other, function(othValue, othIndex) {
                if (!cacheHas(seen, othIndex) &&
                    (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                  return seen.push(othIndex);
                }
              })) {
            result = false;
            break;
          }
        } else if (!(
              arrValue === othValue ||
                equalFunc(arrValue, othValue, bitmask, customizer, stack)
            )) {
          result = false;
          break;
        }
      }
      stack['delete'](array);
      stack['delete'](other);
      return result;
    }

    /**
     * A specialized version of `baseIsEqualDeep` for comparing objects of
     * the same `toStringTag`.
     *
     * **Note:** This function only supports comparing values with tags of
     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {string} tag The `toStringTag` of the objects to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
      switch (tag) {
        case dataViewTag:
          if ((object.byteLength != other.byteLength) ||
              (object.byteOffset != other.byteOffset)) {
            return false;
          }
          object = object.buffer;
          other = other.buffer;

        case arrayBufferTag:
          if ((object.byteLength != other.byteLength) ||
              !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
            return false;
          }
          return true;

        case boolTag:
        case dateTag:
        case numberTag:
          // Coerce booleans to `1` or `0` and dates to milliseconds.
          // Invalid dates are coerced to `NaN`.
          return eq(+object, +other);

        case errorTag:
          return object.name == other.name && object.message == other.message;

        case regexpTag:
        case stringTag:
          // Coerce regexes to strings and treat strings, primitives and objects,
          // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
          // for more details.
          return object == (other + '');

        case mapTag:
          var convert = mapToArray;

        case setTag:
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
          convert || (convert = setToArray);

          if (object.size != other.size && !isPartial) {
            return false;
          }
          // Assume cyclic values are equal.
          var stacked = stack.get(object);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= COMPARE_UNORDERED_FLAG;

          // Recursively compare objects (susceptible to call stack limits).
          stack.set(object, other);
          var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
          stack['delete'](object);
          return result;

        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object) == symbolValueOf.call(other);
          }
      }
      return false;
    }

    /**
     * A specialized version of `baseIsEqualDeep` for objects with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
          objProps = getAllKeys(object),
          objLength = objProps.length,
          othProps = getAllKeys(other),
          othLength = othProps.length;

      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index = objLength;
      while (index--) {
        var key = objProps[index];
        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
          return false;
        }
      }
      // Check that cyclic values are equal.
      var objStacked = stack.get(object);
      var othStacked = stack.get(other);
      if (objStacked && othStacked) {
        return objStacked == other && othStacked == object;
      }
      var result = true;
      stack.set(object, other);
      stack.set(other, object);

      var skipCtor = isPartial;
      while (++index < objLength) {
        key = objProps[index];
        var objValue = object[key],
            othValue = other[key];

        if (customizer) {
          var compared = isPartial
            ? customizer(othValue, objValue, key, other, object, stack)
            : customizer(objValue, othValue, key, object, other, stack);
        }
        // Recursively compare objects (susceptible to call stack limits).
        if (!(compared === undefined
              ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
              : compared
            )) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key == 'constructor');
      }
      if (result && !skipCtor) {
        var objCtor = object.constructor,
            othCtor = other.constructor;

        // Non `Object` object instances with different constructors are not equal.
        if (objCtor != othCtor &&
            ('constructor' in object && 'constructor' in other) &&
            !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
              typeof othCtor == 'function' && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack['delete'](object);
      stack['delete'](other);
      return result;
    }

    /**
     * A specialized version of `baseRest` which flattens the rest array.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @returns {Function} Returns the new function.
     */
    function flatRest(func) {
      return setToString(overRest(func, undefined, flatten), func + '');
    }

    /**
     * Creates an array of own enumerable property names and symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names and symbols.
     */
    function getAllKeys(object) {
      return baseGetAllKeys(object, keys, getSymbols);
    }

    /**
     * Creates an array of own and inherited enumerable property names and
     * symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names and symbols.
     */
    function getAllKeysIn(object) {
      return baseGetAllKeys(object, keysIn, getSymbolsIn);
    }

    /**
     * Gets metadata for `func`.
     *
     * @private
     * @param {Function} func The function to query.
     * @returns {*} Returns the metadata for `func`.
     */
    var getData = !metaMap ? noop : function(func) {
      return metaMap.get(func);
    };

    /**
     * Gets the name of `func`.
     *
     * @private
     * @param {Function} func The function to query.
     * @returns {string} Returns the function name.
     */
    function getFuncName(func) {
      var result = (func.name + ''),
          array = realNames[result],
          length = hasOwnProperty.call(realNames, result) ? array.length : 0;

      while (length--) {
        var data = array[length],
            otherFunc = data.func;
        if (otherFunc == null || otherFunc == func) {
          return data.name;
        }
      }
      return result;
    }

    /**
     * Gets the argument placeholder value for `func`.
     *
     * @private
     * @param {Function} func The function to inspect.
     * @returns {*} Returns the placeholder value.
     */
    function getHolder(func) {
      var object = hasOwnProperty.call(lodash, 'placeholder') ? lodash : func;
      return object.placeholder;
    }

    /**
     * Gets the appropriate "iteratee" function. If `_.iteratee` is customized,
     * this function returns the custom method, otherwise it returns `baseIteratee`.
     * If arguments are provided, the chosen function is invoked with them and
     * its result is returned.
     *
     * @private
     * @param {*} [value] The value to convert to an iteratee.
     * @param {number} [arity] The arity of the created iteratee.
     * @returns {Function} Returns the chosen function or its result.
     */
    function getIteratee() {
      var result = lodash.iteratee || iteratee;
      result = result === iteratee ? baseIteratee : result;
      return arguments.length ? result(arguments[0], arguments[1]) : result;
    }

    /**
     * Gets the data for `map`.
     *
     * @private
     * @param {Object} map The map to query.
     * @param {string} key The reference key.
     * @returns {*} Returns the map data.
     */
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key)
        ? data[typeof key == 'string' ? 'string' : 'hash']
        : data.map;
    }

    /**
     * Gets the property names, values, and compare flags of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the match data of `object`.
     */
    function getMatchData(object) {
      var result = keys(object),
          length = result.length;

      while (length--) {
        var key = result[length],
            value = object[key];

        result[length] = [key, value, isStrictComparable(value)];
      }
      return result;
    }

    /**
     * Gets the native function at `key` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the method to get.
     * @returns {*} Returns the function if it's native, else `undefined`.
     */
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : undefined;
    }

    /**
     * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the raw `toStringTag`.
     */
    function getRawTag(value) {
      var isOwn = hasOwnProperty.call(value, symToStringTag),
          tag = value[symToStringTag];

      try {
        value[symToStringTag] = undefined;
        var unmasked = true;
      } catch (e) {}

      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }

    /**
     * Creates an array of the own enumerable symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of symbols.
     */
    var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
      if (object == null) {
        return [];
      }
      object = Object(object);
      return arrayFilter(nativeGetSymbols(object), function(symbol) {
        return propertyIsEnumerable.call(object, symbol);
      });
    };

    /**
     * Creates an array of the own and inherited enumerable symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of symbols.
     */
    var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
      var result = [];
      while (object) {
        arrayPush(result, getSymbols(object));
        object = getPrototype(object);
      }
      return result;
    };

    /**
     * Gets the `toStringTag` of `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */
    var getTag = baseGetTag;

    // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
    if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
        (Map && getTag(new Map) != mapTag) ||
        (Promise && getTag(Promise.resolve()) != promiseTag) ||
        (Set && getTag(new Set) != setTag) ||
        (WeakMap && getTag(new WeakMap) != weakMapTag)) {
      getTag = function(value) {
        var result = baseGetTag(value),
            Ctor = result == objectTag ? value.constructor : undefined,
            ctorString = Ctor ? toSource(Ctor) : '';

        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString: return dataViewTag;
            case mapCtorString: return mapTag;
            case promiseCtorString: return promiseTag;
            case setCtorString: return setTag;
            case weakMapCtorString: return weakMapTag;
          }
        }
        return result;
      };
    }

    /**
     * Gets the view, applying any `transforms` to the `start` and `end` positions.
     *
     * @private
     * @param {number} start The start of the view.
     * @param {number} end The end of the view.
     * @param {Array} transforms The transformations to apply to the view.
     * @returns {Object} Returns an object containing the `start` and `end`
     *  positions of the view.
     */
    function getView(start, end, transforms) {
      var index = -1,
          length = transforms.length;

      while (++index < length) {
        var data = transforms[index],
            size = data.size;

        switch (data.type) {
          case 'drop':      start += size; break;
          case 'dropRight': end -= size; break;
          case 'take':      end = nativeMin(end, start + size); break;
          case 'takeRight': start = nativeMax(start, end - size); break;
        }
      }
      return { 'start': start, 'end': end };
    }

    /**
     * Extracts wrapper details from the `source` body comment.
     *
     * @private
     * @param {string} source The source to inspect.
     * @returns {Array} Returns the wrapper details.
     */
    function getWrapDetails(source) {
      var match = source.match(reWrapDetails);
      return match ? match[1].split(reSplitDetails) : [];
    }

    /**
     * Checks if `path` exists on `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @param {Function} hasFunc The function to check properties.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     */
    function hasPath(object, path, hasFunc) {
      path = castPath(path, object);

      var index = -1,
          length = path.length,
          result = false;

      while (++index < length) {
        var key = toKey(path[index]);
        if (!(result = object != null && hasFunc(object, key))) {
          break;
        }
        object = object[key];
      }
      if (result || ++index != length) {
        return result;
      }
      length = object == null ? 0 : object.length;
      return !!length && isLength(length) && isIndex(key, length) &&
        (isArray(object) || isArguments(object));
    }

    /**
     * Initializes an array clone.
     *
     * @private
     * @param {Array} array The array to clone.
     * @returns {Array} Returns the initialized clone.
     */
    function initCloneArray(array) {
      var length = array.length,
          result = new array.constructor(length);

      // Add properties assigned by `RegExp#exec`.
      if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
        result.index = array.index;
        result.input = array.input;
      }
      return result;
    }

    /**
     * Initializes an object clone.
     *
     * @private
     * @param {Object} object The object to clone.
     * @returns {Object} Returns the initialized clone.
     */
    function initCloneObject(object) {
      return (typeof object.constructor == 'function' && !isPrototype(object))
        ? baseCreate(getPrototype(object))
        : {};
    }

    /**
     * Initializes an object clone based on its `toStringTag`.
     *
     * **Note:** This function only supports cloning values with tags of
     * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
     *
     * @private
     * @param {Object} object The object to clone.
     * @param {string} tag The `toStringTag` of the object to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the initialized clone.
     */
    function initCloneByTag(object, tag, isDeep) {
      var Ctor = object.constructor;
      switch (tag) {
        case arrayBufferTag:
          return cloneArrayBuffer(object);

        case boolTag:
        case dateTag:
          return new Ctor(+object);

        case dataViewTag:
          return cloneDataView(object, isDeep);

        case float32Tag: case float64Tag:
        case int8Tag: case int16Tag: case int32Tag:
        case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
          return cloneTypedArray(object, isDeep);

        case mapTag:
          return new Ctor;

        case numberTag:
        case stringTag:
          return new Ctor(object);

        case regexpTag:
          return cloneRegExp(object);

        case setTag:
          return new Ctor;

        case symbolTag:
          return cloneSymbol(object);
      }
    }

    /**
     * Inserts wrapper `details` in a comment at the top of the `source` body.
     *
     * @private
     * @param {string} source The source to modify.
     * @returns {Array} details The details to insert.
     * @returns {string} Returns the modified source.
     */
    function insertWrapDetails(source, details) {
      var length = details.length;
      if (!length) {
        return source;
      }
      var lastIndex = length - 1;
      details[lastIndex] = (length > 1 ? '& ' : '') + details[lastIndex];
      details = details.join(length > 2 ? ', ' : ' ');
      return source.replace(reWrapComment, '{\n/* [wrapped with ' + details + '] */\n');
    }

    /**
     * Checks if `value` is a flattenable `arguments` object or array.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
     */
    function isFlattenable(value) {
      return isArray(value) || isArguments(value) ||
        !!(spreadableSymbol && value && value[spreadableSymbol]);
    }

    /**
     * Checks if `value` is a valid array-like index.
     *
     * @private
     * @param {*} value The value to check.
     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
     */
    function isIndex(value, length) {
      var type = typeof value;
      length = length == null ? MAX_SAFE_INTEGER : length;

      return !!length &&
        (type == 'number' ||
          (type != 'symbol' && reIsUint.test(value))) &&
            (value > -1 && value % 1 == 0 && value < length);
    }

    /**
     * Checks if the given arguments are from an iteratee call.
     *
     * @private
     * @param {*} value The potential iteratee value argument.
     * @param {*} index The potential iteratee index or key argument.
     * @param {*} object The potential iteratee object argument.
     * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
     *  else `false`.
     */
    function isIterateeCall(value, index, object) {
      if (!isObject(object)) {
        return false;
      }
      var type = typeof index;
      if (type == 'number'
            ? (isArrayLike(object) && isIndex(index, object.length))
            : (type == 'string' && index in object)
          ) {
        return eq(object[index], value);
      }
      return false;
    }

    /**
     * Checks if `value` is a property name and not a property path.
     *
     * @private
     * @param {*} value The value to check.
     * @param {Object} [object] The object to query keys on.
     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
     */
    function isKey(value, object) {
      if (isArray(value)) {
        return false;
      }
      var type = typeof value;
      if (type == 'number' || type == 'symbol' || type == 'boolean' ||
          value == null || isSymbol(value)) {
        return true;
      }
      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
        (object != null && value in Object(object));
    }

    /**
     * Checks if `value` is suitable for use as unique object key.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
     */
    function isKeyable(value) {
      var type = typeof value;
      return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
        ? (value !== '__proto__')
        : (value === null);
    }

    /**
     * Checks if `func` has a lazy counterpart.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` has a lazy counterpart,
     *  else `false`.
     */
    function isLaziable(func) {
      var funcName = getFuncName(func),
          other = lodash[funcName];

      if (typeof other != 'function' || !(funcName in LazyWrapper.prototype)) {
        return false;
      }
      if (func === other) {
        return true;
      }
      var data = getData(other);
      return !!data && func === data[0];
    }

    /**
     * Checks if `func` has its source masked.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` is masked, else `false`.
     */
    function isMasked(func) {
      return !!maskSrcKey && (maskSrcKey in func);
    }

    /**
     * Checks if `func` is capable of being masked.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `func` is maskable, else `false`.
     */
    var isMaskable = coreJsData ? isFunction : stubFalse;

    /**
     * Checks if `value` is likely a prototype object.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
     */
    function isPrototype(value) {
      var Ctor = value && value.constructor,
          proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

      return value === proto;
    }

    /**
     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` if suitable for strict
     *  equality comparisons, else `false`.
     */
    function isStrictComparable(value) {
      return value === value && !isObject(value);
    }

    /**
     * A specialized version of `matchesProperty` for source values suitable
     * for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {string} key The key of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     */
    function matchesStrictComparable(key, srcValue) {
      return function(object) {
        if (object == null) {
          return false;
        }
        return object[key] === srcValue &&
          (srcValue !== undefined || (key in Object(object)));
      };
    }

    /**
     * A specialized version of `_.memoize` which clears the memoized function's
     * cache when it exceeds `MAX_MEMOIZE_SIZE`.
     *
     * @private
     * @param {Function} func The function to have its output memoized.
     * @returns {Function} Returns the new memoized function.
     */
    function memoizeCapped(func) {
      var result = memoize(func, function(key) {
        if (cache.size === MAX_MEMOIZE_SIZE) {
          cache.clear();
        }
        return key;
      });

      var cache = result.cache;
      return result;
    }

    /**
     * Merges the function metadata of `source` into `data`.
     *
     * Merging metadata reduces the number of wrappers used to invoke a function.
     * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
     * may be applied regardless of execution order. Methods like `_.ary` and
     * `_.rearg` modify function arguments, making the order in which they are
     * executed important, preventing the merging of metadata. However, we make
     * an exception for a safe combined case where curried functions have `_.ary`
     * and or `_.rearg` applied.
     *
     * @private
     * @param {Array} data The destination metadata.
     * @param {Array} source The source metadata.
     * @returns {Array} Returns `data`.
     */
    function mergeData(data, source) {
      var bitmask = data[1],
          srcBitmask = source[1],
          newBitmask = bitmask | srcBitmask,
          isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);

      var isCombo =
        ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_CURRY_FLAG)) ||
        ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_REARG_FLAG) && (data[7].length <= source[8])) ||
        ((srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG)) && (source[7].length <= source[8]) && (bitmask == WRAP_CURRY_FLAG));

      // Exit early if metadata can't be merged.
      if (!(isCommon || isCombo)) {
        return data;
      }
      // Use source `thisArg` if available.
      if (srcBitmask & WRAP_BIND_FLAG) {
        data[2] = source[2];
        // Set when currying a bound function.
        newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
      }
      // Compose partial arguments.
      var value = source[3];
      if (value) {
        var partials = data[3];
        data[3] = partials ? composeArgs(partials, value, source[4]) : value;
        data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
      }
      // Compose partial right arguments.
      value = source[5];
      if (value) {
        partials = data[5];
        data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
        data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
      }
      // Use source `argPos` if available.
      value = source[7];
      if (value) {
        data[7] = value;
      }
      // Use source `ary` if it's smaller.
      if (srcBitmask & WRAP_ARY_FLAG) {
        data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
      }
      // Use source `arity` if one is not provided.
      if (data[9] == null) {
        data[9] = source[9];
      }
      // Use source `func` and merge bitmasks.
      data[0] = source[0];
      data[1] = newBitmask;

      return data;
    }

    /**
     * This function is like
     * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * except that it includes inherited enumerable properties.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
    function nativeKeysIn(object) {
      var result = [];
      if (object != null) {
        for (var key in Object(object)) {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * Converts `value` to a string using `Object.prototype.toString`.
     *
     * @private
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     */
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }

    /**
     * A specialized version of `baseRest` which transforms the rest array.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @param {Function} transform The rest array transform.
     * @returns {Function} Returns the new function.
     */
    function overRest(func, start, transform) {
      start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
      return function() {
        var args = arguments,
            index = -1,
            length = nativeMax(args.length - start, 0),
            array = Array(length);

        while (++index < length) {
          array[index] = args[start + index];
        }
        index = -1;
        var otherArgs = Array(start + 1);
        while (++index < start) {
          otherArgs[index] = args[index];
        }
        otherArgs[start] = transform(array);
        return apply(func, this, otherArgs);
      };
    }

    /**
     * Gets the parent value at `path` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array} path The path to get the parent value of.
     * @returns {*} Returns the parent value.
     */
    function parent(object, path) {
      return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
    }

    /**
     * Reorder `array` according to the specified indexes where the element at
     * the first index is assigned as the first element, the element at
     * the second index is assigned as the second element, and so on.
     *
     * @private
     * @param {Array} array The array to reorder.
     * @param {Array} indexes The arranged array indexes.
     * @returns {Array} Returns `array`.
     */
    function reorder(array, indexes) {
      var arrLength = array.length,
          length = nativeMin(indexes.length, arrLength),
          oldArray = copyArray(array);

      while (length--) {
        var index = indexes[length];
        array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
      }
      return array;
    }

    /**
     * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the property to get.
     * @returns {*} Returns the property value.
     */
    function safeGet(object, key) {
      if (key === 'constructor' && typeof object[key] === 'function') {
        return;
      }

      if (key == '__proto__') {
        return;
      }

      return object[key];
    }

    /**
     * Sets metadata for `func`.
     *
     * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
     * period of time, it will trip its breaker and transition to an identity
     * function to avoid garbage collection pauses in V8. See
     * [V8 issue 2070](https://bugs.chromium.org/p/v8/issues/detail?id=2070)
     * for more details.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */
    var setData = shortOut(baseSetData);

    /**
     * A simple wrapper around the global [`setTimeout`](https://mdn.io/setTimeout).
     *
     * @private
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @returns {number|Object} Returns the timer id or timeout object.
     */
    var setTimeout = ctxSetTimeout || function(func, wait) {
      return root.setTimeout(func, wait);
    };

    /**
     * Sets the `toString` method of `func` to return `string`.
     *
     * @private
     * @param {Function} func The function to modify.
     * @param {Function} string The `toString` result.
     * @returns {Function} Returns `func`.
     */
    var setToString = shortOut(baseSetToString);

    /**
     * Sets the `toString` method of `wrapper` to mimic the source of `reference`
     * with wrapper details in a comment at the top of the source body.
     *
     * @private
     * @param {Function} wrapper The function to modify.
     * @param {Function} reference The reference function.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @returns {Function} Returns `wrapper`.
     */
    function setWrapToString(wrapper, reference, bitmask) {
      var source = (reference + '');
      return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
    }

    /**
     * Creates a function that'll short out and invoke `identity` instead
     * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
     * milliseconds.
     *
     * @private
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new shortable function.
     */
    function shortOut(func) {
      var count = 0,
          lastCalled = 0;

      return function() {
        var stamp = nativeNow(),
            remaining = HOT_SPAN - (stamp - lastCalled);

        lastCalled = stamp;
        if (remaining > 0) {
          if (++count >= HOT_COUNT) {
            return arguments[0];
          }
        } else {
          count = 0;
        }
        return func.apply(undefined, arguments);
      };
    }

    /**
     * A specialized version of `_.shuffle` which mutates and sets the size of `array`.
     *
     * @private
     * @param {Array} array The array to shuffle.
     * @param {number} [size=array.length] The size of `array`.
     * @returns {Array} Returns `array`.
     */
    function shuffleSelf(array, size) {
      var index = -1,
          length = array.length,
          lastIndex = length - 1;

      size = size === undefined ? length : size;
      while (++index < size) {
        var rand = baseRandom(index, lastIndex),
            value = array[rand];

        array[rand] = array[index];
        array[index] = value;
      }
      array.length = size;
      return array;
    }

    /**
     * Converts `string` to a property path array.
     *
     * @private
     * @param {string} string The string to convert.
     * @returns {Array} Returns the property path array.
     */
    var stringToPath = memoizeCapped(function(string) {
      var result = [];
      if (string.charCodeAt(0) === 46 /* . */) {
        result.push('');
      }
      string.replace(rePropName, function(match, number, quote, subString) {
        result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
      });
      return result;
    });

    /**
     * Converts `value` to a string key if it's not a string or symbol.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {string|symbol} Returns the key.
     */
    function toKey(value) {
      if (typeof value == 'string' || isSymbol(value)) {
        return value;
      }
      var result = (value + '');
      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
    }

    /**
     * Converts `func` to its source code.
     *
     * @private
     * @param {Function} func The function to convert.
     * @returns {string} Returns the source code.
     */
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {}
        try {
          return (func + '');
        } catch (e) {}
      }
      return '';
    }

    /**
     * Updates wrapper `details` based on `bitmask` flags.
     *
     * @private
     * @returns {Array} details The details to modify.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @returns {Array} Returns `details`.
     */
    function updateWrapDetails(details, bitmask) {
      arrayEach(wrapFlags, function(pair) {
        var value = '_.' + pair[0];
        if ((bitmask & pair[1]) && !arrayIncludes(details, value)) {
          details.push(value);
        }
      });
      return details.sort();
    }

    /**
     * Creates a clone of `wrapper`.
     *
     * @private
     * @param {Object} wrapper The wrapper to clone.
     * @returns {Object} Returns the cloned wrapper.
     */
    function wrapperClone(wrapper) {
      if (wrapper instanceof LazyWrapper) {
        return wrapper.clone();
      }
      var result = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
      result.__actions__ = copyArray(wrapper.__actions__);
      result.__index__  = wrapper.__index__;
      result.__values__ = wrapper.__values__;
      return result;
    }

    /*------------------------------------------------------------------------*/

    /**
     * Creates an array of elements split into groups the length of `size`.
     * If `array` can't be split evenly, the final chunk will be the remaining
     * elements.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to process.
     * @param {number} [size=1] The length of each chunk
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the new array of chunks.
     * @example
     *
     * _.chunk(['a', 'b', 'c', 'd'], 2);
     * // => [['a', 'b'], ['c', 'd']]
     *
     * _.chunk(['a', 'b', 'c', 'd'], 3);
     * // => [['a', 'b', 'c'], ['d']]
     */
    function chunk(array, size, guard) {
      if ((guard ? isIterateeCall(array, size, guard) : size === undefined)) {
        size = 1;
      } else {
        size = nativeMax(toInteger(size), 0);
      }
      var length = array == null ? 0 : array.length;
      if (!length || size < 1) {
        return [];
      }
      var index = 0,
          resIndex = 0,
          result = Array(nativeCeil(length / size));

      while (index < length) {
        result[resIndex++] = baseSlice(array, index, (index += size));
      }
      return result;
    }

    /**
     * Creates an array with all falsey values removed. The values `false`, `null`,
     * `0`, `""`, `undefined`, and `NaN` are falsey.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to compact.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.compact([0, 1, false, 2, '', 3]);
     * // => [1, 2, 3]
     */
    function compact(array) {
      var index = -1,
          length = array == null ? 0 : array.length,
          resIndex = 0,
          result = [];

      while (++index < length) {
        var value = array[index];
        if (value) {
          result[resIndex++] = value;
        }
      }
      return result;
    }

    /**
     * Creates a new array concatenating `array` with any additional arrays
     * and/or values.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to concatenate.
     * @param {...*} [values] The values to concatenate.
     * @returns {Array} Returns the new concatenated array.
     * @example
     *
     * var array = [1];
     * var other = _.concat(array, 2, [3], [[4]]);
     *
     * console.log(other);
     * // => [1, 2, 3, [4]]
     *
     * console.log(array);
     * // => [1]
     */
    function concat() {
      var length = arguments.length;
      if (!length) {
        return [];
      }
      var args = Array(length - 1),
          array = arguments[0],
          index = length;

      while (index--) {
        args[index - 1] = arguments[index];
      }
      return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));
    }

    /**
     * Creates an array of `array` values not included in the other given arrays
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. The order and references of result values are
     * determined by the first array.
     *
     * **Note:** Unlike `_.pullAll`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.without, _.xor
     * @example
     *
     * _.difference([2, 1], [2, 3]);
     * // => [1]
     */
    var difference = baseRest(function(array, values) {
      return isArrayLikeObject(array)
        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true))
        : [];
    });

    /**
     * This method is like `_.difference` except that it accepts `iteratee` which
     * is invoked for each element of `array` and `values` to generate the criterion
     * by which they're compared. The order and references of result values are
     * determined by the first array. The iteratee is invoked with one argument:
     * (value).
     *
     * **Note:** Unlike `_.pullAllBy`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.differenceBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.differenceBy([{ 'x': 2 }, { 'x': 1 }], [{ 'x': 1 }], 'x');
     * // => [{ 'x': 2 }]
     */
    var differenceBy = baseRest(function(array, values) {
      var iteratee = last(values);
      if (isArrayLikeObject(iteratee)) {
        iteratee = undefined;
      }
      return isArrayLikeObject(array)
        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), getIteratee(iteratee, 2))
        : [];
    });

    /**
     * This method is like `_.difference` except that it accepts `comparator`
     * which is invoked to compare elements of `array` to `values`. The order and
     * references of result values are determined by the first array. The comparator
     * is invoked with two arguments: (arrVal, othVal).
     *
     * **Note:** Unlike `_.pullAllWith`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     *
     * _.differenceWith(objects, [{ 'x': 1, 'y': 2 }], _.isEqual);
     * // => [{ 'x': 2, 'y': 1 }]
     */
    var differenceWith = baseRest(function(array, values) {
      var comparator = last(values);
      if (isArrayLikeObject(comparator)) {
        comparator = undefined;
      }
      return isArrayLikeObject(array)
        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), undefined, comparator)
        : [];
    });

    /**
     * Creates a slice of `array` with `n` elements dropped from the beginning.
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to drop.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.drop([1, 2, 3]);
     * // => [2, 3]
     *
     * _.drop([1, 2, 3], 2);
     * // => [3]
     *
     * _.drop([1, 2, 3], 5);
     * // => []
     *
     * _.drop([1, 2, 3], 0);
     * // => [1, 2, 3]
     */
    function drop(array, n, guard) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      n = (guard || n === undefined) ? 1 : toInteger(n);
      return baseSlice(array, n < 0 ? 0 : n, length);
    }

    /**
     * Creates a slice of `array` with `n` elements dropped from the end.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to drop.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.dropRight([1, 2, 3]);
     * // => [1, 2]
     *
     * _.dropRight([1, 2, 3], 2);
     * // => [1]
     *
     * _.dropRight([1, 2, 3], 5);
     * // => []
     *
     * _.dropRight([1, 2, 3], 0);
     * // => [1, 2, 3]
     */
    function dropRight(array, n, guard) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      n = (guard || n === undefined) ? 1 : toInteger(n);
      n = length - n;
      return baseSlice(array, 0, n < 0 ? 0 : n);
    }

    /**
     * Creates a slice of `array` excluding elements dropped from the end.
     * Elements are dropped until `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.dropRightWhile(users, function(o) { return !o.active; });
     * // => objects for ['barney']
     *
     * // The `_.matches` iteratee shorthand.
     * _.dropRightWhile(users, { 'user': 'pebbles', 'active': false });
     * // => objects for ['barney', 'fred']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.dropRightWhile(users, ['active', false]);
     * // => objects for ['barney']
     *
     * // The `_.property` iteratee shorthand.
     * _.dropRightWhile(users, 'active');
     * // => objects for ['barney', 'fred', 'pebbles']
     */
    function dropRightWhile(array, predicate) {
      return (array && array.length)
        ? baseWhile(array, getIteratee(predicate, 3), true, true)
        : [];
    }

    /**
     * Creates a slice of `array` excluding elements dropped from the beginning.
     * Elements are dropped until `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.dropWhile(users, function(o) { return !o.active; });
     * // => objects for ['pebbles']
     *
     * // The `_.matches` iteratee shorthand.
     * _.dropWhile(users, { 'user': 'barney', 'active': false });
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.dropWhile(users, ['active', false]);
     * // => objects for ['pebbles']
     *
     * // The `_.property` iteratee shorthand.
     * _.dropWhile(users, 'active');
     * // => objects for ['barney', 'fred', 'pebbles']
     */
    function dropWhile(array, predicate) {
      return (array && array.length)
        ? baseWhile(array, getIteratee(predicate, 3), true)
        : [];
    }

    /**
     * Fills elements of `array` with `value` from `start` up to, but not
     * including, `end`.
     *
     * **Note:** This method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Array
     * @param {Array} array The array to fill.
     * @param {*} value The value to fill `array` with.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _.fill(array, 'a');
     * console.log(array);
     * // => ['a', 'a', 'a']
     *
     * _.fill(Array(3), 2);
     * // => [2, 2, 2]
     *
     * _.fill([4, 6, 8, 10], '*', 1, 3);
     * // => [4, '*', '*', 10]
     */
    function fill(array, value, start, end) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {
        start = 0;
        end = length;
      }
      return baseFill(array, value, start, end);
    }

    /**
     * This method is like `_.find` except that it returns the index of the first
     * element `predicate` returns truthy for instead of the element itself.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.findIndex(users, function(o) { return o.user == 'barney'; });
     * // => 0
     *
     * // The `_.matches` iteratee shorthand.
     * _.findIndex(users, { 'user': 'fred', 'active': false });
     * // => 1
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findIndex(users, ['active', false]);
     * // => 0
     *
     * // The `_.property` iteratee shorthand.
     * _.findIndex(users, 'active');
     * // => 2
     */
    function findIndex(array, predicate, fromIndex) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return -1;
      }
      var index = fromIndex == null ? 0 : toInteger(fromIndex);
      if (index < 0) {
        index = nativeMax(length + index, 0);
      }
      return baseFindIndex(array, getIteratee(predicate, 3), index);
    }

    /**
     * This method is like `_.findIndex` except that it iterates over elements
     * of `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=array.length-1] The index to search from.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });
     * // => 2
     *
     * // The `_.matches` iteratee shorthand.
     * _.findLastIndex(users, { 'user': 'barney', 'active': true });
     * // => 0
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findLastIndex(users, ['active', false]);
     * // => 2
     *
     * // The `_.property` iteratee shorthand.
     * _.findLastIndex(users, 'active');
     * // => 0
     */
    function findLastIndex(array, predicate, fromIndex) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return -1;
      }
      var index = length - 1;
      if (fromIndex !== undefined) {
        index = toInteger(fromIndex);
        index = fromIndex < 0
          ? nativeMax(length + index, 0)
          : nativeMin(index, length - 1);
      }
      return baseFindIndex(array, getIteratee(predicate, 3), index, true);
    }

    /**
     * Flattens `array` a single level deep.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * _.flatten([1, [2, [3, [4]], 5]]);
     * // => [1, 2, [3, [4]], 5]
     */
    function flatten(array) {
      var length = array == null ? 0 : array.length;
      return length ? baseFlatten(array, 1) : [];
    }

    /**
     * Recursively flattens `array`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * _.flattenDeep([1, [2, [3, [4]], 5]]);
     * // => [1, 2, 3, 4, 5]
     */
    function flattenDeep(array) {
      var length = array == null ? 0 : array.length;
      return length ? baseFlatten(array, INFINITY) : [];
    }

    /**
     * Recursively flatten `array` up to `depth` times.
     *
     * @static
     * @memberOf _
     * @since 4.4.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @param {number} [depth=1] The maximum recursion depth.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * var array = [1, [2, [3, [4]], 5]];
     *
     * _.flattenDepth(array, 1);
     * // => [1, 2, [3, [4]], 5]
     *
     * _.flattenDepth(array, 2);
     * // => [1, 2, 3, [4], 5]
     */
    function flattenDepth(array, depth) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      depth = depth === undefined ? 1 : toInteger(depth);
      return baseFlatten(array, depth);
    }

    /**
     * The inverse of `_.toPairs`; this method returns an object composed
     * from key-value `pairs`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} pairs The key-value pairs.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.fromPairs([['a', 1], ['b', 2]]);
     * // => { 'a': 1, 'b': 2 }
     */
    function fromPairs(pairs) {
      var index = -1,
          length = pairs == null ? 0 : pairs.length,
          result = {};

      while (++index < length) {
        var pair = pairs[index];
        result[pair[0]] = pair[1];
      }
      return result;
    }

    /**
     * Gets the first element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @alias first
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the first element of `array`.
     * @example
     *
     * _.head([1, 2, 3]);
     * // => 1
     *
     * _.head([]);
     * // => undefined
     */
    function head(array) {
      return (array && array.length) ? array[0] : undefined;
    }

    /**
     * Gets the index at which the first occurrence of `value` is found in `array`
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. If `fromIndex` is negative, it's used as the
     * offset from the end of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.indexOf([1, 2, 1, 2], 2);
     * // => 1
     *
     * // Search from the `fromIndex`.
     * _.indexOf([1, 2, 1, 2], 2, 2);
     * // => 3
     */
    function indexOf(array, value, fromIndex) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return -1;
      }
      var index = fromIndex == null ? 0 : toInteger(fromIndex);
      if (index < 0) {
        index = nativeMax(length + index, 0);
      }
      return baseIndexOf(array, value, index);
    }

    /**
     * Gets all but the last element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.initial([1, 2, 3]);
     * // => [1, 2]
     */
    function initial(array) {
      var length = array == null ? 0 : array.length;
      return length ? baseSlice(array, 0, -1) : [];
    }

    /**
     * Creates an array of unique values that are included in all given arrays
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. The order and references of result values are
     * determined by the first array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * _.intersection([2, 1], [2, 3]);
     * // => [2]
     */
    var intersection = baseRest(function(arrays) {
      var mapped = arrayMap(arrays, castArrayLikeObject);
      return (mapped.length && mapped[0] === arrays[0])
        ? baseIntersection(mapped)
        : [];
    });

    /**
     * This method is like `_.intersection` except that it accepts `iteratee`
     * which is invoked for each element of each `arrays` to generate the criterion
     * by which they're compared. The order and references of result values are
     * determined by the first array. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * _.intersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [2.1]
     *
     * // The `_.property` iteratee shorthand.
     * _.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }]
     */
    var intersectionBy = baseRest(function(arrays) {
      var iteratee = last(arrays),
          mapped = arrayMap(arrays, castArrayLikeObject);

      if (iteratee === last(mapped)) {
        iteratee = undefined;
      } else {
        mapped.pop();
      }
      return (mapped.length && mapped[0] === arrays[0])
        ? baseIntersection(mapped, getIteratee(iteratee, 2))
        : [];
    });

    /**
     * This method is like `_.intersection` except that it accepts `comparator`
     * which is invoked to compare elements of `arrays`. The order and references
     * of result values are determined by the first array. The comparator is
     * invoked with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.intersectionWith(objects, others, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }]
     */
    var intersectionWith = baseRest(function(arrays) {
      var comparator = last(arrays),
          mapped = arrayMap(arrays, castArrayLikeObject);

      comparator = typeof comparator == 'function' ? comparator : undefined;
      if (comparator) {
        mapped.pop();
      }
      return (mapped.length && mapped[0] === arrays[0])
        ? baseIntersection(mapped, undefined, comparator)
        : [];
    });

    /**
     * Converts all elements in `array` into a string separated by `separator`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to convert.
     * @param {string} [separator=','] The element separator.
     * @returns {string} Returns the joined string.
     * @example
     *
     * _.join(['a', 'b', 'c'], '~');
     * // => 'a~b~c'
     */
    function join(array, separator) {
      return array == null ? '' : nativeJoin.call(array, separator);
    }

    /**
     * Gets the last element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the last element of `array`.
     * @example
     *
     * _.last([1, 2, 3]);
     * // => 3
     */
    function last(array) {
      var length = array == null ? 0 : array.length;
      return length ? array[length - 1] : undefined;
    }

    /**
     * This method is like `_.indexOf` except that it iterates over elements of
     * `array` from right to left.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=array.length-1] The index to search from.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.lastIndexOf([1, 2, 1, 2], 2);
     * // => 3
     *
     * // Search from the `fromIndex`.
     * _.lastIndexOf([1, 2, 1, 2], 2, 2);
     * // => 1
     */
    function lastIndexOf(array, value, fromIndex) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return -1;
      }
      var index = length;
      if (fromIndex !== undefined) {
        index = toInteger(fromIndex);
        index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
      }
      return value === value
        ? strictLastIndexOf(array, value, index)
        : baseFindIndex(array, baseIsNaN, index, true);
    }

    /**
     * Gets the element at index `n` of `array`. If `n` is negative, the nth
     * element from the end is returned.
     *
     * @static
     * @memberOf _
     * @since 4.11.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=0] The index of the element to return.
     * @returns {*} Returns the nth element of `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'd'];
     *
     * _.nth(array, 1);
     * // => 'b'
     *
     * _.nth(array, -2);
     * // => 'c';
     */
    function nth(array, n) {
      return (array && array.length) ? baseNth(array, toInteger(n)) : undefined;
    }

    /**
     * Removes all given values from `array` using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * **Note:** Unlike `_.without`, this method mutates `array`. Use `_.remove`
     * to remove elements from an array by predicate.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {...*} [values] The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
     *
     * _.pull(array, 'a', 'c');
     * console.log(array);
     * // => ['b', 'b']
     */
    var pull = baseRest(pullAll);

    /**
     * This method is like `_.pull` except that it accepts an array of values to remove.
     *
     * **Note:** Unlike `_.difference`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
     *
     * _.pullAll(array, ['a', 'c']);
     * console.log(array);
     * // => ['b', 'b']
     */
    function pullAll(array, values) {
      return (array && array.length && values && values.length)
        ? basePullAll(array, values)
        : array;
    }

    /**
     * This method is like `_.pullAll` except that it accepts `iteratee` which is
     * invoked for each element of `array` and `values` to generate the criterion
     * by which they're compared. The iteratee is invoked with one argument: (value).
     *
     * **Note:** Unlike `_.differenceBy`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }];
     *
     * _.pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], 'x');
     * console.log(array);
     * // => [{ 'x': 2 }]
     */
    function pullAllBy(array, values, iteratee) {
      return (array && array.length && values && values.length)
        ? basePullAll(array, values, getIteratee(iteratee, 2))
        : array;
    }

    /**
     * This method is like `_.pullAll` except that it accepts `comparator` which
     * is invoked to compare elements of `array` to `values`. The comparator is
     * invoked with two arguments: (arrVal, othVal).
     *
     * **Note:** Unlike `_.differenceWith`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [{ 'x': 1, 'y': 2 }, { 'x': 3, 'y': 4 }, { 'x': 5, 'y': 6 }];
     *
     * _.pullAllWith(array, [{ 'x': 3, 'y': 4 }], _.isEqual);
     * console.log(array);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 5, 'y': 6 }]
     */
    function pullAllWith(array, values, comparator) {
      return (array && array.length && values && values.length)
        ? basePullAll(array, values, undefined, comparator)
        : array;
    }

    /**
     * Removes elements from `array` corresponding to `indexes` and returns an
     * array of removed elements.
     *
     * **Note:** Unlike `_.at`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {...(number|number[])} [indexes] The indexes of elements to remove.
     * @returns {Array} Returns the new array of removed elements.
     * @example
     *
     * var array = ['a', 'b', 'c', 'd'];
     * var pulled = _.pullAt(array, [1, 3]);
     *
     * console.log(array);
     * // => ['a', 'c']
     *
     * console.log(pulled);
     * // => ['b', 'd']
     */
    var pullAt = flatRest(function(array, indexes) {
      var length = array == null ? 0 : array.length,
          result = baseAt(array, indexes);

      basePullAt(array, arrayMap(indexes, function(index) {
        return isIndex(index, length) ? +index : index;
      }).sort(compareAscending));

      return result;
    });

    /**
     * Removes all elements from `array` that `predicate` returns truthy for
     * and returns an array of the removed elements. The predicate is invoked
     * with three arguments: (value, index, array).
     *
     * **Note:** Unlike `_.filter`, this method mutates `array`. Use `_.pull`
     * to pull elements from an array by value.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new array of removed elements.
     * @example
     *
     * var array = [1, 2, 3, 4];
     * var evens = _.remove(array, function(n) {
     *   return n % 2 == 0;
     * });
     *
     * console.log(array);
     * // => [1, 3]
     *
     * console.log(evens);
     * // => [2, 4]
     */
    function remove(array, predicate) {
      var result = [];
      if (!(array && array.length)) {
        return result;
      }
      var index = -1,
          indexes = [],
          length = array.length;

      predicate = getIteratee(predicate, 3);
      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result.push(value);
          indexes.push(index);
        }
      }
      basePullAt(array, indexes);
      return result;
    }

    /**
     * Reverses `array` so that the first element becomes the last, the second
     * element becomes the second to last, and so on.
     *
     * **Note:** This method mutates `array` and is based on
     * [`Array#reverse`](https://mdn.io/Array/reverse).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _.reverse(array);
     * // => [3, 2, 1]
     *
     * console.log(array);
     * // => [3, 2, 1]
     */
    function reverse(array) {
      return array == null ? array : nativeReverse.call(array);
    }

    /**
     * Creates a slice of `array` from `start` up to, but not including, `end`.
     *
     * **Note:** This method is used instead of
     * [`Array#slice`](https://mdn.io/Array/slice) to ensure dense arrays are
     * returned.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */
    function slice(array, start, end) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {
        start = 0;
        end = length;
      }
      else {
        start = start == null ? 0 : toInteger(start);
        end = end === undefined ? length : toInteger(end);
      }
      return baseSlice(array, start, end);
    }

    /**
     * Uses a binary search to determine the lowest index at which `value`
     * should be inserted into `array` in order to maintain its sort order.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedIndex([30, 50], 40);
     * // => 1
     */
    function sortedIndex(array, value) {
      return baseSortedIndex(array, value);
    }

    /**
     * This method is like `_.sortedIndex` except that it accepts `iteratee`
     * which is invoked for `value` and each element of `array` to compute their
     * sort ranking. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * var objects = [{ 'x': 4 }, { 'x': 5 }];
     *
     * _.sortedIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
     * // => 0
     *
     * // The `_.property` iteratee shorthand.
     * _.sortedIndexBy(objects, { 'x': 4 }, 'x');
     * // => 0
     */
    function sortedIndexBy(array, value, iteratee) {
      return baseSortedIndexBy(array, value, getIteratee(iteratee, 2));
    }

    /**
     * This method is like `_.indexOf` except that it performs a binary
     * search on a sorted `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.sortedIndexOf([4, 5, 5, 5, 6], 5);
     * // => 1
     */
    function sortedIndexOf(array, value) {
      var length = array == null ? 0 : array.length;
      if (length) {
        var index = baseSortedIndex(array, value);
        if (index < length && eq(array[index], value)) {
          return index;
        }
      }
      return -1;
    }

    /**
     * This method is like `_.sortedIndex` except that it returns the highest
     * index at which `value` should be inserted into `array` in order to
     * maintain its sort order.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedLastIndex([4, 5, 5, 5, 6], 5);
     * // => 4
     */
    function sortedLastIndex(array, value) {
      return baseSortedIndex(array, value, true);
    }

    /**
     * This method is like `_.sortedLastIndex` except that it accepts `iteratee`
     * which is invoked for `value` and each element of `array` to compute their
     * sort ranking. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * var objects = [{ 'x': 4 }, { 'x': 5 }];
     *
     * _.sortedLastIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
     * // => 1
     *
     * // The `_.property` iteratee shorthand.
     * _.sortedLastIndexBy(objects, { 'x': 4 }, 'x');
     * // => 1
     */
    function sortedLastIndexBy(array, value, iteratee) {
      return baseSortedIndexBy(array, value, getIteratee(iteratee, 2), true);
    }

    /**
     * This method is like `_.lastIndexOf` except that it performs a binary
     * search on a sorted `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.sortedLastIndexOf([4, 5, 5, 5, 6], 5);
     * // => 3
     */
    function sortedLastIndexOf(array, value) {
      var length = array == null ? 0 : array.length;
      if (length) {
        var index = baseSortedIndex(array, value, true) - 1;
        if (eq(array[index], value)) {
          return index;
        }
      }
      return -1;
    }

    /**
     * This method is like `_.uniq` except that it's designed and optimized
     * for sorted arrays.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.sortedUniq([1, 1, 2]);
     * // => [1, 2]
     */
    function sortedUniq(array) {
      return (array && array.length)
        ? baseSortedUniq(array)
        : [];
    }

    /**
     * This method is like `_.uniqBy` except that it's designed and optimized
     * for sorted arrays.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.sortedUniqBy([1.1, 1.2, 2.3, 2.4], Math.floor);
     * // => [1.1, 2.3]
     */
    function sortedUniqBy(array, iteratee) {
      return (array && array.length)
        ? baseSortedUniq(array, getIteratee(iteratee, 2))
        : [];
    }

    /**
     * Gets all but the first element of `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.tail([1, 2, 3]);
     * // => [2, 3]
     */
    function tail(array) {
      var length = array == null ? 0 : array.length;
      return length ? baseSlice(array, 1, length) : [];
    }

    /**
     * Creates a slice of `array` with `n` elements taken from the beginning.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to take.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.take([1, 2, 3]);
     * // => [1]
     *
     * _.take([1, 2, 3], 2);
     * // => [1, 2]
     *
     * _.take([1, 2, 3], 5);
     * // => [1, 2, 3]
     *
     * _.take([1, 2, 3], 0);
     * // => []
     */
    function take(array, n, guard) {
      if (!(array && array.length)) {
        return [];
      }
      n = (guard || n === undefined) ? 1 : toInteger(n);
      return baseSlice(array, 0, n < 0 ? 0 : n);
    }

    /**
     * Creates a slice of `array` with `n` elements taken from the end.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to take.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.takeRight([1, 2, 3]);
     * // => [3]
     *
     * _.takeRight([1, 2, 3], 2);
     * // => [2, 3]
     *
     * _.takeRight([1, 2, 3], 5);
     * // => [1, 2, 3]
     *
     * _.takeRight([1, 2, 3], 0);
     * // => []
     */
    function takeRight(array, n, guard) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      n = (guard || n === undefined) ? 1 : toInteger(n);
      n = length - n;
      return baseSlice(array, n < 0 ? 0 : n, length);
    }

    /**
     * Creates a slice of `array` with elements taken from the end. Elements are
     * taken until `predicate` returns falsey. The predicate is invoked with
     * three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.takeRightWhile(users, function(o) { return !o.active; });
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.matches` iteratee shorthand.
     * _.takeRightWhile(users, { 'user': 'pebbles', 'active': false });
     * // => objects for ['pebbles']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.takeRightWhile(users, ['active', false]);
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.property` iteratee shorthand.
     * _.takeRightWhile(users, 'active');
     * // => []
     */
    function takeRightWhile(array, predicate) {
      return (array && array.length)
        ? baseWhile(array, getIteratee(predicate, 3), false, true)
        : [];
    }

    /**
     * Creates a slice of `array` with elements taken from the beginning. Elements
     * are taken until `predicate` returns falsey. The predicate is invoked with
     * three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.takeWhile(users, function(o) { return !o.active; });
     * // => objects for ['barney', 'fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.takeWhile(users, { 'user': 'barney', 'active': false });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.takeWhile(users, ['active', false]);
     * // => objects for ['barney', 'fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.takeWhile(users, 'active');
     * // => []
     */
    function takeWhile(array, predicate) {
      return (array && array.length)
        ? baseWhile(array, getIteratee(predicate, 3))
        : [];
    }

    /**
     * Creates an array of unique values, in order, from all given arrays using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * _.union([2], [1, 2]);
     * // => [2, 1]
     */
    var union = baseRest(function(arrays) {
      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
    });

    /**
     * This method is like `_.union` except that it accepts `iteratee` which is
     * invoked for each element of each `arrays` to generate the criterion by
     * which uniqueness is computed. Result values are chosen from the first
     * array in which the value occurs. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * _.unionBy([2.1], [1.2, 2.3], Math.floor);
     * // => [2.1, 1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.unionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */
    var unionBy = baseRest(function(arrays) {
      var iteratee = last(arrays);
      if (isArrayLikeObject(iteratee)) {
        iteratee = undefined;
      }
      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee, 2));
    });

    /**
     * This method is like `_.union` except that it accepts `comparator` which
     * is invoked to compare elements of `arrays`. Result values are chosen from
     * the first array in which the value occurs. The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.unionWith(objects, others, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
     */
    var unionWith = baseRest(function(arrays) {
      var comparator = last(arrays);
      comparator = typeof comparator == 'function' ? comparator : undefined;
      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined, comparator);
    });

    /**
     * Creates a duplicate-free version of an array, using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons, in which only the first occurrence of each element
     * is kept. The order of result values is determined by the order they occur
     * in the array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.uniq([2, 1, 2]);
     * // => [2, 1]
     */
    function uniq(array) {
      return (array && array.length) ? baseUniq(array) : [];
    }

    /**
     * This method is like `_.uniq` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * uniqueness is computed. The order of result values is determined by the
     * order they occur in the array. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.uniqBy([2.1, 1.2, 2.3], Math.floor);
     * // => [2.1, 1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */
    function uniqBy(array, iteratee) {
      return (array && array.length) ? baseUniq(array, getIteratee(iteratee, 2)) : [];
    }

    /**
     * This method is like `_.uniq` except that it accepts `comparator` which
     * is invoked to compare elements of `array`. The order of result values is
     * determined by the order they occur in the array.The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.uniqWith(objects, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]
     */
    function uniqWith(array, comparator) {
      comparator = typeof comparator == 'function' ? comparator : undefined;
      return (array && array.length) ? baseUniq(array, undefined, comparator) : [];
    }

    /**
     * This method is like `_.zip` except that it accepts an array of grouped
     * elements and creates an array regrouping the elements to their pre-zip
     * configuration.
     *
     * @static
     * @memberOf _
     * @since 1.2.0
     * @category Array
     * @param {Array} array The array of grouped elements to process.
     * @returns {Array} Returns the new array of regrouped elements.
     * @example
     *
     * var zipped = _.zip(['a', 'b'], [1, 2], [true, false]);
     * // => [['a', 1, true], ['b', 2, false]]
     *
     * _.unzip(zipped);
     * // => [['a', 'b'], [1, 2], [true, false]]
     */
    function unzip(array) {
      if (!(array && array.length)) {
        return [];
      }
      var length = 0;
      array = arrayFilter(array, function(group) {
        if (isArrayLikeObject(group)) {
          length = nativeMax(group.length, length);
          return true;
        }
      });
      return baseTimes(length, function(index) {
        return arrayMap(array, baseProperty(index));
      });
    }

    /**
     * This method is like `_.unzip` except that it accepts `iteratee` to specify
     * how regrouped values should be combined. The iteratee is invoked with the
     * elements of each group: (...group).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Array
     * @param {Array} array The array of grouped elements to process.
     * @param {Function} [iteratee=_.identity] The function to combine
     *  regrouped values.
     * @returns {Array} Returns the new array of regrouped elements.
     * @example
     *
     * var zipped = _.zip([1, 2], [10, 20], [100, 200]);
     * // => [[1, 10, 100], [2, 20, 200]]
     *
     * _.unzipWith(zipped, _.add);
     * // => [3, 30, 300]
     */
    function unzipWith(array, iteratee) {
      if (!(array && array.length)) {
        return [];
      }
      var result = unzip(array);
      if (iteratee == null) {
        return result;
      }
      return arrayMap(result, function(group) {
        return apply(iteratee, undefined, group);
      });
    }

    /**
     * Creates an array excluding all given values using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * **Note:** Unlike `_.pull`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...*} [values] The values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.difference, _.xor
     * @example
     *
     * _.without([2, 1, 2, 3], 1, 2);
     * // => [3]
     */
    var without = baseRest(function(array, values) {
      return isArrayLikeObject(array)
        ? baseDifference(array, values)
        : [];
    });

    /**
     * Creates an array of unique values that is the
     * [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
     * of the given arrays. The order of result values is determined by the order
     * they occur in the arrays.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.difference, _.without
     * @example
     *
     * _.xor([2, 1], [2, 3]);
     * // => [1, 3]
     */
    var xor = baseRest(function(arrays) {
      return baseXor(arrayFilter(arrays, isArrayLikeObject));
    });

    /**
     * This method is like `_.xor` except that it accepts `iteratee` which is
     * invoked for each element of each `arrays` to generate the criterion by
     * which by which they're compared. The order of result values is determined
     * by the order they occur in the arrays. The iteratee is invoked with one
     * argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.xorBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [1.2, 3.4]
     *
     * // The `_.property` iteratee shorthand.
     * _.xorBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 2 }]
     */
    var xorBy = baseRest(function(arrays) {
      var iteratee = last(arrays);
      if (isArrayLikeObject(iteratee)) {
        iteratee = undefined;
      }
      return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee, 2));
    });

    /**
     * This method is like `_.xor` except that it accepts `comparator` which is
     * invoked to compare elements of `arrays`. The order of result values is
     * determined by the order they occur in the arrays. The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.xorWith(objects, others, _.isEqual);
     * // => [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
     */
    var xorWith = baseRest(function(arrays) {
      var comparator = last(arrays);
      comparator = typeof comparator == 'function' ? comparator : undefined;
      return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined, comparator);
    });

    /**
     * Creates an array of grouped elements, the first of which contains the
     * first elements of the given arrays, the second of which contains the
     * second elements of the given arrays, and so on.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to process.
     * @returns {Array} Returns the new array of grouped elements.
     * @example
     *
     * _.zip(['a', 'b'], [1, 2], [true, false]);
     * // => [['a', 1, true], ['b', 2, false]]
     */
    var zip = baseRest(unzip);

    /**
     * This method is like `_.fromPairs` except that it accepts two arrays,
     * one of property identifiers and one of corresponding values.
     *
     * @static
     * @memberOf _
     * @since 0.4.0
     * @category Array
     * @param {Array} [props=[]] The property identifiers.
     * @param {Array} [values=[]] The property values.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.zipObject(['a', 'b'], [1, 2]);
     * // => { 'a': 1, 'b': 2 }
     */
    function zipObject(props, values) {
      return baseZipObject(props || [], values || [], assignValue);
    }

    /**
     * This method is like `_.zipObject` except that it supports property paths.
     *
     * @static
     * @memberOf _
     * @since 4.1.0
     * @category Array
     * @param {Array} [props=[]] The property identifiers.
     * @param {Array} [values=[]] The property values.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.zipObjectDeep(['a.b[0].c', 'a.b[1].d'], [1, 2]);
     * // => { 'a': { 'b': [{ 'c': 1 }, { 'd': 2 }] } }
     */
    function zipObjectDeep(props, values) {
      return baseZipObject(props || [], values || [], baseSet);
    }

    /**
     * This method is like `_.zip` except that it accepts `iteratee` to specify
     * how grouped values should be combined. The iteratee is invoked with the
     * elements of each group: (...group).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Array
     * @param {...Array} [arrays] The arrays to process.
     * @param {Function} [iteratee=_.identity] The function to combine
     *  grouped values.
     * @returns {Array} Returns the new array of grouped elements.
     * @example
     *
     * _.zipWith([1, 2], [10, 20], [100, 200], function(a, b, c) {
     *   return a + b + c;
     * });
     * // => [111, 222]
     */
    var zipWith = baseRest(function(arrays) {
      var length = arrays.length,
          iteratee = length > 1 ? arrays[length - 1] : undefined;

      iteratee = typeof iteratee == 'function' ? (arrays.pop(), iteratee) : undefined;
      return unzipWith(arrays, iteratee);
    });

    /*------------------------------------------------------------------------*/

    /**
     * Creates a `lodash` wrapper instance that wraps `value` with explicit method
     * chain sequences enabled. The result of such sequences must be unwrapped
     * with `_#value`.
     *
     * @static
     * @memberOf _
     * @since 1.3.0
     * @category Seq
     * @param {*} value The value to wrap.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36 },
     *   { 'user': 'fred',    'age': 40 },
     *   { 'user': 'pebbles', 'age': 1 }
     * ];
     *
     * var youngest = _
     *   .chain(users)
     *   .sortBy('age')
     *   .map(function(o) {
     *     return o.user + ' is ' + o.age;
     *   })
     *   .head()
     *   .value();
     * // => 'pebbles is 1'
     */
    function chain(value) {
      var result = lodash(value);
      result.__chain__ = true;
      return result;
    }

    /**
     * This method invokes `interceptor` and returns `value`. The interceptor
     * is invoked with one argument; (value). The purpose of this method is to
     * "tap into" a method chain sequence in order to modify intermediate results.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @returns {*} Returns `value`.
     * @example
     *
     * _([1, 2, 3])
     *  .tap(function(array) {
     *    // Mutate input array.
     *    array.pop();
     *  })
     *  .reverse()
     *  .value();
     * // => [2, 1]
     */
    function tap(value, interceptor) {
      interceptor(value);
      return value;
    }

    /**
     * This method is like `_.tap` except that it returns the result of `interceptor`.
     * The purpose of this method is to "pass thru" values replacing intermediate
     * results in a method chain sequence.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Seq
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @returns {*} Returns the result of `interceptor`.
     * @example
     *
     * _('  abc  ')
     *  .chain()
     *  .trim()
     *  .thru(function(value) {
     *    return [value];
     *  })
     *  .value();
     * // => ['abc']
     */
    function thru(value, interceptor) {
      return interceptor(value);
    }

    /**
     * This method is the wrapper version of `_.at`.
     *
     * @name at
     * @memberOf _
     * @since 1.0.0
     * @category Seq
     * @param {...(string|string[])} [paths] The property paths to pick.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
     *
     * _(object).at(['a[0].b.c', 'a[1]']).value();
     * // => [3, 4]
     */
    var wrapperAt = flatRest(function(paths) {
      var length = paths.length,
          start = length ? paths[0] : 0,
          value = this.__wrapped__,
          interceptor = function(object) { return baseAt(object, paths); };

      if (length > 1 || this.__actions__.length ||
          !(value instanceof LazyWrapper) || !isIndex(start)) {
        return this.thru(interceptor);
      }
      value = value.slice(start, +start + (length ? 1 : 0));
      value.__actions__.push({
        'func': thru,
        'args': [interceptor],
        'thisArg': undefined
      });
      return new LodashWrapper(value, this.__chain__).thru(function(array) {
        if (length && !array.length) {
          array.push(undefined);
        }
        return array;
      });
    });

    /**
     * Creates a `lodash` wrapper instance with explicit method chain sequences enabled.
     *
     * @name chain
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * // A sequence without explicit chaining.
     * _(users).head();
     * // => { 'user': 'barney', 'age': 36 }
     *
     * // A sequence with explicit chaining.
     * _(users)
     *   .chain()
     *   .head()
     *   .pick('user')
     *   .value();
     * // => { 'user': 'barney' }
     */
    function wrapperChain() {
      return chain(this);
    }

    /**
     * Executes the chain sequence and returns the wrapped result.
     *
     * @name commit
     * @memberOf _
     * @since 3.2.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2];
     * var wrapped = _(array).push(3);
     *
     * console.log(array);
     * // => [1, 2]
     *
     * wrapped = wrapped.commit();
     * console.log(array);
     * // => [1, 2, 3]
     *
     * wrapped.last();
     * // => 3
     *
     * console.log(array);
     * // => [1, 2, 3]
     */
    function wrapperCommit() {
      return new LodashWrapper(this.value(), this.__chain__);
    }

    /**
     * Gets the next value on a wrapped object following the
     * [iterator protocol](https://mdn.io/iteration_protocols#iterator).
     *
     * @name next
     * @memberOf _
     * @since 4.0.0
     * @category Seq
     * @returns {Object} Returns the next iterator value.
     * @example
     *
     * var wrapped = _([1, 2]);
     *
     * wrapped.next();
     * // => { 'done': false, 'value': 1 }
     *
     * wrapped.next();
     * // => { 'done': false, 'value': 2 }
     *
     * wrapped.next();
     * // => { 'done': true, 'value': undefined }
     */
    function wrapperNext() {
      if (this.__values__ === undefined) {
        this.__values__ = toArray(this.value());
      }
      var done = this.__index__ >= this.__values__.length,
          value = done ? undefined : this.__values__[this.__index__++];

      return { 'done': done, 'value': value };
    }

    /**
     * Enables the wrapper to be iterable.
     *
     * @name Symbol.iterator
     * @memberOf _
     * @since 4.0.0
     * @category Seq
     * @returns {Object} Returns the wrapper object.
     * @example
     *
     * var wrapped = _([1, 2]);
     *
     * wrapped[Symbol.iterator]() === wrapped;
     * // => true
     *
     * Array.from(wrapped);
     * // => [1, 2]
     */
    function wrapperToIterator() {
      return this;
    }

    /**
     * Creates a clone of the chain sequence planting `value` as the wrapped value.
     *
     * @name plant
     * @memberOf _
     * @since 3.2.0
     * @category Seq
     * @param {*} value The value to plant.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var wrapped = _([1, 2]).map(square);
     * var other = wrapped.plant([3, 4]);
     *
     * other.value();
     * // => [9, 16]
     *
     * wrapped.value();
     * // => [1, 4]
     */
    function wrapperPlant(value) {
      var result,
          parent = this;

      while (parent instanceof baseLodash) {
        var clone = wrapperClone(parent);
        clone.__index__ = 0;
        clone.__values__ = undefined;
        if (result) {
          previous.__wrapped__ = clone;
        } else {
          result = clone;
        }
        var previous = clone;
        parent = parent.__wrapped__;
      }
      previous.__wrapped__ = value;
      return result;
    }

    /**
     * This method is the wrapper version of `_.reverse`.
     *
     * **Note:** This method mutates the wrapped array.
     *
     * @name reverse
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _(array).reverse().value()
     * // => [3, 2, 1]
     *
     * console.log(array);
     * // => [3, 2, 1]
     */
    function wrapperReverse() {
      var value = this.__wrapped__;
      if (value instanceof LazyWrapper) {
        var wrapped = value;
        if (this.__actions__.length) {
          wrapped = new LazyWrapper(this);
        }
        wrapped = wrapped.reverse();
        wrapped.__actions__.push({
          'func': thru,
          'args': [reverse],
          'thisArg': undefined
        });
        return new LodashWrapper(wrapped, this.__chain__);
      }
      return this.thru(reverse);
    }

    /**
     * Executes the chain sequence to resolve the unwrapped value.
     *
     * @name value
     * @memberOf _
     * @since 0.1.0
     * @alias toJSON, valueOf
     * @category Seq
     * @returns {*} Returns the resolved unwrapped value.
     * @example
     *
     * _([1, 2, 3]).value();
     * // => [1, 2, 3]
     */
    function wrapperValue() {
      return baseWrapperValue(this.__wrapped__, this.__actions__);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The corresponding value of
     * each key is the number of times the key was returned by `iteratee`. The
     * iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.countBy([6.1, 4.2, 6.3], Math.floor);
     * // => { '4': 1, '6': 2 }
     *
     * // The `_.property` iteratee shorthand.
     * _.countBy(['one', 'two', 'three'], 'length');
     * // => { '3': 2, '5': 1 }
     */
    var countBy = createAggregator(function(result, value, key) {
      if (hasOwnProperty.call(result, key)) {
        ++result[key];
      } else {
        baseAssignValue(result, key, 1);
      }
    });

    /**
     * Checks if `predicate` returns truthy for **all** elements of `collection`.
     * Iteration is stopped once `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index|key, collection).
     *
     * **Note:** This method returns `true` for
     * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because
     * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of
     * elements of empty collections.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`.
     * @example
     *
     * _.every([true, 1, null, 'yes'], Boolean);
     * // => false
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': false },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.every(users, { 'user': 'barney', 'active': false });
     * // => false
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.every(users, ['active', false]);
     * // => true
     *
     * // The `_.property` iteratee shorthand.
     * _.every(users, 'active');
     * // => false
     */
    function every(collection, predicate, guard) {
      var func = isArray(collection) ? arrayEvery : baseEvery;
      if (guard && isIterateeCall(collection, predicate, guard)) {
        predicate = undefined;
      }
      return func(collection, getIteratee(predicate, 3));
    }

    /**
     * Iterates over elements of `collection`, returning an array of all elements
     * `predicate` returns truthy for. The predicate is invoked with three
     * arguments: (value, index|key, collection).
     *
     * **Note:** Unlike `_.remove`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     * @see _.reject
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * _.filter(users, function(o) { return !o.active; });
     * // => objects for ['fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.filter(users, { 'age': 36, 'active': true });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.filter(users, ['active', false]);
     * // => objects for ['fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.filter(users, 'active');
     * // => objects for ['barney']
     *
     * // Combining several predicates using `_.overEvery` or `_.overSome`.
     * _.filter(users, _.overSome([{ 'age': 36 }, ['age', 40]]));
     * // => objects for ['fred', 'barney']
     */
    function filter(collection, predicate) {
      var func = isArray(collection) ? arrayFilter : baseFilter;
      return func(collection, getIteratee(predicate, 3));
    }

    /**
     * Iterates over elements of `collection`, returning the first element
     * `predicate` returns truthy for. The predicate is invoked with three
     * arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36, 'active': true },
     *   { 'user': 'fred',    'age': 40, 'active': false },
     *   { 'user': 'pebbles', 'age': 1,  'active': true }
     * ];
     *
     * _.find(users, function(o) { return o.age < 40; });
     * // => object for 'barney'
     *
     * // The `_.matches` iteratee shorthand.
     * _.find(users, { 'age': 1, 'active': true });
     * // => object for 'pebbles'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.find(users, ['active', false]);
     * // => object for 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.find(users, 'active');
     * // => object for 'barney'
     */
    var find = createFind(findIndex);

    /**
     * This method is like `_.find` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=collection.length-1] The index to search from.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * _.findLast([1, 2, 3, 4], function(n) {
     *   return n % 2 == 1;
     * });
     * // => 3
     */
    var findLast = createFind(findLastIndex);

    /**
     * Creates a flattened array of values by running each element in `collection`
     * thru `iteratee` and flattening the mapped results. The iteratee is invoked
     * with three arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [n, n];
     * }
     *
     * _.flatMap([1, 2], duplicate);
     * // => [1, 1, 2, 2]
     */
    function flatMap(collection, iteratee) {
      return baseFlatten(map(collection, iteratee), 1);
    }

    /**
     * This method is like `_.flatMap` except that it recursively flattens the
     * mapped results.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [[[n, n]]];
     * }
     *
     * _.flatMapDeep([1, 2], duplicate);
     * // => [1, 1, 2, 2]
     */
    function flatMapDeep(collection, iteratee) {
      return baseFlatten(map(collection, iteratee), INFINITY);
    }

    /**
     * This method is like `_.flatMap` except that it recursively flattens the
     * mapped results up to `depth` times.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {number} [depth=1] The maximum recursion depth.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [[[n, n]]];
     * }
     *
     * _.flatMapDepth([1, 2], duplicate, 2);
     * // => [[1, 1], [2, 2]]
     */
    function flatMapDepth(collection, iteratee, depth) {
      depth = depth === undefined ? 1 : toInteger(depth);
      return baseFlatten(map(collection, iteratee), depth);
    }

    /**
     * Iterates over elements of `collection` and invokes `iteratee` for each element.
     * The iteratee is invoked with three arguments: (value, index|key, collection).
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * **Note:** As with other "Collections" methods, objects with a "length"
     * property are iterated like arrays. To avoid this behavior use `_.forIn`
     * or `_.forOwn` for object iteration.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @alias each
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     * @see _.forEachRight
     * @example
     *
     * _.forEach([1, 2], function(value) {
     *   console.log(value);
     * });
     * // => Logs `1` then `2`.
     *
     * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
     */
    function forEach(collection, iteratee) {
      var func = isArray(collection) ? arrayEach : baseEach;
      return func(collection, getIteratee(iteratee, 3));
    }

    /**
     * This method is like `_.forEach` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @alias eachRight
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     * @see _.forEach
     * @example
     *
     * _.forEachRight([1, 2], function(value) {
     *   console.log(value);
     * });
     * // => Logs `2` then `1`.
     */
    function forEachRight(collection, iteratee) {
      var func = isArray(collection) ? arrayEachRight : baseEachRight;
      return func(collection, getIteratee(iteratee, 3));
    }

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The order of grouped values
     * is determined by the order they occur in `collection`. The corresponding
     * value of each key is an array of elements responsible for generating the
     * key. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.groupBy([6.1, 4.2, 6.3], Math.floor);
     * // => { '4': [4.2], '6': [6.1, 6.3] }
     *
     * // The `_.property` iteratee shorthand.
     * _.groupBy(['one', 'two', 'three'], 'length');
     * // => { '3': ['one', 'two'], '5': ['three'] }
     */
    var groupBy = createAggregator(function(result, value, key) {
      if (hasOwnProperty.call(result, key)) {
        result[key].push(value);
      } else {
        baseAssignValue(result, key, [value]);
      }
    });

    /**
     * Checks if `value` is in `collection`. If `collection` is a string, it's
     * checked for a substring of `value`, otherwise
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * is used for equality comparisons. If `fromIndex` is negative, it's used as
     * the offset from the end of `collection`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object|string} collection The collection to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=0] The index to search from.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
     * @returns {boolean} Returns `true` if `value` is found, else `false`.
     * @example
     *
     * _.includes([1, 2, 3], 1);
     * // => true
     *
     * _.includes([1, 2, 3], 1, 2);
     * // => false
     *
     * _.includes({ 'a': 1, 'b': 2 }, 1);
     * // => true
     *
     * _.includes('abcd', 'bc');
     * // => true
     */
    function includes(collection, value, fromIndex, guard) {
      collection = isArrayLike(collection) ? collection : values(collection);
      fromIndex = (fromIndex && !guard) ? toInteger(fromIndex) : 0;

      var length = collection.length;
      if (fromIndex < 0) {
        fromIndex = nativeMax(length + fromIndex, 0);
      }
      return isString(collection)
        ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1)
        : (!!length && baseIndexOf(collection, value, fromIndex) > -1);
    }

    /**
     * Invokes the method at `path` of each element in `collection`, returning
     * an array of the results of each invoked method. Any additional arguments
     * are provided to each invoked method. If `path` is a function, it's invoked
     * for, and `this` bound to, each element in `collection`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Array|Function|string} path The path of the method to invoke or
     *  the function invoked per iteration.
     * @param {...*} [args] The arguments to invoke each method with.
     * @returns {Array} Returns the array of results.
     * @example
     *
     * _.invokeMap([[5, 1, 7], [3, 2, 1]], 'sort');
     * // => [[1, 5, 7], [1, 2, 3]]
     *
     * _.invokeMap([123, 456], String.prototype.split, '');
     * // => [['1', '2', '3'], ['4', '5', '6']]
     */
    var invokeMap = baseRest(function(collection, path, args) {
      var index = -1,
          isFunc = typeof path == 'function',
          result = isArrayLike(collection) ? Array(collection.length) : [];

      baseEach(collection, function(value) {
        result[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
      });
      return result;
    });

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The corresponding value of
     * each key is the last element responsible for generating the key. The
     * iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * var array = [
     *   { 'dir': 'left', 'code': 97 },
     *   { 'dir': 'right', 'code': 100 }
     * ];
     *
     * _.keyBy(array, function(o) {
     *   return String.fromCharCode(o.code);
     * });
     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
     *
     * _.keyBy(array, 'dir');
     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
     */
    var keyBy = createAggregator(function(result, value, key) {
      baseAssignValue(result, key, value);
    });

    /**
     * Creates an array of values by running each element in `collection` thru
     * `iteratee`. The iteratee is invoked with three arguments:
     * (value, index|key, collection).
     *
     * Many lodash methods are guarded to work as iteratees for methods like
     * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
     *
     * The guarded methods are:
     * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
     * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
     * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
     * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * _.map([4, 8], square);
     * // => [16, 64]
     *
     * _.map({ 'a': 4, 'b': 8 }, square);
     * // => [16, 64] (iteration order is not guaranteed)
     *
     * var users = [
     *   { 'user': 'barney' },
     *   { 'user': 'fred' }
     * ];
     *
     * // The `_.property` iteratee shorthand.
     * _.map(users, 'user');
     * // => ['barney', 'fred']
     */
    function map(collection, iteratee) {
      var func = isArray(collection) ? arrayMap : baseMap;
      return func(collection, getIteratee(iteratee, 3));
    }

    /**
     * This method is like `_.sortBy` except that it allows specifying the sort
     * orders of the iteratees to sort by. If `orders` is unspecified, all values
     * are sorted in ascending order. Otherwise, specify an order of "desc" for
     * descending or "asc" for ascending sort order of corresponding values.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Array[]|Function[]|Object[]|string[]} [iteratees=[_.identity]]
     *  The iteratees to sort by.
     * @param {string[]} [orders] The sort orders of `iteratees`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * var users = [
     *   { 'user': 'fred',   'age': 48 },
     *   { 'user': 'barney', 'age': 34 },
     *   { 'user': 'fred',   'age': 40 },
     *   { 'user': 'barney', 'age': 36 }
     * ];
     *
     * // Sort by `user` in ascending order and by `age` in descending order.
     * _.orderBy(users, ['user', 'age'], ['asc', 'desc']);
     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
     */
    function orderBy(collection, iteratees, orders, guard) {
      if (collection == null) {
        return [];
      }
      if (!isArray(iteratees)) {
        iteratees = iteratees == null ? [] : [iteratees];
      }
      orders = guard ? undefined : orders;
      if (!isArray(orders)) {
        orders = orders == null ? [] : [orders];
      }
      return baseOrderBy(collection, iteratees, orders);
    }

    /**
     * Creates an array of elements split into two groups, the first of which
     * contains elements `predicate` returns truthy for, the second of which
     * contains elements `predicate` returns falsey for. The predicate is
     * invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the array of grouped elements.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36, 'active': false },
     *   { 'user': 'fred',    'age': 40, 'active': true },
     *   { 'user': 'pebbles', 'age': 1,  'active': false }
     * ];
     *
     * _.partition(users, function(o) { return o.active; });
     * // => objects for [['fred'], ['barney', 'pebbles']]
     *
     * // The `_.matches` iteratee shorthand.
     * _.partition(users, { 'age': 1, 'active': false });
     * // => objects for [['pebbles'], ['barney', 'fred']]
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.partition(users, ['active', false]);
     * // => objects for [['barney', 'pebbles'], ['fred']]
     *
     * // The `_.property` iteratee shorthand.
     * _.partition(users, 'active');
     * // => objects for [['fred'], ['barney', 'pebbles']]
     */
    var partition = createAggregator(function(result, value, key) {
      result[key ? 0 : 1].push(value);
    }, function() { return [[], []]; });

    /**
     * Reduces `collection` to a value which is the accumulated result of running
     * each element in `collection` thru `iteratee`, where each successive
     * invocation is supplied the return value of the previous. If `accumulator`
     * is not given, the first element of `collection` is used as the initial
     * value. The iteratee is invoked with four arguments:
     * (accumulator, value, index|key, collection).
     *
     * Many lodash methods are guarded to work as iteratees for methods like
     * `_.reduce`, `_.reduceRight`, and `_.transform`.
     *
     * The guarded methods are:
     * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,
     * and `sortBy`
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @returns {*} Returns the accumulated value.
     * @see _.reduceRight
     * @example
     *
     * _.reduce([1, 2], function(sum, n) {
     *   return sum + n;
     * }, 0);
     * // => 3
     *
     * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
     *   (result[value] || (result[value] = [])).push(key);
     *   return result;
     * }, {});
     * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)
     */
    function reduce(collection, iteratee, accumulator) {
      var func = isArray(collection) ? arrayReduce : baseReduce,
          initAccum = arguments.length < 3;

      return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEach);
    }

    /**
     * This method is like `_.reduce` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @returns {*} Returns the accumulated value.
     * @see _.reduce
     * @example
     *
     * var array = [[0, 1], [2, 3], [4, 5]];
     *
     * _.reduceRight(array, function(flattened, other) {
     *   return flattened.concat(other);
     * }, []);
     * // => [4, 5, 2, 3, 0, 1]
     */
    function reduceRight(collection, iteratee, accumulator) {
      var func = isArray(collection) ? arrayReduceRight : baseReduce,
          initAccum = arguments.length < 3;

      return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEachRight);
    }

    /**
     * The opposite of `_.filter`; this method returns the elements of `collection`
     * that `predicate` does **not** return truthy for.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     * @see _.filter
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': false },
     *   { 'user': 'fred',   'age': 40, 'active': true }
     * ];
     *
     * _.reject(users, function(o) { return !o.active; });
     * // => objects for ['fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.reject(users, { 'age': 40, 'active': true });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.reject(users, ['active', false]);
     * // => objects for ['fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.reject(users, 'active');
     * // => objects for ['barney']
     */
    function reject(collection, predicate) {
      var func = isArray(collection) ? arrayFilter : baseFilter;
      return func(collection, negate(getIteratee(predicate, 3)));
    }

    /**
     * Gets a random element from `collection`.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to sample.
     * @returns {*} Returns the random element.
     * @example
     *
     * _.sample([1, 2, 3, 4]);
     * // => 2
     */
    function sample(collection) {
      var func = isArray(collection) ? arraySample : baseSample;
      return func(collection);
    }

    /**
     * Gets `n` random elements at unique keys from `collection` up to the
     * size of `collection`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to sample.
     * @param {number} [n=1] The number of elements to sample.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the random elements.
     * @example
     *
     * _.sampleSize([1, 2, 3], 2);
     * // => [3, 1]
     *
     * _.sampleSize([1, 2, 3], 4);
     * // => [2, 3, 1]
     */
    function sampleSize(collection, n, guard) {
      if ((guard ? isIterateeCall(collection, n, guard) : n === undefined)) {
        n = 1;
      } else {
        n = toInteger(n);
      }
      var func = isArray(collection) ? arraySampleSize : baseSampleSize;
      return func(collection, n);
    }

    /**
     * Creates an array of shuffled values, using a version of the
     * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to shuffle.
     * @returns {Array} Returns the new shuffled array.
     * @example
     *
     * _.shuffle([1, 2, 3, 4]);
     * // => [4, 1, 3, 2]
     */
    function shuffle(collection) {
      var func = isArray(collection) ? arrayShuffle : baseShuffle;
      return func(collection);
    }

    /**
     * Gets the size of `collection` by returning its length for array-like
     * values or the number of own enumerable string keyed properties for objects.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object|string} collection The collection to inspect.
     * @returns {number} Returns the collection size.
     * @example
     *
     * _.size([1, 2, 3]);
     * // => 3
     *
     * _.size({ 'a': 1, 'b': 2 });
     * // => 2
     *
     * _.size('pebbles');
     * // => 7
     */
    function size(collection) {
      if (collection == null) {
        return 0;
      }
      if (isArrayLike(collection)) {
        return isString(collection) ? stringSize(collection) : collection.length;
      }
      var tag = getTag(collection);
      if (tag == mapTag || tag == setTag) {
        return collection.size;
      }
      return baseKeys(collection).length;
    }

    /**
     * Checks if `predicate` returns truthy for **any** element of `collection`.
     * Iteration is stopped once `predicate` returns truthy. The predicate is
     * invoked with three arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     * @example
     *
     * _.some([null, 0, 'yes', false], Boolean);
     * // => true
     *
     * var users = [
     *   { 'user': 'barney', 'active': true },
     *   { 'user': 'fred',   'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.some(users, { 'user': 'barney', 'active': false });
     * // => false
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.some(users, ['active', false]);
     * // => true
     *
     * // The `_.property` iteratee shorthand.
     * _.some(users, 'active');
     * // => true
     */
    function some(collection, predicate, guard) {
      var func = isArray(collection) ? arraySome : baseSome;
      if (guard && isIterateeCall(collection, predicate, guard)) {
        predicate = undefined;
      }
      return func(collection, getIteratee(predicate, 3));
    }

    /**
     * Creates an array of elements, sorted in ascending order by the results of
     * running each element in a collection thru each iteratee. This method
     * performs a stable sort, that is, it preserves the original sort order of
     * equal elements. The iteratees are invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {...(Function|Function[])} [iteratees=[_.identity]]
     *  The iteratees to sort by.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * var users = [
     *   { 'user': 'fred',   'age': 48 },
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 30 },
     *   { 'user': 'barney', 'age': 34 }
     * ];
     *
     * _.sortBy(users, [function(o) { return o.user; }]);
     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 30]]
     *
     * _.sortBy(users, ['user', 'age']);
     * // => objects for [['barney', 34], ['barney', 36], ['fred', 30], ['fred', 48]]
     */
    var sortBy = baseRest(function(collection, iteratees) {
      if (collection == null) {
        return [];
      }
      var length = iteratees.length;
      if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
        iteratees = [];
      } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
        iteratees = [iteratees[0]];
      }
      return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
    });

    /*------------------------------------------------------------------------*/

    /**
     * Gets the timestamp of the number of milliseconds that have elapsed since
     * the Unix epoch (1 January 1970 00:00:00 UTC).
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Date
     * @returns {number} Returns the timestamp.
     * @example
     *
     * _.defer(function(stamp) {
     *   console.log(_.now() - stamp);
     * }, _.now());
     * // => Logs the number of milliseconds it took for the deferred invocation.
     */
    var now = ctxNow || function() {
      return root.Date.now();
    };

    /*------------------------------------------------------------------------*/

    /**
     * The opposite of `_.before`; this method creates a function that invokes
     * `func` once it's called `n` or more times.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {number} n The number of calls before `func` is invoked.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var saves = ['profile', 'settings'];
     *
     * var done = _.after(saves.length, function() {
     *   console.log('done saving!');
     * });
     *
     * _.forEach(saves, function(type) {
     *   asyncSave({ 'type': type, 'complete': done });
     * });
     * // => Logs 'done saving!' after the two async saves have completed.
     */
    function after(n, func) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      n = toInteger(n);
      return function() {
        if (--n < 1) {
          return func.apply(this, arguments);
        }
      };
    }

    /**
     * Creates a function that invokes `func`, with up to `n` arguments,
     * ignoring any additional arguments.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to cap arguments for.
     * @param {number} [n=func.length] The arity cap.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new capped function.
     * @example
     *
     * _.map(['6', '8', '10'], _.ary(parseInt, 1));
     * // => [6, 8, 10]
     */
    function ary(func, n, guard) {
      n = guard ? undefined : n;
      n = (func && n == null) ? func.length : n;
      return createWrap(func, WRAP_ARY_FLAG, undefined, undefined, undefined, undefined, n);
    }

    /**
     * Creates a function that invokes `func`, with the `this` binding and arguments
     * of the created function, while it's called less than `n` times. Subsequent
     * calls to the created function return the result of the last `func` invocation.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {number} n The number of calls at which `func` is no longer invoked.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * jQuery(element).on('click', _.before(5, addContactToList));
     * // => Allows adding up to 4 contacts to the list.
     */
    function before(n, func) {
      var result;
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      n = toInteger(n);
      return function() {
        if (--n > 0) {
          result = func.apply(this, arguments);
        }
        if (n <= 1) {
          func = undefined;
        }
        return result;
      };
    }

    /**
     * Creates a function that invokes `func` with the `this` binding of `thisArg`
     * and `partials` prepended to the arguments it receives.
     *
     * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
     * may be used as a placeholder for partially applied arguments.
     *
     * **Note:** Unlike native `Function#bind`, this method doesn't set the "length"
     * property of bound functions.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to bind.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * function greet(greeting, punctuation) {
     *   return greeting + ' ' + this.user + punctuation;
     * }
     *
     * var object = { 'user': 'fred' };
     *
     * var bound = _.bind(greet, object, 'hi');
     * bound('!');
     * // => 'hi fred!'
     *
     * // Bound with placeholders.
     * var bound = _.bind(greet, object, _, '!');
     * bound('hi');
     * // => 'hi fred!'
     */
    var bind = baseRest(function(func, thisArg, partials) {
      var bitmask = WRAP_BIND_FLAG;
      if (partials.length) {
        var holders = replaceHolders(partials, getHolder(bind));
        bitmask |= WRAP_PARTIAL_FLAG;
      }
      return createWrap(func, bitmask, thisArg, partials, holders);
    });

    /**
     * Creates a function that invokes the method at `object[key]` with `partials`
     * prepended to the arguments it receives.
     *
     * This method differs from `_.bind` by allowing bound functions to reference
     * methods that may be redefined or don't yet exist. See
     * [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)
     * for more details.
     *
     * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * @static
     * @memberOf _
     * @since 0.10.0
     * @category Function
     * @param {Object} object The object to invoke the method on.
     * @param {string} key The key of the method.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var object = {
     *   'user': 'fred',
     *   'greet': function(greeting, punctuation) {
     *     return greeting + ' ' + this.user + punctuation;
     *   }
     * };
     *
     * var bound = _.bindKey(object, 'greet', 'hi');
     * bound('!');
     * // => 'hi fred!'
     *
     * object.greet = function(greeting, punctuation) {
     *   return greeting + 'ya ' + this.user + punctuation;
     * };
     *
     * bound('!');
     * // => 'hiya fred!'
     *
     * // Bound with placeholders.
     * var bound = _.bindKey(object, 'greet', _, '!');
     * bound('hi');
     * // => 'hiya fred!'
     */
    var bindKey = baseRest(function(object, key, partials) {
      var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
      if (partials.length) {
        var holders = replaceHolders(partials, getHolder(bindKey));
        bitmask |= WRAP_PARTIAL_FLAG;
      }
      return createWrap(key, bitmask, object, partials, holders);
    });

    /**
     * Creates a function that accepts arguments of `func` and either invokes
     * `func` returning its result, if at least `arity` number of arguments have
     * been provided, or returns a function that accepts the remaining `func`
     * arguments, and so on. The arity of `func` may be specified if `func.length`
     * is not sufficient.
     *
     * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
     * may be used as a placeholder for provided arguments.
     *
     * **Note:** This method doesn't set the "length" property of curried functions.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Function
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var abc = function(a, b, c) {
     *   return [a, b, c];
     * };
     *
     * var curried = _.curry(abc);
     *
     * curried(1)(2)(3);
     * // => [1, 2, 3]
     *
     * curried(1, 2)(3);
     * // => [1, 2, 3]
     *
     * curried(1, 2, 3);
     * // => [1, 2, 3]
     *
     * // Curried with placeholders.
     * curried(1)(_, 3)(2);
     * // => [1, 2, 3]
     */
    function curry(func, arity, guard) {
      arity = guard ? undefined : arity;
      var result = createWrap(func, WRAP_CURRY_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
      result.placeholder = curry.placeholder;
      return result;
    }

    /**
     * This method is like `_.curry` except that arguments are applied to `func`
     * in the manner of `_.partialRight` instead of `_.partial`.
     *
     * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for provided arguments.
     *
     * **Note:** This method doesn't set the "length" property of curried functions.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var abc = function(a, b, c) {
     *   return [a, b, c];
     * };
     *
     * var curried = _.curryRight(abc);
     *
     * curried(3)(2)(1);
     * // => [1, 2, 3]
     *
     * curried(2, 3)(1);
     * // => [1, 2, 3]
     *
     * curried(1, 2, 3);
     * // => [1, 2, 3]
     *
     * // Curried with placeholders.
     * curried(3)(1, _)(2);
     * // => [1, 2, 3]
     */
    function curryRight(func, arity, guard) {
      arity = guard ? undefined : arity;
      var result = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
      result.placeholder = curryRight.placeholder;
      return result;
    }

    /**
     * Creates a debounced function that delays invoking `func` until after `wait`
     * milliseconds have elapsed since the last time the debounced function was
     * invoked. The debounced function comes with a `cancel` method to cancel
     * delayed `func` invocations and a `flush` method to immediately invoke them.
     * Provide `options` to indicate whether `func` should be invoked on the
     * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
     * with the last arguments provided to the debounced function. Subsequent
     * calls to the debounced function return the result of the last `func`
     * invocation.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is
     * invoked on the trailing edge of the timeout only if the debounced function
     * is invoked more than once during the `wait` timeout.
     *
     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
     *
     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
     * for details over the differences between `_.debounce` and `_.throttle`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to debounce.
     * @param {number} [wait=0] The number of milliseconds to delay.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.leading=false]
     *  Specify invoking on the leading edge of the timeout.
     * @param {number} [options.maxWait]
     *  The maximum time `func` is allowed to be delayed before it's invoked.
     * @param {boolean} [options.trailing=true]
     *  Specify invoking on the trailing edge of the timeout.
     * @returns {Function} Returns the new debounced function.
     * @example
     *
     * // Avoid costly calculations while the window size is in flux.
     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
     *
     * // Invoke `sendMail` when clicked, debouncing subsequent calls.
     * jQuery(element).on('click', _.debounce(sendMail, 300, {
     *   'leading': true,
     *   'trailing': false
     * }));
     *
     * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
     * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
     * var source = new EventSource('/stream');
     * jQuery(source).on('message', debounced);
     *
     * // Cancel the trailing debounced invocation.
     * jQuery(window).on('popstate', debounced.cancel);
     */
    function debounce(func, wait, options) {
      var lastArgs,
          lastThis,
          maxWait,
          result,
          timerId,
          lastCallTime,
          lastInvokeTime = 0,
          leading = false,
          maxing = false,
          trailing = true;

      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      wait = toNumber(wait) || 0;
      if (isObject(options)) {
        leading = !!options.leading;
        maxing = 'maxWait' in options;
        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
        trailing = 'trailing' in options ? !!options.trailing : trailing;
      }

      function invokeFunc(time) {
        var args = lastArgs,
            thisArg = lastThis;

        lastArgs = lastThis = undefined;
        lastInvokeTime = time;
        result = func.apply(thisArg, args);
        return result;
      }

      function leadingEdge(time) {
        // Reset any `maxWait` timer.
        lastInvokeTime = time;
        // Start the timer for the trailing edge.
        timerId = setTimeout(timerExpired, wait);
        // Invoke the leading edge.
        return leading ? invokeFunc(time) : result;
      }

      function remainingWait(time) {
        var timeSinceLastCall = time - lastCallTime,
            timeSinceLastInvoke = time - lastInvokeTime,
            timeWaiting = wait - timeSinceLastCall;

        return maxing
          ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)
          : timeWaiting;
      }

      function shouldInvoke(time) {
        var timeSinceLastCall = time - lastCallTime,
            timeSinceLastInvoke = time - lastInvokeTime;

        // Either this is the first call, activity has stopped and we're at the
        // trailing edge, the system time has gone backwards and we're treating
        // it as the trailing edge, or we've hit the `maxWait` limit.
        return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
          (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
      }

      function timerExpired() {
        var time = now();
        if (shouldInvoke(time)) {
          return trailingEdge(time);
        }
        // Restart the timer.
        timerId = setTimeout(timerExpired, remainingWait(time));
      }

      function trailingEdge(time) {
        timerId = undefined;

        // Only invoke if we have `lastArgs` which means `func` has been
        // debounced at least once.
        if (trailing && lastArgs) {
          return invokeFunc(time);
        }
        lastArgs = lastThis = undefined;
        return result;
      }

      function cancel() {
        if (timerId !== undefined) {
          clearTimeout(timerId);
        }
        lastInvokeTime = 0;
        lastArgs = lastCallTime = lastThis = timerId = undefined;
      }

      function flush() {
        return timerId === undefined ? result : trailingEdge(now());
      }

      function debounced() {
        var time = now(),
            isInvoking = shouldInvoke(time);

        lastArgs = arguments;
        lastThis = this;
        lastCallTime = time;

        if (isInvoking) {
          if (timerId === undefined) {
            return leadingEdge(lastCallTime);
          }
          if (maxing) {
            // Handle invocations in a tight loop.
            clearTimeout(timerId);
            timerId = setTimeout(timerExpired, wait);
            return invokeFunc(lastCallTime);
          }
        }
        if (timerId === undefined) {
          timerId = setTimeout(timerExpired, wait);
        }
        return result;
      }
      debounced.cancel = cancel;
      debounced.flush = flush;
      return debounced;
    }

    /**
     * Defers invoking the `func` until the current call stack has cleared. Any
     * additional arguments are provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to defer.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.defer(function(text) {
     *   console.log(text);
     * }, 'deferred');
     * // => Logs 'deferred' after one millisecond.
     */
    var defer = baseRest(function(func, args) {
      return baseDelay(func, 1, args);
    });

    /**
     * Invokes `func` after `wait` milliseconds. Any additional arguments are
     * provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.delay(function(text) {
     *   console.log(text);
     * }, 1000, 'later');
     * // => Logs 'later' after one second.
     */
    var delay = baseRest(function(func, wait, args) {
      return baseDelay(func, toNumber(wait) || 0, args);
    });

    /**
     * Creates a function that invokes `func` with arguments reversed.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to flip arguments for.
     * @returns {Function} Returns the new flipped function.
     * @example
     *
     * var flipped = _.flip(function() {
     *   return _.toArray(arguments);
     * });
     *
     * flipped('a', 'b', 'c', 'd');
     * // => ['d', 'c', 'b', 'a']
     */
    function flip(func) {
      return createWrap(func, WRAP_FLIP_FLAG);
    }

    /**
     * Creates a function that memoizes the result of `func`. If `resolver` is
     * provided, it determines the cache key for storing the result based on the
     * arguments provided to the memoized function. By default, the first argument
     * provided to the memoized function is used as the map cache key. The `func`
     * is invoked with the `this` binding of the memoized function.
     *
     * **Note:** The cache is exposed as the `cache` property on the memoized
     * function. Its creation may be customized by replacing the `_.memoize.Cache`
     * constructor with one whose instances implement the
     * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
     * method interface of `clear`, `delete`, `get`, `has`, and `set`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to have its output memoized.
     * @param {Function} [resolver] The function to resolve the cache key.
     * @returns {Function} Returns the new memoized function.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     * var other = { 'c': 3, 'd': 4 };
     *
     * var values = _.memoize(_.values);
     * values(object);
     * // => [1, 2]
     *
     * values(other);
     * // => [3, 4]
     *
     * object.a = 2;
     * values(object);
     * // => [1, 2]
     *
     * // Modify the result cache.
     * values.cache.set(object, ['a', 'b']);
     * values(object);
     * // => ['a', 'b']
     *
     * // Replace `_.memoize.Cache`.
     * _.memoize.Cache = WeakMap;
     */
    function memoize(func, resolver) {
      if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function() {
        var args = arguments,
            key = resolver ? resolver.apply(this, args) : args[0],
            cache = memoized.cache;

        if (cache.has(key)) {
          return cache.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result) || cache;
        return result;
      };
      memoized.cache = new (memoize.Cache || MapCache);
      return memoized;
    }

    // Expose `MapCache`.
    memoize.Cache = MapCache;

    /**
     * Creates a function that negates the result of the predicate `func`. The
     * `func` predicate is invoked with the `this` binding and arguments of the
     * created function.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} predicate The predicate to negate.
     * @returns {Function} Returns the new negated function.
     * @example
     *
     * function isEven(n) {
     *   return n % 2 == 0;
     * }
     *
     * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
     * // => [1, 3, 5]
     */
    function negate(predicate) {
      if (typeof predicate != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      return function() {
        var args = arguments;
        switch (args.length) {
          case 0: return !predicate.call(this);
          case 1: return !predicate.call(this, args[0]);
          case 2: return !predicate.call(this, args[0], args[1]);
          case 3: return !predicate.call(this, args[0], args[1], args[2]);
        }
        return !predicate.apply(this, args);
      };
    }

    /**
     * Creates a function that is restricted to invoking `func` once. Repeat calls
     * to the function return the value of the first invocation. The `func` is
     * invoked with the `this` binding and arguments of the created function.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var initialize = _.once(createApplication);
     * initialize();
     * initialize();
     * // => `createApplication` is invoked once
     */
    function once(func) {
      return before(2, func);
    }

    /**
     * Creates a function that invokes `func` with its arguments transformed.
     *
     * @static
     * @since 4.0.0
     * @memberOf _
     * @category Function
     * @param {Function} func The function to wrap.
     * @param {...(Function|Function[])} [transforms=[_.identity]]
     *  The argument transforms.
     * @returns {Function} Returns the new function.
     * @example
     *
     * function doubled(n) {
     *   return n * 2;
     * }
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var func = _.overArgs(function(x, y) {
     *   return [x, y];
     * }, [square, doubled]);
     *
     * func(9, 3);
     * // => [81, 6]
     *
     * func(10, 5);
     * // => [100, 10]
     */
    var overArgs = castRest(function(func, transforms) {
      transforms = (transforms.length == 1 && isArray(transforms[0]))
        ? arrayMap(transforms[0], baseUnary(getIteratee()))
        : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));

      var funcsLength = transforms.length;
      return baseRest(function(args) {
        var index = -1,
            length = nativeMin(args.length, funcsLength);

        while (++index < length) {
          args[index] = transforms[index].call(this, args[index]);
        }
        return apply(func, this, args);
      });
    });

    /**
     * Creates a function that invokes `func` with `partials` prepended to the
     * arguments it receives. This method is like `_.bind` except it does **not**
     * alter the `this` binding.
     *
     * The `_.partial.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * **Note:** This method doesn't set the "length" property of partially
     * applied functions.
     *
     * @static
     * @memberOf _
     * @since 0.2.0
     * @category Function
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * function greet(greeting, name) {
     *   return greeting + ' ' + name;
     * }
     *
     * var sayHelloTo = _.partial(greet, 'hello');
     * sayHelloTo('fred');
     * // => 'hello fred'
     *
     * // Partially applied with placeholders.
     * var greetFred = _.partial(greet, _, 'fred');
     * greetFred('hi');
     * // => 'hi fred'
     */
    var partial = baseRest(function(func, partials) {
      var holders = replaceHolders(partials, getHolder(partial));
      return createWrap(func, WRAP_PARTIAL_FLAG, undefined, partials, holders);
    });

    /**
     * This method is like `_.partial` except that partially applied arguments
     * are appended to the arguments it receives.
     *
     * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * **Note:** This method doesn't set the "length" property of partially
     * applied functions.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Function
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * function greet(greeting, name) {
     *   return greeting + ' ' + name;
     * }
     *
     * var greetFred = _.partialRight(greet, 'fred');
     * greetFred('hi');
     * // => 'hi fred'
     *
     * // Partially applied with placeholders.
     * var sayHelloTo = _.partialRight(greet, 'hello', _);
     * sayHelloTo('fred');
     * // => 'hello fred'
     */
    var partialRight = baseRest(function(func, partials) {
      var holders = replaceHolders(partials, getHolder(partialRight));
      return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined, partials, holders);
    });

    /**
     * Creates a function that invokes `func` with arguments arranged according
     * to the specified `indexes` where the argument value at the first index is
     * provided as the first argument, the argument value at the second index is
     * provided as the second argument, and so on.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to rearrange arguments for.
     * @param {...(number|number[])} indexes The arranged argument indexes.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var rearged = _.rearg(function(a, b, c) {
     *   return [a, b, c];
     * }, [2, 0, 1]);
     *
     * rearged('b', 'c', 'a')
     * // => ['a', 'b', 'c']
     */
    var rearg = flatRest(function(func, indexes) {
      return createWrap(func, WRAP_REARG_FLAG, undefined, undefined, undefined, indexes);
    });

    /**
     * Creates a function that invokes `func` with the `this` binding of the
     * created function and arguments from `start` and beyond provided as
     * an array.
     *
     * **Note:** This method is based on the
     * [rest parameter](https://mdn.io/rest_parameters).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var say = _.rest(function(what, names) {
     *   return what + ' ' + _.initial(names).join(', ') +
     *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
     * });
     *
     * say('hello', 'fred', 'barney', 'pebbles');
     * // => 'hello fred, barney, & pebbles'
     */
    function rest(func, start) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      start = start === undefined ? start : toInteger(start);
      return baseRest(func, start);
    }

    /**
     * Creates a function that invokes `func` with the `this` binding of the
     * create function and an array of arguments much like
     * [`Function#apply`](http://www.ecma-international.org/ecma-262/7.0/#sec-function.prototype.apply).
     *
     * **Note:** This method is based on the
     * [spread operator](https://mdn.io/spread_operator).
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Function
     * @param {Function} func The function to spread arguments over.
     * @param {number} [start=0] The start position of the spread.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var say = _.spread(function(who, what) {
     *   return who + ' says ' + what;
     * });
     *
     * say(['fred', 'hello']);
     * // => 'fred says hello'
     *
     * var numbers = Promise.all([
     *   Promise.resolve(40),
     *   Promise.resolve(36)
     * ]);
     *
     * numbers.then(_.spread(function(x, y) {
     *   return x + y;
     * }));
     * // => a Promise of 76
     */
    function spread(func, start) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      start = start == null ? 0 : nativeMax(toInteger(start), 0);
      return baseRest(function(args) {
        var array = args[start],
            otherArgs = castSlice(args, 0, start);

        if (array) {
          arrayPush(otherArgs, array);
        }
        return apply(func, this, otherArgs);
      });
    }

    /**
     * Creates a throttled function that only invokes `func` at most once per
     * every `wait` milliseconds. The throttled function comes with a `cancel`
     * method to cancel delayed `func` invocations and a `flush` method to
     * immediately invoke them. Provide `options` to indicate whether `func`
     * should be invoked on the leading and/or trailing edge of the `wait`
     * timeout. The `func` is invoked with the last arguments provided to the
     * throttled function. Subsequent calls to the throttled function return the
     * result of the last `func` invocation.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is
     * invoked on the trailing edge of the timeout only if the throttled function
     * is invoked more than once during the `wait` timeout.
     *
     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
     *
     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
     * for details over the differences between `_.throttle` and `_.debounce`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to throttle.
     * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.leading=true]
     *  Specify invoking on the leading edge of the timeout.
     * @param {boolean} [options.trailing=true]
     *  Specify invoking on the trailing edge of the timeout.
     * @returns {Function} Returns the new throttled function.
     * @example
     *
     * // Avoid excessively updating the position while scrolling.
     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
     *
     * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
     * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
     * jQuery(element).on('click', throttled);
     *
     * // Cancel the trailing throttled invocation.
     * jQuery(window).on('popstate', throttled.cancel);
     */
    function throttle(func, wait, options) {
      var leading = true,
          trailing = true;

      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      if (isObject(options)) {
        leading = 'leading' in options ? !!options.leading : leading;
        trailing = 'trailing' in options ? !!options.trailing : trailing;
      }
      return debounce(func, wait, {
        'leading': leading,
        'maxWait': wait,
        'trailing': trailing
      });
    }

    /**
     * Creates a function that accepts up to one argument, ignoring any
     * additional arguments.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to cap arguments for.
     * @returns {Function} Returns the new capped function.
     * @example
     *
     * _.map(['6', '8', '10'], _.unary(parseInt));
     * // => [6, 8, 10]
     */
    function unary(func) {
      return ary(func, 1);
    }

    /**
     * Creates a function that provides `value` to `wrapper` as its first
     * argument. Any additional arguments provided to the function are appended
     * to those provided to the `wrapper`. The wrapper is invoked with the `this`
     * binding of the created function.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {*} value The value to wrap.
     * @param {Function} [wrapper=identity] The wrapper function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var p = _.wrap(_.escape, function(func, text) {
     *   return '<p>' + func(text) + '</p>';
     * });
     *
     * p('fred, barney, & pebbles');
     * // => '<p>fred, barney, &amp; pebbles</p>'
     */
    function wrap(value, wrapper) {
      return partial(castFunction(wrapper), value);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Casts `value` as an array if it's not one.
     *
     * @static
     * @memberOf _
     * @since 4.4.0
     * @category Lang
     * @param {*} value The value to inspect.
     * @returns {Array} Returns the cast array.
     * @example
     *
     * _.castArray(1);
     * // => [1]
     *
     * _.castArray({ 'a': 1 });
     * // => [{ 'a': 1 }]
     *
     * _.castArray('abc');
     * // => ['abc']
     *
     * _.castArray(null);
     * // => [null]
     *
     * _.castArray(undefined);
     * // => [undefined]
     *
     * _.castArray();
     * // => []
     *
     * var array = [1, 2, 3];
     * console.log(_.castArray(array) === array);
     * // => true
     */
    function castArray() {
      if (!arguments.length) {
        return [];
      }
      var value = arguments[0];
      return isArray(value) ? value : [value];
    }

    /**
     * Creates a shallow clone of `value`.
     *
     * **Note:** This method is loosely based on the
     * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
     * and supports cloning arrays, array buffers, booleans, date objects, maps,
     * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
     * arrays. The own enumerable properties of `arguments` objects are cloned
     * as plain objects. An empty object is returned for uncloneable values such
     * as error objects, functions, DOM nodes, and WeakMaps.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to clone.
     * @returns {*} Returns the cloned value.
     * @see _.cloneDeep
     * @example
     *
     * var objects = [{ 'a': 1 }, { 'b': 2 }];
     *
     * var shallow = _.clone(objects);
     * console.log(shallow[0] === objects[0]);
     * // => true
     */
    function clone(value) {
      return baseClone(value, CLONE_SYMBOLS_FLAG);
    }

    /**
     * This method is like `_.clone` except that it accepts `customizer` which
     * is invoked to produce the cloned value. If `customizer` returns `undefined`,
     * cloning is handled by the method instead. The `customizer` is invoked with
     * up to four arguments; (value [, index|key, object, stack]).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to clone.
     * @param {Function} [customizer] The function to customize cloning.
     * @returns {*} Returns the cloned value.
     * @see _.cloneDeepWith
     * @example
     *
     * function customizer(value) {
     *   if (_.isElement(value)) {
     *     return value.cloneNode(false);
     *   }
     * }
     *
     * var el = _.cloneWith(document.body, customizer);
     *
     * console.log(el === document.body);
     * // => false
     * console.log(el.nodeName);
     * // => 'BODY'
     * console.log(el.childNodes.length);
     * // => 0
     */
    function cloneWith(value, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
    }

    /**
     * This method is like `_.clone` except that it recursively clones `value`.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Lang
     * @param {*} value The value to recursively clone.
     * @returns {*} Returns the deep cloned value.
     * @see _.clone
     * @example
     *
     * var objects = [{ 'a': 1 }, { 'b': 2 }];
     *
     * var deep = _.cloneDeep(objects);
     * console.log(deep[0] === objects[0]);
     * // => false
     */
    function cloneDeep(value) {
      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
    }

    /**
     * This method is like `_.cloneWith` except that it recursively clones `value`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to recursively clone.
     * @param {Function} [customizer] The function to customize cloning.
     * @returns {*} Returns the deep cloned value.
     * @see _.cloneWith
     * @example
     *
     * function customizer(value) {
     *   if (_.isElement(value)) {
     *     return value.cloneNode(true);
     *   }
     * }
     *
     * var el = _.cloneDeepWith(document.body, customizer);
     *
     * console.log(el === document.body);
     * // => false
     * console.log(el.nodeName);
     * // => 'BODY'
     * console.log(el.childNodes.length);
     * // => 20
     */
    function cloneDeepWith(value, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
    }

    /**
     * Checks if `object` conforms to `source` by invoking the predicate
     * properties of `source` with the corresponding property values of `object`.
     *
     * **Note:** This method is equivalent to `_.conforms` when `source` is
     * partially applied.
     *
     * @static
     * @memberOf _
     * @since 4.14.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property predicates to conform to.
     * @returns {boolean} Returns `true` if `object` conforms, else `false`.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     *
     * _.conformsTo(object, { 'b': function(n) { return n > 1; } });
     * // => true
     *
     * _.conformsTo(object, { 'b': function(n) { return n > 2; } });
     * // => false
     */
    function conformsTo(object, source) {
      return source == null || baseConformsTo(object, source, keys(source));
    }

    /**
     * Performs a
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * comparison between two values to determine if they are equivalent.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'a': 1 };
     * var other = { 'a': 1 };
     *
     * _.eq(object, object);
     * // => true
     *
     * _.eq(object, other);
     * // => false
     *
     * _.eq('a', 'a');
     * // => true
     *
     * _.eq('a', Object('a'));
     * // => false
     *
     * _.eq(NaN, NaN);
     * // => true
     */
    function eq(value, other) {
      return value === other || (value !== value && other !== other);
    }

    /**
     * Checks if `value` is greater than `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than `other`,
     *  else `false`.
     * @see _.lt
     * @example
     *
     * _.gt(3, 1);
     * // => true
     *
     * _.gt(3, 3);
     * // => false
     *
     * _.gt(1, 3);
     * // => false
     */
    var gt = createRelationalOperation(baseGt);

    /**
     * Checks if `value` is greater than or equal to `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than or equal to
     *  `other`, else `false`.
     * @see _.lte
     * @example
     *
     * _.gte(3, 1);
     * // => true
     *
     * _.gte(3, 3);
     * // => true
     *
     * _.gte(1, 3);
     * // => false
     */
    var gte = createRelationalOperation(function(value, other) {
      return value >= other;
    });

    /**
     * Checks if `value` is likely an `arguments` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     *  else `false`.
     * @example
     *
     * _.isArguments(function() { return arguments; }());
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */
    var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
        !propertyIsEnumerable.call(value, 'callee');
    };

    /**
     * Checks if `value` is classified as an `Array` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array, else `false`.
     * @example
     *
     * _.isArray([1, 2, 3]);
     * // => true
     *
     * _.isArray(document.body.children);
     * // => false
     *
     * _.isArray('abc');
     * // => false
     *
     * _.isArray(_.noop);
     * // => false
     */
    var isArray = Array.isArray;

    /**
     * Checks if `value` is classified as an `ArrayBuffer` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
     * @example
     *
     * _.isArrayBuffer(new ArrayBuffer(2));
     * // => true
     *
     * _.isArrayBuffer(new Array(2));
     * // => false
     */
    var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;

    /**
     * Checks if `value` is array-like. A value is considered array-like if it's
     * not a function and has a `value.length` that's an integer greater than or
     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
     * @example
     *
     * _.isArrayLike([1, 2, 3]);
     * // => true
     *
     * _.isArrayLike(document.body.children);
     * // => true
     *
     * _.isArrayLike('abc');
     * // => true
     *
     * _.isArrayLike(_.noop);
     * // => false
     */
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }

    /**
     * This method is like `_.isArrayLike` except that it also checks if `value`
     * is an object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array-like object,
     *  else `false`.
     * @example
     *
     * _.isArrayLikeObject([1, 2, 3]);
     * // => true
     *
     * _.isArrayLikeObject(document.body.children);
     * // => true
     *
     * _.isArrayLikeObject('abc');
     * // => false
     *
     * _.isArrayLikeObject(_.noop);
     * // => false
     */
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }

    /**
     * Checks if `value` is classified as a boolean primitive or object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.
     * @example
     *
     * _.isBoolean(false);
     * // => true
     *
     * _.isBoolean(null);
     * // => false
     */
    function isBoolean(value) {
      return value === true || value === false ||
        (isObjectLike(value) && baseGetTag(value) == boolTag);
    }

    /**
     * Checks if `value` is a buffer.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
     * @example
     *
     * _.isBuffer(new Buffer(2));
     * // => true
     *
     * _.isBuffer(new Uint8Array(2));
     * // => false
     */
    var isBuffer = nativeIsBuffer || stubFalse;

    /**
     * Checks if `value` is classified as a `Date` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
     * @example
     *
     * _.isDate(new Date);
     * // => true
     *
     * _.isDate('Mon April 23 2012');
     * // => false
     */
    var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;

    /**
     * Checks if `value` is likely a DOM element.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.
     * @example
     *
     * _.isElement(document.body);
     * // => true
     *
     * _.isElement('<body>');
     * // => false
     */
    function isElement(value) {
      return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
    }

    /**
     * Checks if `value` is an empty object, collection, map, or set.
     *
     * Objects are considered empty if they have no own enumerable string keyed
     * properties.
     *
     * Array-like values such as `arguments` objects, arrays, buffers, strings, or
     * jQuery-like collections are considered empty if they have a `length` of `0`.
     * Similarly, maps and sets are considered empty if they have a `size` of `0`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is empty, else `false`.
     * @example
     *
     * _.isEmpty(null);
     * // => true
     *
     * _.isEmpty(true);
     * // => true
     *
     * _.isEmpty(1);
     * // => true
     *
     * _.isEmpty([1, 2, 3]);
     * // => false
     *
     * _.isEmpty({ 'a': 1 });
     * // => false
     */
    function isEmpty(value) {
      if (value == null) {
        return true;
      }
      if (isArrayLike(value) &&
          (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' ||
            isBuffer(value) || isTypedArray(value) || isArguments(value))) {
        return !value.length;
      }
      var tag = getTag(value);
      if (tag == mapTag || tag == setTag) {
        return !value.size;
      }
      if (isPrototype(value)) {
        return !baseKeys(value).length;
      }
      for (var key in value) {
        if (hasOwnProperty.call(value, key)) {
          return false;
        }
      }
      return true;
    }

    /**
     * Performs a deep comparison between two values to determine if they are
     * equivalent.
     *
     * **Note:** This method supports comparing arrays, array buffers, booleans,
     * date objects, error objects, maps, numbers, `Object` objects, regexes,
     * sets, strings, symbols, and typed arrays. `Object` objects are compared
     * by their own, not inherited, enumerable properties. Functions and DOM
     * nodes are compared by strict equality, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'a': 1 };
     * var other = { 'a': 1 };
     *
     * _.isEqual(object, other);
     * // => true
     *
     * object === other;
     * // => false
     */
    function isEqual(value, other) {
      return baseIsEqual(value, other);
    }

    /**
     * This method is like `_.isEqual` except that it accepts `customizer` which
     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
     * are handled by the method instead. The `customizer` is invoked with up to
     * six arguments: (objValue, othValue [, index|key, object, other, stack]).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * function isGreeting(value) {
     *   return /^h(?:i|ello)$/.test(value);
     * }
     *
     * function customizer(objValue, othValue) {
     *   if (isGreeting(objValue) && isGreeting(othValue)) {
     *     return true;
     *   }
     * }
     *
     * var array = ['hello', 'goodbye'];
     * var other = ['hi', 'goodbye'];
     *
     * _.isEqualWith(array, other, customizer);
     * // => true
     */
    function isEqualWith(value, other, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      var result = customizer ? customizer(value, other) : undefined;
      return result === undefined ? baseIsEqual(value, other, undefined, customizer) : !!result;
    }

    /**
     * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
     * `SyntaxError`, `TypeError`, or `URIError` object.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
     * @example
     *
     * _.isError(new Error);
     * // => true
     *
     * _.isError(Error);
     * // => false
     */
    function isError(value) {
      if (!isObjectLike(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == errorTag || tag == domExcTag ||
        (typeof value.message == 'string' && typeof value.name == 'string' && !isPlainObject(value));
    }

    /**
     * Checks if `value` is a finite primitive number.
     *
     * **Note:** This method is based on
     * [`Number.isFinite`](https://mdn.io/Number/isFinite).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
     * @example
     *
     * _.isFinite(3);
     * // => true
     *
     * _.isFinite(Number.MIN_VALUE);
     * // => true
     *
     * _.isFinite(Infinity);
     * // => false
     *
     * _.isFinite('3');
     * // => false
     */
    function isFinite(value) {
      return typeof value == 'number' && nativeIsFinite(value);
    }

    /**
     * Checks if `value` is classified as a `Function` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a function, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     *
     * _.isFunction(/abc/);
     * // => false
     */
    function isFunction(value) {
      if (!isObject(value)) {
        return false;
      }
      // The use of `Object#toString` avoids issues with the `typeof` operator
      // in Safari 9 which returns 'object' for typed arrays and other constructors.
      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }

    /**
     * Checks if `value` is an integer.
     *
     * **Note:** This method is based on
     * [`Number.isInteger`](https://mdn.io/Number/isInteger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an integer, else `false`.
     * @example
     *
     * _.isInteger(3);
     * // => true
     *
     * _.isInteger(Number.MIN_VALUE);
     * // => false
     *
     * _.isInteger(Infinity);
     * // => false
     *
     * _.isInteger('3');
     * // => false
     */
    function isInteger(value) {
      return typeof value == 'number' && value == toInteger(value);
    }

    /**
     * Checks if `value` is a valid array-like length.
     *
     * **Note:** This method is loosely based on
     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
     * @example
     *
     * _.isLength(3);
     * // => true
     *
     * _.isLength(Number.MIN_VALUE);
     * // => false
     *
     * _.isLength(Infinity);
     * // => false
     *
     * _.isLength('3');
     * // => false
     */
    function isLength(value) {
      return typeof value == 'number' &&
        value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }

    /**
     * Checks if `value` is the
     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(_.noop);
     * // => true
     *
     * _.isObject(null);
     * // => false
     */
    function isObject(value) {
      var type = typeof value;
      return value != null && (type == 'object' || type == 'function');
    }

    /**
     * Checks if `value` is object-like. A value is object-like if it's not `null`
     * and has a `typeof` result of "object".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
     * @example
     *
     * _.isObjectLike({});
     * // => true
     *
     * _.isObjectLike([1, 2, 3]);
     * // => true
     *
     * _.isObjectLike(_.noop);
     * // => false
     *
     * _.isObjectLike(null);
     * // => false
     */
    function isObjectLike(value) {
      return value != null && typeof value == 'object';
    }

    /**
     * Checks if `value` is classified as a `Map` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
     * @example
     *
     * _.isMap(new Map);
     * // => true
     *
     * _.isMap(new WeakMap);
     * // => false
     */
    var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;

    /**
     * Performs a partial deep comparison between `object` and `source` to
     * determine if `object` contains equivalent property values.
     *
     * **Note:** This method is equivalent to `_.matches` when `source` is
     * partially applied.
     *
     * Partial comparisons will match empty array and empty object `source`
     * values against any array or object value, respectively. See `_.isEqual`
     * for a list of supported value comparisons.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     *
     * _.isMatch(object, { 'b': 2 });
     * // => true
     *
     * _.isMatch(object, { 'b': 1 });
     * // => false
     */
    function isMatch(object, source) {
      return object === source || baseIsMatch(object, source, getMatchData(source));
    }

    /**
     * This method is like `_.isMatch` except that it accepts `customizer` which
     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
     * are handled by the method instead. The `customizer` is invoked with five
     * arguments: (objValue, srcValue, index|key, object, source).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     * @example
     *
     * function isGreeting(value) {
     *   return /^h(?:i|ello)$/.test(value);
     * }
     *
     * function customizer(objValue, srcValue) {
     *   if (isGreeting(objValue) && isGreeting(srcValue)) {
     *     return true;
     *   }
     * }
     *
     * var object = { 'greeting': 'hello' };
     * var source = { 'greeting': 'hi' };
     *
     * _.isMatchWith(object, source, customizer);
     * // => true
     */
    function isMatchWith(object, source, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return baseIsMatch(object, source, getMatchData(source), customizer);
    }

    /**
     * Checks if `value` is `NaN`.
     *
     * **Note:** This method is based on
     * [`Number.isNaN`](https://mdn.io/Number/isNaN) and is not the same as
     * global [`isNaN`](https://mdn.io/isNaN) which returns `true` for
     * `undefined` and other non-number values.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
     * @example
     *
     * _.isNaN(NaN);
     * // => true
     *
     * _.isNaN(new Number(NaN));
     * // => true
     *
     * isNaN(undefined);
     * // => true
     *
     * _.isNaN(undefined);
     * // => false
     */
    function isNaN(value) {
      // An `NaN` primitive is the only value that is not equal to itself.
      // Perform the `toStringTag` check first to avoid errors with some
      // ActiveX objects in IE.
      return isNumber(value) && value != +value;
    }

    /**
     * Checks if `value` is a pristine native function.
     *
     * **Note:** This method can't reliably detect native functions in the presence
     * of the core-js package because core-js circumvents this kind of detection.
     * Despite multiple requests, the core-js maintainer has made it clear: any
     * attempt to fix the detection will be obstructed. As a result, we're left
     * with little choice but to throw an error. Unfortunately, this also affects
     * packages, like [babel-polyfill](https://www.npmjs.com/package/babel-polyfill),
     * which rely on core-js.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function,
     *  else `false`.
     * @example
     *
     * _.isNative(Array.prototype.push);
     * // => true
     *
     * _.isNative(_);
     * // => false
     */
    function isNative(value) {
      if (isMaskable(value)) {
        throw new Error(CORE_ERROR_TEXT);
      }
      return baseIsNative(value);
    }

    /**
     * Checks if `value` is `null`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
     * @example
     *
     * _.isNull(null);
     * // => true
     *
     * _.isNull(void 0);
     * // => false
     */
    function isNull(value) {
      return value === null;
    }

    /**
     * Checks if `value` is `null` or `undefined`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is nullish, else `false`.
     * @example
     *
     * _.isNil(null);
     * // => true
     *
     * _.isNil(void 0);
     * // => true
     *
     * _.isNil(NaN);
     * // => false
     */
    function isNil(value) {
      return value == null;
    }

    /**
     * Checks if `value` is classified as a `Number` primitive or object.
     *
     * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are
     * classified as numbers, use the `_.isFinite` method.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a number, else `false`.
     * @example
     *
     * _.isNumber(3);
     * // => true
     *
     * _.isNumber(Number.MIN_VALUE);
     * // => true
     *
     * _.isNumber(Infinity);
     * // => true
     *
     * _.isNumber('3');
     * // => false
     */
    function isNumber(value) {
      return typeof value == 'number' ||
        (isObjectLike(value) && baseGetTag(value) == numberTag);
    }

    /**
     * Checks if `value` is a plain object, that is, an object created by the
     * `Object` constructor or one with a `[[Prototype]]` of `null`.
     *
     * @static
     * @memberOf _
     * @since 0.8.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * _.isPlainObject(new Foo);
     * // => false
     *
     * _.isPlainObject([1, 2, 3]);
     * // => false
     *
     * _.isPlainObject({ 'x': 0, 'y': 0 });
     * // => true
     *
     * _.isPlainObject(Object.create(null));
     * // => true
     */
    function isPlainObject(value) {
      if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
        return false;
      }
      var proto = getPrototype(value);
      if (proto === null) {
        return true;
      }
      var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
      return typeof Ctor == 'function' && Ctor instanceof Ctor &&
        funcToString.call(Ctor) == objectCtorString;
    }

    /**
     * Checks if `value` is classified as a `RegExp` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
     * @example
     *
     * _.isRegExp(/abc/);
     * // => true
     *
     * _.isRegExp('/abc/');
     * // => false
     */
    var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;

    /**
     * Checks if `value` is a safe integer. An integer is safe if it's an IEEE-754
     * double precision number which isn't the result of a rounded unsafe integer.
     *
     * **Note:** This method is based on
     * [`Number.isSafeInteger`](https://mdn.io/Number/isSafeInteger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a safe integer, else `false`.
     * @example
     *
     * _.isSafeInteger(3);
     * // => true
     *
     * _.isSafeInteger(Number.MIN_VALUE);
     * // => false
     *
     * _.isSafeInteger(Infinity);
     * // => false
     *
     * _.isSafeInteger('3');
     * // => false
     */
    function isSafeInteger(value) {
      return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
    }

    /**
     * Checks if `value` is classified as a `Set` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
     * @example
     *
     * _.isSet(new Set);
     * // => true
     *
     * _.isSet(new WeakSet);
     * // => false
     */
    var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;

    /**
     * Checks if `value` is classified as a `String` primitive or object.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a string, else `false`.
     * @example
     *
     * _.isString('abc');
     * // => true
     *
     * _.isString(1);
     * // => false
     */
    function isString(value) {
      return typeof value == 'string' ||
        (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);
    }

    /**
     * Checks if `value` is classified as a `Symbol` primitive or object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
     * @example
     *
     * _.isSymbol(Symbol.iterator);
     * // => true
     *
     * _.isSymbol('abc');
     * // => false
     */
    function isSymbol(value) {
      return typeof value == 'symbol' ||
        (isObjectLike(value) && baseGetTag(value) == symbolTag);
    }

    /**
     * Checks if `value` is classified as a typed array.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     * @example
     *
     * _.isTypedArray(new Uint8Array);
     * // => true
     *
     * _.isTypedArray([]);
     * // => false
     */
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

    /**
     * Checks if `value` is `undefined`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
     * @example
     *
     * _.isUndefined(void 0);
     * // => true
     *
     * _.isUndefined(null);
     * // => false
     */
    function isUndefined(value) {
      return value === undefined;
    }

    /**
     * Checks if `value` is classified as a `WeakMap` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a weak map, else `false`.
     * @example
     *
     * _.isWeakMap(new WeakMap);
     * // => true
     *
     * _.isWeakMap(new Map);
     * // => false
     */
    function isWeakMap(value) {
      return isObjectLike(value) && getTag(value) == weakMapTag;
    }

    /**
     * Checks if `value` is classified as a `WeakSet` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a weak set, else `false`.
     * @example
     *
     * _.isWeakSet(new WeakSet);
     * // => true
     *
     * _.isWeakSet(new Set);
     * // => false
     */
    function isWeakSet(value) {
      return isObjectLike(value) && baseGetTag(value) == weakSetTag;
    }

    /**
     * Checks if `value` is less than `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than `other`,
     *  else `false`.
     * @see _.gt
     * @example
     *
     * _.lt(1, 3);
     * // => true
     *
     * _.lt(3, 3);
     * // => false
     *
     * _.lt(3, 1);
     * // => false
     */
    var lt = createRelationalOperation(baseLt);

    /**
     * Checks if `value` is less than or equal to `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than or equal to
     *  `other`, else `false`.
     * @see _.gte
     * @example
     *
     * _.lte(1, 3);
     * // => true
     *
     * _.lte(3, 3);
     * // => true
     *
     * _.lte(3, 1);
     * // => false
     */
    var lte = createRelationalOperation(function(value, other) {
      return value <= other;
    });

    /**
     * Converts `value` to an array.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {Array} Returns the converted array.
     * @example
     *
     * _.toArray({ 'a': 1, 'b': 2 });
     * // => [1, 2]
     *
     * _.toArray('abc');
     * // => ['a', 'b', 'c']
     *
     * _.toArray(1);
     * // => []
     *
     * _.toArray(null);
     * // => []
     */
    function toArray(value) {
      if (!value) {
        return [];
      }
      if (isArrayLike(value)) {
        return isString(value) ? stringToArray(value) : copyArray(value);
      }
      if (symIterator && value[symIterator]) {
        return iteratorToArray(value[symIterator]());
      }
      var tag = getTag(value),
          func = tag == mapTag ? mapToArray : (tag == setTag ? setToArray : values);

      return func(value);
    }

    /**
     * Converts `value` to a finite number.
     *
     * @static
     * @memberOf _
     * @since 4.12.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted number.
     * @example
     *
     * _.toFinite(3.2);
     * // => 3.2
     *
     * _.toFinite(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toFinite(Infinity);
     * // => 1.7976931348623157e+308
     *
     * _.toFinite('3.2');
     * // => 3.2
     */
    function toFinite(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber(value);
      if (value === INFINITY || value === -INFINITY) {
        var sign = (value < 0 ? -1 : 1);
        return sign * MAX_INTEGER;
      }
      return value === value ? value : 0;
    }

    /**
     * Converts `value` to an integer.
     *
     * **Note:** This method is loosely based on
     * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toInteger(3.2);
     * // => 3
     *
     * _.toInteger(Number.MIN_VALUE);
     * // => 0
     *
     * _.toInteger(Infinity);
     * // => 1.7976931348623157e+308
     *
     * _.toInteger('3.2');
     * // => 3
     */
    function toInteger(value) {
      var result = toFinite(value),
          remainder = result % 1;

      return result === result ? (remainder ? result - remainder : result) : 0;
    }

    /**
     * Converts `value` to an integer suitable for use as the length of an
     * array-like object.
     *
     * **Note:** This method is based on
     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toLength(3.2);
     * // => 3
     *
     * _.toLength(Number.MIN_VALUE);
     * // => 0
     *
     * _.toLength(Infinity);
     * // => 4294967295
     *
     * _.toLength('3.2');
     * // => 3
     */
    function toLength(value) {
      return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
    }

    /**
     * Converts `value` to a number.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to process.
     * @returns {number} Returns the number.
     * @example
     *
     * _.toNumber(3.2);
     * // => 3.2
     *
     * _.toNumber(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toNumber(Infinity);
     * // => Infinity
     *
     * _.toNumber('3.2');
     * // => 3.2
     */
    function toNumber(value) {
      if (typeof value == 'number') {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject(value)) {
        var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
        value = isObject(other) ? (other + '') : other;
      }
      if (typeof value != 'string') {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, '');
      var isBinary = reIsBinary.test(value);
      return (isBinary || reIsOctal.test(value))
        ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
        : (reIsBadHex.test(value) ? NAN : +value);
    }

    /**
     * Converts `value` to a plain object flattening inherited enumerable string
     * keyed properties of `value` to own properties of the plain object.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {Object} Returns the converted plain object.
     * @example
     *
     * function Foo() {
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.assign({ 'a': 1 }, new Foo);
     * // => { 'a': 1, 'b': 2 }
     *
     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
     * // => { 'a': 1, 'b': 2, 'c': 3 }
     */
    function toPlainObject(value) {
      return copyObject(value, keysIn(value));
    }

    /**
     * Converts `value` to a safe integer. A safe integer can be compared and
     * represented correctly.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toSafeInteger(3.2);
     * // => 3
     *
     * _.toSafeInteger(Number.MIN_VALUE);
     * // => 0
     *
     * _.toSafeInteger(Infinity);
     * // => 9007199254740991
     *
     * _.toSafeInteger('3.2');
     * // => 3
     */
    function toSafeInteger(value) {
      return value
        ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER)
        : (value === 0 ? value : 0);
    }

    /**
     * Converts `value` to a string. An empty string is returned for `null`
     * and `undefined` values. The sign of `-0` is preserved.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.toString(null);
     * // => ''
     *
     * _.toString(-0);
     * // => '-0'
     *
     * _.toString([1, 2, 3]);
     * // => '1,2,3'
     */
    function toString(value) {
      return value == null ? '' : baseToString(value);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Assigns own enumerable string keyed properties of source objects to the
     * destination object. Source objects are applied from left to right.
     * Subsequent sources overwrite property assignments of previous sources.
     *
     * **Note:** This method mutates `object` and is loosely based on
     * [`Object.assign`](https://mdn.io/Object/assign).
     *
     * @static
     * @memberOf _
     * @since 0.10.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.assignIn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * function Bar() {
     *   this.c = 3;
     * }
     *
     * Foo.prototype.b = 2;
     * Bar.prototype.d = 4;
     *
     * _.assign({ 'a': 0 }, new Foo, new Bar);
     * // => { 'a': 1, 'c': 3 }
     */
    var assign = createAssigner(function(object, source) {
      if (isPrototype(source) || isArrayLike(source)) {
        copyObject(source, keys(source), object);
        return;
      }
      for (var key in source) {
        if (hasOwnProperty.call(source, key)) {
          assignValue(object, key, source[key]);
        }
      }
    });

    /**
     * This method is like `_.assign` except that it iterates over own and
     * inherited source properties.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias extend
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.assign
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * function Bar() {
     *   this.c = 3;
     * }
     *
     * Foo.prototype.b = 2;
     * Bar.prototype.d = 4;
     *
     * _.assignIn({ 'a': 0 }, new Foo, new Bar);
     * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4 }
     */
    var assignIn = createAssigner(function(object, source) {
      copyObject(source, keysIn(source), object);
    });

    /**
     * This method is like `_.assignIn` except that it accepts `customizer`
     * which is invoked to produce the assigned values. If `customizer` returns
     * `undefined`, assignment is handled by the method instead. The `customizer`
     * is invoked with five arguments: (objValue, srcValue, key, object, source).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias extendWith
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @see _.assignWith
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   return _.isUndefined(objValue) ? srcValue : objValue;
     * }
     *
     * var defaults = _.partialRight(_.assignInWith, customizer);
     *
     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */
    var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
      copyObject(source, keysIn(source), object, customizer);
    });

    /**
     * This method is like `_.assign` except that it accepts `customizer`
     * which is invoked to produce the assigned values. If `customizer` returns
     * `undefined`, assignment is handled by the method instead. The `customizer`
     * is invoked with five arguments: (objValue, srcValue, key, object, source).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @see _.assignInWith
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   return _.isUndefined(objValue) ? srcValue : objValue;
     * }
     *
     * var defaults = _.partialRight(_.assignWith, customizer);
     *
     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */
    var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
      copyObject(source, keys(source), object, customizer);
    });

    /**
     * Creates an array of values corresponding to `paths` of `object`.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {...(string|string[])} [paths] The property paths to pick.
     * @returns {Array} Returns the picked values.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
     *
     * _.at(object, ['a[0].b.c', 'a[1]']);
     * // => [3, 4]
     */
    var at = flatRest(baseAt);

    /**
     * Creates an object that inherits from the `prototype` object. If a
     * `properties` object is given, its own enumerable string keyed properties
     * are assigned to the created object.
     *
     * @static
     * @memberOf _
     * @since 2.3.0
     * @category Object
     * @param {Object} prototype The object to inherit from.
     * @param {Object} [properties] The properties to assign to the object.
     * @returns {Object} Returns the new object.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * function Circle() {
     *   Shape.call(this);
     * }
     *
     * Circle.prototype = _.create(Shape.prototype, {
     *   'constructor': Circle
     * });
     *
     * var circle = new Circle;
     * circle instanceof Circle;
     * // => true
     *
     * circle instanceof Shape;
     * // => true
     */
    function create(prototype, properties) {
      var result = baseCreate(prototype);
      return properties == null ? result : baseAssign(result, properties);
    }

    /**
     * Assigns own and inherited enumerable string keyed properties of source
     * objects to the destination object for all destination properties that
     * resolve to `undefined`. Source objects are applied from left to right.
     * Once a property is set, additional values of the same property are ignored.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.defaultsDeep
     * @example
     *
     * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */
    var defaults = baseRest(function(object, sources) {
      object = Object(object);

      var index = -1;
      var length = sources.length;
      var guard = length > 2 ? sources[2] : undefined;

      if (guard && isIterateeCall(sources[0], sources[1], guard)) {
        length = 1;
      }

      while (++index < length) {
        var source = sources[index];
        var props = keysIn(source);
        var propsIndex = -1;
        var propsLength = props.length;

        while (++propsIndex < propsLength) {
          var key = props[propsIndex];
          var value = object[key];

          if (value === undefined ||
              (eq(value, objectProto[key]) && !hasOwnProperty.call(object, key))) {
            object[key] = source[key];
          }
        }
      }

      return object;
    });

    /**
     * This method is like `_.defaults` except that it recursively assigns
     * default properties.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.defaults
     * @example
     *
     * _.defaultsDeep({ 'a': { 'b': 2 } }, { 'a': { 'b': 1, 'c': 3 } });
     * // => { 'a': { 'b': 2, 'c': 3 } }
     */
    var defaultsDeep = baseRest(function(args) {
      args.push(undefined, customDefaultsMerge);
      return apply(mergeWith, undefined, args);
    });

    /**
     * This method is like `_.find` except that it returns the key of the first
     * element `predicate` returns truthy for instead of the element itself.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {string|undefined} Returns the key of the matched element,
     *  else `undefined`.
     * @example
     *
     * var users = {
     *   'barney':  { 'age': 36, 'active': true },
     *   'fred':    { 'age': 40, 'active': false },
     *   'pebbles': { 'age': 1,  'active': true }
     * };
     *
     * _.findKey(users, function(o) { return o.age < 40; });
     * // => 'barney' (iteration order is not guaranteed)
     *
     * // The `_.matches` iteratee shorthand.
     * _.findKey(users, { 'age': 1, 'active': true });
     * // => 'pebbles'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findKey(users, ['active', false]);
     * // => 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.findKey(users, 'active');
     * // => 'barney'
     */
    function findKey(object, predicate) {
      return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
    }

    /**
     * This method is like `_.findKey` except that it iterates over elements of
     * a collection in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {string|undefined} Returns the key of the matched element,
     *  else `undefined`.
     * @example
     *
     * var users = {
     *   'barney':  { 'age': 36, 'active': true },
     *   'fred':    { 'age': 40, 'active': false },
     *   'pebbles': { 'age': 1,  'active': true }
     * };
     *
     * _.findLastKey(users, function(o) { return o.age < 40; });
     * // => returns 'pebbles' assuming `_.findKey` returns 'barney'
     *
     * // The `_.matches` iteratee shorthand.
     * _.findLastKey(users, { 'age': 36, 'active': true });
     * // => 'barney'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findLastKey(users, ['active', false]);
     * // => 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.findLastKey(users, 'active');
     * // => 'pebbles'
     */
    function findLastKey(object, predicate) {
      return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
    }

    /**
     * Iterates over own and inherited enumerable string keyed properties of an
     * object and invokes `iteratee` for each property. The iteratee is invoked
     * with three arguments: (value, key, object). Iteratee functions may exit
     * iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 0.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forInRight
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forIn(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a', 'b', then 'c' (iteration order is not guaranteed).
     */
    function forIn(object, iteratee) {
      return object == null
        ? object
        : baseFor(object, getIteratee(iteratee, 3), keysIn);
    }

    /**
     * This method is like `_.forIn` except that it iterates over properties of
     * `object` in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forIn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forInRight(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'c', 'b', then 'a' assuming `_.forIn` logs 'a', 'b', then 'c'.
     */
    function forInRight(object, iteratee) {
      return object == null
        ? object
        : baseForRight(object, getIteratee(iteratee, 3), keysIn);
    }

    /**
     * Iterates over own enumerable string keyed properties of an object and
     * invokes `iteratee` for each property. The iteratee is invoked with three
     * arguments: (value, key, object). Iteratee functions may exit iteration
     * early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 0.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forOwnRight
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forOwn(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
     */
    function forOwn(object, iteratee) {
      return object && baseForOwn(object, getIteratee(iteratee, 3));
    }

    /**
     * This method is like `_.forOwn` except that it iterates over properties of
     * `object` in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forOwn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forOwnRight(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'b' then 'a' assuming `_.forOwn` logs 'a' then 'b'.
     */
    function forOwnRight(object, iteratee) {
      return object && baseForOwnRight(object, getIteratee(iteratee, 3));
    }

    /**
     * Creates an array of function property names from own enumerable properties
     * of `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the function names.
     * @see _.functionsIn
     * @example
     *
     * function Foo() {
     *   this.a = _.constant('a');
     *   this.b = _.constant('b');
     * }
     *
     * Foo.prototype.c = _.constant('c');
     *
     * _.functions(new Foo);
     * // => ['a', 'b']
     */
    function functions(object) {
      return object == null ? [] : baseFunctions(object, keys(object));
    }

    /**
     * Creates an array of function property names from own and inherited
     * enumerable properties of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the function names.
     * @see _.functions
     * @example
     *
     * function Foo() {
     *   this.a = _.constant('a');
     *   this.b = _.constant('b');
     * }
     *
     * Foo.prototype.c = _.constant('c');
     *
     * _.functionsIn(new Foo);
     * // => ['a', 'b', 'c']
     */
    function functionsIn(object) {
      return object == null ? [] : baseFunctions(object, keysIn(object));
    }

    /**
     * Gets the value at `path` of `object`. If the resolved value is
     * `undefined`, the `defaultValue` is returned in its place.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.get(object, 'a[0].b.c');
     * // => 3
     *
     * _.get(object, ['a', '0', 'b', 'c']);
     * // => 3
     *
     * _.get(object, 'a.b.c', 'default');
     * // => 'default'
     */
    function get(object, path, defaultValue) {
      var result = object == null ? undefined : baseGet(object, path);
      return result === undefined ? defaultValue : result;
    }

    /**
     * Checks if `path` is a direct property of `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     * @example
     *
     * var object = { 'a': { 'b': 2 } };
     * var other = _.create({ 'a': _.create({ 'b': 2 }) });
     *
     * _.has(object, 'a');
     * // => true
     *
     * _.has(object, 'a.b');
     * // => true
     *
     * _.has(object, ['a', 'b']);
     * // => true
     *
     * _.has(other, 'a');
     * // => false
     */
    function has(object, path) {
      return object != null && hasPath(object, path, baseHas);
    }

    /**
     * Checks if `path` is a direct or inherited property of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     * @example
     *
     * var object = _.create({ 'a': _.create({ 'b': 2 }) });
     *
     * _.hasIn(object, 'a');
     * // => true
     *
     * _.hasIn(object, 'a.b');
     * // => true
     *
     * _.hasIn(object, ['a', 'b']);
     * // => true
     *
     * _.hasIn(object, 'b');
     * // => false
     */
    function hasIn(object, path) {
      return object != null && hasPath(object, path, baseHasIn);
    }

    /**
     * Creates an object composed of the inverted keys and values of `object`.
     * If `object` contains duplicate values, subsequent values overwrite
     * property assignments of previous values.
     *
     * @static
     * @memberOf _
     * @since 0.7.0
     * @category Object
     * @param {Object} object The object to invert.
     * @returns {Object} Returns the new inverted object.
     * @example
     *
     * var object = { 'a': 1, 'b': 2, 'c': 1 };
     *
     * _.invert(object);
     * // => { '1': 'c', '2': 'b' }
     */
    var invert = createInverter(function(result, value, key) {
      if (value != null &&
          typeof value.toString != 'function') {
        value = nativeObjectToString.call(value);
      }

      result[value] = key;
    }, constant(identity));

    /**
     * This method is like `_.invert` except that the inverted object is generated
     * from the results of running each element of `object` thru `iteratee`. The
     * corresponding inverted value of each inverted key is an array of keys
     * responsible for generating the inverted value. The iteratee is invoked
     * with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.1.0
     * @category Object
     * @param {Object} object The object to invert.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Object} Returns the new inverted object.
     * @example
     *
     * var object = { 'a': 1, 'b': 2, 'c': 1 };
     *
     * _.invertBy(object);
     * // => { '1': ['a', 'c'], '2': ['b'] }
     *
     * _.invertBy(object, function(value) {
     *   return 'group' + value;
     * });
     * // => { 'group1': ['a', 'c'], 'group2': ['b'] }
     */
    var invertBy = createInverter(function(result, value, key) {
      if (value != null &&
          typeof value.toString != 'function') {
        value = nativeObjectToString.call(value);
      }

      if (hasOwnProperty.call(result, value)) {
        result[value].push(key);
      } else {
        result[value] = [key];
      }
    }, getIteratee);

    /**
     * Invokes the method at `path` of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the method to invoke.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {*} Returns the result of the invoked method.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': [1, 2, 3, 4] } }] };
     *
     * _.invoke(object, 'a[0].b.c.slice', 1, 3);
     * // => [2, 3]
     */
    var invoke = baseRest(baseInvoke);

    /**
     * Creates an array of the own enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects. See the
     * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * for more details.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keys(new Foo);
     * // => ['a', 'b'] (iteration order is not guaranteed)
     *
     * _.keys('hi');
     * // => ['0', '1']
     */
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }

    /**
     * Creates an array of the own and inherited enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keysIn(new Foo);
     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
     */
    function keysIn(object) {
      return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
    }

    /**
     * The opposite of `_.mapValues`; this method creates an object with the
     * same values as `object` and keys generated by running each own enumerable
     * string keyed property of `object` thru `iteratee`. The iteratee is invoked
     * with three arguments: (value, key, object).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns the new mapped object.
     * @see _.mapValues
     * @example
     *
     * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {
     *   return key + value;
     * });
     * // => { 'a1': 1, 'b2': 2 }
     */
    function mapKeys(object, iteratee) {
      var result = {};
      iteratee = getIteratee(iteratee, 3);

      baseForOwn(object, function(value, key, object) {
        baseAssignValue(result, iteratee(value, key, object), value);
      });
      return result;
    }

    /**
     * Creates an object with the same keys as `object` and values generated
     * by running each own enumerable string keyed property of `object` thru
     * `iteratee`. The iteratee is invoked with three arguments:
     * (value, key, object).
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns the new mapped object.
     * @see _.mapKeys
     * @example
     *
     * var users = {
     *   'fred':    { 'user': 'fred',    'age': 40 },
     *   'pebbles': { 'user': 'pebbles', 'age': 1 }
     * };
     *
     * _.mapValues(users, function(o) { return o.age; });
     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
     *
     * // The `_.property` iteratee shorthand.
     * _.mapValues(users, 'age');
     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
     */
    function mapValues(object, iteratee) {
      var result = {};
      iteratee = getIteratee(iteratee, 3);

      baseForOwn(object, function(value, key, object) {
        baseAssignValue(result, key, iteratee(value, key, object));
      });
      return result;
    }

    /**
     * This method is like `_.assign` except that it recursively merges own and
     * inherited enumerable string keyed properties of source objects into the
     * destination object. Source properties that resolve to `undefined` are
     * skipped if a destination value exists. Array and plain object properties
     * are merged recursively. Other objects and value types are overridden by
     * assignment. Source objects are applied from left to right. Subsequent
     * sources overwrite property assignments of previous sources.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {
     *   'a': [{ 'b': 2 }, { 'd': 4 }]
     * };
     *
     * var other = {
     *   'a': [{ 'c': 3 }, { 'e': 5 }]
     * };
     *
     * _.merge(object, other);
     * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
     */
    var merge = createAssigner(function(object, source, srcIndex) {
      baseMerge(object, source, srcIndex);
    });

    /**
     * This method is like `_.merge` except that it accepts `customizer` which
     * is invoked to produce the merged values of the destination and source
     * properties. If `customizer` returns `undefined`, merging is handled by the
     * method instead. The `customizer` is invoked with six arguments:
     * (objValue, srcValue, key, object, source, stack).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} customizer The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   if (_.isArray(objValue)) {
     *     return objValue.concat(srcValue);
     *   }
     * }
     *
     * var object = { 'a': [1], 'b': [2] };
     * var other = { 'a': [3], 'b': [4] };
     *
     * _.mergeWith(object, other, customizer);
     * // => { 'a': [1, 3], 'b': [2, 4] }
     */
    var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
      baseMerge(object, source, srcIndex, customizer);
    });

    /**
     * The opposite of `_.pick`; this method creates an object composed of the
     * own and inherited enumerable property paths of `object` that are not omitted.
     *
     * **Note:** This method is considerably slower than `_.pick`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The source object.
     * @param {...(string|string[])} [paths] The property paths to omit.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.omit(object, ['a', 'c']);
     * // => { 'b': '2' }
     */
    var omit = flatRest(function(object, paths) {
      var result = {};
      if (object == null) {
        return result;
      }
      var isDeep = false;
      paths = arrayMap(paths, function(path) {
        path = castPath(path, object);
        isDeep || (isDeep = path.length > 1);
        return path;
      });
      copyObject(object, getAllKeysIn(object), result);
      if (isDeep) {
        result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
      }
      var length = paths.length;
      while (length--) {
        baseUnset(result, paths[length]);
      }
      return result;
    });

    /**
     * The opposite of `_.pickBy`; this method creates an object composed of
     * the own and inherited enumerable string keyed properties of `object` that
     * `predicate` doesn't return truthy for. The predicate is invoked with two
     * arguments: (value, key).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The source object.
     * @param {Function} [predicate=_.identity] The function invoked per property.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.omitBy(object, _.isNumber);
     * // => { 'b': '2' }
     */
    function omitBy(object, predicate) {
      return pickBy(object, negate(getIteratee(predicate)));
    }

    /**
     * Creates an object composed of the picked `object` properties.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The source object.
     * @param {...(string|string[])} [paths] The property paths to pick.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.pick(object, ['a', 'c']);
     * // => { 'a': 1, 'c': 3 }
     */
    var pick = flatRest(function(object, paths) {
      return object == null ? {} : basePick(object, paths);
    });

    /**
     * Creates an object composed of the `object` properties `predicate` returns
     * truthy for. The predicate is invoked with two arguments: (value, key).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The source object.
     * @param {Function} [predicate=_.identity] The function invoked per property.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.pickBy(object, _.isNumber);
     * // => { 'a': 1, 'c': 3 }
     */
    function pickBy(object, predicate) {
      if (object == null) {
        return {};
      }
      var props = arrayMap(getAllKeysIn(object), function(prop) {
        return [prop];
      });
      predicate = getIteratee(predicate);
      return basePickBy(object, props, function(value, path) {
        return predicate(value, path[0]);
      });
    }

    /**
     * This method is like `_.get` except that if the resolved value is a
     * function it's invoked with the `this` binding of its parent object and
     * its result is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to resolve.
     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };
     *
     * _.result(object, 'a[0].b.c1');
     * // => 3
     *
     * _.result(object, 'a[0].b.c2');
     * // => 4
     *
     * _.result(object, 'a[0].b.c3', 'default');
     * // => 'default'
     *
     * _.result(object, 'a[0].b.c3', _.constant('default'));
     * // => 'default'
     */
    function result(object, path, defaultValue) {
      path = castPath(path, object);

      var index = -1,
          length = path.length;

      // Ensure the loop is entered when path is empty.
      if (!length) {
        length = 1;
        object = undefined;
      }
      while (++index < length) {
        var value = object == null ? undefined : object[toKey(path[index])];
        if (value === undefined) {
          index = length;
          value = defaultValue;
        }
        object = isFunction(value) ? value.call(object) : value;
      }
      return object;
    }

    /**
     * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
     * it's created. Arrays are created for missing index properties while objects
     * are created for all other missing properties. Use `_.setWith` to customize
     * `path` creation.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.set(object, 'a[0].b.c', 4);
     * console.log(object.a[0].b.c);
     * // => 4
     *
     * _.set(object, ['x', '0', 'y', 'z'], 5);
     * console.log(object.x[0].y.z);
     * // => 5
     */
    function set(object, path, value) {
      return object == null ? object : baseSet(object, path, value);
    }

    /**
     * This method is like `_.set` except that it accepts `customizer` which is
     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
     * path creation is handled by the method instead. The `customizer` is invoked
     * with three arguments: (nsValue, key, nsObject).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {};
     *
     * _.setWith(object, '[0][1]', 'a', Object);
     * // => { '0': { '1': 'a' } }
     */
    function setWith(object, path, value, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return object == null ? object : baseSet(object, path, value, customizer);
    }

    /**
     * Creates an array of own enumerable string keyed-value pairs for `object`
     * which can be consumed by `_.fromPairs`. If `object` is a map or set, its
     * entries are returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias entries
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the key-value pairs.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.toPairs(new Foo);
     * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)
     */
    var toPairs = createToPairs(keys);

    /**
     * Creates an array of own and inherited enumerable string keyed-value pairs
     * for `object` which can be consumed by `_.fromPairs`. If `object` is a map
     * or set, its entries are returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias entriesIn
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the key-value pairs.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.toPairsIn(new Foo);
     * // => [['a', 1], ['b', 2], ['c', 3]] (iteration order is not guaranteed)
     */
    var toPairsIn = createToPairs(keysIn);

    /**
     * An alternative to `_.reduce`; this method transforms `object` to a new
     * `accumulator` object which is the result of running each of its own
     * enumerable string keyed properties thru `iteratee`, with each invocation
     * potentially mutating the `accumulator` object. If `accumulator` is not
     * provided, a new object with the same `[[Prototype]]` will be used. The
     * iteratee is invoked with four arguments: (accumulator, value, key, object).
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 1.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The custom accumulator value.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * _.transform([2, 3, 4], function(result, n) {
     *   result.push(n *= n);
     *   return n % 2 == 0;
     * }, []);
     * // => [4, 9]
     *
     * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
     *   (result[value] || (result[value] = [])).push(key);
     * }, {});
     * // => { '1': ['a', 'c'], '2': ['b'] }
     */
    function transform(object, iteratee, accumulator) {
      var isArr = isArray(object),
          isArrLike = isArr || isBuffer(object) || isTypedArray(object);

      iteratee = getIteratee(iteratee, 4);
      if (accumulator == null) {
        var Ctor = object && object.constructor;
        if (isArrLike) {
          accumulator = isArr ? new Ctor : [];
        }
        else if (isObject(object)) {
          accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
        }
        else {
          accumulator = {};
        }
      }
      (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object) {
        return iteratee(accumulator, value, index, object);
      });
      return accumulator;
    }

    /**
     * Removes the property at `path` of `object`.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to unset.
     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 7 } }] };
     * _.unset(object, 'a[0].b.c');
     * // => true
     *
     * console.log(object);
     * // => { 'a': [{ 'b': {} }] };
     *
     * _.unset(object, ['a', '0', 'b', 'c']);
     * // => true
     *
     * console.log(object);
     * // => { 'a': [{ 'b': {} }] };
     */
    function unset(object, path) {
      return object == null ? true : baseUnset(object, path);
    }

    /**
     * This method is like `_.set` except that accepts `updater` to produce the
     * value to set. Use `_.updateWith` to customize `path` creation. The `updater`
     * is invoked with one argument: (value).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {Function} updater The function to produce the updated value.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.update(object, 'a[0].b.c', function(n) { return n * n; });
     * console.log(object.a[0].b.c);
     * // => 9
     *
     * _.update(object, 'x[0].y.z', function(n) { return n ? n + 1 : 0; });
     * console.log(object.x[0].y.z);
     * // => 0
     */
    function update(object, path, updater) {
      return object == null ? object : baseUpdate(object, path, castFunction(updater));
    }

    /**
     * This method is like `_.update` except that it accepts `customizer` which is
     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
     * path creation is handled by the method instead. The `customizer` is invoked
     * with three arguments: (nsValue, key, nsObject).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {Function} updater The function to produce the updated value.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {};
     *
     * _.updateWith(object, '[0][1]', _.constant('a'), Object);
     * // => { '0': { '1': 'a' } }
     */
    function updateWith(object, path, updater, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
    }

    /**
     * Creates an array of the own enumerable string keyed property values of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.values(new Foo);
     * // => [1, 2] (iteration order is not guaranteed)
     *
     * _.values('hi');
     * // => ['h', 'i']
     */
    function values(object) {
      return object == null ? [] : baseValues(object, keys(object));
    }

    /**
     * Creates an array of the own and inherited enumerable string keyed property
     * values of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.valuesIn(new Foo);
     * // => [1, 2, 3] (iteration order is not guaranteed)
     */
    function valuesIn(object) {
      return object == null ? [] : baseValues(object, keysIn(object));
    }

    /*------------------------------------------------------------------------*/

    /**
     * Clamps `number` within the inclusive `lower` and `upper` bounds.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Number
     * @param {number} number The number to clamp.
     * @param {number} [lower] The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the clamped number.
     * @example
     *
     * _.clamp(-10, -5, 5);
     * // => -5
     *
     * _.clamp(10, -5, 5);
     * // => 5
     */
    function clamp(number, lower, upper) {
      if (upper === undefined) {
        upper = lower;
        lower = undefined;
      }
      if (upper !== undefined) {
        upper = toNumber(upper);
        upper = upper === upper ? upper : 0;
      }
      if (lower !== undefined) {
        lower = toNumber(lower);
        lower = lower === lower ? lower : 0;
      }
      return baseClamp(toNumber(number), lower, upper);
    }

    /**
     * Checks if `n` is between `start` and up to, but not including, `end`. If
     * `end` is not specified, it's set to `start` with `start` then set to `0`.
     * If `start` is greater than `end` the params are swapped to support
     * negative ranges.
     *
     * @static
     * @memberOf _
     * @since 3.3.0
     * @category Number
     * @param {number} number The number to check.
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
     * @see _.range, _.rangeRight
     * @example
     *
     * _.inRange(3, 2, 4);
     * // => true
     *
     * _.inRange(4, 8);
     * // => true
     *
     * _.inRange(4, 2);
     * // => false
     *
     * _.inRange(2, 2);
     * // => false
     *
     * _.inRange(1.2, 2);
     * // => true
     *
     * _.inRange(5.2, 4);
     * // => false
     *
     * _.inRange(-3, -2, -6);
     * // => true
     */
    function inRange(number, start, end) {
      start = toFinite(start);
      if (end === undefined) {
        end = start;
        start = 0;
      } else {
        end = toFinite(end);
      }
      number = toNumber(number);
      return baseInRange(number, start, end);
    }

    /**
     * Produces a random number between the inclusive `lower` and `upper` bounds.
     * If only one argument is provided a number between `0` and the given number
     * is returned. If `floating` is `true`, or either `lower` or `upper` are
     * floats, a floating-point number is returned instead of an integer.
     *
     * **Note:** JavaScript follows the IEEE-754 standard for resolving
     * floating-point values which can produce unexpected results.
     *
     * @static
     * @memberOf _
     * @since 0.7.0
     * @category Number
     * @param {number} [lower=0] The lower bound.
     * @param {number} [upper=1] The upper bound.
     * @param {boolean} [floating] Specify returning a floating-point number.
     * @returns {number} Returns the random number.
     * @example
     *
     * _.random(0, 5);
     * // => an integer between 0 and 5
     *
     * _.random(5);
     * // => also an integer between 0 and 5
     *
     * _.random(5, true);
     * // => a floating-point number between 0 and 5
     *
     * _.random(1.2, 5.2);
     * // => a floating-point number between 1.2 and 5.2
     */
    function random(lower, upper, floating) {
      if (floating && typeof floating != 'boolean' && isIterateeCall(lower, upper, floating)) {
        upper = floating = undefined;
      }
      if (floating === undefined) {
        if (typeof upper == 'boolean') {
          floating = upper;
          upper = undefined;
        }
        else if (typeof lower == 'boolean') {
          floating = lower;
          lower = undefined;
        }
      }
      if (lower === undefined && upper === undefined) {
        lower = 0;
        upper = 1;
      }
      else {
        lower = toFinite(lower);
        if (upper === undefined) {
          upper = lower;
          lower = 0;
        } else {
          upper = toFinite(upper);
        }
      }
      if (lower > upper) {
        var temp = lower;
        lower = upper;
        upper = temp;
      }
      if (floating || lower % 1 || upper % 1) {
        var rand = nativeRandom();
        return nativeMin(lower + (rand * (upper - lower + freeParseFloat('1e-' + ((rand + '').length - 1)))), upper);
      }
      return baseRandom(lower, upper);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the camel cased string.
     * @example
     *
     * _.camelCase('Foo Bar');
     * // => 'fooBar'
     *
     * _.camelCase('--foo-bar--');
     * // => 'fooBar'
     *
     * _.camelCase('__FOO_BAR__');
     * // => 'fooBar'
     */
    var camelCase = createCompounder(function(result, word, index) {
      word = word.toLowerCase();
      return result + (index ? capitalize(word) : word);
    });

    /**
     * Converts the first character of `string` to upper case and the remaining
     * to lower case.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to capitalize.
     * @returns {string} Returns the capitalized string.
     * @example
     *
     * _.capitalize('FRED');
     * // => 'Fred'
     */
    function capitalize(string) {
      return upperFirst(toString(string).toLowerCase());
    }

    /**
     * Deburrs `string` by converting
     * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
     * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
     * letters to basic Latin letters and removing
     * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to deburr.
     * @returns {string} Returns the deburred string.
     * @example
     *
     * _.deburr('dj vu');
     * // => 'deja vu'
     */
    function deburr(string) {
      string = toString(string);
      return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');
    }

    /**
     * Checks if `string` ends with the given target string.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {string} [target] The string to search for.
     * @param {number} [position=string.length] The position to search up to.
     * @returns {boolean} Returns `true` if `string` ends with `target`,
     *  else `false`.
     * @example
     *
     * _.endsWith('abc', 'c');
     * // => true
     *
     * _.endsWith('abc', 'b');
     * // => false
     *
     * _.endsWith('abc', 'b', 2);
     * // => true
     */
    function endsWith(string, target, position) {
      string = toString(string);
      target = baseToString(target);

      var length = string.length;
      position = position === undefined
        ? length
        : baseClamp(toInteger(position), 0, length);

      var end = position;
      position -= target.length;
      return position >= 0 && string.slice(position, end) == target;
    }

    /**
     * Converts the characters "&", "<", ">", '"', and "'" in `string` to their
     * corresponding HTML entities.
     *
     * **Note:** No other characters are escaped. To escape additional
     * characters use a third-party library like [_he_](https://mths.be/he).
     *
     * Though the ">" character is escaped for symmetry, characters like
     * ">" and "/" don't need escaping in HTML and have no special meaning
     * unless they're part of a tag or unquoted attribute value. See
     * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
     * (under "semi-related fun fact") for more details.
     *
     * When working with HTML you should always
     * [quote attribute values](http://wonko.com/post/html-escaping) to reduce
     * XSS vectors.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escape('fred, barney, & pebbles');
     * // => 'fred, barney, &amp; pebbles'
     */
    function escape(string) {
      string = toString(string);
      return (string && reHasUnescapedHtml.test(string))
        ? string.replace(reUnescapedHtml, escapeHtmlChar)
        : string;
    }

    /**
     * Escapes the `RegExp` special characters "^", "$", "\", ".", "*", "+",
     * "?", "(", ")", "[", "]", "{", "}", and "|" in `string`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escapeRegExp('[lodash](https://lodash.com/)');
     * // => '\[lodash\]\(https://lodash\.com/\)'
     */
    function escapeRegExp(string) {
      string = toString(string);
      return (string && reHasRegExpChar.test(string))
        ? string.replace(reRegExpChar, '\\$&')
        : string;
    }

    /**
     * Converts `string` to
     * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the kebab cased string.
     * @example
     *
     * _.kebabCase('Foo Bar');
     * // => 'foo-bar'
     *
     * _.kebabCase('fooBar');
     * // => 'foo-bar'
     *
     * _.kebabCase('__FOO_BAR__');
     * // => 'foo-bar'
     */
    var kebabCase = createCompounder(function(result, word, index) {
      return result + (index ? '-' : '') + word.toLowerCase();
    });

    /**
     * Converts `string`, as space separated words, to lower case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the lower cased string.
     * @example
     *
     * _.lowerCase('--Foo-Bar--');
     * // => 'foo bar'
     *
     * _.lowerCase('fooBar');
     * // => 'foo bar'
     *
     * _.lowerCase('__FOO_BAR__');
     * // => 'foo bar'
     */
    var lowerCase = createCompounder(function(result, word, index) {
      return result + (index ? ' ' : '') + word.toLowerCase();
    });

    /**
     * Converts the first character of `string` to lower case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.lowerFirst('Fred');
     * // => 'fred'
     *
     * _.lowerFirst('FRED');
     * // => 'fRED'
     */
    var lowerFirst = createCaseFirst('toLowerCase');

    /**
     * Pads `string` on the left and right sides if it's shorter than `length`.
     * Padding characters are truncated if they can't be evenly divided by `length`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.pad('abc', 8);
     * // => '  abc   '
     *
     * _.pad('abc', 8, '_-');
     * // => '_-abc_-_'
     *
     * _.pad('abc', 3);
     * // => 'abc'
     */
    function pad(string, length, chars) {
      string = toString(string);
      length = toInteger(length);

      var strLength = length ? stringSize(string) : 0;
      if (!length || strLength >= length) {
        return string;
      }
      var mid = (length - strLength) / 2;
      return (
        createPadding(nativeFloor(mid), chars) +
        string +
        createPadding(nativeCeil(mid), chars)
      );
    }

    /**
     * Pads `string` on the right side if it's shorter than `length`. Padding
     * characters are truncated if they exceed `length`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.padEnd('abc', 6);
     * // => 'abc   '
     *
     * _.padEnd('abc', 6, '_-');
     * // => 'abc_-_'
     *
     * _.padEnd('abc', 3);
     * // => 'abc'
     */
    function padEnd(string, length, chars) {
      string = toString(string);
      length = toInteger(length);

      var strLength = length ? stringSize(string) : 0;
      return (length && strLength < length)
        ? (string + createPadding(length - strLength, chars))
        : string;
    }

    /**
     * Pads `string` on the left side if it's shorter than `length`. Padding
     * characters are truncated if they exceed `length`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.padStart('abc', 6);
     * // => '   abc'
     *
     * _.padStart('abc', 6, '_-');
     * // => '_-_abc'
     *
     * _.padStart('abc', 3);
     * // => 'abc'
     */
    function padStart(string, length, chars) {
      string = toString(string);
      length = toInteger(length);

      var strLength = length ? stringSize(string) : 0;
      return (length && strLength < length)
        ? (createPadding(length - strLength, chars) + string)
        : string;
    }

    /**
     * Converts `string` to an integer of the specified radix. If `radix` is
     * `undefined` or `0`, a `radix` of `10` is used unless `value` is a
     * hexadecimal, in which case a `radix` of `16` is used.
     *
     * **Note:** This method aligns with the
     * [ES5 implementation](https://es5.github.io/#x15.1.2.2) of `parseInt`.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category String
     * @param {string} string The string to convert.
     * @param {number} [radix=10] The radix to interpret `value` by.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.parseInt('08');
     * // => 8
     *
     * _.map(['6', '08', '10'], _.parseInt);
     * // => [6, 8, 10]
     */
    function parseInt(string, radix, guard) {
      if (guard || radix == null) {
        radix = 0;
      } else if (radix) {
        radix = +radix;
      }
      return nativeParseInt(toString(string).replace(reTrimStart, ''), radix || 0);
    }

    /**
     * Repeats the given string `n` times.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to repeat.
     * @param {number} [n=1] The number of times to repeat the string.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the repeated string.
     * @example
     *
     * _.repeat('*', 3);
     * // => '***'
     *
     * _.repeat('abc', 2);
     * // => 'abcabc'
     *
     * _.repeat('abc', 0);
     * // => ''
     */
    function repeat(string, n, guard) {
      if ((guard ? isIterateeCall(string, n, guard) : n === undefined)) {
        n = 1;
      } else {
        n = toInteger(n);
      }
      return baseRepeat(toString(string), n);
    }

    /**
     * Replaces matches for `pattern` in `string` with `replacement`.
     *
     * **Note:** This method is based on
     * [`String#replace`](https://mdn.io/String/replace).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to modify.
     * @param {RegExp|string} pattern The pattern to replace.
     * @param {Function|string} replacement The match replacement.
     * @returns {string} Returns the modified string.
     * @example
     *
     * _.replace('Hi Fred', 'Fred', 'Barney');
     * // => 'Hi Barney'
     */
    function replace() {
      var args = arguments,
          string = toString(args[0]);

      return args.length < 3 ? string : string.replace(args[1], args[2]);
    }

    /**
     * Converts `string` to
     * [snake case](https://en.wikipedia.org/wiki/Snake_case).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the snake cased string.
     * @example
     *
     * _.snakeCase('Foo Bar');
     * // => 'foo_bar'
     *
     * _.snakeCase('fooBar');
     * // => 'foo_bar'
     *
     * _.snakeCase('--FOO-BAR--');
     * // => 'foo_bar'
     */
    var snakeCase = createCompounder(function(result, word, index) {
      return result + (index ? '_' : '') + word.toLowerCase();
    });

    /**
     * Splits `string` by `separator`.
     *
     * **Note:** This method is based on
     * [`String#split`](https://mdn.io/String/split).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to split.
     * @param {RegExp|string} separator The separator pattern to split by.
     * @param {number} [limit] The length to truncate results to.
     * @returns {Array} Returns the string segments.
     * @example
     *
     * _.split('a-b-c', '-', 2);
     * // => ['a', 'b']
     */
    function split(string, separator, limit) {
      if (limit && typeof limit != 'number' && isIterateeCall(string, separator, limit)) {
        separator = limit = undefined;
      }
      limit = limit === undefined ? MAX_ARRAY_LENGTH : limit >>> 0;
      if (!limit) {
        return [];
      }
      string = toString(string);
      if (string && (
            typeof separator == 'string' ||
            (separator != null && !isRegExp(separator))
          )) {
        separator = baseToString(separator);
        if (!separator && hasUnicode(string)) {
          return castSlice(stringToArray(string), 0, limit);
        }
      }
      return string.split(separator, limit);
    }

    /**
     * Converts `string` to
     * [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).
     *
     * @static
     * @memberOf _
     * @since 3.1.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the start cased string.
     * @example
     *
     * _.startCase('--foo-bar--');
     * // => 'Foo Bar'
     *
     * _.startCase('fooBar');
     * // => 'Foo Bar'
     *
     * _.startCase('__FOO_BAR__');
     * // => 'FOO BAR'
     */
    var startCase = createCompounder(function(result, word, index) {
      return result + (index ? ' ' : '') + upperFirst(word);
    });

    /**
     * Checks if `string` starts with the given target string.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {string} [target] The string to search for.
     * @param {number} [position=0] The position to search from.
     * @returns {boolean} Returns `true` if `string` starts with `target`,
     *  else `false`.
     * @example
     *
     * _.startsWith('abc', 'a');
     * // => true
     *
     * _.startsWith('abc', 'b');
     * // => false
     *
     * _.startsWith('abc', 'b', 1);
     * // => true
     */
    function startsWith(string, target, position) {
      string = toString(string);
      position = position == null
        ? 0
        : baseClamp(toInteger(position), 0, string.length);

      target = baseToString(target);
      return string.slice(position, position + target.length) == target;
    }

    /**
     * Creates a compiled template function that can interpolate data properties
     * in "interpolate" delimiters, HTML-escape interpolated data properties in
     * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
     * properties may be accessed as free variables in the template. If a setting
     * object is given, it takes precedence over `_.templateSettings` values.
     *
     * **Note:** In the development build `_.template` utilizes
     * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
     * for easier debugging.
     *
     * For more information on precompiling templates see
     * [lodash's custom builds documentation](https://lodash.com/custom-builds).
     *
     * For more information on Chrome extension sandboxes see
     * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category String
     * @param {string} [string=''] The template string.
     * @param {Object} [options={}] The options object.
     * @param {RegExp} [options.escape=_.templateSettings.escape]
     *  The HTML "escape" delimiter.
     * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]
     *  The "evaluate" delimiter.
     * @param {Object} [options.imports=_.templateSettings.imports]
     *  An object to import into the template as free variables.
     * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]
     *  The "interpolate" delimiter.
     * @param {string} [options.sourceURL='lodash.templateSources[n]']
     *  The sourceURL of the compiled template.
     * @param {string} [options.variable='obj']
     *  The data object variable name.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the compiled template function.
     * @example
     *
     * // Use the "interpolate" delimiter to create a compiled template.
     * var compiled = _.template('hello <%= user %>!');
     * compiled({ 'user': 'fred' });
     * // => 'hello fred!'
     *
     * // Use the HTML "escape" delimiter to escape data property values.
     * var compiled = _.template('<b><%- value %></b>');
     * compiled({ 'value': '<script>' });
     * // => '<b>&lt;script&gt;</b>'
     *
     * // Use the "evaluate" delimiter to execute JavaScript and generate HTML.
     * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
     * compiled({ 'users': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // Use the internal `print` function in "evaluate" delimiters.
     * var compiled = _.template('<% print("hello " + user); %>!');
     * compiled({ 'user': 'barney' });
     * // => 'hello barney!'
     *
     * // Use the ES template literal delimiter as an "interpolate" delimiter.
     * // Disable support by replacing the "interpolate" delimiter.
     * var compiled = _.template('hello ${ user }!');
     * compiled({ 'user': 'pebbles' });
     * // => 'hello pebbles!'
     *
     * // Use backslashes to treat delimiters as plain text.
     * var compiled = _.template('<%= "\\<%- value %\\>" %>');
     * compiled({ 'value': 'ignored' });
     * // => '<%- value %>'
     *
     * // Use the `imports` option to import `jQuery` as `jq`.
     * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
     * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
     * compiled({ 'users': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // Use the `sourceURL` option to specify a custom sourceURL for the template.
     * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
     * compiled(data);
     * // => Find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector.
     *
     * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.
     * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
     * compiled.source;
     * // => function(data) {
     * //   var __t, __p = '';
     * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
     * //   return __p;
     * // }
     *
     * // Use custom template delimiters.
     * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
     * var compiled = _.template('hello {{ user }}!');
     * compiled({ 'user': 'mustache' });
     * // => 'hello mustache!'
     *
     * // Use the `source` property to inline compiled templates for meaningful
     * // line numbers in error messages and stack traces.
     * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\
     *   var JST = {\
     *     "main": ' + _.template(mainText).source + '\
     *   };\
     * ');
     */
    function template(string, options, guard) {
      // Based on John Resig's `tmpl` implementation
      // (http://ejohn.org/blog/javascript-micro-templating/)
      // and Laura Doktorova's doT.js (https://github.com/olado/doT).
      var settings = lodash.templateSettings;

      if (guard && isIterateeCall(string, options, guard)) {
        options = undefined;
      }
      string = toString(string);
      options = assignInWith({}, options, settings, customDefaultsAssignIn);

      var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn),
          importsKeys = keys(imports),
          importsValues = baseValues(imports, importsKeys);

      var isEscaping,
          isEvaluating,
          index = 0,
          interpolate = options.interpolate || reNoMatch,
          source = "__p += '";

      // Compile the regexp to match each delimiter.
      var reDelimiters = RegExp(
        (options.escape || reNoMatch).source + '|' +
        interpolate.source + '|' +
        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
        (options.evaluate || reNoMatch).source + '|$'
      , 'g');

      // Use a sourceURL for easier debugging.
      // The sourceURL gets injected into the source that's eval-ed, so be careful
      // to normalize all kinds of whitespace, so e.g. newlines (and unicode versions of it) can't sneak in
      // and escape the comment, thus injecting code that gets evaled.
      var sourceURL = '//# sourceURL=' +
        (hasOwnProperty.call(options, 'sourceURL')
          ? (options.sourceURL + '').replace(/\s/g, ' ')
          : ('lodash.templateSources[' + (++templateCounter) + ']')
        ) + '\n';

      string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
        interpolateValue || (interpolateValue = esTemplateValue);

        // Escape characters that can't be included in string literals.
        source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);

        // Replace delimiters with snippets.
        if (escapeValue) {
          isEscaping = true;
          source += "' +\n__e(" + escapeValue + ") +\n'";
        }
        if (evaluateValue) {
          isEvaluating = true;
          source += "';\n" + evaluateValue + ";\n__p += '";
        }
        if (interpolateValue) {
          source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
        }
        index = offset + match.length;

        // The JS engine embedded in Adobe products needs `match` returned in
        // order to produce the correct `offset` value.
        return match;
      });

      source += "';\n";

      // If `variable` is not specified wrap a with-statement around the generated
      // code to add the data object to the top of the scope chain.
      var variable = hasOwnProperty.call(options, 'variable') && options.variable;
      if (!variable) {
        source = 'with (obj) {\n' + source + '\n}\n';
      }
      // Cleanup code by stripping empty strings.
      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
        .replace(reEmptyStringMiddle, '$1')
        .replace(reEmptyStringTrailing, '$1;');

      // Frame code as the function body.
      source = 'function(' + (variable || 'obj') + ') {\n' +
        (variable
          ? ''
          : 'obj || (obj = {});\n'
        ) +
        "var __t, __p = ''" +
        (isEscaping
           ? ', __e = _.escape'
           : ''
        ) +
        (isEvaluating
          ? ', __j = Array.prototype.join;\n' +
            "function print() { __p += __j.call(arguments, '') }\n"
          : ';\n'
        ) +
        source +
        'return __p\n}';

      var result = attempt(function() {
        return Function(importsKeys, sourceURL + 'return ' + source)
          .apply(undefined, importsValues);
      });

      // Provide the compiled function's source by its `toString` method or
      // the `source` property as a convenience for inlining compiled templates.
      result.source = source;
      if (isError(result)) {
        throw result;
      }
      return result;
    }

    /**
     * Converts `string`, as a whole, to lower case just like
     * [String#toLowerCase](https://mdn.io/toLowerCase).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the lower cased string.
     * @example
     *
     * _.toLower('--Foo-Bar--');
     * // => '--foo-bar--'
     *
     * _.toLower('fooBar');
     * // => 'foobar'
     *
     * _.toLower('__FOO_BAR__');
     * // => '__foo_bar__'
     */
    function toLower(value) {
      return toString(value).toLowerCase();
    }

    /**
     * Converts `string`, as a whole, to upper case just like
     * [String#toUpperCase](https://mdn.io/toUpperCase).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the upper cased string.
     * @example
     *
     * _.toUpper('--foo-bar--');
     * // => '--FOO-BAR--'
     *
     * _.toUpper('fooBar');
     * // => 'FOOBAR'
     *
     * _.toUpper('__foo_bar__');
     * // => '__FOO_BAR__'
     */
    function toUpper(value) {
      return toString(value).toUpperCase();
    }

    /**
     * Removes leading and trailing whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trim('  abc  ');
     * // => 'abc'
     *
     * _.trim('-_-abc-_-', '_-');
     * // => 'abc'
     *
     * _.map(['  foo  ', '  bar  '], _.trim);
     * // => ['foo', 'bar']
     */
    function trim(string, chars, guard) {
      string = toString(string);
      if (string && (guard || chars === undefined)) {
        return string.replace(reTrim, '');
      }
      if (!string || !(chars = baseToString(chars))) {
        return string;
      }
      var strSymbols = stringToArray(string),
          chrSymbols = stringToArray(chars),
          start = charsStartIndex(strSymbols, chrSymbols),
          end = charsEndIndex(strSymbols, chrSymbols) + 1;

      return castSlice(strSymbols, start, end).join('');
    }

    /**
     * Removes trailing whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trimEnd('  abc  ');
     * // => '  abc'
     *
     * _.trimEnd('-_-abc-_-', '_-');
     * // => '-_-abc'
     */
    function trimEnd(string, chars, guard) {
      string = toString(string);
      if (string && (guard || chars === undefined)) {
        return string.replace(reTrimEnd, '');
      }
      if (!string || !(chars = baseToString(chars))) {
        return string;
      }
      var strSymbols = stringToArray(string),
          end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;

      return castSlice(strSymbols, 0, end).join('');
    }

    /**
     * Removes leading whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trimStart('  abc  ');
     * // => 'abc  '
     *
     * _.trimStart('-_-abc-_-', '_-');
     * // => 'abc-_-'
     */
    function trimStart(string, chars, guard) {
      string = toString(string);
      if (string && (guard || chars === undefined)) {
        return string.replace(reTrimStart, '');
      }
      if (!string || !(chars = baseToString(chars))) {
        return string;
      }
      var strSymbols = stringToArray(string),
          start = charsStartIndex(strSymbols, stringToArray(chars));

      return castSlice(strSymbols, start).join('');
    }

    /**
     * Truncates `string` if it's longer than the given maximum string length.
     * The last characters of the truncated string are replaced with the omission
     * string which defaults to "...".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to truncate.
     * @param {Object} [options={}] The options object.
     * @param {number} [options.length=30] The maximum string length.
     * @param {string} [options.omission='...'] The string to indicate text is omitted.
     * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
     * @returns {string} Returns the truncated string.
     * @example
     *
     * _.truncate('hi-diddly-ho there, neighborino');
     * // => 'hi-diddly-ho there, neighbo...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'length': 24,
     *   'separator': ' '
     * });
     * // => 'hi-diddly-ho there,...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'length': 24,
     *   'separator': /,? +/
     * });
     * // => 'hi-diddly-ho there...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'omission': ' [...]'
     * });
     * // => 'hi-diddly-ho there, neig [...]'
     */
    function truncate(string, options) {
      var length = DEFAULT_TRUNC_LENGTH,
          omission = DEFAULT_TRUNC_OMISSION;

      if (isObject(options)) {
        var separator = 'separator' in options ? options.separator : separator;
        length = 'length' in options ? toInteger(options.length) : length;
        omission = 'omission' in options ? baseToString(options.omission) : omission;
      }
      string = toString(string);

      var strLength = string.length;
      if (hasUnicode(string)) {
        var strSymbols = stringToArray(string);
        strLength = strSymbols.length;
      }
      if (length >= strLength) {
        return string;
      }
      var end = length - stringSize(omission);
      if (end < 1) {
        return omission;
      }
      var result = strSymbols
        ? castSlice(strSymbols, 0, end).join('')
        : string.slice(0, end);

      if (separator === undefined) {
        return result + omission;
      }
      if (strSymbols) {
        end += (result.length - end);
      }
      if (isRegExp(separator)) {
        if (string.slice(end).search(separator)) {
          var match,
              substring = result;

          if (!separator.global) {
            separator = RegExp(separator.source, toString(reFlags.exec(separator)) + 'g');
          }
          separator.lastIndex = 0;
          while ((match = separator.exec(substring))) {
            var newEnd = match.index;
          }
          result = result.slice(0, newEnd === undefined ? end : newEnd);
        }
      } else if (string.indexOf(baseToString(separator), end) != end) {
        var index = result.lastIndexOf(separator);
        if (index > -1) {
          result = result.slice(0, index);
        }
      }
      return result + omission;
    }

    /**
     * The inverse of `_.escape`; this method converts the HTML entities
     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to
     * their corresponding characters.
     *
     * **Note:** No other HTML entities are unescaped. To unescape additional
     * HTML entities use a third-party library like [_he_](https://mths.be/he).
     *
     * @static
     * @memberOf _
     * @since 0.6.0
     * @category String
     * @param {string} [string=''] The string to unescape.
     * @returns {string} Returns the unescaped string.
     * @example
     *
     * _.unescape('fred, barney, &amp; pebbles');
     * // => 'fred, barney, & pebbles'
     */
    function unescape(string) {
      string = toString(string);
      return (string && reHasEscapedHtml.test(string))
        ? string.replace(reEscapedHtml, unescapeHtmlChar)
        : string;
    }

    /**
     * Converts `string`, as space separated words, to upper case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the upper cased string.
     * @example
     *
     * _.upperCase('--foo-bar');
     * // => 'FOO BAR'
     *
     * _.upperCase('fooBar');
     * // => 'FOO BAR'
     *
     * _.upperCase('__foo_bar__');
     * // => 'FOO BAR'
     */
    var upperCase = createCompounder(function(result, word, index) {
      return result + (index ? ' ' : '') + word.toUpperCase();
    });

    /**
     * Converts the first character of `string` to upper case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.upperFirst('fred');
     * // => 'Fred'
     *
     * _.upperFirst('FRED');
     * // => 'FRED'
     */
    var upperFirst = createCaseFirst('toUpperCase');

    /**
     * Splits `string` into an array of its words.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {RegExp|string} [pattern] The pattern to match words.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the words of `string`.
     * @example
     *
     * _.words('fred, barney, & pebbles');
     * // => ['fred', 'barney', 'pebbles']
     *
     * _.words('fred, barney, & pebbles', /[^, ]+/g);
     * // => ['fred', 'barney', '&', 'pebbles']
     */
    function words(string, pattern, guard) {
      string = toString(string);
      pattern = guard ? undefined : pattern;

      if (pattern === undefined) {
        return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
      }
      return string.match(pattern) || [];
    }

    /*------------------------------------------------------------------------*/

    /**
     * Attempts to invoke `func`, returning either the result or the caught error
     * object. Any additional arguments are provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Function} func The function to attempt.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {*} Returns the `func` result or error object.
     * @example
     *
     * // Avoid throwing errors for invalid selectors.
     * var elements = _.attempt(function(selector) {
     *   return document.querySelectorAll(selector);
     * }, '>_>');
     *
     * if (_.isError(elements)) {
     *   elements = [];
     * }
     */
    var attempt = baseRest(function(func, args) {
      try {
        return apply(func, undefined, args);
      } catch (e) {
        return isError(e) ? e : new Error(e);
      }
    });

    /**
     * Binds methods of an object to the object itself, overwriting the existing
     * method.
     *
     * **Note:** This method doesn't set the "length" property of bound functions.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {Object} object The object to bind and assign the bound methods to.
     * @param {...(string|string[])} methodNames The object method names to bind.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var view = {
     *   'label': 'docs',
     *   'click': function() {
     *     console.log('clicked ' + this.label);
     *   }
     * };
     *
     * _.bindAll(view, ['click']);
     * jQuery(element).on('click', view.click);
     * // => Logs 'clicked docs' when clicked.
     */
    var bindAll = flatRest(function(object, methodNames) {
      arrayEach(methodNames, function(key) {
        key = toKey(key);
        baseAssignValue(object, key, bind(object[key], object));
      });
      return object;
    });

    /**
     * Creates a function that iterates over `pairs` and invokes the corresponding
     * function of the first predicate to return truthy. The predicate-function
     * pairs are invoked with the `this` binding and arguments of the created
     * function.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {Array} pairs The predicate-function pairs.
     * @returns {Function} Returns the new composite function.
     * @example
     *
     * var func = _.cond([
     *   [_.matches({ 'a': 1 }),           _.constant('matches A')],
     *   [_.conforms({ 'b': _.isNumber }), _.constant('matches B')],
     *   [_.stubTrue,                      _.constant('no match')]
     * ]);
     *
     * func({ 'a': 1, 'b': 2 });
     * // => 'matches A'
     *
     * func({ 'a': 0, 'b': 1 });
     * // => 'matches B'
     *
     * func({ 'a': '1', 'b': '2' });
     * // => 'no match'
     */
    function cond(pairs) {
      var length = pairs == null ? 0 : pairs.length,
          toIteratee = getIteratee();

      pairs = !length ? [] : arrayMap(pairs, function(pair) {
        if (typeof pair[1] != 'function') {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        return [toIteratee(pair[0]), pair[1]];
      });

      return baseRest(function(args) {
        var index = -1;
        while (++index < length) {
          var pair = pairs[index];
          if (apply(pair[0], this, args)) {
            return apply(pair[1], this, args);
          }
        }
      });
    }

    /**
     * Creates a function that invokes the predicate properties of `source` with
     * the corresponding property values of a given object, returning `true` if
     * all predicates return truthy, else `false`.
     *
     * **Note:** The created function is equivalent to `_.conformsTo` with
     * `source` partially applied.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {Object} source The object of property predicates to conform to.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 2, 'b': 1 },
     *   { 'a': 1, 'b': 2 }
     * ];
     *
     * _.filter(objects, _.conforms({ 'b': function(n) { return n > 1; } }));
     * // => [{ 'a': 1, 'b': 2 }]
     */
    function conforms(source) {
      return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
    }

    /**
     * Creates a function that returns `value`.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Util
     * @param {*} value The value to return from the new function.
     * @returns {Function} Returns the new constant function.
     * @example
     *
     * var objects = _.times(2, _.constant({ 'a': 1 }));
     *
     * console.log(objects);
     * // => [{ 'a': 1 }, { 'a': 1 }]
     *
     * console.log(objects[0] === objects[1]);
     * // => true
     */
    function constant(value) {
      return function() {
        return value;
      };
    }

    /**
     * Checks `value` to determine whether a default value should be returned in
     * its place. The `defaultValue` is returned if `value` is `NaN`, `null`,
     * or `undefined`.
     *
     * @static
     * @memberOf _
     * @since 4.14.0
     * @category Util
     * @param {*} value The value to check.
     * @param {*} defaultValue The default value.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * _.defaultTo(1, 10);
     * // => 1
     *
     * _.defaultTo(undefined, 10);
     * // => 10
     */
    function defaultTo(value, defaultValue) {
      return (value == null || value !== value) ? defaultValue : value;
    }

    /**
     * Creates a function that returns the result of invoking the given functions
     * with the `this` binding of the created function, where each successive
     * invocation is supplied the return value of the previous.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {...(Function|Function[])} [funcs] The functions to invoke.
     * @returns {Function} Returns the new composite function.
     * @see _.flowRight
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var addSquare = _.flow([_.add, square]);
     * addSquare(1, 2);
     * // => 9
     */
    var flow = createFlow();

    /**
     * This method is like `_.flow` except that it creates a function that
     * invokes the given functions from right to left.
     *
     * @static
     * @since 3.0.0
     * @memberOf _
     * @category Util
     * @param {...(Function|Function[])} [funcs] The functions to invoke.
     * @returns {Function} Returns the new composite function.
     * @see _.flow
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var addSquare = _.flowRight([square, _.add]);
     * addSquare(1, 2);
     * // => 9
     */
    var flowRight = createFlow(true);

    /**
     * This method returns the first argument it receives.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {*} value Any value.
     * @returns {*} Returns `value`.
     * @example
     *
     * var object = { 'a': 1 };
     *
     * console.log(_.identity(object) === object);
     * // => true
     */
    function identity(value) {
      return value;
    }

    /**
     * Creates a function that invokes `func` with the arguments of the created
     * function. If `func` is a property name, the created function returns the
     * property value for a given element. If `func` is an array or object, the
     * created function returns `true` for elements that contain the equivalent
     * source properties, otherwise it returns `false`.
     *
     * @static
     * @since 4.0.0
     * @memberOf _
     * @category Util
     * @param {*} [func=_.identity] The value to convert to a callback.
     * @returns {Function} Returns the callback.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.filter(users, _.iteratee({ 'user': 'barney', 'active': true }));
     * // => [{ 'user': 'barney', 'age': 36, 'active': true }]
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.filter(users, _.iteratee(['user', 'fred']));
     * // => [{ 'user': 'fred', 'age': 40 }]
     *
     * // The `_.property` iteratee shorthand.
     * _.map(users, _.iteratee('user'));
     * // => ['barney', 'fred']
     *
     * // Create custom iteratee shorthands.
     * _.iteratee = _.wrap(_.iteratee, function(iteratee, func) {
     *   return !_.isRegExp(func) ? iteratee(func) : function(string) {
     *     return func.test(string);
     *   };
     * });
     *
     * _.filter(['abc', 'def'], /ef/);
     * // => ['def']
     */
    function iteratee(func) {
      return baseIteratee(typeof func == 'function' ? func : baseClone(func, CLONE_DEEP_FLAG));
    }

    /**
     * Creates a function that performs a partial deep comparison between a given
     * object and `source`, returning `true` if the given object has equivalent
     * property values, else `false`.
     *
     * **Note:** The created function is equivalent to `_.isMatch` with `source`
     * partially applied.
     *
     * Partial comparisons will match empty array and empty object `source`
     * values against any array or object value, respectively. See `_.isEqual`
     * for a list of supported value comparisons.
     *
     * **Note:** Multiple values can be checked by combining several matchers
     * using `_.overSome`
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 1, 'b': 2, 'c': 3 },
     *   { 'a': 4, 'b': 5, 'c': 6 }
     * ];
     *
     * _.filter(objects, _.matches({ 'a': 4, 'c': 6 }));
     * // => [{ 'a': 4, 'b': 5, 'c': 6 }]
     *
     * // Checking for several possible values
     * _.filter(objects, _.overSome([_.matches({ 'a': 1 }), _.matches({ 'a': 4 })]));
     * // => [{ 'a': 1, 'b': 2, 'c': 3 }, { 'a': 4, 'b': 5, 'c': 6 }]
     */
    function matches(source) {
      return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
    }

    /**
     * Creates a function that performs a partial deep comparison between the
     * value at `path` of a given object to `srcValue`, returning `true` if the
     * object value is equivalent, else `false`.
     *
     * **Note:** Partial comparisons will match empty array and empty object
     * `srcValue` values against any array or object value, respectively. See
     * `_.isEqual` for a list of supported value comparisons.
     *
     * **Note:** Multiple values can be checked by combining several matchers
     * using `_.overSome`
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Util
     * @param {Array|string} path The path of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 1, 'b': 2, 'c': 3 },
     *   { 'a': 4, 'b': 5, 'c': 6 }
     * ];
     *
     * _.find(objects, _.matchesProperty('a', 4));
     * // => { 'a': 4, 'b': 5, 'c': 6 }
     *
     * // Checking for several possible values
     * _.filter(objects, _.overSome([_.matchesProperty('a', 1), _.matchesProperty('a', 4)]));
     * // => [{ 'a': 1, 'b': 2, 'c': 3 }, { 'a': 4, 'b': 5, 'c': 6 }]
     */
    function matchesProperty(path, srcValue) {
      return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
    }

    /**
     * Creates a function that invokes the method at `path` of a given object.
     * Any additional arguments are provided to the invoked method.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Util
     * @param {Array|string} path The path of the method to invoke.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {Function} Returns the new invoker function.
     * @example
     *
     * var objects = [
     *   { 'a': { 'b': _.constant(2) } },
     *   { 'a': { 'b': _.constant(1) } }
     * ];
     *
     * _.map(objects, _.method('a.b'));
     * // => [2, 1]
     *
     * _.map(objects, _.method(['a', 'b']));
     * // => [2, 1]
     */
    var method = baseRest(function(path, args) {
      return function(object) {
        return baseInvoke(object, path, args);
      };
    });

    /**
     * The opposite of `_.method`; this method creates a function that invokes
     * the method at a given path of `object`. Any additional arguments are
     * provided to the invoked method.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Util
     * @param {Object} object The object to query.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {Function} Returns the new invoker function.
     * @example
     *
     * var array = _.times(3, _.constant),
     *     object = { 'a': array, 'b': array, 'c': array };
     *
     * _.map(['a[2]', 'c[0]'], _.methodOf(object));
     * // => [2, 0]
     *
     * _.map([['a', '2'], ['c', '0']], _.methodOf(object));
     * // => [2, 0]
     */
    var methodOf = baseRest(function(object, args) {
      return function(path) {
        return baseInvoke(object, path, args);
      };
    });

    /**
     * Adds all own enumerable string keyed function properties of a source
     * object to the destination object. If `object` is a function, then methods
     * are added to its prototype as well.
     *
     * **Note:** Use `_.runInContext` to create a pristine `lodash` function to
     * avoid conflicts caused by modifying the original.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {Function|Object} [object=lodash] The destination object.
     * @param {Object} source The object of functions to add.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.chain=true] Specify whether mixins are chainable.
     * @returns {Function|Object} Returns `object`.
     * @example
     *
     * function vowels(string) {
     *   return _.filter(string, function(v) {
     *     return /[aeiou]/i.test(v);
     *   });
     * }
     *
     * _.mixin({ 'vowels': vowels });
     * _.vowels('fred');
     * // => ['e']
     *
     * _('fred').vowels().value();
     * // => ['e']
     *
     * _.mixin({ 'vowels': vowels }, { 'chain': false });
     * _('fred').vowels();
     * // => ['e']
     */
    function mixin(object, source, options) {
      var props = keys(source),
          methodNames = baseFunctions(source, props);

      if (options == null &&
          !(isObject(source) && (methodNames.length || !props.length))) {
        options = source;
        source = object;
        object = this;
        methodNames = baseFunctions(source, keys(source));
      }
      var chain = !(isObject(options) && 'chain' in options) || !!options.chain,
          isFunc = isFunction(object);

      arrayEach(methodNames, function(methodName) {
        var func = source[methodName];
        object[methodName] = func;
        if (isFunc) {
          object.prototype[methodName] = function() {
            var chainAll = this.__chain__;
            if (chain || chainAll) {
              var result = object(this.__wrapped__),
                  actions = result.__actions__ = copyArray(this.__actions__);

              actions.push({ 'func': func, 'args': arguments, 'thisArg': object });
              result.__chain__ = chainAll;
              return result;
            }
            return func.apply(object, arrayPush([this.value()], arguments));
          };
        }
      });

      return object;
    }

    /**
     * Reverts the `_` variable to its previous value and returns a reference to
     * the `lodash` function.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @returns {Function} Returns the `lodash` function.
     * @example
     *
     * var lodash = _.noConflict();
     */
    function noConflict() {
      if (root._ === this) {
        root._ = oldDash;
      }
      return this;
    }

    /**
     * This method returns `undefined`.
     *
     * @static
     * @memberOf _
     * @since 2.3.0
     * @category Util
     * @example
     *
     * _.times(2, _.noop);
     * // => [undefined, undefined]
     */
    function noop() {
      // No operation performed.
    }

    /**
     * Creates a function that gets the argument at index `n`. If `n` is negative,
     * the nth argument from the end is returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {number} [n=0] The index of the argument to return.
     * @returns {Function} Returns the new pass-thru function.
     * @example
     *
     * var func = _.nthArg(1);
     * func('a', 'b', 'c', 'd');
     * // => 'b'
     *
     * var func = _.nthArg(-2);
     * func('a', 'b', 'c', 'd');
     * // => 'c'
     */
    function nthArg(n) {
      n = toInteger(n);
      return baseRest(function(args) {
        return baseNth(args, n);
      });
    }

    /**
     * Creates a function that invokes `iteratees` with the arguments it receives
     * and returns their results.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [iteratees=[_.identity]]
     *  The iteratees to invoke.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.over([Math.max, Math.min]);
     *
     * func(1, 2, 3, 4);
     * // => [4, 1]
     */
    var over = createOver(arrayMap);

    /**
     * Creates a function that checks if **all** of the `predicates` return
     * truthy when invoked with the arguments it receives.
     *
     * Following shorthands are possible for providing predicates.
     * Pass an `Object` and it will be used as an parameter for `_.matches` to create the predicate.
     * Pass an `Array` of parameters for `_.matchesProperty` and the predicate will be created using them.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [predicates=[_.identity]]
     *  The predicates to check.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.overEvery([Boolean, isFinite]);
     *
     * func('1');
     * // => true
     *
     * func(null);
     * // => false
     *
     * func(NaN);
     * // => false
     */
    var overEvery = createOver(arrayEvery);

    /**
     * Creates a function that checks if **any** of the `predicates` return
     * truthy when invoked with the arguments it receives.
     *
     * Following shorthands are possible for providing predicates.
     * Pass an `Object` and it will be used as an parameter for `_.matches` to create the predicate.
     * Pass an `Array` of parameters for `_.matchesProperty` and the predicate will be created using them.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [predicates=[_.identity]]
     *  The predicates to check.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.overSome([Boolean, isFinite]);
     *
     * func('1');
     * // => true
     *
     * func(null);
     * // => true
     *
     * func(NaN);
     * // => false
     *
     * var matchesFunc = _.overSome([{ 'a': 1 }, { 'a': 2 }])
     * var matchesPropertyFunc = _.overSome([['a', 1], ['a', 2]])
     */
    var overSome = createOver(arraySome);

    /**
     * Creates a function that returns the value at `path` of a given object.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Util
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new accessor function.
     * @example
     *
     * var objects = [
     *   { 'a': { 'b': 2 } },
     *   { 'a': { 'b': 1 } }
     * ];
     *
     * _.map(objects, _.property('a.b'));
     * // => [2, 1]
     *
     * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
     * // => [1, 2]
     */
    function property(path) {
      return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
    }

    /**
     * The opposite of `_.property`; this method creates a function that returns
     * the value at a given path of `object`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Object} object The object to query.
     * @returns {Function} Returns the new accessor function.
     * @example
     *
     * var array = [0, 1, 2],
     *     object = { 'a': array, 'b': array, 'c': array };
     *
     * _.map(['a[2]', 'c[0]'], _.propertyOf(object));
     * // => [2, 0]
     *
     * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));
     * // => [2, 0]
     */
    function propertyOf(object) {
      return function(path) {
        return object == null ? undefined : baseGet(object, path);
      };
    }

    /**
     * Creates an array of numbers (positive and/or negative) progressing from
     * `start` up to, but not including, `end`. A step of `-1` is used if a negative
     * `start` is specified without an `end` or `step`. If `end` is not specified,
     * it's set to `start` with `start` then set to `0`.
     *
     * **Note:** JavaScript follows the IEEE-754 standard for resolving
     * floating-point values which can produce unexpected results.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns the range of numbers.
     * @see _.inRange, _.rangeRight
     * @example
     *
     * _.range(4);
     * // => [0, 1, 2, 3]
     *
     * _.range(-4);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 5);
     * // => [1, 2, 3, 4]
     *
     * _.range(0, 20, 5);
     * // => [0, 5, 10, 15]
     *
     * _.range(0, -4, -1);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.range(0);
     * // => []
     */
    var range = createRange();

    /**
     * This method is like `_.range` except that it populates values in
     * descending order.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns the range of numbers.
     * @see _.inRange, _.range
     * @example
     *
     * _.rangeRight(4);
     * // => [3, 2, 1, 0]
     *
     * _.rangeRight(-4);
     * // => [-3, -2, -1, 0]
     *
     * _.rangeRight(1, 5);
     * // => [4, 3, 2, 1]
     *
     * _.rangeRight(0, 20, 5);
     * // => [15, 10, 5, 0]
     *
     * _.rangeRight(0, -4, -1);
     * // => [-3, -2, -1, 0]
     *
     * _.rangeRight(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.rangeRight(0);
     * // => []
     */
    var rangeRight = createRange(true);

    /**
     * This method returns a new empty array.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {Array} Returns the new empty array.
     * @example
     *
     * var arrays = _.times(2, _.stubArray);
     *
     * console.log(arrays);
     * // => [[], []]
     *
     * console.log(arrays[0] === arrays[1]);
     * // => false
     */
    function stubArray() {
      return [];
    }

    /**
     * This method returns `false`.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {boolean} Returns `false`.
     * @example
     *
     * _.times(2, _.stubFalse);
     * // => [false, false]
     */
    function stubFalse() {
      return false;
    }

    /**
     * This method returns a new empty object.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {Object} Returns the new empty object.
     * @example
     *
     * var objects = _.times(2, _.stubObject);
     *
     * console.log(objects);
     * // => [{}, {}]
     *
     * console.log(objects[0] === objects[1]);
     * // => false
     */
    function stubObject() {
      return {};
    }

    /**
     * This method returns an empty string.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {string} Returns the empty string.
     * @example
     *
     * _.times(2, _.stubString);
     * // => ['', '']
     */
    function stubString() {
      return '';
    }

    /**
     * This method returns `true`.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {boolean} Returns `true`.
     * @example
     *
     * _.times(2, _.stubTrue);
     * // => [true, true]
     */
    function stubTrue() {
      return true;
    }

    /**
     * Invokes the iteratee `n` times, returning an array of the results of
     * each invocation. The iteratee is invoked with one argument; (index).
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {number} n The number of times to invoke `iteratee`.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the array of results.
     * @example
     *
     * _.times(3, String);
     * // => ['0', '1', '2']
     *
     *  _.times(4, _.constant(0));
     * // => [0, 0, 0, 0]
     */
    function times(n, iteratee) {
      n = toInteger(n);
      if (n < 1 || n > MAX_SAFE_INTEGER) {
        return [];
      }
      var index = MAX_ARRAY_LENGTH,
          length = nativeMin(n, MAX_ARRAY_LENGTH);

      iteratee = getIteratee(iteratee);
      n -= MAX_ARRAY_LENGTH;

      var result = baseTimes(length, iteratee);
      while (++index < n) {
        iteratee(index);
      }
      return result;
    }

    /**
     * Converts `value` to a property path array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {*} value The value to convert.
     * @returns {Array} Returns the new property path array.
     * @example
     *
     * _.toPath('a.b.c');
     * // => ['a', 'b', 'c']
     *
     * _.toPath('a[0].b.c');
     * // => ['a', '0', 'b', 'c']
     */
    function toPath(value) {
      if (isArray(value)) {
        return arrayMap(value, toKey);
      }
      return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
    }

    /**
     * Generates a unique ID. If `prefix` is given, the ID is appended to it.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {string} [prefix=''] The value to prefix the ID with.
     * @returns {string} Returns the unique ID.
     * @example
     *
     * _.uniqueId('contact_');
     * // => 'contact_104'
     *
     * _.uniqueId();
     * // => '105'
     */
    function uniqueId(prefix) {
      var id = ++idCounter;
      return toString(prefix) + id;
    }

    /*------------------------------------------------------------------------*/

    /**
     * Adds two numbers.
     *
     * @static
     * @memberOf _
     * @since 3.4.0
     * @category Math
     * @param {number} augend The first number in an addition.
     * @param {number} addend The second number in an addition.
     * @returns {number} Returns the total.
     * @example
     *
     * _.add(6, 4);
     * // => 10
     */
    var add = createMathOperation(function(augend, addend) {
      return augend + addend;
    }, 0);

    /**
     * Computes `number` rounded up to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round up.
     * @param {number} [precision=0] The precision to round up to.
     * @returns {number} Returns the rounded up number.
     * @example
     *
     * _.ceil(4.006);
     * // => 5
     *
     * _.ceil(6.004, 2);
     * // => 6.01
     *
     * _.ceil(6040, -2);
     * // => 6100
     */
    var ceil = createRound('ceil');

    /**
     * Divide two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {number} dividend The first number in a division.
     * @param {number} divisor The second number in a division.
     * @returns {number} Returns the quotient.
     * @example
     *
     * _.divide(6, 4);
     * // => 1.5
     */
    var divide = createMathOperation(function(dividend, divisor) {
      return dividend / divisor;
    }, 1);

    /**
     * Computes `number` rounded down to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round down.
     * @param {number} [precision=0] The precision to round down to.
     * @returns {number} Returns the rounded down number.
     * @example
     *
     * _.floor(4.006);
     * // => 4
     *
     * _.floor(0.046, 2);
     * // => 0.04
     *
     * _.floor(4060, -2);
     * // => 4000
     */
    var floor = createRound('floor');

    /**
     * Computes the maximum value of `array`. If `array` is empty or falsey,
     * `undefined` is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * _.max([4, 2, 8, 6]);
     * // => 8
     *
     * _.max([]);
     * // => undefined
     */
    function max(array) {
      return (array && array.length)
        ? baseExtremum(array, identity, baseGt)
        : undefined;
    }

    /**
     * This method is like `_.max` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * the value is ranked. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * var objects = [{ 'n': 1 }, { 'n': 2 }];
     *
     * _.maxBy(objects, function(o) { return o.n; });
     * // => { 'n': 2 }
     *
     * // The `_.property` iteratee shorthand.
     * _.maxBy(objects, 'n');
     * // => { 'n': 2 }
     */
    function maxBy(array, iteratee) {
      return (array && array.length)
        ? baseExtremum(array, getIteratee(iteratee, 2), baseGt)
        : undefined;
    }

    /**
     * Computes the mean of the values in `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {number} Returns the mean.
     * @example
     *
     * _.mean([4, 2, 8, 6]);
     * // => 5
     */
    function mean(array) {
      return baseMean(array, identity);
    }

    /**
     * This method is like `_.mean` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the value to be averaged.
     * The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the mean.
     * @example
     *
     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
     *
     * _.meanBy(objects, function(o) { return o.n; });
     * // => 5
     *
     * // The `_.property` iteratee shorthand.
     * _.meanBy(objects, 'n');
     * // => 5
     */
    function meanBy(array, iteratee) {
      return baseMean(array, getIteratee(iteratee, 2));
    }

    /**
     * Computes the minimum value of `array`. If `array` is empty or falsey,
     * `undefined` is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * _.min([4, 2, 8, 6]);
     * // => 2
     *
     * _.min([]);
     * // => undefined
     */
    function min(array) {
      return (array && array.length)
        ? baseExtremum(array, identity, baseLt)
        : undefined;
    }

    /**
     * This method is like `_.min` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * the value is ranked. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * var objects = [{ 'n': 1 }, { 'n': 2 }];
     *
     * _.minBy(objects, function(o) { return o.n; });
     * // => { 'n': 1 }
     *
     * // The `_.property` iteratee shorthand.
     * _.minBy(objects, 'n');
     * // => { 'n': 1 }
     */
    function minBy(array, iteratee) {
      return (array && array.length)
        ? baseExtremum(array, getIteratee(iteratee, 2), baseLt)
        : undefined;
    }

    /**
     * Multiply two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {number} multiplier The first number in a multiplication.
     * @param {number} multiplicand The second number in a multiplication.
     * @returns {number} Returns the product.
     * @example
     *
     * _.multiply(6, 4);
     * // => 24
     */
    var multiply = createMathOperation(function(multiplier, multiplicand) {
      return multiplier * multiplicand;
    }, 1);

    /**
     * Computes `number` rounded to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round.
     * @param {number} [precision=0] The precision to round to.
     * @returns {number} Returns the rounded number.
     * @example
     *
     * _.round(4.006);
     * // => 4
     *
     * _.round(4.006, 2);
     * // => 4.01
     *
     * _.round(4060, -2);
     * // => 4100
     */
    var round = createRound('round');

    /**
     * Subtract two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {number} minuend The first number in a subtraction.
     * @param {number} subtrahend The second number in a subtraction.
     * @returns {number} Returns the difference.
     * @example
     *
     * _.subtract(6, 4);
     * // => 2
     */
    var subtract = createMathOperation(function(minuend, subtrahend) {
      return minuend - subtrahend;
    }, 0);

    /**
     * Computes the sum of the values in `array`.
     *
     * @static
     * @memberOf _
     * @since 3.4.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {number} Returns the sum.
     * @example
     *
     * _.sum([4, 2, 8, 6]);
     * // => 20
     */
    function sum(array) {
      return (array && array.length)
        ? baseSum(array, identity)
        : 0;
    }

    /**
     * This method is like `_.sum` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the value to be summed.
     * The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the sum.
     * @example
     *
     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
     *
     * _.sumBy(objects, function(o) { return o.n; });
     * // => 20
     *
     * // The `_.property` iteratee shorthand.
     * _.sumBy(objects, 'n');
     * // => 20
     */
    function sumBy(array, iteratee) {
      return (array && array.length)
        ? baseSum(array, getIteratee(iteratee, 2))
        : 0;
    }

    /*------------------------------------------------------------------------*/

    // Add methods that return wrapped values in chain sequences.
    lodash.after = after;
    lodash.ary = ary;
    lodash.assign = assign;
    lodash.assignIn = assignIn;
    lodash.assignInWith = assignInWith;
    lodash.assignWith = assignWith;
    lodash.at = at;
    lodash.before = before;
    lodash.bind = bind;
    lodash.bindAll = bindAll;
    lodash.bindKey = bindKey;
    lodash.castArray = castArray;
    lodash.chain = chain;
    lodash.chunk = chunk;
    lodash.compact = compact;
    lodash.concat = concat;
    lodash.cond = cond;
    lodash.conforms = conforms;
    lodash.constant = constant;
    lodash.countBy = countBy;
    lodash.create = create;
    lodash.curry = curry;
    lodash.curryRight = curryRight;
    lodash.debounce = debounce;
    lodash.defaults = defaults;
    lodash.defaultsDeep = defaultsDeep;
    lodash.defer = defer;
    lodash.delay = delay;
    lodash.difference = difference;
    lodash.differenceBy = differenceBy;
    lodash.differenceWith = differenceWith;
    lodash.drop = drop;
    lodash.dropRight = dropRight;
    lodash.dropRightWhile = dropRightWhile;
    lodash.dropWhile = dropWhile;
    lodash.fill = fill;
    lodash.filter = filter;
    lodash.flatMap = flatMap;
    lodash.flatMapDeep = flatMapDeep;
    lodash.flatMapDepth = flatMapDepth;
    lodash.flatten = flatten;
    lodash.flattenDeep = flattenDeep;
    lodash.flattenDepth = flattenDepth;
    lodash.flip = flip;
    lodash.flow = flow;
    lodash.flowRight = flowRight;
    lodash.fromPairs = fromPairs;
    lodash.functions = functions;
    lodash.functionsIn = functionsIn;
    lodash.groupBy = groupBy;
    lodash.initial = initial;
    lodash.intersection = intersection;
    lodash.intersectionBy = intersectionBy;
    lodash.intersectionWith = intersectionWith;
    lodash.invert = invert;
    lodash.invertBy = invertBy;
    lodash.invokeMap = invokeMap;
    lodash.iteratee = iteratee;
    lodash.keyBy = keyBy;
    lodash.keys = keys;
    lodash.keysIn = keysIn;
    lodash.map = map;
    lodash.mapKeys = mapKeys;
    lodash.mapValues = mapValues;
    lodash.matches = matches;
    lodash.matchesProperty = matchesProperty;
    lodash.memoize = memoize;
    lodash.merge = merge;
    lodash.mergeWith = mergeWith;
    lodash.method = method;
    lodash.methodOf = methodOf;
    lodash.mixin = mixin;
    lodash.negate = negate;
    lodash.nthArg = nthArg;
    lodash.omit = omit;
    lodash.omitBy = omitBy;
    lodash.once = once;
    lodash.orderBy = orderBy;
    lodash.over = over;
    lodash.overArgs = overArgs;
    lodash.overEvery = overEvery;
    lodash.overSome = overSome;
    lodash.partial = partial;
    lodash.partialRight = partialRight;
    lodash.partition = partition;
    lodash.pick = pick;
    lodash.pickBy = pickBy;
    lodash.property = property;
    lodash.propertyOf = propertyOf;
    lodash.pull = pull;
    lodash.pullAll = pullAll;
    lodash.pullAllBy = pullAllBy;
    lodash.pullAllWith = pullAllWith;
    lodash.pullAt = pullAt;
    lodash.range = range;
    lodash.rangeRight = rangeRight;
    lodash.rearg = rearg;
    lodash.reject = reject;
    lodash.remove = remove;
    lodash.rest = rest;
    lodash.reverse = reverse;
    lodash.sampleSize = sampleSize;
    lodash.set = set;
    lodash.setWith = setWith;
    lodash.shuffle = shuffle;
    lodash.slice = slice;
    lodash.sortBy = sortBy;
    lodash.sortedUniq = sortedUniq;
    lodash.sortedUniqBy = sortedUniqBy;
    lodash.split = split;
    lodash.spread = spread;
    lodash.tail = tail;
    lodash.take = take;
    lodash.takeRight = takeRight;
    lodash.takeRightWhile = takeRightWhile;
    lodash.takeWhile = takeWhile;
    lodash.tap = tap;
    lodash.throttle = throttle;
    lodash.thru = thru;
    lodash.toArray = toArray;
    lodash.toPairs = toPairs;
    lodash.toPairsIn = toPairsIn;
    lodash.toPath = toPath;
    lodash.toPlainObject = toPlainObject;
    lodash.transform = transform;
    lodash.unary = unary;
    lodash.union = union;
    lodash.unionBy = unionBy;
    lodash.unionWith = unionWith;
    lodash.uniq = uniq;
    lodash.uniqBy = uniqBy;
    lodash.uniqWith = uniqWith;
    lodash.unset = unset;
    lodash.unzip = unzip;
    lodash.unzipWith = unzipWith;
    lodash.update = update;
    lodash.updateWith = updateWith;
    lodash.values = values;
    lodash.valuesIn = valuesIn;
    lodash.without = without;
    lodash.words = words;
    lodash.wrap = wrap;
    lodash.xor = xor;
    lodash.xorBy = xorBy;
    lodash.xorWith = xorWith;
    lodash.zip = zip;
    lodash.zipObject = zipObject;
    lodash.zipObjectDeep = zipObjectDeep;
    lodash.zipWith = zipWith;

    // Add aliases.
    lodash.entries = toPairs;
    lodash.entriesIn = toPairsIn;
    lodash.extend = assignIn;
    lodash.extendWith = assignInWith;

    // Add methods to `lodash.prototype`.
    mixin(lodash, lodash);

    /*------------------------------------------------------------------------*/

    // Add methods that return unwrapped values in chain sequences.
    lodash.add = add;
    lodash.attempt = attempt;
    lodash.camelCase = camelCase;
    lodash.capitalize = capitalize;
    lodash.ceil = ceil;
    lodash.clamp = clamp;
    lodash.clone = clone;
    lodash.cloneDeep = cloneDeep;
    lodash.cloneDeepWith = cloneDeepWith;
    lodash.cloneWith = cloneWith;
    lodash.conformsTo = conformsTo;
    lodash.deburr = deburr;
    lodash.defaultTo = defaultTo;
    lodash.divide = divide;
    lodash.endsWith = endsWith;
    lodash.eq = eq;
    lodash.escape = escape;
    lodash.escapeRegExp = escapeRegExp;
    lodash.every = every;
    lodash.find = find;
    lodash.findIndex = findIndex;
    lodash.findKey = findKey;
    lodash.findLast = findLast;
    lodash.findLastIndex = findLastIndex;
    lodash.findLastKey = findLastKey;
    lodash.floor = floor;
    lodash.forEach = forEach;
    lodash.forEachRight = forEachRight;
    lodash.forIn = forIn;
    lodash.forInRight = forInRight;
    lodash.forOwn = forOwn;
    lodash.forOwnRight = forOwnRight;
    lodash.get = get;
    lodash.gt = gt;
    lodash.gte = gte;
    lodash.has = has;
    lodash.hasIn = hasIn;
    lodash.head = head;
    lodash.identity = identity;
    lodash.includes = includes;
    lodash.indexOf = indexOf;
    lodash.inRange = inRange;
    lodash.invoke = invoke;
    lodash.isArguments = isArguments;
    lodash.isArray = isArray;
    lodash.isArrayBuffer = isArrayBuffer;
    lodash.isArrayLike = isArrayLike;
    lodash.isArrayLikeObject = isArrayLikeObject;
    lodash.isBoolean = isBoolean;
    lodash.isBuffer = isBuffer;
    lodash.isDate = isDate;
    lodash.isElement = isElement;
    lodash.isEmpty = isEmpty;
    lodash.isEqual = isEqual;
    lodash.isEqualWith = isEqualWith;
    lodash.isError = isError;
    lodash.isFinite = isFinite;
    lodash.isFunction = isFunction;
    lodash.isInteger = isInteger;
    lodash.isLength = isLength;
    lodash.isMap = isMap;
    lodash.isMatch = isMatch;
    lodash.isMatchWith = isMatchWith;
    lodash.isNaN = isNaN;
    lodash.isNative = isNative;
    lodash.isNil = isNil;
    lodash.isNull = isNull;
    lodash.isNumber = isNumber;
    lodash.isObject = isObject;
    lodash.isObjectLike = isObjectLike;
    lodash.isPlainObject = isPlainObject;
    lodash.isRegExp = isRegExp;
    lodash.isSafeInteger = isSafeInteger;
    lodash.isSet = isSet;
    lodash.isString = isString;
    lodash.isSymbol = isSymbol;
    lodash.isTypedArray = isTypedArray;
    lodash.isUndefined = isUndefined;
    lodash.isWeakMap = isWeakMap;
    lodash.isWeakSet = isWeakSet;
    lodash.join = join;
    lodash.kebabCase = kebabCase;
    lodash.last = last;
    lodash.lastIndexOf = lastIndexOf;
    lodash.lowerCase = lowerCase;
    lodash.lowerFirst = lowerFirst;
    lodash.lt = lt;
    lodash.lte = lte;
    lodash.max = max;
    lodash.maxBy = maxBy;
    lodash.mean = mean;
    lodash.meanBy = meanBy;
    lodash.min = min;
    lodash.minBy = minBy;
    lodash.stubArray = stubArray;
    lodash.stubFalse = stubFalse;
    lodash.stubObject = stubObject;
    lodash.stubString = stubString;
    lodash.stubTrue = stubTrue;
    lodash.multiply = multiply;
    lodash.nth = nth;
    lodash.noConflict = noConflict;
    lodash.noop = noop;
    lodash.now = now;
    lodash.pad = pad;
    lodash.padEnd = padEnd;
    lodash.padStart = padStart;
    lodash.parseInt = parseInt;
    lodash.random = random;
    lodash.reduce = reduce;
    lodash.reduceRight = reduceRight;
    lodash.repeat = repeat;
    lodash.replace = replace;
    lodash.result = result;
    lodash.round = round;
    lodash.runInContext = runInContext;
    lodash.sample = sample;
    lodash.size = size;
    lodash.snakeCase = snakeCase;
    lodash.some = some;
    lodash.sortedIndex = sortedIndex;
    lodash.sortedIndexBy = sortedIndexBy;
    lodash.sortedIndexOf = sortedIndexOf;
    lodash.sortedLastIndex = sortedLastIndex;
    lodash.sortedLastIndexBy = sortedLastIndexBy;
    lodash.sortedLastIndexOf = sortedLastIndexOf;
    lodash.startCase = startCase;
    lodash.startsWith = startsWith;
    lodash.subtract = subtract;
    lodash.sum = sum;
    lodash.sumBy = sumBy;
    lodash.template = template;
    lodash.times = times;
    lodash.toFinite = toFinite;
    lodash.toInteger = toInteger;
    lodash.toLength = toLength;
    lodash.toLower = toLower;
    lodash.toNumber = toNumber;
    lodash.toSafeInteger = toSafeInteger;
    lodash.toString = toString;
    lodash.toUpper = toUpper;
    lodash.trim = trim;
    lodash.trimEnd = trimEnd;
    lodash.trimStart = trimStart;
    lodash.truncate = truncate;
    lodash.unescape = unescape;
    lodash.uniqueId = uniqueId;
    lodash.upperCase = upperCase;
    lodash.upperFirst = upperFirst;

    // Add aliases.
    lodash.each = forEach;
    lodash.eachRight = forEachRight;
    lodash.first = head;

    mixin(lodash, (function() {
      var source = {};
      baseForOwn(lodash, function(func, methodName) {
        if (!hasOwnProperty.call(lodash.prototype, methodName)) {
          source[methodName] = func;
        }
      });
      return source;
    }()), { 'chain': false });

    /*------------------------------------------------------------------------*/

    /**
     * The semantic version number.
     *
     * @static
     * @memberOf _
     * @type {string}
     */
    lodash.VERSION = VERSION;

    // Assign default placeholders.
    arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function(methodName) {
      lodash[methodName].placeholder = lodash;
    });

    // Add `LazyWrapper` methods for `_.drop` and `_.take` variants.
    arrayEach(['drop', 'take'], function(methodName, index) {
      LazyWrapper.prototype[methodName] = function(n) {
        n = n === undefined ? 1 : nativeMax(toInteger(n), 0);

        var result = (this.__filtered__ && !index)
          ? new LazyWrapper(this)
          : this.clone();

        if (result.__filtered__) {
          result.__takeCount__ = nativeMin(n, result.__takeCount__);
        } else {
          result.__views__.push({
            'size': nativeMin(n, MAX_ARRAY_LENGTH),
            'type': methodName + (result.__dir__ < 0 ? 'Right' : '')
          });
        }
        return result;
      };

      LazyWrapper.prototype[methodName + 'Right'] = function(n) {
        return this.reverse()[methodName](n).reverse();
      };
    });

    // Add `LazyWrapper` methods that accept an `iteratee` value.
    arrayEach(['filter', 'map', 'takeWhile'], function(methodName, index) {
      var type = index + 1,
          isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;

      LazyWrapper.prototype[methodName] = function(iteratee) {
        var result = this.clone();
        result.__iteratees__.push({
          'iteratee': getIteratee(iteratee, 3),
          'type': type
        });
        result.__filtered__ = result.__filtered__ || isFilter;
        return result;
      };
    });

    // Add `LazyWrapper` methods for `_.head` and `_.last`.
    arrayEach(['head', 'last'], function(methodName, index) {
      var takeName = 'take' + (index ? 'Right' : '');

      LazyWrapper.prototype[methodName] = function() {
        return this[takeName](1).value()[0];
      };
    });

    // Add `LazyWrapper` methods for `_.initial` and `_.tail`.
    arrayEach(['initial', 'tail'], function(methodName, index) {
      var dropName = 'drop' + (index ? '' : 'Right');

      LazyWrapper.prototype[methodName] = function() {
        return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
      };
    });

    LazyWrapper.prototype.compact = function() {
      return this.filter(identity);
    };

    LazyWrapper.prototype.find = function(predicate) {
      return this.filter(predicate).head();
    };

    LazyWrapper.prototype.findLast = function(predicate) {
      return this.reverse().find(predicate);
    };

    LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
      if (typeof path == 'function') {
        return new LazyWrapper(this);
      }
      return this.map(function(value) {
        return baseInvoke(value, path, args);
      });
    });

    LazyWrapper.prototype.reject = function(predicate) {
      return this.filter(negate(getIteratee(predicate)));
    };

    LazyWrapper.prototype.slice = function(start, end) {
      start = toInteger(start);

      var result = this;
      if (result.__filtered__ && (start > 0 || end < 0)) {
        return new LazyWrapper(result);
      }
      if (start < 0) {
        result = result.takeRight(-start);
      } else if (start) {
        result = result.drop(start);
      }
      if (end !== undefined) {
        end = toInteger(end);
        result = end < 0 ? result.dropRight(-end) : result.take(end - start);
      }
      return result;
    };

    LazyWrapper.prototype.takeRightWhile = function(predicate) {
      return this.reverse().takeWhile(predicate).reverse();
    };

    LazyWrapper.prototype.toArray = function() {
      return this.take(MAX_ARRAY_LENGTH);
    };

    // Add `LazyWrapper` methods to `lodash.prototype`.
    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
      var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName),
          isTaker = /^(?:head|last)$/.test(methodName),
          lodashFunc = lodash[isTaker ? ('take' + (methodName == 'last' ? 'Right' : '')) : methodName],
          retUnwrapped = isTaker || /^find/.test(methodName);

      if (!lodashFunc) {
        return;
      }
      lodash.prototype[methodName] = function() {
        var value = this.__wrapped__,
            args = isTaker ? [1] : arguments,
            isLazy = value instanceof LazyWrapper,
            iteratee = args[0],
            useLazy = isLazy || isArray(value);

        var interceptor = function(value) {
          var result = lodashFunc.apply(lodash, arrayPush([value], args));
          return (isTaker && chainAll) ? result[0] : result;
        };

        if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {
          // Avoid lazy use if the iteratee has a "length" value other than `1`.
          isLazy = useLazy = false;
        }
        var chainAll = this.__chain__,
            isHybrid = !!this.__actions__.length,
            isUnwrapped = retUnwrapped && !chainAll,
            onlyLazy = isLazy && !isHybrid;

        if (!retUnwrapped && useLazy) {
          value = onlyLazy ? value : new LazyWrapper(this);
          var result = func.apply(value, args);
          result.__actions__.push({ 'func': thru, 'args': [interceptor], 'thisArg': undefined });
          return new LodashWrapper(result, chainAll);
        }
        if (isUnwrapped && onlyLazy) {
          return func.apply(this, args);
        }
        result = this.thru(interceptor);
        return isUnwrapped ? (isTaker ? result.value()[0] : result.value()) : result;
      };
    });

    // Add `Array` methods to `lodash.prototype`.
    arrayEach(['pop', 'push', 'shift', 'sort', 'splice', 'unshift'], function(methodName) {
      var func = arrayProto[methodName],
          chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',
          retUnwrapped = /^(?:pop|shift)$/.test(methodName);

      lodash.prototype[methodName] = function() {
        var args = arguments;
        if (retUnwrapped && !this.__chain__) {
          var value = this.value();
          return func.apply(isArray(value) ? value : [], args);
        }
        return this[chainName](function(value) {
          return func.apply(isArray(value) ? value : [], args);
        });
      };
    });

    // Map minified method names to their real names.
    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
      var lodashFunc = lodash[methodName];
      if (lodashFunc) {
        var key = lodashFunc.name + '';
        if (!hasOwnProperty.call(realNames, key)) {
          realNames[key] = [];
        }
        realNames[key].push({ 'name': methodName, 'func': lodashFunc });
      }
    });

    realNames[createHybrid(undefined, WRAP_BIND_KEY_FLAG).name] = [{
      'name': 'wrapper',
      'func': undefined
    }];

    // Add methods to `LazyWrapper`.
    LazyWrapper.prototype.clone = lazyClone;
    LazyWrapper.prototype.reverse = lazyReverse;
    LazyWrapper.prototype.value = lazyValue;

    // Add chain sequence methods to the `lodash` wrapper.
    lodash.prototype.at = wrapperAt;
    lodash.prototype.chain = wrapperChain;
    lodash.prototype.commit = wrapperCommit;
    lodash.prototype.next = wrapperNext;
    lodash.prototype.plant = wrapperPlant;
    lodash.prototype.reverse = wrapperReverse;
    lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;

    // Add lazy aliases.
    lodash.prototype.first = lodash.prototype.head;

    if (symIterator) {
      lodash.prototype[symIterator] = wrapperToIterator;
    }
    return lodash;
  });

  /*--------------------------------------------------------------------------*/

  // Export lodash.
  var _ = runInContext();

  // Some AMD build optimizers, like r.js, check for condition patterns like:
  if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
    // Expose Lodash on the global object to prevent errors when Lodash is
    // loaded by a script tag in the presence of an AMD loader.
    // See http://requirejs.org/docs/errors.html#mismatch for more details.
    // Use `_.noConflict` to remove Lodash from the global object.
    root._ = _;

    // Define as an anonymous module so, through path mapping, it can be
    // referenced as the "underscore" module.
    define(function() {
      return _;
    });
  }
  // Check for `exports` after `define` in case a build optimizer adds it.
  else if (freeModule) {
    // Export for Node.js.
    (freeModule.exports = _)._ = _;
    // Export for CommonJS support.
    freeExports._ = _;
  }
  else {
    // Export to the global object.
    root._ = _;
  }
}.call(this));

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],112:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("./internal/Observable");
exports.Observable = Observable_1.Observable;
var ConnectableObservable_1 = require("./internal/observable/ConnectableObservable");
exports.ConnectableObservable = ConnectableObservable_1.ConnectableObservable;
var groupBy_1 = require("./internal/operators/groupBy");
exports.GroupedObservable = groupBy_1.GroupedObservable;
var observable_1 = require("./internal/symbol/observable");
exports.observable = observable_1.observable;
var Subject_1 = require("./internal/Subject");
exports.Subject = Subject_1.Subject;
var BehaviorSubject_1 = require("./internal/BehaviorSubject");
exports.BehaviorSubject = BehaviorSubject_1.BehaviorSubject;
var ReplaySubject_1 = require("./internal/ReplaySubject");
exports.ReplaySubject = ReplaySubject_1.ReplaySubject;
var AsyncSubject_1 = require("./internal/AsyncSubject");
exports.AsyncSubject = AsyncSubject_1.AsyncSubject;
var asap_1 = require("./internal/scheduler/asap");
exports.asap = asap_1.asap;
exports.asapScheduler = asap_1.asapScheduler;
var async_1 = require("./internal/scheduler/async");
exports.async = async_1.async;
exports.asyncScheduler = async_1.asyncScheduler;
var queue_1 = require("./internal/scheduler/queue");
exports.queue = queue_1.queue;
exports.queueScheduler = queue_1.queueScheduler;
var animationFrame_1 = require("./internal/scheduler/animationFrame");
exports.animationFrame = animationFrame_1.animationFrame;
exports.animationFrameScheduler = animationFrame_1.animationFrameScheduler;
var VirtualTimeScheduler_1 = require("./internal/scheduler/VirtualTimeScheduler");
exports.VirtualTimeScheduler = VirtualTimeScheduler_1.VirtualTimeScheduler;
exports.VirtualAction = VirtualTimeScheduler_1.VirtualAction;
var Scheduler_1 = require("./internal/Scheduler");
exports.Scheduler = Scheduler_1.Scheduler;
var Subscription_1 = require("./internal/Subscription");
exports.Subscription = Subscription_1.Subscription;
var Subscriber_1 = require("./internal/Subscriber");
exports.Subscriber = Subscriber_1.Subscriber;
var Notification_1 = require("./internal/Notification");
exports.Notification = Notification_1.Notification;
exports.NotificationKind = Notification_1.NotificationKind;
var pipe_1 = require("./internal/util/pipe");
exports.pipe = pipe_1.pipe;
var noop_1 = require("./internal/util/noop");
exports.noop = noop_1.noop;
var identity_1 = require("./internal/util/identity");
exports.identity = identity_1.identity;
var isObservable_1 = require("./internal/util/isObservable");
exports.isObservable = isObservable_1.isObservable;
var ArgumentOutOfRangeError_1 = require("./internal/util/ArgumentOutOfRangeError");
exports.ArgumentOutOfRangeError = ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;
var EmptyError_1 = require("./internal/util/EmptyError");
exports.EmptyError = EmptyError_1.EmptyError;
var ObjectUnsubscribedError_1 = require("./internal/util/ObjectUnsubscribedError");
exports.ObjectUnsubscribedError = ObjectUnsubscribedError_1.ObjectUnsubscribedError;
var UnsubscriptionError_1 = require("./internal/util/UnsubscriptionError");
exports.UnsubscriptionError = UnsubscriptionError_1.UnsubscriptionError;
var TimeoutError_1 = require("./internal/util/TimeoutError");
exports.TimeoutError = TimeoutError_1.TimeoutError;
var bindCallback_1 = require("./internal/observable/bindCallback");
exports.bindCallback = bindCallback_1.bindCallback;
var bindNodeCallback_1 = require("./internal/observable/bindNodeCallback");
exports.bindNodeCallback = bindNodeCallback_1.bindNodeCallback;
var combineLatest_1 = require("./internal/observable/combineLatest");
exports.combineLatest = combineLatest_1.combineLatest;
var concat_1 = require("./internal/observable/concat");
exports.concat = concat_1.concat;
var defer_1 = require("./internal/observable/defer");
exports.defer = defer_1.defer;
var empty_1 = require("./internal/observable/empty");
exports.empty = empty_1.empty;
var forkJoin_1 = require("./internal/observable/forkJoin");
exports.forkJoin = forkJoin_1.forkJoin;
var from_1 = require("./internal/observable/from");
exports.from = from_1.from;
var fromEvent_1 = require("./internal/observable/fromEvent");
exports.fromEvent = fromEvent_1.fromEvent;
var fromEventPattern_1 = require("./internal/observable/fromEventPattern");
exports.fromEventPattern = fromEventPattern_1.fromEventPattern;
var generate_1 = require("./internal/observable/generate");
exports.generate = generate_1.generate;
var iif_1 = require("./internal/observable/iif");
exports.iif = iif_1.iif;
var interval_1 = require("./internal/observable/interval");
exports.interval = interval_1.interval;
var merge_1 = require("./internal/observable/merge");
exports.merge = merge_1.merge;
var never_1 = require("./internal/observable/never");
exports.never = never_1.never;
var of_1 = require("./internal/observable/of");
exports.of = of_1.of;
var onErrorResumeNext_1 = require("./internal/observable/onErrorResumeNext");
exports.onErrorResumeNext = onErrorResumeNext_1.onErrorResumeNext;
var pairs_1 = require("./internal/observable/pairs");
exports.pairs = pairs_1.pairs;
var partition_1 = require("./internal/observable/partition");
exports.partition = partition_1.partition;
var race_1 = require("./internal/observable/race");
exports.race = race_1.race;
var range_1 = require("./internal/observable/range");
exports.range = range_1.range;
var throwError_1 = require("./internal/observable/throwError");
exports.throwError = throwError_1.throwError;
var timer_1 = require("./internal/observable/timer");
exports.timer = timer_1.timer;
var using_1 = require("./internal/observable/using");
exports.using = using_1.using;
var zip_1 = require("./internal/observable/zip");
exports.zip = zip_1.zip;
var scheduled_1 = require("./internal/scheduled/scheduled");
exports.scheduled = scheduled_1.scheduled;
var empty_2 = require("./internal/observable/empty");
exports.EMPTY = empty_2.EMPTY;
var never_2 = require("./internal/observable/never");
exports.NEVER = never_2.NEVER;
var config_1 = require("./internal/config");
exports.config = config_1.config;

},{"./internal/AsyncSubject":113,"./internal/BehaviorSubject":114,"./internal/Notification":116,"./internal/Observable":117,"./internal/ReplaySubject":120,"./internal/Scheduler":121,"./internal/Subject":122,"./internal/Subscriber":124,"./internal/Subscription":125,"./internal/config":126,"./internal/observable/ConnectableObservable":128,"./internal/observable/bindCallback":130,"./internal/observable/bindNodeCallback":131,"./internal/observable/combineLatest":132,"./internal/observable/concat":133,"./internal/observable/defer":134,"./internal/observable/empty":135,"./internal/observable/forkJoin":136,"./internal/observable/from":137,"./internal/observable/fromEvent":139,"./internal/observable/fromEventPattern":140,"./internal/observable/generate":141,"./internal/observable/iif":142,"./internal/observable/interval":143,"./internal/observable/merge":144,"./internal/observable/never":145,"./internal/observable/of":146,"./internal/observable/onErrorResumeNext":147,"./internal/observable/pairs":148,"./internal/observable/partition":149,"./internal/observable/race":150,"./internal/observable/range":151,"./internal/observable/throwError":152,"./internal/observable/timer":153,"./internal/observable/using":154,"./internal/observable/zip":155,"./internal/operators/groupBy":191,"./internal/scheduled/scheduled":264,"./internal/scheduler/VirtualTimeScheduler":274,"./internal/scheduler/animationFrame":275,"./internal/scheduler/asap":276,"./internal/scheduler/async":277,"./internal/scheduler/queue":278,"./internal/symbol/observable":280,"./internal/util/ArgumentOutOfRangeError":282,"./internal/util/EmptyError":283,"./internal/util/ObjectUnsubscribedError":285,"./internal/util/TimeoutError":286,"./internal/util/UnsubscriptionError":287,"./internal/util/identity":290,"./internal/util/isObservable":299,"./internal/util/noop":302,"./internal/util/pipe":304}],113:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subject_1 = require("./Subject");
var Subscription_1 = require("./Subscription");
var AsyncSubject = (function (_super) {
    __extends(AsyncSubject, _super);
    function AsyncSubject() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.value = null;
        _this.hasNext = false;
        _this.hasCompleted = false;
        return _this;
    }
    AsyncSubject.prototype._subscribe = function (subscriber) {
        if (this.hasError) {
            subscriber.error(this.thrownError);
            return Subscription_1.Subscription.EMPTY;
        }
        else if (this.hasCompleted && this.hasNext) {
            subscriber.next(this.value);
            subscriber.complete();
            return Subscription_1.Subscription.EMPTY;
        }
        return _super.prototype._subscribe.call(this, subscriber);
    };
    AsyncSubject.prototype.next = function (value) {
        if (!this.hasCompleted) {
            this.value = value;
            this.hasNext = true;
        }
    };
    AsyncSubject.prototype.error = function (error) {
        if (!this.hasCompleted) {
            _super.prototype.error.call(this, error);
        }
    };
    AsyncSubject.prototype.complete = function () {
        this.hasCompleted = true;
        if (this.hasNext) {
            _super.prototype.next.call(this, this.value);
        }
        _super.prototype.complete.call(this);
    };
    return AsyncSubject;
}(Subject_1.Subject));
exports.AsyncSubject = AsyncSubject;

},{"./Subject":122,"./Subscription":125}],114:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subject_1 = require("./Subject");
var ObjectUnsubscribedError_1 = require("./util/ObjectUnsubscribedError");
var BehaviorSubject = (function (_super) {
    __extends(BehaviorSubject, _super);
    function BehaviorSubject(_value) {
        var _this = _super.call(this) || this;
        _this._value = _value;
        return _this;
    }
    Object.defineProperty(BehaviorSubject.prototype, "value", {
        get: function () {
            return this.getValue();
        },
        enumerable: true,
        configurable: true
    });
    BehaviorSubject.prototype._subscribe = function (subscriber) {
        var subscription = _super.prototype._subscribe.call(this, subscriber);
        if (subscription && !subscription.closed) {
            subscriber.next(this._value);
        }
        return subscription;
    };
    BehaviorSubject.prototype.getValue = function () {
        if (this.hasError) {
            throw this.thrownError;
        }
        else if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        else {
            return this._value;
        }
    };
    BehaviorSubject.prototype.next = function (value) {
        _super.prototype.next.call(this, this._value = value);
    };
    return BehaviorSubject;
}(Subject_1.Subject));
exports.BehaviorSubject = BehaviorSubject;

},{"./Subject":122,"./util/ObjectUnsubscribedError":285}],115:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("./Subscriber");
var InnerSubscriber = (function (_super) {
    __extends(InnerSubscriber, _super);
    function InnerSubscriber(parent, outerValue, outerIndex) {
        var _this = _super.call(this) || this;
        _this.parent = parent;
        _this.outerValue = outerValue;
        _this.outerIndex = outerIndex;
        _this.index = 0;
        return _this;
    }
    InnerSubscriber.prototype._next = function (value) {
        this.parent.notifyNext(this.outerValue, value, this.outerIndex, this.index++, this);
    };
    InnerSubscriber.prototype._error = function (error) {
        this.parent.notifyError(error, this);
        this.unsubscribe();
    };
    InnerSubscriber.prototype._complete = function () {
        this.parent.notifyComplete(this);
        this.unsubscribe();
    };
    return InnerSubscriber;
}(Subscriber_1.Subscriber));
exports.InnerSubscriber = InnerSubscriber;

},{"./Subscriber":124}],116:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var empty_1 = require("./observable/empty");
var of_1 = require("./observable/of");
var throwError_1 = require("./observable/throwError");
var NotificationKind;
(function (NotificationKind) {
    NotificationKind["NEXT"] = "N";
    NotificationKind["ERROR"] = "E";
    NotificationKind["COMPLETE"] = "C";
})(NotificationKind = exports.NotificationKind || (exports.NotificationKind = {}));
var Notification = (function () {
    function Notification(kind, value, error) {
        this.kind = kind;
        this.value = value;
        this.error = error;
        this.hasValue = kind === 'N';
    }
    Notification.prototype.observe = function (observer) {
        switch (this.kind) {
            case 'N':
                return observer.next && observer.next(this.value);
            case 'E':
                return observer.error && observer.error(this.error);
            case 'C':
                return observer.complete && observer.complete();
        }
    };
    Notification.prototype.do = function (next, error, complete) {
        var kind = this.kind;
        switch (kind) {
            case 'N':
                return next && next(this.value);
            case 'E':
                return error && error(this.error);
            case 'C':
                return complete && complete();
        }
    };
    Notification.prototype.accept = function (nextOrObserver, error, complete) {
        if (nextOrObserver && typeof nextOrObserver.next === 'function') {
            return this.observe(nextOrObserver);
        }
        else {
            return this.do(nextOrObserver, error, complete);
        }
    };
    Notification.prototype.toObservable = function () {
        var kind = this.kind;
        switch (kind) {
            case 'N':
                return of_1.of(this.value);
            case 'E':
                return throwError_1.throwError(this.error);
            case 'C':
                return empty_1.empty();
        }
        throw new Error('unexpected notification kind value');
    };
    Notification.createNext = function (value) {
        if (typeof value !== 'undefined') {
            return new Notification('N', value);
        }
        return Notification.undefinedValueNotification;
    };
    Notification.createError = function (err) {
        return new Notification('E', undefined, err);
    };
    Notification.createComplete = function () {
        return Notification.completeNotification;
    };
    Notification.completeNotification = new Notification('C');
    Notification.undefinedValueNotification = new Notification('N', undefined);
    return Notification;
}());
exports.Notification = Notification;

},{"./observable/empty":135,"./observable/of":146,"./observable/throwError":152}],117:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var canReportError_1 = require("./util/canReportError");
var toSubscriber_1 = require("./util/toSubscriber");
var observable_1 = require("./symbol/observable");
var pipe_1 = require("./util/pipe");
var config_1 = require("./config");
var Observable = (function () {
    function Observable(subscribe) {
        this._isScalar = false;
        if (subscribe) {
            this._subscribe = subscribe;
        }
    }
    Observable.prototype.lift = function (operator) {
        var observable = new Observable();
        observable.source = this;
        observable.operator = operator;
        return observable;
    };
    Observable.prototype.subscribe = function (observerOrNext, error, complete) {
        var operator = this.operator;
        var sink = toSubscriber_1.toSubscriber(observerOrNext, error, complete);
        if (operator) {
            sink.add(operator.call(sink, this.source));
        }
        else {
            sink.add(this.source || (config_1.config.useDeprecatedSynchronousErrorHandling && !sink.syncErrorThrowable) ?
                this._subscribe(sink) :
                this._trySubscribe(sink));
        }
        if (config_1.config.useDeprecatedSynchronousErrorHandling) {
            if (sink.syncErrorThrowable) {
                sink.syncErrorThrowable = false;
                if (sink.syncErrorThrown) {
                    throw sink.syncErrorValue;
                }
            }
        }
        return sink;
    };
    Observable.prototype._trySubscribe = function (sink) {
        try {
            return this._subscribe(sink);
        }
        catch (err) {
            if (config_1.config.useDeprecatedSynchronousErrorHandling) {
                sink.syncErrorThrown = true;
                sink.syncErrorValue = err;
            }
            if (canReportError_1.canReportError(sink)) {
                sink.error(err);
            }
            else {
                console.warn(err);
            }
        }
    };
    Observable.prototype.forEach = function (next, promiseCtor) {
        var _this = this;
        promiseCtor = getPromiseCtor(promiseCtor);
        return new promiseCtor(function (resolve, reject) {
            var subscription;
            subscription = _this.subscribe(function (value) {
                try {
                    next(value);
                }
                catch (err) {
                    reject(err);
                    if (subscription) {
                        subscription.unsubscribe();
                    }
                }
            }, reject, resolve);
        });
    };
    Observable.prototype._subscribe = function (subscriber) {
        var source = this.source;
        return source && source.subscribe(subscriber);
    };
    Observable.prototype[observable_1.observable] = function () {
        return this;
    };
    Observable.prototype.pipe = function () {
        var operations = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            operations[_i] = arguments[_i];
        }
        if (operations.length === 0) {
            return this;
        }
        return pipe_1.pipeFromArray(operations)(this);
    };
    Observable.prototype.toPromise = function (promiseCtor) {
        var _this = this;
        promiseCtor = getPromiseCtor(promiseCtor);
        return new promiseCtor(function (resolve, reject) {
            var value;
            _this.subscribe(function (x) { return value = x; }, function (err) { return reject(err); }, function () { return resolve(value); });
        });
    };
    Observable.create = function (subscribe) {
        return new Observable(subscribe);
    };
    return Observable;
}());
exports.Observable = Observable;
function getPromiseCtor(promiseCtor) {
    if (!promiseCtor) {
        promiseCtor = config_1.config.Promise || Promise;
    }
    if (!promiseCtor) {
        throw new Error('no Promise impl found');
    }
    return promiseCtor;
}

},{"./config":126,"./symbol/observable":280,"./util/canReportError":288,"./util/pipe":304,"./util/toSubscriber":311}],118:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var config_1 = require("./config");
var hostReportError_1 = require("./util/hostReportError");
exports.empty = {
    closed: true,
    next: function (value) { },
    error: function (err) {
        if (config_1.config.useDeprecatedSynchronousErrorHandling) {
            throw err;
        }
        else {
            hostReportError_1.hostReportError(err);
        }
    },
    complete: function () { }
};

},{"./config":126,"./util/hostReportError":289}],119:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("./Subscriber");
var OuterSubscriber = (function (_super) {
    __extends(OuterSubscriber, _super);
    function OuterSubscriber() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    OuterSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.destination.next(innerValue);
    };
    OuterSubscriber.prototype.notifyError = function (error, innerSub) {
        this.destination.error(error);
    };
    OuterSubscriber.prototype.notifyComplete = function (innerSub) {
        this.destination.complete();
    };
    return OuterSubscriber;
}(Subscriber_1.Subscriber));
exports.OuterSubscriber = OuterSubscriber;

},{"./Subscriber":124}],120:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subject_1 = require("./Subject");
var queue_1 = require("./scheduler/queue");
var Subscription_1 = require("./Subscription");
var observeOn_1 = require("./operators/observeOn");
var ObjectUnsubscribedError_1 = require("./util/ObjectUnsubscribedError");
var SubjectSubscription_1 = require("./SubjectSubscription");
var ReplaySubject = (function (_super) {
    __extends(ReplaySubject, _super);
    function ReplaySubject(bufferSize, windowTime, scheduler) {
        if (bufferSize === void 0) { bufferSize = Number.POSITIVE_INFINITY; }
        if (windowTime === void 0) { windowTime = Number.POSITIVE_INFINITY; }
        var _this = _super.call(this) || this;
        _this.scheduler = scheduler;
        _this._events = [];
        _this._infiniteTimeWindow = false;
        _this._bufferSize = bufferSize < 1 ? 1 : bufferSize;
        _this._windowTime = windowTime < 1 ? 1 : windowTime;
        if (windowTime === Number.POSITIVE_INFINITY) {
            _this._infiniteTimeWindow = true;
            _this.next = _this.nextInfiniteTimeWindow;
        }
        else {
            _this.next = _this.nextTimeWindow;
        }
        return _this;
    }
    ReplaySubject.prototype.nextInfiniteTimeWindow = function (value) {
        if (!this.isStopped) {
            var _events = this._events;
            _events.push(value);
            if (_events.length > this._bufferSize) {
                _events.shift();
            }
        }
        _super.prototype.next.call(this, value);
    };
    ReplaySubject.prototype.nextTimeWindow = function (value) {
        if (!this.isStopped) {
            this._events.push(new ReplayEvent(this._getNow(), value));
            this._trimBufferThenGetEvents();
        }
        _super.prototype.next.call(this, value);
    };
    ReplaySubject.prototype._subscribe = function (subscriber) {
        var _infiniteTimeWindow = this._infiniteTimeWindow;
        var _events = _infiniteTimeWindow ? this._events : this._trimBufferThenGetEvents();
        var scheduler = this.scheduler;
        var len = _events.length;
        var subscription;
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        else if (this.isStopped || this.hasError) {
            subscription = Subscription_1.Subscription.EMPTY;
        }
        else {
            this.observers.push(subscriber);
            subscription = new SubjectSubscription_1.SubjectSubscription(this, subscriber);
        }
        if (scheduler) {
            subscriber.add(subscriber = new observeOn_1.ObserveOnSubscriber(subscriber, scheduler));
        }
        if (_infiniteTimeWindow) {
            for (var i = 0; i < len && !subscriber.closed; i++) {
                subscriber.next(_events[i]);
            }
        }
        else {
            for (var i = 0; i < len && !subscriber.closed; i++) {
                subscriber.next(_events[i].value);
            }
        }
        if (this.hasError) {
            subscriber.error(this.thrownError);
        }
        else if (this.isStopped) {
            subscriber.complete();
        }
        return subscription;
    };
    ReplaySubject.prototype._getNow = function () {
        return (this.scheduler || queue_1.queue).now();
    };
    ReplaySubject.prototype._trimBufferThenGetEvents = function () {
        var now = this._getNow();
        var _bufferSize = this._bufferSize;
        var _windowTime = this._windowTime;
        var _events = this._events;
        var eventsCount = _events.length;
        var spliceCount = 0;
        while (spliceCount < eventsCount) {
            if ((now - _events[spliceCount].time) < _windowTime) {
                break;
            }
            spliceCount++;
        }
        if (eventsCount > _bufferSize) {
            spliceCount = Math.max(spliceCount, eventsCount - _bufferSize);
        }
        if (spliceCount > 0) {
            _events.splice(0, spliceCount);
        }
        return _events;
    };
    return ReplaySubject;
}(Subject_1.Subject));
exports.ReplaySubject = ReplaySubject;
var ReplayEvent = (function () {
    function ReplayEvent(time, value) {
        this.time = time;
        this.value = value;
    }
    return ReplayEvent;
}());

},{"./Subject":122,"./SubjectSubscription":123,"./Subscription":125,"./operators/observeOn":207,"./scheduler/queue":278,"./util/ObjectUnsubscribedError":285}],121:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Scheduler = (function () {
    function Scheduler(SchedulerAction, now) {
        if (now === void 0) { now = Scheduler.now; }
        this.SchedulerAction = SchedulerAction;
        this.now = now;
    }
    Scheduler.prototype.schedule = function (work, delay, state) {
        if (delay === void 0) { delay = 0; }
        return new this.SchedulerAction(this, work).schedule(state, delay);
    };
    Scheduler.now = function () { return Date.now(); };
    return Scheduler;
}());
exports.Scheduler = Scheduler;

},{}],122:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("./Observable");
var Subscriber_1 = require("./Subscriber");
var Subscription_1 = require("./Subscription");
var ObjectUnsubscribedError_1 = require("./util/ObjectUnsubscribedError");
var SubjectSubscription_1 = require("./SubjectSubscription");
var rxSubscriber_1 = require("../internal/symbol/rxSubscriber");
var SubjectSubscriber = (function (_super) {
    __extends(SubjectSubscriber, _super);
    function SubjectSubscriber(destination) {
        var _this = _super.call(this, destination) || this;
        _this.destination = destination;
        return _this;
    }
    return SubjectSubscriber;
}(Subscriber_1.Subscriber));
exports.SubjectSubscriber = SubjectSubscriber;
var Subject = (function (_super) {
    __extends(Subject, _super);
    function Subject() {
        var _this = _super.call(this) || this;
        _this.observers = [];
        _this.closed = false;
        _this.isStopped = false;
        _this.hasError = false;
        _this.thrownError = null;
        return _this;
    }
    Subject.prototype[rxSubscriber_1.rxSubscriber] = function () {
        return new SubjectSubscriber(this);
    };
    Subject.prototype.lift = function (operator) {
        var subject = new AnonymousSubject(this, this);
        subject.operator = operator;
        return subject;
    };
    Subject.prototype.next = function (value) {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        if (!this.isStopped) {
            var observers = this.observers;
            var len = observers.length;
            var copy = observers.slice();
            for (var i = 0; i < len; i++) {
                copy[i].next(value);
            }
        }
    };
    Subject.prototype.error = function (err) {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        this.hasError = true;
        this.thrownError = err;
        this.isStopped = true;
        var observers = this.observers;
        var len = observers.length;
        var copy = observers.slice();
        for (var i = 0; i < len; i++) {
            copy[i].error(err);
        }
        this.observers.length = 0;
    };
    Subject.prototype.complete = function () {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        this.isStopped = true;
        var observers = this.observers;
        var len = observers.length;
        var copy = observers.slice();
        for (var i = 0; i < len; i++) {
            copy[i].complete();
        }
        this.observers.length = 0;
    };
    Subject.prototype.unsubscribe = function () {
        this.isStopped = true;
        this.closed = true;
        this.observers = null;
    };
    Subject.prototype._trySubscribe = function (subscriber) {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        else {
            return _super.prototype._trySubscribe.call(this, subscriber);
        }
    };
    Subject.prototype._subscribe = function (subscriber) {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        else if (this.hasError) {
            subscriber.error(this.thrownError);
            return Subscription_1.Subscription.EMPTY;
        }
        else if (this.isStopped) {
            subscriber.complete();
            return Subscription_1.Subscription.EMPTY;
        }
        else {
            this.observers.push(subscriber);
            return new SubjectSubscription_1.SubjectSubscription(this, subscriber);
        }
    };
    Subject.prototype.asObservable = function () {
        var observable = new Observable_1.Observable();
        observable.source = this;
        return observable;
    };
    Subject.create = function (destination, source) {
        return new AnonymousSubject(destination, source);
    };
    return Subject;
}(Observable_1.Observable));
exports.Subject = Subject;
var AnonymousSubject = (function (_super) {
    __extends(AnonymousSubject, _super);
    function AnonymousSubject(destination, source) {
        var _this = _super.call(this) || this;
        _this.destination = destination;
        _this.source = source;
        return _this;
    }
    AnonymousSubject.prototype.next = function (value) {
        var destination = this.destination;
        if (destination && destination.next) {
            destination.next(value);
        }
    };
    AnonymousSubject.prototype.error = function (err) {
        var destination = this.destination;
        if (destination && destination.error) {
            this.destination.error(err);
        }
    };
    AnonymousSubject.prototype.complete = function () {
        var destination = this.destination;
        if (destination && destination.complete) {
            this.destination.complete();
        }
    };
    AnonymousSubject.prototype._subscribe = function (subscriber) {
        var source = this.source;
        if (source) {
            return this.source.subscribe(subscriber);
        }
        else {
            return Subscription_1.Subscription.EMPTY;
        }
    };
    return AnonymousSubject;
}(Subject));
exports.AnonymousSubject = AnonymousSubject;

},{"../internal/symbol/rxSubscriber":281,"./Observable":117,"./SubjectSubscription":123,"./Subscriber":124,"./Subscription":125,"./util/ObjectUnsubscribedError":285}],123:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscription_1 = require("./Subscription");
var SubjectSubscription = (function (_super) {
    __extends(SubjectSubscription, _super);
    function SubjectSubscription(subject, subscriber) {
        var _this = _super.call(this) || this;
        _this.subject = subject;
        _this.subscriber = subscriber;
        _this.closed = false;
        return _this;
    }
    SubjectSubscription.prototype.unsubscribe = function () {
        if (this.closed) {
            return;
        }
        this.closed = true;
        var subject = this.subject;
        var observers = subject.observers;
        this.subject = null;
        if (!observers || observers.length === 0 || subject.isStopped || subject.closed) {
            return;
        }
        var subscriberIndex = observers.indexOf(this.subscriber);
        if (subscriberIndex !== -1) {
            observers.splice(subscriberIndex, 1);
        }
    };
    return SubjectSubscription;
}(Subscription_1.Subscription));
exports.SubjectSubscription = SubjectSubscription;

},{"./Subscription":125}],124:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var isFunction_1 = require("./util/isFunction");
var Observer_1 = require("./Observer");
var Subscription_1 = require("./Subscription");
var rxSubscriber_1 = require("../internal/symbol/rxSubscriber");
var config_1 = require("./config");
var hostReportError_1 = require("./util/hostReportError");
var Subscriber = (function (_super) {
    __extends(Subscriber, _super);
    function Subscriber(destinationOrNext, error, complete) {
        var _this = _super.call(this) || this;
        _this.syncErrorValue = null;
        _this.syncErrorThrown = false;
        _this.syncErrorThrowable = false;
        _this.isStopped = false;
        switch (arguments.length) {
            case 0:
                _this.destination = Observer_1.empty;
                break;
            case 1:
                if (!destinationOrNext) {
                    _this.destination = Observer_1.empty;
                    break;
                }
                if (typeof destinationOrNext === 'object') {
                    if (destinationOrNext instanceof Subscriber) {
                        _this.syncErrorThrowable = destinationOrNext.syncErrorThrowable;
                        _this.destination = destinationOrNext;
                        destinationOrNext.add(_this);
                    }
                    else {
                        _this.syncErrorThrowable = true;
                        _this.destination = new SafeSubscriber(_this, destinationOrNext);
                    }
                    break;
                }
            default:
                _this.syncErrorThrowable = true;
                _this.destination = new SafeSubscriber(_this, destinationOrNext, error, complete);
                break;
        }
        return _this;
    }
    Subscriber.prototype[rxSubscriber_1.rxSubscriber] = function () { return this; };
    Subscriber.create = function (next, error, complete) {
        var subscriber = new Subscriber(next, error, complete);
        subscriber.syncErrorThrowable = false;
        return subscriber;
    };
    Subscriber.prototype.next = function (value) {
        if (!this.isStopped) {
            this._next(value);
        }
    };
    Subscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            this.isStopped = true;
            this._error(err);
        }
    };
    Subscriber.prototype.complete = function () {
        if (!this.isStopped) {
            this.isStopped = true;
            this._complete();
        }
    };
    Subscriber.prototype.unsubscribe = function () {
        if (this.closed) {
            return;
        }
        this.isStopped = true;
        _super.prototype.unsubscribe.call(this);
    };
    Subscriber.prototype._next = function (value) {
        this.destination.next(value);
    };
    Subscriber.prototype._error = function (err) {
        this.destination.error(err);
        this.unsubscribe();
    };
    Subscriber.prototype._complete = function () {
        this.destination.complete();
        this.unsubscribe();
    };
    Subscriber.prototype._unsubscribeAndRecycle = function () {
        var _parentOrParents = this._parentOrParents;
        this._parentOrParents = null;
        this.unsubscribe();
        this.closed = false;
        this.isStopped = false;
        this._parentOrParents = _parentOrParents;
        return this;
    };
    return Subscriber;
}(Subscription_1.Subscription));
exports.Subscriber = Subscriber;
var SafeSubscriber = (function (_super) {
    __extends(SafeSubscriber, _super);
    function SafeSubscriber(_parentSubscriber, observerOrNext, error, complete) {
        var _this = _super.call(this) || this;
        _this._parentSubscriber = _parentSubscriber;
        var next;
        var context = _this;
        if (isFunction_1.isFunction(observerOrNext)) {
            next = observerOrNext;
        }
        else if (observerOrNext) {
            next = observerOrNext.next;
            error = observerOrNext.error;
            complete = observerOrNext.complete;
            if (observerOrNext !== Observer_1.empty) {
                context = Object.create(observerOrNext);
                if (isFunction_1.isFunction(context.unsubscribe)) {
                    _this.add(context.unsubscribe.bind(context));
                }
                context.unsubscribe = _this.unsubscribe.bind(_this);
            }
        }
        _this._context = context;
        _this._next = next;
        _this._error = error;
        _this._complete = complete;
        return _this;
    }
    SafeSubscriber.prototype.next = function (value) {
        if (!this.isStopped && this._next) {
            var _parentSubscriber = this._parentSubscriber;
            if (!config_1.config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
                this.__tryOrUnsub(this._next, value);
            }
            else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            var _parentSubscriber = this._parentSubscriber;
            var useDeprecatedSynchronousErrorHandling = config_1.config.useDeprecatedSynchronousErrorHandling;
            if (this._error) {
                if (!useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
                    this.__tryOrUnsub(this._error, err);
                    this.unsubscribe();
                }
                else {
                    this.__tryOrSetError(_parentSubscriber, this._error, err);
                    this.unsubscribe();
                }
            }
            else if (!_parentSubscriber.syncErrorThrowable) {
                this.unsubscribe();
                if (useDeprecatedSynchronousErrorHandling) {
                    throw err;
                }
                hostReportError_1.hostReportError(err);
            }
            else {
                if (useDeprecatedSynchronousErrorHandling) {
                    _parentSubscriber.syncErrorValue = err;
                    _parentSubscriber.syncErrorThrown = true;
                }
                else {
                    hostReportError_1.hostReportError(err);
                }
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.complete = function () {
        var _this = this;
        if (!this.isStopped) {
            var _parentSubscriber = this._parentSubscriber;
            if (this._complete) {
                var wrappedComplete = function () { return _this._complete.call(_this._context); };
                if (!config_1.config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
                    this.__tryOrUnsub(wrappedComplete);
                    this.unsubscribe();
                }
                else {
                    this.__tryOrSetError(_parentSubscriber, wrappedComplete);
                    this.unsubscribe();
                }
            }
            else {
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.__tryOrUnsub = function (fn, value) {
        try {
            fn.call(this._context, value);
        }
        catch (err) {
            this.unsubscribe();
            if (config_1.config.useDeprecatedSynchronousErrorHandling) {
                throw err;
            }
            else {
                hostReportError_1.hostReportError(err);
            }
        }
    };
    SafeSubscriber.prototype.__tryOrSetError = function (parent, fn, value) {
        if (!config_1.config.useDeprecatedSynchronousErrorHandling) {
            throw new Error('bad call');
        }
        try {
            fn.call(this._context, value);
        }
        catch (err) {
            if (config_1.config.useDeprecatedSynchronousErrorHandling) {
                parent.syncErrorValue = err;
                parent.syncErrorThrown = true;
                return true;
            }
            else {
                hostReportError_1.hostReportError(err);
                return true;
            }
        }
        return false;
    };
    SafeSubscriber.prototype._unsubscribe = function () {
        var _parentSubscriber = this._parentSubscriber;
        this._context = null;
        this._parentSubscriber = null;
        _parentSubscriber.unsubscribe();
    };
    return SafeSubscriber;
}(Subscriber));
exports.SafeSubscriber = SafeSubscriber;

},{"../internal/symbol/rxSubscriber":281,"./Observer":118,"./Subscription":125,"./config":126,"./util/hostReportError":289,"./util/isFunction":294}],125:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var isArray_1 = require("./util/isArray");
var isObject_1 = require("./util/isObject");
var isFunction_1 = require("./util/isFunction");
var UnsubscriptionError_1 = require("./util/UnsubscriptionError");
var Subscription = (function () {
    function Subscription(unsubscribe) {
        this.closed = false;
        this._parentOrParents = null;
        this._subscriptions = null;
        if (unsubscribe) {
            this._ctorUnsubscribe = true;
            this._unsubscribe = unsubscribe;
        }
    }
    Subscription.prototype.unsubscribe = function () {
        var errors;
        if (this.closed) {
            return;
        }
        var _a = this, _parentOrParents = _a._parentOrParents, _ctorUnsubscribe = _a._ctorUnsubscribe, _unsubscribe = _a._unsubscribe, _subscriptions = _a._subscriptions;
        this.closed = true;
        this._parentOrParents = null;
        this._subscriptions = null;
        if (_parentOrParents instanceof Subscription) {
            _parentOrParents.remove(this);
        }
        else if (_parentOrParents !== null) {
            for (var index = 0; index < _parentOrParents.length; ++index) {
                var parent_1 = _parentOrParents[index];
                parent_1.remove(this);
            }
        }
        if (isFunction_1.isFunction(_unsubscribe)) {
            if (_ctorUnsubscribe) {
                this._unsubscribe = undefined;
            }
            try {
                _unsubscribe.call(this);
            }
            catch (e) {
                errors = e instanceof UnsubscriptionError_1.UnsubscriptionError ? flattenUnsubscriptionErrors(e.errors) : [e];
            }
        }
        if (isArray_1.isArray(_subscriptions)) {
            var index = -1;
            var len = _subscriptions.length;
            while (++index < len) {
                var sub = _subscriptions[index];
                if (isObject_1.isObject(sub)) {
                    try {
                        sub.unsubscribe();
                    }
                    catch (e) {
                        errors = errors || [];
                        if (e instanceof UnsubscriptionError_1.UnsubscriptionError) {
                            errors = errors.concat(flattenUnsubscriptionErrors(e.errors));
                        }
                        else {
                            errors.push(e);
                        }
                    }
                }
            }
        }
        if (errors) {
            throw new UnsubscriptionError_1.UnsubscriptionError(errors);
        }
    };
    Subscription.prototype.add = function (teardown) {
        var subscription = teardown;
        if (!teardown) {
            return Subscription.EMPTY;
        }
        switch (typeof teardown) {
            case 'function':
                subscription = new Subscription(teardown);
            case 'object':
                if (subscription === this || subscription.closed || typeof subscription.unsubscribe !== 'function') {
                    return subscription;
                }
                else if (this.closed) {
                    subscription.unsubscribe();
                    return subscription;
                }
                else if (!(subscription instanceof Subscription)) {
                    var tmp = subscription;
                    subscription = new Subscription();
                    subscription._subscriptions = [tmp];
                }
                break;
            default: {
                throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');
            }
        }
        var _parentOrParents = subscription._parentOrParents;
        if (_parentOrParents === null) {
            subscription._parentOrParents = this;
        }
        else if (_parentOrParents instanceof Subscription) {
            if (_parentOrParents === this) {
                return subscription;
            }
            subscription._parentOrParents = [_parentOrParents, this];
        }
        else if (_parentOrParents.indexOf(this) === -1) {
            _parentOrParents.push(this);
        }
        else {
            return subscription;
        }
        var subscriptions = this._subscriptions;
        if (subscriptions === null) {
            this._subscriptions = [subscription];
        }
        else {
            subscriptions.push(subscription);
        }
        return subscription;
    };
    Subscription.prototype.remove = function (subscription) {
        var subscriptions = this._subscriptions;
        if (subscriptions) {
            var subscriptionIndex = subscriptions.indexOf(subscription);
            if (subscriptionIndex !== -1) {
                subscriptions.splice(subscriptionIndex, 1);
            }
        }
    };
    Subscription.EMPTY = (function (empty) {
        empty.closed = true;
        return empty;
    }(new Subscription()));
    return Subscription;
}());
exports.Subscription = Subscription;
function flattenUnsubscriptionErrors(errors) {
    return errors.reduce(function (errs, err) { return errs.concat((err instanceof UnsubscriptionError_1.UnsubscriptionError) ? err.errors : err); }, []);
}

},{"./util/UnsubscriptionError":287,"./util/isArray":291,"./util/isFunction":294,"./util/isObject":298}],126:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _enable_super_gross_mode_that_will_cause_bad_things = false;
exports.config = {
    Promise: undefined,
    set useDeprecatedSynchronousErrorHandling(value) {
        if (value) {
            var error = new Error();
            console.warn('DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \n' + error.stack);
        }
        else if (_enable_super_gross_mode_that_will_cause_bad_things) {
            console.log('RxJS: Back to a better error behavior. Thank you. <3');
        }
        _enable_super_gross_mode_that_will_cause_bad_things = value;
    },
    get useDeprecatedSynchronousErrorHandling() {
        return _enable_super_gross_mode_that_will_cause_bad_things;
    },
};

},{}],127:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("./Subscriber");
var Observable_1 = require("./Observable");
var subscribeTo_1 = require("./util/subscribeTo");
var SimpleInnerSubscriber = (function (_super) {
    __extends(SimpleInnerSubscriber, _super);
    function SimpleInnerSubscriber(parent) {
        var _this = _super.call(this) || this;
        _this.parent = parent;
        return _this;
    }
    SimpleInnerSubscriber.prototype._next = function (value) {
        this.parent.notifyNext(value);
    };
    SimpleInnerSubscriber.prototype._error = function (error) {
        this.parent.notifyError(error);
        this.unsubscribe();
    };
    SimpleInnerSubscriber.prototype._complete = function () {
        this.parent.notifyComplete();
        this.unsubscribe();
    };
    return SimpleInnerSubscriber;
}(Subscriber_1.Subscriber));
exports.SimpleInnerSubscriber = SimpleInnerSubscriber;
var ComplexInnerSubscriber = (function (_super) {
    __extends(ComplexInnerSubscriber, _super);
    function ComplexInnerSubscriber(parent, outerValue, outerIndex) {
        var _this = _super.call(this) || this;
        _this.parent = parent;
        _this.outerValue = outerValue;
        _this.outerIndex = outerIndex;
        return _this;
    }
    ComplexInnerSubscriber.prototype._next = function (value) {
        this.parent.notifyNext(this.outerValue, value, this.outerIndex, this);
    };
    ComplexInnerSubscriber.prototype._error = function (error) {
        this.parent.notifyError(error);
        this.unsubscribe();
    };
    ComplexInnerSubscriber.prototype._complete = function () {
        this.parent.notifyComplete(this);
        this.unsubscribe();
    };
    return ComplexInnerSubscriber;
}(Subscriber_1.Subscriber));
exports.ComplexInnerSubscriber = ComplexInnerSubscriber;
var SimpleOuterSubscriber = (function (_super) {
    __extends(SimpleOuterSubscriber, _super);
    function SimpleOuterSubscriber() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    SimpleOuterSubscriber.prototype.notifyNext = function (innerValue) {
        this.destination.next(innerValue);
    };
    SimpleOuterSubscriber.prototype.notifyError = function (err) {
        this.destination.error(err);
    };
    SimpleOuterSubscriber.prototype.notifyComplete = function () {
        this.destination.complete();
    };
    return SimpleOuterSubscriber;
}(Subscriber_1.Subscriber));
exports.SimpleOuterSubscriber = SimpleOuterSubscriber;
var ComplexOuterSubscriber = (function (_super) {
    __extends(ComplexOuterSubscriber, _super);
    function ComplexOuterSubscriber() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ComplexOuterSubscriber.prototype.notifyNext = function (_outerValue, innerValue, _outerIndex, _innerSub) {
        this.destination.next(innerValue);
    };
    ComplexOuterSubscriber.prototype.notifyError = function (error) {
        this.destination.error(error);
    };
    ComplexOuterSubscriber.prototype.notifyComplete = function (_innerSub) {
        this.destination.complete();
    };
    return ComplexOuterSubscriber;
}(Subscriber_1.Subscriber));
exports.ComplexOuterSubscriber = ComplexOuterSubscriber;
function innerSubscribe(result, innerSubscriber) {
    if (innerSubscriber.closed) {
        return undefined;
    }
    if (result instanceof Observable_1.Observable) {
        return result.subscribe(innerSubscriber);
    }
    return subscribeTo_1.subscribeTo(result)(innerSubscriber);
}
exports.innerSubscribe = innerSubscribe;

},{"./Observable":117,"./Subscriber":124,"./util/subscribeTo":305}],128:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subject_1 = require("../Subject");
var Observable_1 = require("../Observable");
var Subscriber_1 = require("../Subscriber");
var Subscription_1 = require("../Subscription");
var refCount_1 = require("../operators/refCount");
var ConnectableObservable = (function (_super) {
    __extends(ConnectableObservable, _super);
    function ConnectableObservable(source, subjectFactory) {
        var _this = _super.call(this) || this;
        _this.source = source;
        _this.subjectFactory = subjectFactory;
        _this._refCount = 0;
        _this._isComplete = false;
        return _this;
    }
    ConnectableObservable.prototype._subscribe = function (subscriber) {
        return this.getSubject().subscribe(subscriber);
    };
    ConnectableObservable.prototype.getSubject = function () {
        var subject = this._subject;
        if (!subject || subject.isStopped) {
            this._subject = this.subjectFactory();
        }
        return this._subject;
    };
    ConnectableObservable.prototype.connect = function () {
        var connection = this._connection;
        if (!connection) {
            this._isComplete = false;
            connection = this._connection = new Subscription_1.Subscription();
            connection.add(this.source
                .subscribe(new ConnectableSubscriber(this.getSubject(), this)));
            if (connection.closed) {
                this._connection = null;
                connection = Subscription_1.Subscription.EMPTY;
            }
        }
        return connection;
    };
    ConnectableObservable.prototype.refCount = function () {
        return refCount_1.refCount()(this);
    };
    return ConnectableObservable;
}(Observable_1.Observable));
exports.ConnectableObservable = ConnectableObservable;
exports.connectableObservableDescriptor = (function () {
    var connectableProto = ConnectableObservable.prototype;
    return {
        operator: { value: null },
        _refCount: { value: 0, writable: true },
        _subject: { value: null, writable: true },
        _connection: { value: null, writable: true },
        _subscribe: { value: connectableProto._subscribe },
        _isComplete: { value: connectableProto._isComplete, writable: true },
        getSubject: { value: connectableProto.getSubject },
        connect: { value: connectableProto.connect },
        refCount: { value: connectableProto.refCount }
    };
})();
var ConnectableSubscriber = (function (_super) {
    __extends(ConnectableSubscriber, _super);
    function ConnectableSubscriber(destination, connectable) {
        var _this = _super.call(this, destination) || this;
        _this.connectable = connectable;
        return _this;
    }
    ConnectableSubscriber.prototype._error = function (err) {
        this._unsubscribe();
        _super.prototype._error.call(this, err);
    };
    ConnectableSubscriber.prototype._complete = function () {
        this.connectable._isComplete = true;
        this._unsubscribe();
        _super.prototype._complete.call(this);
    };
    ConnectableSubscriber.prototype._unsubscribe = function () {
        var connectable = this.connectable;
        if (connectable) {
            this.connectable = null;
            var connection = connectable._connection;
            connectable._refCount = 0;
            connectable._subject = null;
            connectable._connection = null;
            if (connection) {
                connection.unsubscribe();
            }
        }
    };
    return ConnectableSubscriber;
}(Subject_1.SubjectSubscriber));
var RefCountOperator = (function () {
    function RefCountOperator(connectable) {
        this.connectable = connectable;
    }
    RefCountOperator.prototype.call = function (subscriber, source) {
        var connectable = this.connectable;
        connectable._refCount++;
        var refCounter = new RefCountSubscriber(subscriber, connectable);
        var subscription = source.subscribe(refCounter);
        if (!refCounter.closed) {
            refCounter.connection = connectable.connect();
        }
        return subscription;
    };
    return RefCountOperator;
}());
var RefCountSubscriber = (function (_super) {
    __extends(RefCountSubscriber, _super);
    function RefCountSubscriber(destination, connectable) {
        var _this = _super.call(this, destination) || this;
        _this.connectable = connectable;
        return _this;
    }
    RefCountSubscriber.prototype._unsubscribe = function () {
        var connectable = this.connectable;
        if (!connectable) {
            this.connection = null;
            return;
        }
        this.connectable = null;
        var refCount = connectable._refCount;
        if (refCount <= 0) {
            this.connection = null;
            return;
        }
        connectable._refCount = refCount - 1;
        if (refCount > 1) {
            this.connection = null;
            return;
        }
        var connection = this.connection;
        var sharedConnection = connectable._connection;
        this.connection = null;
        if (sharedConnection && (!connection || sharedConnection === connection)) {
            sharedConnection.unsubscribe();
        }
    };
    return RefCountSubscriber;
}(Subscriber_1.Subscriber));

},{"../Observable":117,"../Subject":122,"../Subscriber":124,"../Subscription":125,"../operators/refCount":218}],129:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("../Observable");
var asap_1 = require("../scheduler/asap");
var isNumeric_1 = require("../util/isNumeric");
var SubscribeOnObservable = (function (_super) {
    __extends(SubscribeOnObservable, _super);
    function SubscribeOnObservable(source, delayTime, scheduler) {
        if (delayTime === void 0) { delayTime = 0; }
        if (scheduler === void 0) { scheduler = asap_1.asap; }
        var _this = _super.call(this) || this;
        _this.source = source;
        _this.delayTime = delayTime;
        _this.scheduler = scheduler;
        if (!isNumeric_1.isNumeric(delayTime) || delayTime < 0) {
            _this.delayTime = 0;
        }
        if (!scheduler || typeof scheduler.schedule !== 'function') {
            _this.scheduler = asap_1.asap;
        }
        return _this;
    }
    SubscribeOnObservable.create = function (source, delay, scheduler) {
        if (delay === void 0) { delay = 0; }
        if (scheduler === void 0) { scheduler = asap_1.asap; }
        return new SubscribeOnObservable(source, delay, scheduler);
    };
    SubscribeOnObservable.dispatch = function (arg) {
        var source = arg.source, subscriber = arg.subscriber;
        return this.add(source.subscribe(subscriber));
    };
    SubscribeOnObservable.prototype._subscribe = function (subscriber) {
        var delay = this.delayTime;
        var source = this.source;
        var scheduler = this.scheduler;
        return scheduler.schedule(SubscribeOnObservable.dispatch, delay, {
            source: source, subscriber: subscriber
        });
    };
    return SubscribeOnObservable;
}(Observable_1.Observable));
exports.SubscribeOnObservable = SubscribeOnObservable;

},{"../Observable":117,"../scheduler/asap":276,"../util/isNumeric":297}],130:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("../Observable");
var AsyncSubject_1 = require("../AsyncSubject");
var map_1 = require("../operators/map");
var canReportError_1 = require("../util/canReportError");
var isArray_1 = require("../util/isArray");
var isScheduler_1 = require("../util/isScheduler");
function bindCallback(callbackFunc, resultSelector, scheduler) {
    if (resultSelector) {
        if (isScheduler_1.isScheduler(resultSelector)) {
            scheduler = resultSelector;
        }
        else {
            return function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return bindCallback(callbackFunc, scheduler).apply(void 0, args).pipe(map_1.map(function (args) { return isArray_1.isArray(args) ? resultSelector.apply(void 0, args) : resultSelector(args); }));
            };
        }
    }
    return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var context = this;
        var subject;
        var params = {
            context: context,
            subject: subject,
            callbackFunc: callbackFunc,
            scheduler: scheduler,
        };
        return new Observable_1.Observable(function (subscriber) {
            if (!scheduler) {
                if (!subject) {
                    subject = new AsyncSubject_1.AsyncSubject();
                    var handler = function () {
                        var innerArgs = [];
                        for (var _i = 0; _i < arguments.length; _i++) {
                            innerArgs[_i] = arguments[_i];
                        }
                        subject.next(innerArgs.length <= 1 ? innerArgs[0] : innerArgs);
                        subject.complete();
                    };
                    try {
                        callbackFunc.apply(context, args.concat([handler]));
                    }
                    catch (err) {
                        if (canReportError_1.canReportError(subject)) {
                            subject.error(err);
                        }
                        else {
                            console.warn(err);
                        }
                    }
                }
                return subject.subscribe(subscriber);
            }
            else {
                var state = {
                    args: args, subscriber: subscriber, params: params,
                };
                return scheduler.schedule(dispatch, 0, state);
            }
        });
    };
}
exports.bindCallback = bindCallback;
function dispatch(state) {
    var _this = this;
    var self = this;
    var args = state.args, subscriber = state.subscriber, params = state.params;
    var callbackFunc = params.callbackFunc, context = params.context, scheduler = params.scheduler;
    var subject = params.subject;
    if (!subject) {
        subject = params.subject = new AsyncSubject_1.AsyncSubject();
        var handler = function () {
            var innerArgs = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                innerArgs[_i] = arguments[_i];
            }
            var value = innerArgs.length <= 1 ? innerArgs[0] : innerArgs;
            _this.add(scheduler.schedule(dispatchNext, 0, { value: value, subject: subject }));
        };
        try {
            callbackFunc.apply(context, args.concat([handler]));
        }
        catch (err) {
            subject.error(err);
        }
    }
    this.add(subject.subscribe(subscriber));
}
function dispatchNext(state) {
    var value = state.value, subject = state.subject;
    subject.next(value);
    subject.complete();
}
function dispatchError(state) {
    var err = state.err, subject = state.subject;
    subject.error(err);
}

},{"../AsyncSubject":113,"../Observable":117,"../operators/map":196,"../util/canReportError":288,"../util/isArray":291,"../util/isScheduler":301}],131:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("../Observable");
var AsyncSubject_1 = require("../AsyncSubject");
var map_1 = require("../operators/map");
var canReportError_1 = require("../util/canReportError");
var isScheduler_1 = require("../util/isScheduler");
var isArray_1 = require("../util/isArray");
function bindNodeCallback(callbackFunc, resultSelector, scheduler) {
    if (resultSelector) {
        if (isScheduler_1.isScheduler(resultSelector)) {
            scheduler = resultSelector;
        }
        else {
            return function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return bindNodeCallback(callbackFunc, scheduler).apply(void 0, args).pipe(map_1.map(function (args) { return isArray_1.isArray(args) ? resultSelector.apply(void 0, args) : resultSelector(args); }));
            };
        }
    }
    return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var params = {
            subject: undefined,
            args: args,
            callbackFunc: callbackFunc,
            scheduler: scheduler,
            context: this,
        };
        return new Observable_1.Observable(function (subscriber) {
            var context = params.context;
            var subject = params.subject;
            if (!scheduler) {
                if (!subject) {
                    subject = params.subject = new AsyncSubject_1.AsyncSubject();
                    var handler = function () {
                        var innerArgs = [];
                        for (var _i = 0; _i < arguments.length; _i++) {
                            innerArgs[_i] = arguments[_i];
                        }
                        var err = innerArgs.shift();
                        if (err) {
                            subject.error(err);
                            return;
                        }
                        subject.next(innerArgs.length <= 1 ? innerArgs[0] : innerArgs);
                        subject.complete();
                    };
                    try {
                        callbackFunc.apply(context, args.concat([handler]));
                    }
                    catch (err) {
                        if (canReportError_1.canReportError(subject)) {
                            subject.error(err);
                        }
                        else {
                            console.warn(err);
                        }
                    }
                }
                return subject.subscribe(subscriber);
            }
            else {
                return scheduler.schedule(dispatch, 0, { params: params, subscriber: subscriber, context: context });
            }
        });
    };
}
exports.bindNodeCallback = bindNodeCallback;
function dispatch(state) {
    var _this = this;
    var params = state.params, subscriber = state.subscriber, context = state.context;
    var callbackFunc = params.callbackFunc, args = params.args, scheduler = params.scheduler;
    var subject = params.subject;
    if (!subject) {
        subject = params.subject = new AsyncSubject_1.AsyncSubject();
        var handler = function () {
            var innerArgs = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                innerArgs[_i] = arguments[_i];
            }
            var err = innerArgs.shift();
            if (err) {
                _this.add(scheduler.schedule(dispatchError, 0, { err: err, subject: subject }));
            }
            else {
                var value = innerArgs.length <= 1 ? innerArgs[0] : innerArgs;
                _this.add(scheduler.schedule(dispatchNext, 0, { value: value, subject: subject }));
            }
        };
        try {
            callbackFunc.apply(context, args.concat([handler]));
        }
        catch (err) {
            this.add(scheduler.schedule(dispatchError, 0, { err: err, subject: subject }));
        }
    }
    this.add(subject.subscribe(subscriber));
}
function dispatchNext(arg) {
    var value = arg.value, subject = arg.subject;
    subject.next(value);
    subject.complete();
}
function dispatchError(arg) {
    var err = arg.err, subject = arg.subject;
    subject.error(err);
}

},{"../AsyncSubject":113,"../Observable":117,"../operators/map":196,"../util/canReportError":288,"../util/isArray":291,"../util/isScheduler":301}],132:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var isScheduler_1 = require("../util/isScheduler");
var isArray_1 = require("../util/isArray");
var OuterSubscriber_1 = require("../OuterSubscriber");
var subscribeToResult_1 = require("../util/subscribeToResult");
var fromArray_1 = require("./fromArray");
var NONE = {};
function combineLatest() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i] = arguments[_i];
    }
    var resultSelector = undefined;
    var scheduler = undefined;
    if (isScheduler_1.isScheduler(observables[observables.length - 1])) {
        scheduler = observables.pop();
    }
    if (typeof observables[observables.length - 1] === 'function') {
        resultSelector = observables.pop();
    }
    if (observables.length === 1 && isArray_1.isArray(observables[0])) {
        observables = observables[0];
    }
    return fromArray_1.fromArray(observables, scheduler).lift(new CombineLatestOperator(resultSelector));
}
exports.combineLatest = combineLatest;
var CombineLatestOperator = (function () {
    function CombineLatestOperator(resultSelector) {
        this.resultSelector = resultSelector;
    }
    CombineLatestOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new CombineLatestSubscriber(subscriber, this.resultSelector));
    };
    return CombineLatestOperator;
}());
exports.CombineLatestOperator = CombineLatestOperator;
var CombineLatestSubscriber = (function (_super) {
    __extends(CombineLatestSubscriber, _super);
    function CombineLatestSubscriber(destination, resultSelector) {
        var _this = _super.call(this, destination) || this;
        _this.resultSelector = resultSelector;
        _this.active = 0;
        _this.values = [];
        _this.observables = [];
        return _this;
    }
    CombineLatestSubscriber.prototype._next = function (observable) {
        this.values.push(NONE);
        this.observables.push(observable);
    };
    CombineLatestSubscriber.prototype._complete = function () {
        var observables = this.observables;
        var len = observables.length;
        if (len === 0) {
            this.destination.complete();
        }
        else {
            this.active = len;
            this.toRespond = len;
            for (var i = 0; i < len; i++) {
                var observable = observables[i];
                this.add(subscribeToResult_1.subscribeToResult(this, observable, undefined, i));
            }
        }
    };
    CombineLatestSubscriber.prototype.notifyComplete = function (unused) {
        if ((this.active -= 1) === 0) {
            this.destination.complete();
        }
    };
    CombineLatestSubscriber.prototype.notifyNext = function (_outerValue, innerValue, outerIndex) {
        var values = this.values;
        var oldVal = values[outerIndex];
        var toRespond = !this.toRespond
            ? 0
            : oldVal === NONE ? --this.toRespond : this.toRespond;
        values[outerIndex] = innerValue;
        if (toRespond === 0) {
            if (this.resultSelector) {
                this._tryResultSelector(values);
            }
            else {
                this.destination.next(values.slice());
            }
        }
    };
    CombineLatestSubscriber.prototype._tryResultSelector = function (values) {
        var result;
        try {
            result = this.resultSelector.apply(this, values);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return CombineLatestSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
exports.CombineLatestSubscriber = CombineLatestSubscriber;

},{"../OuterSubscriber":119,"../util/isArray":291,"../util/isScheduler":301,"../util/subscribeToResult":310,"./fromArray":138}],133:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var of_1 = require("./of");
var concatAll_1 = require("../operators/concatAll");
function concat() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i] = arguments[_i];
    }
    return concatAll_1.concatAll()(of_1.of.apply(void 0, observables));
}
exports.concat = concat;

},{"../operators/concatAll":167,"./of":146}],134:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("../Observable");
var from_1 = require("./from");
var empty_1 = require("./empty");
function defer(observableFactory) {
    return new Observable_1.Observable(function (subscriber) {
        var input;
        try {
            input = observableFactory();
        }
        catch (err) {
            subscriber.error(err);
            return undefined;
        }
        var source = input ? from_1.from(input) : empty_1.empty();
        return source.subscribe(subscriber);
    });
}
exports.defer = defer;

},{"../Observable":117,"./empty":135,"./from":137}],135:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("../Observable");
exports.EMPTY = new Observable_1.Observable(function (subscriber) { return subscriber.complete(); });
function empty(scheduler) {
    return scheduler ? emptyScheduled(scheduler) : exports.EMPTY;
}
exports.empty = empty;
function emptyScheduled(scheduler) {
    return new Observable_1.Observable(function (subscriber) { return scheduler.schedule(function () { return subscriber.complete(); }); });
}

},{"../Observable":117}],136:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("../Observable");
var isArray_1 = require("../util/isArray");
var map_1 = require("../operators/map");
var isObject_1 = require("../util/isObject");
var from_1 = require("./from");
function forkJoin() {
    var sources = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        sources[_i] = arguments[_i];
    }
    if (sources.length === 1) {
        var first_1 = sources[0];
        if (isArray_1.isArray(first_1)) {
            return forkJoinInternal(first_1, null);
        }
        if (isObject_1.isObject(first_1) && Object.getPrototypeOf(first_1) === Object.prototype) {
            var keys = Object.keys(first_1);
            return forkJoinInternal(keys.map(function (key) { return first_1[key]; }), keys);
        }
    }
    if (typeof sources[sources.length - 1] === 'function') {
        var resultSelector_1 = sources.pop();
        sources = (sources.length === 1 && isArray_1.isArray(sources[0])) ? sources[0] : sources;
        return forkJoinInternal(sources, null).pipe(map_1.map(function (args) { return resultSelector_1.apply(void 0, args); }));
    }
    return forkJoinInternal(sources, null);
}
exports.forkJoin = forkJoin;
function forkJoinInternal(sources, keys) {
    return new Observable_1.Observable(function (subscriber) {
        var len = sources.length;
        if (len === 0) {
            subscriber.complete();
            return;
        }
        var values = new Array(len);
        var completed = 0;
        var emitted = 0;
        var _loop_1 = function (i) {
            var source = from_1.from(sources[i]);
            var hasValue = false;
            subscriber.add(source.subscribe({
                next: function (value) {
                    if (!hasValue) {
                        hasValue = true;
                        emitted++;
                    }
                    values[i] = value;
                },
                error: function (err) { return subscriber.error(err); },
                complete: function () {
                    completed++;
                    if (completed === len || !hasValue) {
                        if (emitted === len) {
                            subscriber.next(keys ?
                                keys.reduce(function (result, key, i) { return (result[key] = values[i], result); }, {}) :
                                values);
                        }
                        subscriber.complete();
                    }
                }
            }));
        };
        for (var i = 0; i < len; i++) {
            _loop_1(i);
        }
    });
}

},{"../Observable":117,"../operators/map":196,"../util/isArray":291,"../util/isObject":298,"./from":137}],137:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("../Observable");
var subscribeTo_1 = require("../util/subscribeTo");
var scheduled_1 = require("../scheduled/scheduled");
function from(input, scheduler) {
    if (!scheduler) {
        if (input instanceof Observable_1.Observable) {
            return input;
        }
        return new Observable_1.Observable(subscribeTo_1.subscribeTo(input));
    }
    else {
        return scheduled_1.scheduled(input, scheduler);
    }
}
exports.from = from;

},{"../Observable":117,"../scheduled/scheduled":264,"../util/subscribeTo":305}],138:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("../Observable");
var subscribeToArray_1 = require("../util/subscribeToArray");
var scheduleArray_1 = require("../scheduled/scheduleArray");
function fromArray(input, scheduler) {
    if (!scheduler) {
        return new Observable_1.Observable(subscribeToArray_1.subscribeToArray(input));
    }
    else {
        return scheduleArray_1.scheduleArray(input, scheduler);
    }
}
exports.fromArray = fromArray;

},{"../Observable":117,"../scheduled/scheduleArray":260,"../util/subscribeToArray":306}],139:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("../Observable");
var isArray_1 = require("../util/isArray");
var isFunction_1 = require("../util/isFunction");
var map_1 = require("../operators/map");
var toString = (function () { return Object.prototype.toString; })();
function fromEvent(target, eventName, options, resultSelector) {
    if (isFunction_1.isFunction(options)) {
        resultSelector = options;
        options = undefined;
    }
    if (resultSelector) {
        return fromEvent(target, eventName, options).pipe(map_1.map(function (args) { return isArray_1.isArray(args) ? resultSelector.apply(void 0, args) : resultSelector(args); }));
    }
    return new Observable_1.Observable(function (subscriber) {
        function handler(e) {
            if (arguments.length > 1) {
                subscriber.next(Array.prototype.slice.call(arguments));
            }
            else {
                subscriber.next(e);
            }
        }
        setupSubscription(target, eventName, handler, subscriber, options);
    });
}
exports.fromEvent = fromEvent;
function setupSubscription(sourceObj, eventName, handler, subscriber, options) {
    var unsubscribe;
    if (isEventTarget(sourceObj)) {
        var source_1 = sourceObj;
        sourceObj.addEventListener(eventName, handler, options);
        unsubscribe = function () { return source_1.removeEventListener(eventName, handler, options); };
    }
    else if (isJQueryStyleEventEmitter(sourceObj)) {
        var source_2 = sourceObj;
        sourceObj.on(eventName, handler);
        unsubscribe = function () { return source_2.off(eventName, handler); };
    }
    else if (isNodeStyleEventEmitter(sourceObj)) {
        var source_3 = sourceObj;
        sourceObj.addListener(eventName, handler);
        unsubscribe = function () { return source_3.removeListener(eventName, handler); };
    }
    else if (sourceObj && sourceObj.length) {
        for (var i = 0, len = sourceObj.length; i < len; i++) {
            setupSubscription(sourceObj[i], eventName, handler, subscriber, options);
        }
    }
    else {
        throw new TypeError('Invalid event target');
    }
    subscriber.add(unsubscribe);
}
function isNodeStyleEventEmitter(sourceObj) {
    return sourceObj && typeof sourceObj.addListener === 'function' && typeof sourceObj.removeListener === 'function';
}
function isJQueryStyleEventEmitter(sourceObj) {
    return sourceObj && typeof sourceObj.on === 'function' && typeof sourceObj.off === 'function';
}
function isEventTarget(sourceObj) {
    return sourceObj && typeof sourceObj.addEventListener === 'function' && typeof sourceObj.removeEventListener === 'function';
}

},{"../Observable":117,"../operators/map":196,"../util/isArray":291,"../util/isFunction":294}],140:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("../Observable");
var isArray_1 = require("../util/isArray");
var isFunction_1 = require("../util/isFunction");
var map_1 = require("../operators/map");
function fromEventPattern(addHandler, removeHandler, resultSelector) {
    if (resultSelector) {
        return fromEventPattern(addHandler, removeHandler).pipe(map_1.map(function (args) { return isArray_1.isArray(args) ? resultSelector.apply(void 0, args) : resultSelector(args); }));
    }
    return new Observable_1.Observable(function (subscriber) {
        var handler = function () {
            var e = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                e[_i] = arguments[_i];
            }
            return subscriber.next(e.length === 1 ? e[0] : e);
        };
        var retValue;
        try {
            retValue = addHandler(handler);
        }
        catch (err) {
            subscriber.error(err);
            return undefined;
        }
        if (!isFunction_1.isFunction(removeHandler)) {
            return undefined;
        }
        return function () { return removeHandler(handler, retValue); };
    });
}
exports.fromEventPattern = fromEventPattern;

},{"../Observable":117,"../operators/map":196,"../util/isArray":291,"../util/isFunction":294}],141:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("../Observable");
var identity_1 = require("../util/identity");
var isScheduler_1 = require("../util/isScheduler");
function generate(initialStateOrOptions, condition, iterate, resultSelectorOrObservable, scheduler) {
    var resultSelector;
    var initialState;
    if (arguments.length == 1) {
        var options = initialStateOrOptions;
        initialState = options.initialState;
        condition = options.condition;
        iterate = options.iterate;
        resultSelector = options.resultSelector || identity_1.identity;
        scheduler = options.scheduler;
    }
    else if (resultSelectorOrObservable === undefined || isScheduler_1.isScheduler(resultSelectorOrObservable)) {
        initialState = initialStateOrOptions;
        resultSelector = identity_1.identity;
        scheduler = resultSelectorOrObservable;
    }
    else {
        initialState = initialStateOrOptions;
        resultSelector = resultSelectorOrObservable;
    }
    return new Observable_1.Observable(function (subscriber) {
        var state = initialState;
        if (scheduler) {
            return scheduler.schedule(dispatch, 0, {
                subscriber: subscriber,
                iterate: iterate,
                condition: condition,
                resultSelector: resultSelector,
                state: state
            });
        }
        do {
            if (condition) {
                var conditionResult = void 0;
                try {
                    conditionResult = condition(state);
                }
                catch (err) {
                    subscriber.error(err);
                    return undefined;
                }
                if (!conditionResult) {
                    subscriber.complete();
                    break;
                }
            }
            var value = void 0;
            try {
                value = resultSelector(state);
            }
            catch (err) {
                subscriber.error(err);
                return undefined;
            }
            subscriber.next(value);
            if (subscriber.closed) {
                break;
            }
            try {
                state = iterate(state);
            }
            catch (err) {
                subscriber.error(err);
                return undefined;
            }
        } while (true);
        return undefined;
    });
}
exports.generate = generate;
function dispatch(state) {
    var subscriber = state.subscriber, condition = state.condition;
    if (subscriber.closed) {
        return undefined;
    }
    if (state.needIterate) {
        try {
            state.state = state.iterate(state.state);
        }
        catch (err) {
            subscriber.error(err);
            return undefined;
        }
    }
    else {
        state.needIterate = true;
    }
    if (condition) {
        var conditionResult = void 0;
        try {
            conditionResult = condition(state.state);
        }
        catch (err) {
            subscriber.error(err);
            return undefined;
        }
        if (!conditionResult) {
            subscriber.complete();
            return undefined;
        }
        if (subscriber.closed) {
            return undefined;
        }
    }
    var value;
    try {
        value = state.resultSelector(state.state);
    }
    catch (err) {
        subscriber.error(err);
        return undefined;
    }
    if (subscriber.closed) {
        return undefined;
    }
    subscriber.next(value);
    if (subscriber.closed) {
        return undefined;
    }
    return this.schedule(state);
}

},{"../Observable":117,"../util/identity":290,"../util/isScheduler":301}],142:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var defer_1 = require("./defer");
var empty_1 = require("./empty");
function iif(condition, trueResult, falseResult) {
    if (trueResult === void 0) { trueResult = empty_1.EMPTY; }
    if (falseResult === void 0) { falseResult = empty_1.EMPTY; }
    return defer_1.defer(function () { return condition() ? trueResult : falseResult; });
}
exports.iif = iif;

},{"./defer":134,"./empty":135}],143:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("../Observable");
var async_1 = require("../scheduler/async");
var isNumeric_1 = require("../util/isNumeric");
function interval(period, scheduler) {
    if (period === void 0) { period = 0; }
    if (scheduler === void 0) { scheduler = async_1.async; }
    if (!isNumeric_1.isNumeric(period) || period < 0) {
        period = 0;
    }
    if (!scheduler || typeof scheduler.schedule !== 'function') {
        scheduler = async_1.async;
    }
    return new Observable_1.Observable(function (subscriber) {
        subscriber.add(scheduler.schedule(dispatch, period, { subscriber: subscriber, counter: 0, period: period }));
        return subscriber;
    });
}
exports.interval = interval;
function dispatch(state) {
    var subscriber = state.subscriber, counter = state.counter, period = state.period;
    subscriber.next(counter);
    this.schedule({ subscriber: subscriber, counter: counter + 1, period: period }, period);
}

},{"../Observable":117,"../scheduler/async":277,"../util/isNumeric":297}],144:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("../Observable");
var isScheduler_1 = require("../util/isScheduler");
var mergeAll_1 = require("../operators/mergeAll");
var fromArray_1 = require("./fromArray");
function merge() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i] = arguments[_i];
    }
    var concurrent = Number.POSITIVE_INFINITY;
    var scheduler = null;
    var last = observables[observables.length - 1];
    if (isScheduler_1.isScheduler(last)) {
        scheduler = observables.pop();
        if (observables.length > 1 && typeof observables[observables.length - 1] === 'number') {
            concurrent = observables.pop();
        }
    }
    else if (typeof last === 'number') {
        concurrent = observables.pop();
    }
    if (scheduler === null && observables.length === 1 && observables[0] instanceof Observable_1.Observable) {
        return observables[0];
    }
    return mergeAll_1.mergeAll(concurrent)(fromArray_1.fromArray(observables, scheduler));
}
exports.merge = merge;

},{"../Observable":117,"../operators/mergeAll":201,"../util/isScheduler":301,"./fromArray":138}],145:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("../Observable");
var noop_1 = require("../util/noop");
exports.NEVER = new Observable_1.Observable(noop_1.noop);
function never() {
    return exports.NEVER;
}
exports.never = never;

},{"../Observable":117,"../util/noop":302}],146:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var isScheduler_1 = require("../util/isScheduler");
var fromArray_1 = require("./fromArray");
var scheduleArray_1 = require("../scheduled/scheduleArray");
function of() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    var scheduler = args[args.length - 1];
    if (isScheduler_1.isScheduler(scheduler)) {
        args.pop();
        return scheduleArray_1.scheduleArray(args, scheduler);
    }
    else {
        return fromArray_1.fromArray(args);
    }
}
exports.of = of;

},{"../scheduled/scheduleArray":260,"../util/isScheduler":301,"./fromArray":138}],147:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("../Observable");
var from_1 = require("./from");
var isArray_1 = require("../util/isArray");
var empty_1 = require("./empty");
function onErrorResumeNext() {
    var sources = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        sources[_i] = arguments[_i];
    }
    if (sources.length === 0) {
        return empty_1.EMPTY;
    }
    var first = sources[0], remainder = sources.slice(1);
    if (sources.length === 1 && isArray_1.isArray(first)) {
        return onErrorResumeNext.apply(void 0, first);
    }
    return new Observable_1.Observable(function (subscriber) {
        var subNext = function () { return subscriber.add(onErrorResumeNext.apply(void 0, remainder).subscribe(subscriber)); };
        return from_1.from(first).subscribe({
            next: function (value) { subscriber.next(value); },
            error: subNext,
            complete: subNext,
        });
    });
}
exports.onErrorResumeNext = onErrorResumeNext;

},{"../Observable":117,"../util/isArray":291,"./empty":135,"./from":137}],148:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("../Observable");
var Subscription_1 = require("../Subscription");
function pairs(obj, scheduler) {
    if (!scheduler) {
        return new Observable_1.Observable(function (subscriber) {
            var keys = Object.keys(obj);
            for (var i = 0; i < keys.length && !subscriber.closed; i++) {
                var key = keys[i];
                if (obj.hasOwnProperty(key)) {
                    subscriber.next([key, obj[key]]);
                }
            }
            subscriber.complete();
        });
    }
    else {
        return new Observable_1.Observable(function (subscriber) {
            var keys = Object.keys(obj);
            var subscription = new Subscription_1.Subscription();
            subscription.add(scheduler.schedule(dispatch, 0, { keys: keys, index: 0, subscriber: subscriber, subscription: subscription, obj: obj }));
            return subscription;
        });
    }
}
exports.pairs = pairs;
function dispatch(state) {
    var keys = state.keys, index = state.index, subscriber = state.subscriber, subscription = state.subscription, obj = state.obj;
    if (!subscriber.closed) {
        if (index < keys.length) {
            var key = keys[index];
            subscriber.next([key, obj[key]]);
            subscription.add(this.schedule({ keys: keys, index: index + 1, subscriber: subscriber, subscription: subscription, obj: obj }));
        }
        else {
            subscriber.complete();
        }
    }
}
exports.dispatch = dispatch;

},{"../Observable":117,"../Subscription":125}],149:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var not_1 = require("../util/not");
var subscribeTo_1 = require("../util/subscribeTo");
var filter_1 = require("../operators/filter");
var Observable_1 = require("../Observable");
function partition(source, predicate, thisArg) {
    return [
        filter_1.filter(predicate, thisArg)(new Observable_1.Observable(subscribeTo_1.subscribeTo(source))),
        filter_1.filter(not_1.not(predicate, thisArg))(new Observable_1.Observable(subscribeTo_1.subscribeTo(source)))
    ];
}
exports.partition = partition;

},{"../Observable":117,"../operators/filter":186,"../util/not":303,"../util/subscribeTo":305}],150:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var isArray_1 = require("../util/isArray");
var fromArray_1 = require("./fromArray");
var OuterSubscriber_1 = require("../OuterSubscriber");
var subscribeToResult_1 = require("../util/subscribeToResult");
function race() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i] = arguments[_i];
    }
    if (observables.length === 1) {
        if (isArray_1.isArray(observables[0])) {
            observables = observables[0];
        }
        else {
            return observables[0];
        }
    }
    return fromArray_1.fromArray(observables, undefined).lift(new RaceOperator());
}
exports.race = race;
var RaceOperator = (function () {
    function RaceOperator() {
    }
    RaceOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new RaceSubscriber(subscriber));
    };
    return RaceOperator;
}());
exports.RaceOperator = RaceOperator;
var RaceSubscriber = (function (_super) {
    __extends(RaceSubscriber, _super);
    function RaceSubscriber(destination) {
        var _this = _super.call(this, destination) || this;
        _this.hasFirst = false;
        _this.observables = [];
        _this.subscriptions = [];
        return _this;
    }
    RaceSubscriber.prototype._next = function (observable) {
        this.observables.push(observable);
    };
    RaceSubscriber.prototype._complete = function () {
        var observables = this.observables;
        var len = observables.length;
        if (len === 0) {
            this.destination.complete();
        }
        else {
            for (var i = 0; i < len && !this.hasFirst; i++) {
                var observable = observables[i];
                var subscription = subscribeToResult_1.subscribeToResult(this, observable, undefined, i);
                if (this.subscriptions) {
                    this.subscriptions.push(subscription);
                }
                this.add(subscription);
            }
            this.observables = null;
        }
    };
    RaceSubscriber.prototype.notifyNext = function (_outerValue, innerValue, outerIndex) {
        if (!this.hasFirst) {
            this.hasFirst = true;
            for (var i = 0; i < this.subscriptions.length; i++) {
                if (i !== outerIndex) {
                    var subscription = this.subscriptions[i];
                    subscription.unsubscribe();
                    this.remove(subscription);
                }
            }
            this.subscriptions = null;
        }
        this.destination.next(innerValue);
    };
    return RaceSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
exports.RaceSubscriber = RaceSubscriber;

},{"../OuterSubscriber":119,"../util/isArray":291,"../util/subscribeToResult":310,"./fromArray":138}],151:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("../Observable");
function range(start, count, scheduler) {
    if (start === void 0) { start = 0; }
    return new Observable_1.Observable(function (subscriber) {
        if (count === undefined) {
            count = start;
            start = 0;
        }
        var index = 0;
        var current = start;
        if (scheduler) {
            return scheduler.schedule(dispatch, 0, {
                index: index, count: count, start: start, subscriber: subscriber
            });
        }
        else {
            do {
                if (index++ >= count) {
                    subscriber.complete();
                    break;
                }
                subscriber.next(current++);
                if (subscriber.closed) {
                    break;
                }
            } while (true);
        }
        return undefined;
    });
}
exports.range = range;
function dispatch(state) {
    var start = state.start, index = state.index, count = state.count, subscriber = state.subscriber;
    if (index >= count) {
        subscriber.complete();
        return;
    }
    subscriber.next(start);
    if (subscriber.closed) {
        return;
    }
    state.index = index + 1;
    state.start = start + 1;
    this.schedule(state);
}
exports.dispatch = dispatch;

},{"../Observable":117}],152:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("../Observable");
function throwError(error, scheduler) {
    if (!scheduler) {
        return new Observable_1.Observable(function (subscriber) { return subscriber.error(error); });
    }
    else {
        return new Observable_1.Observable(function (subscriber) { return scheduler.schedule(dispatch, 0, { error: error, subscriber: subscriber }); });
    }
}
exports.throwError = throwError;
function dispatch(_a) {
    var error = _a.error, subscriber = _a.subscriber;
    subscriber.error(error);
}

},{"../Observable":117}],153:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("../Observable");
var async_1 = require("../scheduler/async");
var isNumeric_1 = require("../util/isNumeric");
var isScheduler_1 = require("../util/isScheduler");
function timer(dueTime, periodOrScheduler, scheduler) {
    if (dueTime === void 0) { dueTime = 0; }
    var period = -1;
    if (isNumeric_1.isNumeric(periodOrScheduler)) {
        period = Number(periodOrScheduler) < 1 && 1 || Number(periodOrScheduler);
    }
    else if (isScheduler_1.isScheduler(periodOrScheduler)) {
        scheduler = periodOrScheduler;
    }
    if (!isScheduler_1.isScheduler(scheduler)) {
        scheduler = async_1.async;
    }
    return new Observable_1.Observable(function (subscriber) {
        var due = isNumeric_1.isNumeric(dueTime)
            ? dueTime
            : (+dueTime - scheduler.now());
        return scheduler.schedule(dispatch, due, {
            index: 0, period: period, subscriber: subscriber
        });
    });
}
exports.timer = timer;
function dispatch(state) {
    var index = state.index, period = state.period, subscriber = state.subscriber;
    subscriber.next(index);
    if (subscriber.closed) {
        return;
    }
    else if (period === -1) {
        return subscriber.complete();
    }
    state.index = index + 1;
    this.schedule(state, period);
}

},{"../Observable":117,"../scheduler/async":277,"../util/isNumeric":297,"../util/isScheduler":301}],154:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("../Observable");
var from_1 = require("./from");
var empty_1 = require("./empty");
function using(resourceFactory, observableFactory) {
    return new Observable_1.Observable(function (subscriber) {
        var resource;
        try {
            resource = resourceFactory();
        }
        catch (err) {
            subscriber.error(err);
            return undefined;
        }
        var result;
        try {
            result = observableFactory(resource);
        }
        catch (err) {
            subscriber.error(err);
            return undefined;
        }
        var source = result ? from_1.from(result) : empty_1.EMPTY;
        var subscription = source.subscribe(subscriber);
        return function () {
            subscription.unsubscribe();
            if (resource) {
                resource.unsubscribe();
            }
        };
    });
}
exports.using = using;

},{"../Observable":117,"./empty":135,"./from":137}],155:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var fromArray_1 = require("./fromArray");
var isArray_1 = require("../util/isArray");
var Subscriber_1 = require("../Subscriber");
var iterator_1 = require("../../internal/symbol/iterator");
var innerSubscribe_1 = require("../innerSubscribe");
function zip() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i] = arguments[_i];
    }
    var resultSelector = observables[observables.length - 1];
    if (typeof resultSelector === 'function') {
        observables.pop();
    }
    return fromArray_1.fromArray(observables, undefined).lift(new ZipOperator(resultSelector));
}
exports.zip = zip;
var ZipOperator = (function () {
    function ZipOperator(resultSelector) {
        this.resultSelector = resultSelector;
    }
    ZipOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ZipSubscriber(subscriber, this.resultSelector));
    };
    return ZipOperator;
}());
exports.ZipOperator = ZipOperator;
var ZipSubscriber = (function (_super) {
    __extends(ZipSubscriber, _super);
    function ZipSubscriber(destination, resultSelector, values) {
        if (values === void 0) { values = Object.create(null); }
        var _this = _super.call(this, destination) || this;
        _this.resultSelector = resultSelector;
        _this.iterators = [];
        _this.active = 0;
        _this.resultSelector = (typeof resultSelector === 'function') ? resultSelector : undefined;
        return _this;
    }
    ZipSubscriber.prototype._next = function (value) {
        var iterators = this.iterators;
        if (isArray_1.isArray(value)) {
            iterators.push(new StaticArrayIterator(value));
        }
        else if (typeof value[iterator_1.iterator] === 'function') {
            iterators.push(new StaticIterator(value[iterator_1.iterator]()));
        }
        else {
            iterators.push(new ZipBufferIterator(this.destination, this, value));
        }
    };
    ZipSubscriber.prototype._complete = function () {
        var iterators = this.iterators;
        var len = iterators.length;
        this.unsubscribe();
        if (len === 0) {
            this.destination.complete();
            return;
        }
        this.active = len;
        for (var i = 0; i < len; i++) {
            var iterator = iterators[i];
            if (iterator.stillUnsubscribed) {
                var destination = this.destination;
                destination.add(iterator.subscribe());
            }
            else {
                this.active--;
            }
        }
    };
    ZipSubscriber.prototype.notifyInactive = function () {
        this.active--;
        if (this.active === 0) {
            this.destination.complete();
        }
    };
    ZipSubscriber.prototype.checkIterators = function () {
        var iterators = this.iterators;
        var len = iterators.length;
        var destination = this.destination;
        for (var i = 0; i < len; i++) {
            var iterator = iterators[i];
            if (typeof iterator.hasValue === 'function' && !iterator.hasValue()) {
                return;
            }
        }
        var shouldComplete = false;
        var args = [];
        for (var i = 0; i < len; i++) {
            var iterator = iterators[i];
            var result = iterator.next();
            if (iterator.hasCompleted()) {
                shouldComplete = true;
            }
            if (result.done) {
                destination.complete();
                return;
            }
            args.push(result.value);
        }
        if (this.resultSelector) {
            this._tryresultSelector(args);
        }
        else {
            destination.next(args);
        }
        if (shouldComplete) {
            destination.complete();
        }
    };
    ZipSubscriber.prototype._tryresultSelector = function (args) {
        var result;
        try {
            result = this.resultSelector.apply(this, args);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return ZipSubscriber;
}(Subscriber_1.Subscriber));
exports.ZipSubscriber = ZipSubscriber;
var StaticIterator = (function () {
    function StaticIterator(iterator) {
        this.iterator = iterator;
        this.nextResult = iterator.next();
    }
    StaticIterator.prototype.hasValue = function () {
        return true;
    };
    StaticIterator.prototype.next = function () {
        var result = this.nextResult;
        this.nextResult = this.iterator.next();
        return result;
    };
    StaticIterator.prototype.hasCompleted = function () {
        var nextResult = this.nextResult;
        return Boolean(nextResult && nextResult.done);
    };
    return StaticIterator;
}());
var StaticArrayIterator = (function () {
    function StaticArrayIterator(array) {
        this.array = array;
        this.index = 0;
        this.length = 0;
        this.length = array.length;
    }
    StaticArrayIterator.prototype[iterator_1.iterator] = function () {
        return this;
    };
    StaticArrayIterator.prototype.next = function (value) {
        var i = this.index++;
        var array = this.array;
        return i < this.length ? { value: array[i], done: false } : { value: null, done: true };
    };
    StaticArrayIterator.prototype.hasValue = function () {
        return this.array.length > this.index;
    };
    StaticArrayIterator.prototype.hasCompleted = function () {
        return this.array.length === this.index;
    };
    return StaticArrayIterator;
}());
var ZipBufferIterator = (function (_super) {
    __extends(ZipBufferIterator, _super);
    function ZipBufferIterator(destination, parent, observable) {
        var _this = _super.call(this, destination) || this;
        _this.parent = parent;
        _this.observable = observable;
        _this.stillUnsubscribed = true;
        _this.buffer = [];
        _this.isComplete = false;
        return _this;
    }
    ZipBufferIterator.prototype[iterator_1.iterator] = function () {
        return this;
    };
    ZipBufferIterator.prototype.next = function () {
        var buffer = this.buffer;
        if (buffer.length === 0 && this.isComplete) {
            return { value: null, done: true };
        }
        else {
            return { value: buffer.shift(), done: false };
        }
    };
    ZipBufferIterator.prototype.hasValue = function () {
        return this.buffer.length > 0;
    };
    ZipBufferIterator.prototype.hasCompleted = function () {
        return this.buffer.length === 0 && this.isComplete;
    };
    ZipBufferIterator.prototype.notifyComplete = function () {
        if (this.buffer.length > 0) {
            this.isComplete = true;
            this.parent.notifyInactive();
        }
        else {
            this.destination.complete();
        }
    };
    ZipBufferIterator.prototype.notifyNext = function (innerValue) {
        this.buffer.push(innerValue);
        this.parent.checkIterators();
    };
    ZipBufferIterator.prototype.subscribe = function () {
        return innerSubscribe_1.innerSubscribe(this.observable, new innerSubscribe_1.SimpleInnerSubscriber(this));
    };
    return ZipBufferIterator;
}(innerSubscribe_1.SimpleOuterSubscriber));

},{"../../internal/symbol/iterator":279,"../Subscriber":124,"../innerSubscribe":127,"../util/isArray":291,"./fromArray":138}],156:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var innerSubscribe_1 = require("../innerSubscribe");
function audit(durationSelector) {
    return function auditOperatorFunction(source) {
        return source.lift(new AuditOperator(durationSelector));
    };
}
exports.audit = audit;
var AuditOperator = (function () {
    function AuditOperator(durationSelector) {
        this.durationSelector = durationSelector;
    }
    AuditOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new AuditSubscriber(subscriber, this.durationSelector));
    };
    return AuditOperator;
}());
var AuditSubscriber = (function (_super) {
    __extends(AuditSubscriber, _super);
    function AuditSubscriber(destination, durationSelector) {
        var _this = _super.call(this, destination) || this;
        _this.durationSelector = durationSelector;
        _this.hasValue = false;
        return _this;
    }
    AuditSubscriber.prototype._next = function (value) {
        this.value = value;
        this.hasValue = true;
        if (!this.throttled) {
            var duration = void 0;
            try {
                var durationSelector = this.durationSelector;
                duration = durationSelector(value);
            }
            catch (err) {
                return this.destination.error(err);
            }
            var innerSubscription = innerSubscribe_1.innerSubscribe(duration, new innerSubscribe_1.SimpleInnerSubscriber(this));
            if (!innerSubscription || innerSubscription.closed) {
                this.clearThrottle();
            }
            else {
                this.add(this.throttled = innerSubscription);
            }
        }
    };
    AuditSubscriber.prototype.clearThrottle = function () {
        var _a = this, value = _a.value, hasValue = _a.hasValue, throttled = _a.throttled;
        if (throttled) {
            this.remove(throttled);
            this.throttled = undefined;
            throttled.unsubscribe();
        }
        if (hasValue) {
            this.value = undefined;
            this.hasValue = false;
            this.destination.next(value);
        }
    };
    AuditSubscriber.prototype.notifyNext = function () {
        this.clearThrottle();
    };
    AuditSubscriber.prototype.notifyComplete = function () {
        this.clearThrottle();
    };
    return AuditSubscriber;
}(innerSubscribe_1.SimpleOuterSubscriber));

},{"../innerSubscribe":127}],157:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var async_1 = require("../scheduler/async");
var audit_1 = require("./audit");
var timer_1 = require("../observable/timer");
function auditTime(duration, scheduler) {
    if (scheduler === void 0) { scheduler = async_1.async; }
    return audit_1.audit(function () { return timer_1.timer(duration, scheduler); });
}
exports.auditTime = auditTime;

},{"../observable/timer":153,"../scheduler/async":277,"./audit":156}],158:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var innerSubscribe_1 = require("../innerSubscribe");
function buffer(closingNotifier) {
    return function bufferOperatorFunction(source) {
        return source.lift(new BufferOperator(closingNotifier));
    };
}
exports.buffer = buffer;
var BufferOperator = (function () {
    function BufferOperator(closingNotifier) {
        this.closingNotifier = closingNotifier;
    }
    BufferOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new BufferSubscriber(subscriber, this.closingNotifier));
    };
    return BufferOperator;
}());
var BufferSubscriber = (function (_super) {
    __extends(BufferSubscriber, _super);
    function BufferSubscriber(destination, closingNotifier) {
        var _this = _super.call(this, destination) || this;
        _this.buffer = [];
        _this.add(innerSubscribe_1.innerSubscribe(closingNotifier, new innerSubscribe_1.SimpleInnerSubscriber(_this)));
        return _this;
    }
    BufferSubscriber.prototype._next = function (value) {
        this.buffer.push(value);
    };
    BufferSubscriber.prototype.notifyNext = function () {
        var buffer = this.buffer;
        this.buffer = [];
        this.destination.next(buffer);
    };
    return BufferSubscriber;
}(innerSubscribe_1.SimpleOuterSubscriber));

},{"../innerSubscribe":127}],159:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
function bufferCount(bufferSize, startBufferEvery) {
    if (startBufferEvery === void 0) { startBufferEvery = null; }
    return function bufferCountOperatorFunction(source) {
        return source.lift(new BufferCountOperator(bufferSize, startBufferEvery));
    };
}
exports.bufferCount = bufferCount;
var BufferCountOperator = (function () {
    function BufferCountOperator(bufferSize, startBufferEvery) {
        this.bufferSize = bufferSize;
        this.startBufferEvery = startBufferEvery;
        if (!startBufferEvery || bufferSize === startBufferEvery) {
            this.subscriberClass = BufferCountSubscriber;
        }
        else {
            this.subscriberClass = BufferSkipCountSubscriber;
        }
    }
    BufferCountOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new this.subscriberClass(subscriber, this.bufferSize, this.startBufferEvery));
    };
    return BufferCountOperator;
}());
var BufferCountSubscriber = (function (_super) {
    __extends(BufferCountSubscriber, _super);
    function BufferCountSubscriber(destination, bufferSize) {
        var _this = _super.call(this, destination) || this;
        _this.bufferSize = bufferSize;
        _this.buffer = [];
        return _this;
    }
    BufferCountSubscriber.prototype._next = function (value) {
        var buffer = this.buffer;
        buffer.push(value);
        if (buffer.length == this.bufferSize) {
            this.destination.next(buffer);
            this.buffer = [];
        }
    };
    BufferCountSubscriber.prototype._complete = function () {
        var buffer = this.buffer;
        if (buffer.length > 0) {
            this.destination.next(buffer);
        }
        _super.prototype._complete.call(this);
    };
    return BufferCountSubscriber;
}(Subscriber_1.Subscriber));
var BufferSkipCountSubscriber = (function (_super) {
    __extends(BufferSkipCountSubscriber, _super);
    function BufferSkipCountSubscriber(destination, bufferSize, startBufferEvery) {
        var _this = _super.call(this, destination) || this;
        _this.bufferSize = bufferSize;
        _this.startBufferEvery = startBufferEvery;
        _this.buffers = [];
        _this.count = 0;
        return _this;
    }
    BufferSkipCountSubscriber.prototype._next = function (value) {
        var _a = this, bufferSize = _a.bufferSize, startBufferEvery = _a.startBufferEvery, buffers = _a.buffers, count = _a.count;
        this.count++;
        if (count % startBufferEvery === 0) {
            buffers.push([]);
        }
        for (var i = buffers.length; i--;) {
            var buffer = buffers[i];
            buffer.push(value);
            if (buffer.length === bufferSize) {
                buffers.splice(i, 1);
                this.destination.next(buffer);
            }
        }
    };
    BufferSkipCountSubscriber.prototype._complete = function () {
        var _a = this, buffers = _a.buffers, destination = _a.destination;
        while (buffers.length > 0) {
            var buffer = buffers.shift();
            if (buffer.length > 0) {
                destination.next(buffer);
            }
        }
        _super.prototype._complete.call(this);
    };
    return BufferSkipCountSubscriber;
}(Subscriber_1.Subscriber));

},{"../Subscriber":124}],160:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var async_1 = require("../scheduler/async");
var Subscriber_1 = require("../Subscriber");
var isScheduler_1 = require("../util/isScheduler");
function bufferTime(bufferTimeSpan) {
    var length = arguments.length;
    var scheduler = async_1.async;
    if (isScheduler_1.isScheduler(arguments[arguments.length - 1])) {
        scheduler = arguments[arguments.length - 1];
        length--;
    }
    var bufferCreationInterval = null;
    if (length >= 2) {
        bufferCreationInterval = arguments[1];
    }
    var maxBufferSize = Number.POSITIVE_INFINITY;
    if (length >= 3) {
        maxBufferSize = arguments[2];
    }
    return function bufferTimeOperatorFunction(source) {
        return source.lift(new BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler));
    };
}
exports.bufferTime = bufferTime;
var BufferTimeOperator = (function () {
    function BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {
        this.bufferTimeSpan = bufferTimeSpan;
        this.bufferCreationInterval = bufferCreationInterval;
        this.maxBufferSize = maxBufferSize;
        this.scheduler = scheduler;
    }
    BufferTimeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new BufferTimeSubscriber(subscriber, this.bufferTimeSpan, this.bufferCreationInterval, this.maxBufferSize, this.scheduler));
    };
    return BufferTimeOperator;
}());
var Context = (function () {
    function Context() {
        this.buffer = [];
    }
    return Context;
}());
var BufferTimeSubscriber = (function (_super) {
    __extends(BufferTimeSubscriber, _super);
    function BufferTimeSubscriber(destination, bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.bufferTimeSpan = bufferTimeSpan;
        _this.bufferCreationInterval = bufferCreationInterval;
        _this.maxBufferSize = maxBufferSize;
        _this.scheduler = scheduler;
        _this.contexts = [];
        var context = _this.openContext();
        _this.timespanOnly = bufferCreationInterval == null || bufferCreationInterval < 0;
        if (_this.timespanOnly) {
            var timeSpanOnlyState = { subscriber: _this, context: context, bufferTimeSpan: bufferTimeSpan };
            _this.add(context.closeAction = scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));
        }
        else {
            var closeState = { subscriber: _this, context: context };
            var creationState = { bufferTimeSpan: bufferTimeSpan, bufferCreationInterval: bufferCreationInterval, subscriber: _this, scheduler: scheduler };
            _this.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, closeState));
            _this.add(scheduler.schedule(dispatchBufferCreation, bufferCreationInterval, creationState));
        }
        return _this;
    }
    BufferTimeSubscriber.prototype._next = function (value) {
        var contexts = this.contexts;
        var len = contexts.length;
        var filledBufferContext;
        for (var i = 0; i < len; i++) {
            var context_1 = contexts[i];
            var buffer = context_1.buffer;
            buffer.push(value);
            if (buffer.length == this.maxBufferSize) {
                filledBufferContext = context_1;
            }
        }
        if (filledBufferContext) {
            this.onBufferFull(filledBufferContext);
        }
    };
    BufferTimeSubscriber.prototype._error = function (err) {
        this.contexts.length = 0;
        _super.prototype._error.call(this, err);
    };
    BufferTimeSubscriber.prototype._complete = function () {
        var _a = this, contexts = _a.contexts, destination = _a.destination;
        while (contexts.length > 0) {
            var context_2 = contexts.shift();
            destination.next(context_2.buffer);
        }
        _super.prototype._complete.call(this);
    };
    BufferTimeSubscriber.prototype._unsubscribe = function () {
        this.contexts = null;
    };
    BufferTimeSubscriber.prototype.onBufferFull = function (context) {
        this.closeContext(context);
        var closeAction = context.closeAction;
        closeAction.unsubscribe();
        this.remove(closeAction);
        if (!this.closed && this.timespanOnly) {
            context = this.openContext();
            var bufferTimeSpan = this.bufferTimeSpan;
            var timeSpanOnlyState = { subscriber: this, context: context, bufferTimeSpan: bufferTimeSpan };
            this.add(context.closeAction = this.scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));
        }
    };
    BufferTimeSubscriber.prototype.openContext = function () {
        var context = new Context();
        this.contexts.push(context);
        return context;
    };
    BufferTimeSubscriber.prototype.closeContext = function (context) {
        this.destination.next(context.buffer);
        var contexts = this.contexts;
        var spliceIndex = contexts ? contexts.indexOf(context) : -1;
        if (spliceIndex >= 0) {
            contexts.splice(contexts.indexOf(context), 1);
        }
    };
    return BufferTimeSubscriber;
}(Subscriber_1.Subscriber));
function dispatchBufferTimeSpanOnly(state) {
    var subscriber = state.subscriber;
    var prevContext = state.context;
    if (prevContext) {
        subscriber.closeContext(prevContext);
    }
    if (!subscriber.closed) {
        state.context = subscriber.openContext();
        state.context.closeAction = this.schedule(state, state.bufferTimeSpan);
    }
}
function dispatchBufferCreation(state) {
    var bufferCreationInterval = state.bufferCreationInterval, bufferTimeSpan = state.bufferTimeSpan, subscriber = state.subscriber, scheduler = state.scheduler;
    var context = subscriber.openContext();
    var action = this;
    if (!subscriber.closed) {
        subscriber.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, { subscriber: subscriber, context: context }));
        action.schedule(state, bufferCreationInterval);
    }
}
function dispatchBufferClose(arg) {
    var subscriber = arg.subscriber, context = arg.context;
    subscriber.closeContext(context);
}

},{"../Subscriber":124,"../scheduler/async":277,"../util/isScheduler":301}],161:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscription_1 = require("../Subscription");
var subscribeToResult_1 = require("../util/subscribeToResult");
var OuterSubscriber_1 = require("../OuterSubscriber");
function bufferToggle(openings, closingSelector) {
    return function bufferToggleOperatorFunction(source) {
        return source.lift(new BufferToggleOperator(openings, closingSelector));
    };
}
exports.bufferToggle = bufferToggle;
var BufferToggleOperator = (function () {
    function BufferToggleOperator(openings, closingSelector) {
        this.openings = openings;
        this.closingSelector = closingSelector;
    }
    BufferToggleOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new BufferToggleSubscriber(subscriber, this.openings, this.closingSelector));
    };
    return BufferToggleOperator;
}());
var BufferToggleSubscriber = (function (_super) {
    __extends(BufferToggleSubscriber, _super);
    function BufferToggleSubscriber(destination, openings, closingSelector) {
        var _this = _super.call(this, destination) || this;
        _this.closingSelector = closingSelector;
        _this.contexts = [];
        _this.add(subscribeToResult_1.subscribeToResult(_this, openings));
        return _this;
    }
    BufferToggleSubscriber.prototype._next = function (value) {
        var contexts = this.contexts;
        var len = contexts.length;
        for (var i = 0; i < len; i++) {
            contexts[i].buffer.push(value);
        }
    };
    BufferToggleSubscriber.prototype._error = function (err) {
        var contexts = this.contexts;
        while (contexts.length > 0) {
            var context_1 = contexts.shift();
            context_1.subscription.unsubscribe();
            context_1.buffer = null;
            context_1.subscription = null;
        }
        this.contexts = null;
        _super.prototype._error.call(this, err);
    };
    BufferToggleSubscriber.prototype._complete = function () {
        var contexts = this.contexts;
        while (contexts.length > 0) {
            var context_2 = contexts.shift();
            this.destination.next(context_2.buffer);
            context_2.subscription.unsubscribe();
            context_2.buffer = null;
            context_2.subscription = null;
        }
        this.contexts = null;
        _super.prototype._complete.call(this);
    };
    BufferToggleSubscriber.prototype.notifyNext = function (outerValue, innerValue) {
        outerValue ? this.closeBuffer(outerValue) : this.openBuffer(innerValue);
    };
    BufferToggleSubscriber.prototype.notifyComplete = function (innerSub) {
        this.closeBuffer(innerSub.context);
    };
    BufferToggleSubscriber.prototype.openBuffer = function (value) {
        try {
            var closingSelector = this.closingSelector;
            var closingNotifier = closingSelector.call(this, value);
            if (closingNotifier) {
                this.trySubscribe(closingNotifier);
            }
        }
        catch (err) {
            this._error(err);
        }
    };
    BufferToggleSubscriber.prototype.closeBuffer = function (context) {
        var contexts = this.contexts;
        if (contexts && context) {
            var buffer = context.buffer, subscription = context.subscription;
            this.destination.next(buffer);
            contexts.splice(contexts.indexOf(context), 1);
            this.remove(subscription);
            subscription.unsubscribe();
        }
    };
    BufferToggleSubscriber.prototype.trySubscribe = function (closingNotifier) {
        var contexts = this.contexts;
        var buffer = [];
        var subscription = new Subscription_1.Subscription();
        var context = { buffer: buffer, subscription: subscription };
        contexts.push(context);
        var innerSubscription = subscribeToResult_1.subscribeToResult(this, closingNotifier, context);
        if (!innerSubscription || innerSubscription.closed) {
            this.closeBuffer(context);
        }
        else {
            innerSubscription.context = context;
            this.add(innerSubscription);
            subscription.add(innerSubscription);
        }
    };
    return BufferToggleSubscriber;
}(OuterSubscriber_1.OuterSubscriber));

},{"../OuterSubscriber":119,"../Subscription":125,"../util/subscribeToResult":310}],162:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscription_1 = require("../Subscription");
var innerSubscribe_1 = require("../innerSubscribe");
function bufferWhen(closingSelector) {
    return function (source) {
        return source.lift(new BufferWhenOperator(closingSelector));
    };
}
exports.bufferWhen = bufferWhen;
var BufferWhenOperator = (function () {
    function BufferWhenOperator(closingSelector) {
        this.closingSelector = closingSelector;
    }
    BufferWhenOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new BufferWhenSubscriber(subscriber, this.closingSelector));
    };
    return BufferWhenOperator;
}());
var BufferWhenSubscriber = (function (_super) {
    __extends(BufferWhenSubscriber, _super);
    function BufferWhenSubscriber(destination, closingSelector) {
        var _this = _super.call(this, destination) || this;
        _this.closingSelector = closingSelector;
        _this.subscribing = false;
        _this.openBuffer();
        return _this;
    }
    BufferWhenSubscriber.prototype._next = function (value) {
        this.buffer.push(value);
    };
    BufferWhenSubscriber.prototype._complete = function () {
        var buffer = this.buffer;
        if (buffer) {
            this.destination.next(buffer);
        }
        _super.prototype._complete.call(this);
    };
    BufferWhenSubscriber.prototype._unsubscribe = function () {
        this.buffer = undefined;
        this.subscribing = false;
    };
    BufferWhenSubscriber.prototype.notifyNext = function () {
        this.openBuffer();
    };
    BufferWhenSubscriber.prototype.notifyComplete = function () {
        if (this.subscribing) {
            this.complete();
        }
        else {
            this.openBuffer();
        }
    };
    BufferWhenSubscriber.prototype.openBuffer = function () {
        var closingSubscription = this.closingSubscription;
        if (closingSubscription) {
            this.remove(closingSubscription);
            closingSubscription.unsubscribe();
        }
        var buffer = this.buffer;
        if (this.buffer) {
            this.destination.next(buffer);
        }
        this.buffer = [];
        var closingNotifier;
        try {
            var closingSelector = this.closingSelector;
            closingNotifier = closingSelector();
        }
        catch (err) {
            return this.error(err);
        }
        closingSubscription = new Subscription_1.Subscription();
        this.closingSubscription = closingSubscription;
        this.add(closingSubscription);
        this.subscribing = true;
        closingSubscription.add(innerSubscribe_1.innerSubscribe(closingNotifier, new innerSubscribe_1.SimpleInnerSubscriber(this)));
        this.subscribing = false;
    };
    return BufferWhenSubscriber;
}(innerSubscribe_1.SimpleOuterSubscriber));

},{"../Subscription":125,"../innerSubscribe":127}],163:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var innerSubscribe_1 = require("../innerSubscribe");
function catchError(selector) {
    return function catchErrorOperatorFunction(source) {
        var operator = new CatchOperator(selector);
        var caught = source.lift(operator);
        return (operator.caught = caught);
    };
}
exports.catchError = catchError;
var CatchOperator = (function () {
    function CatchOperator(selector) {
        this.selector = selector;
    }
    CatchOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new CatchSubscriber(subscriber, this.selector, this.caught));
    };
    return CatchOperator;
}());
var CatchSubscriber = (function (_super) {
    __extends(CatchSubscriber, _super);
    function CatchSubscriber(destination, selector, caught) {
        var _this = _super.call(this, destination) || this;
        _this.selector = selector;
        _this.caught = caught;
        return _this;
    }
    CatchSubscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            var result = void 0;
            try {
                result = this.selector(err, this.caught);
            }
            catch (err2) {
                _super.prototype.error.call(this, err2);
                return;
            }
            this._unsubscribeAndRecycle();
            var innerSubscriber = new innerSubscribe_1.SimpleInnerSubscriber(this);
            this.add(innerSubscriber);
            var innerSubscription = innerSubscribe_1.innerSubscribe(result, innerSubscriber);
            if (innerSubscription !== innerSubscriber) {
                this.add(innerSubscription);
            }
        }
    };
    return CatchSubscriber;
}(innerSubscribe_1.SimpleOuterSubscriber));

},{"../innerSubscribe":127}],164:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var combineLatest_1 = require("../observable/combineLatest");
function combineAll(project) {
    return function (source) { return source.lift(new combineLatest_1.CombineLatestOperator(project)); };
}
exports.combineAll = combineAll;

},{"../observable/combineLatest":132}],165:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var isArray_1 = require("../util/isArray");
var combineLatest_1 = require("../observable/combineLatest");
var from_1 = require("../observable/from");
var none = {};
function combineLatest() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i] = arguments[_i];
    }
    var project = null;
    if (typeof observables[observables.length - 1] === 'function') {
        project = observables.pop();
    }
    if (observables.length === 1 && isArray_1.isArray(observables[0])) {
        observables = observables[0].slice();
    }
    return function (source) { return source.lift.call(from_1.from([source].concat(observables)), new combineLatest_1.CombineLatestOperator(project)); };
}
exports.combineLatest = combineLatest;

},{"../observable/combineLatest":132,"../observable/from":137,"../util/isArray":291}],166:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var concat_1 = require("../observable/concat");
function concat() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i] = arguments[_i];
    }
    return function (source) { return source.lift.call(concat_1.concat.apply(void 0, [source].concat(observables))); };
}
exports.concat = concat;

},{"../observable/concat":133}],167:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var mergeAll_1 = require("./mergeAll");
function concatAll() {
    return mergeAll_1.mergeAll(1);
}
exports.concatAll = concatAll;

},{"./mergeAll":201}],168:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var mergeMap_1 = require("./mergeMap");
function concatMap(project, resultSelector) {
    return mergeMap_1.mergeMap(project, resultSelector, 1);
}
exports.concatMap = concatMap;

},{"./mergeMap":202}],169:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var concatMap_1 = require("./concatMap");
function concatMapTo(innerObservable, resultSelector) {
    return concatMap_1.concatMap(function () { return innerObservable; }, resultSelector);
}
exports.concatMapTo = concatMapTo;

},{"./concatMap":168}],170:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
function count(predicate) {
    return function (source) { return source.lift(new CountOperator(predicate, source)); };
}
exports.count = count;
var CountOperator = (function () {
    function CountOperator(predicate, source) {
        this.predicate = predicate;
        this.source = source;
    }
    CountOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new CountSubscriber(subscriber, this.predicate, this.source));
    };
    return CountOperator;
}());
var CountSubscriber = (function (_super) {
    __extends(CountSubscriber, _super);
    function CountSubscriber(destination, predicate, source) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.source = source;
        _this.count = 0;
        _this.index = 0;
        return _this;
    }
    CountSubscriber.prototype._next = function (value) {
        if (this.predicate) {
            this._tryPredicate(value);
        }
        else {
            this.count++;
        }
    };
    CountSubscriber.prototype._tryPredicate = function (value) {
        var result;
        try {
            result = this.predicate(value, this.index++, this.source);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        if (result) {
            this.count++;
        }
    };
    CountSubscriber.prototype._complete = function () {
        this.destination.next(this.count);
        this.destination.complete();
    };
    return CountSubscriber;
}(Subscriber_1.Subscriber));

},{"../Subscriber":124}],171:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var innerSubscribe_1 = require("../innerSubscribe");
function debounce(durationSelector) {
    return function (source) { return source.lift(new DebounceOperator(durationSelector)); };
}
exports.debounce = debounce;
var DebounceOperator = (function () {
    function DebounceOperator(durationSelector) {
        this.durationSelector = durationSelector;
    }
    DebounceOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DebounceSubscriber(subscriber, this.durationSelector));
    };
    return DebounceOperator;
}());
var DebounceSubscriber = (function (_super) {
    __extends(DebounceSubscriber, _super);
    function DebounceSubscriber(destination, durationSelector) {
        var _this = _super.call(this, destination) || this;
        _this.durationSelector = durationSelector;
        _this.hasValue = false;
        return _this;
    }
    DebounceSubscriber.prototype._next = function (value) {
        try {
            var result = this.durationSelector.call(this, value);
            if (result) {
                this._tryNext(value, result);
            }
        }
        catch (err) {
            this.destination.error(err);
        }
    };
    DebounceSubscriber.prototype._complete = function () {
        this.emitValue();
        this.destination.complete();
    };
    DebounceSubscriber.prototype._tryNext = function (value, duration) {
        var subscription = this.durationSubscription;
        this.value = value;
        this.hasValue = true;
        if (subscription) {
            subscription.unsubscribe();
            this.remove(subscription);
        }
        subscription = innerSubscribe_1.innerSubscribe(duration, new innerSubscribe_1.SimpleInnerSubscriber(this));
        if (subscription && !subscription.closed) {
            this.add(this.durationSubscription = subscription);
        }
    };
    DebounceSubscriber.prototype.notifyNext = function () {
        this.emitValue();
    };
    DebounceSubscriber.prototype.notifyComplete = function () {
        this.emitValue();
    };
    DebounceSubscriber.prototype.emitValue = function () {
        if (this.hasValue) {
            var value = this.value;
            var subscription = this.durationSubscription;
            if (subscription) {
                this.durationSubscription = undefined;
                subscription.unsubscribe();
                this.remove(subscription);
            }
            this.value = undefined;
            this.hasValue = false;
            _super.prototype._next.call(this, value);
        }
    };
    return DebounceSubscriber;
}(innerSubscribe_1.SimpleOuterSubscriber));

},{"../innerSubscribe":127}],172:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
var async_1 = require("../scheduler/async");
function debounceTime(dueTime, scheduler) {
    if (scheduler === void 0) { scheduler = async_1.async; }
    return function (source) { return source.lift(new DebounceTimeOperator(dueTime, scheduler)); };
}
exports.debounceTime = debounceTime;
var DebounceTimeOperator = (function () {
    function DebounceTimeOperator(dueTime, scheduler) {
        this.dueTime = dueTime;
        this.scheduler = scheduler;
    }
    DebounceTimeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DebounceTimeSubscriber(subscriber, this.dueTime, this.scheduler));
    };
    return DebounceTimeOperator;
}());
var DebounceTimeSubscriber = (function (_super) {
    __extends(DebounceTimeSubscriber, _super);
    function DebounceTimeSubscriber(destination, dueTime, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.dueTime = dueTime;
        _this.scheduler = scheduler;
        _this.debouncedSubscription = null;
        _this.lastValue = null;
        _this.hasValue = false;
        return _this;
    }
    DebounceTimeSubscriber.prototype._next = function (value) {
        this.clearDebounce();
        this.lastValue = value;
        this.hasValue = true;
        this.add(this.debouncedSubscription = this.scheduler.schedule(dispatchNext, this.dueTime, this));
    };
    DebounceTimeSubscriber.prototype._complete = function () {
        this.debouncedNext();
        this.destination.complete();
    };
    DebounceTimeSubscriber.prototype.debouncedNext = function () {
        this.clearDebounce();
        if (this.hasValue) {
            var lastValue = this.lastValue;
            this.lastValue = null;
            this.hasValue = false;
            this.destination.next(lastValue);
        }
    };
    DebounceTimeSubscriber.prototype.clearDebounce = function () {
        var debouncedSubscription = this.debouncedSubscription;
        if (debouncedSubscription !== null) {
            this.remove(debouncedSubscription);
            debouncedSubscription.unsubscribe();
            this.debouncedSubscription = null;
        }
    };
    return DebounceTimeSubscriber;
}(Subscriber_1.Subscriber));
function dispatchNext(subscriber) {
    subscriber.debouncedNext();
}

},{"../Subscriber":124,"../scheduler/async":277}],173:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
function defaultIfEmpty(defaultValue) {
    if (defaultValue === void 0) { defaultValue = null; }
    return function (source) { return source.lift(new DefaultIfEmptyOperator(defaultValue)); };
}
exports.defaultIfEmpty = defaultIfEmpty;
var DefaultIfEmptyOperator = (function () {
    function DefaultIfEmptyOperator(defaultValue) {
        this.defaultValue = defaultValue;
    }
    DefaultIfEmptyOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DefaultIfEmptySubscriber(subscriber, this.defaultValue));
    };
    return DefaultIfEmptyOperator;
}());
var DefaultIfEmptySubscriber = (function (_super) {
    __extends(DefaultIfEmptySubscriber, _super);
    function DefaultIfEmptySubscriber(destination, defaultValue) {
        var _this = _super.call(this, destination) || this;
        _this.defaultValue = defaultValue;
        _this.isEmpty = true;
        return _this;
    }
    DefaultIfEmptySubscriber.prototype._next = function (value) {
        this.isEmpty = false;
        this.destination.next(value);
    };
    DefaultIfEmptySubscriber.prototype._complete = function () {
        if (this.isEmpty) {
            this.destination.next(this.defaultValue);
        }
        this.destination.complete();
    };
    return DefaultIfEmptySubscriber;
}(Subscriber_1.Subscriber));

},{"../Subscriber":124}],174:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var async_1 = require("../scheduler/async");
var isDate_1 = require("../util/isDate");
var Subscriber_1 = require("../Subscriber");
var Notification_1 = require("../Notification");
function delay(delay, scheduler) {
    if (scheduler === void 0) { scheduler = async_1.async; }
    var absoluteDelay = isDate_1.isDate(delay);
    var delayFor = absoluteDelay ? (+delay - scheduler.now()) : Math.abs(delay);
    return function (source) { return source.lift(new DelayOperator(delayFor, scheduler)); };
}
exports.delay = delay;
var DelayOperator = (function () {
    function DelayOperator(delay, scheduler) {
        this.delay = delay;
        this.scheduler = scheduler;
    }
    DelayOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DelaySubscriber(subscriber, this.delay, this.scheduler));
    };
    return DelayOperator;
}());
var DelaySubscriber = (function (_super) {
    __extends(DelaySubscriber, _super);
    function DelaySubscriber(destination, delay, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.delay = delay;
        _this.scheduler = scheduler;
        _this.queue = [];
        _this.active = false;
        _this.errored = false;
        return _this;
    }
    DelaySubscriber.dispatch = function (state) {
        var source = state.source;
        var queue = source.queue;
        var scheduler = state.scheduler;
        var destination = state.destination;
        while (queue.length > 0 && (queue[0].time - scheduler.now()) <= 0) {
            queue.shift().notification.observe(destination);
        }
        if (queue.length > 0) {
            var delay_1 = Math.max(0, queue[0].time - scheduler.now());
            this.schedule(state, delay_1);
        }
        else {
            this.unsubscribe();
            source.active = false;
        }
    };
    DelaySubscriber.prototype._schedule = function (scheduler) {
        this.active = true;
        var destination = this.destination;
        destination.add(scheduler.schedule(DelaySubscriber.dispatch, this.delay, {
            source: this, destination: this.destination, scheduler: scheduler
        }));
    };
    DelaySubscriber.prototype.scheduleNotification = function (notification) {
        if (this.errored === true) {
            return;
        }
        var scheduler = this.scheduler;
        var message = new DelayMessage(scheduler.now() + this.delay, notification);
        this.queue.push(message);
        if (this.active === false) {
            this._schedule(scheduler);
        }
    };
    DelaySubscriber.prototype._next = function (value) {
        this.scheduleNotification(Notification_1.Notification.createNext(value));
    };
    DelaySubscriber.prototype._error = function (err) {
        this.errored = true;
        this.queue = [];
        this.destination.error(err);
        this.unsubscribe();
    };
    DelaySubscriber.prototype._complete = function () {
        this.scheduleNotification(Notification_1.Notification.createComplete());
        this.unsubscribe();
    };
    return DelaySubscriber;
}(Subscriber_1.Subscriber));
var DelayMessage = (function () {
    function DelayMessage(time, notification) {
        this.time = time;
        this.notification = notification;
    }
    return DelayMessage;
}());

},{"../Notification":116,"../Subscriber":124,"../scheduler/async":277,"../util/isDate":293}],175:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
var Observable_1 = require("../Observable");
var OuterSubscriber_1 = require("../OuterSubscriber");
var subscribeToResult_1 = require("../util/subscribeToResult");
function delayWhen(delayDurationSelector, subscriptionDelay) {
    if (subscriptionDelay) {
        return function (source) {
            return new SubscriptionDelayObservable(source, subscriptionDelay)
                .lift(new DelayWhenOperator(delayDurationSelector));
        };
    }
    return function (source) { return source.lift(new DelayWhenOperator(delayDurationSelector)); };
}
exports.delayWhen = delayWhen;
var DelayWhenOperator = (function () {
    function DelayWhenOperator(delayDurationSelector) {
        this.delayDurationSelector = delayDurationSelector;
    }
    DelayWhenOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DelayWhenSubscriber(subscriber, this.delayDurationSelector));
    };
    return DelayWhenOperator;
}());
var DelayWhenSubscriber = (function (_super) {
    __extends(DelayWhenSubscriber, _super);
    function DelayWhenSubscriber(destination, delayDurationSelector) {
        var _this = _super.call(this, destination) || this;
        _this.delayDurationSelector = delayDurationSelector;
        _this.completed = false;
        _this.delayNotifierSubscriptions = [];
        _this.index = 0;
        return _this;
    }
    DelayWhenSubscriber.prototype.notifyNext = function (outerValue, _innerValue, _outerIndex, _innerIndex, innerSub) {
        this.destination.next(outerValue);
        this.removeSubscription(innerSub);
        this.tryComplete();
    };
    DelayWhenSubscriber.prototype.notifyError = function (error, innerSub) {
        this._error(error);
    };
    DelayWhenSubscriber.prototype.notifyComplete = function (innerSub) {
        var value = this.removeSubscription(innerSub);
        if (value) {
            this.destination.next(value);
        }
        this.tryComplete();
    };
    DelayWhenSubscriber.prototype._next = function (value) {
        var index = this.index++;
        try {
            var delayNotifier = this.delayDurationSelector(value, index);
            if (delayNotifier) {
                this.tryDelay(delayNotifier, value);
            }
        }
        catch (err) {
            this.destination.error(err);
        }
    };
    DelayWhenSubscriber.prototype._complete = function () {
        this.completed = true;
        this.tryComplete();
        this.unsubscribe();
    };
    DelayWhenSubscriber.prototype.removeSubscription = function (subscription) {
        subscription.unsubscribe();
        var subscriptionIdx = this.delayNotifierSubscriptions.indexOf(subscription);
        if (subscriptionIdx !== -1) {
            this.delayNotifierSubscriptions.splice(subscriptionIdx, 1);
        }
        return subscription.outerValue;
    };
    DelayWhenSubscriber.prototype.tryDelay = function (delayNotifier, value) {
        var notifierSubscription = subscribeToResult_1.subscribeToResult(this, delayNotifier, value);
        if (notifierSubscription && !notifierSubscription.closed) {
            var destination = this.destination;
            destination.add(notifierSubscription);
            this.delayNotifierSubscriptions.push(notifierSubscription);
        }
    };
    DelayWhenSubscriber.prototype.tryComplete = function () {
        if (this.completed && this.delayNotifierSubscriptions.length === 0) {
            this.destination.complete();
        }
    };
    return DelayWhenSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
var SubscriptionDelayObservable = (function (_super) {
    __extends(SubscriptionDelayObservable, _super);
    function SubscriptionDelayObservable(source, subscriptionDelay) {
        var _this = _super.call(this) || this;
        _this.source = source;
        _this.subscriptionDelay = subscriptionDelay;
        return _this;
    }
    SubscriptionDelayObservable.prototype._subscribe = function (subscriber) {
        this.subscriptionDelay.subscribe(new SubscriptionDelaySubscriber(subscriber, this.source));
    };
    return SubscriptionDelayObservable;
}(Observable_1.Observable));
var SubscriptionDelaySubscriber = (function (_super) {
    __extends(SubscriptionDelaySubscriber, _super);
    function SubscriptionDelaySubscriber(parent, source) {
        var _this = _super.call(this) || this;
        _this.parent = parent;
        _this.source = source;
        _this.sourceSubscribed = false;
        return _this;
    }
    SubscriptionDelaySubscriber.prototype._next = function (unused) {
        this.subscribeToSource();
    };
    SubscriptionDelaySubscriber.prototype._error = function (err) {
        this.unsubscribe();
        this.parent.error(err);
    };
    SubscriptionDelaySubscriber.prototype._complete = function () {
        this.unsubscribe();
        this.subscribeToSource();
    };
    SubscriptionDelaySubscriber.prototype.subscribeToSource = function () {
        if (!this.sourceSubscribed) {
            this.sourceSubscribed = true;
            this.unsubscribe();
            this.source.subscribe(this.parent);
        }
    };
    return SubscriptionDelaySubscriber;
}(Subscriber_1.Subscriber));

},{"../Observable":117,"../OuterSubscriber":119,"../Subscriber":124,"../util/subscribeToResult":310}],176:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
function dematerialize() {
    return function dematerializeOperatorFunction(source) {
        return source.lift(new DeMaterializeOperator());
    };
}
exports.dematerialize = dematerialize;
var DeMaterializeOperator = (function () {
    function DeMaterializeOperator() {
    }
    DeMaterializeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DeMaterializeSubscriber(subscriber));
    };
    return DeMaterializeOperator;
}());
var DeMaterializeSubscriber = (function (_super) {
    __extends(DeMaterializeSubscriber, _super);
    function DeMaterializeSubscriber(destination) {
        return _super.call(this, destination) || this;
    }
    DeMaterializeSubscriber.prototype._next = function (value) {
        value.observe(this.destination);
    };
    return DeMaterializeSubscriber;
}(Subscriber_1.Subscriber));

},{"../Subscriber":124}],177:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var innerSubscribe_1 = require("../innerSubscribe");
function distinct(keySelector, flushes) {
    return function (source) { return source.lift(new DistinctOperator(keySelector, flushes)); };
}
exports.distinct = distinct;
var DistinctOperator = (function () {
    function DistinctOperator(keySelector, flushes) {
        this.keySelector = keySelector;
        this.flushes = flushes;
    }
    DistinctOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DistinctSubscriber(subscriber, this.keySelector, this.flushes));
    };
    return DistinctOperator;
}());
var DistinctSubscriber = (function (_super) {
    __extends(DistinctSubscriber, _super);
    function DistinctSubscriber(destination, keySelector, flushes) {
        var _this = _super.call(this, destination) || this;
        _this.keySelector = keySelector;
        _this.values = new Set();
        if (flushes) {
            _this.add(innerSubscribe_1.innerSubscribe(flushes, new innerSubscribe_1.SimpleInnerSubscriber(_this)));
        }
        return _this;
    }
    DistinctSubscriber.prototype.notifyNext = function () {
        this.values.clear();
    };
    DistinctSubscriber.prototype.notifyError = function (error) {
        this._error(error);
    };
    DistinctSubscriber.prototype._next = function (value) {
        if (this.keySelector) {
            this._useKeySelector(value);
        }
        else {
            this._finalizeNext(value, value);
        }
    };
    DistinctSubscriber.prototype._useKeySelector = function (value) {
        var key;
        var destination = this.destination;
        try {
            key = this.keySelector(value);
        }
        catch (err) {
            destination.error(err);
            return;
        }
        this._finalizeNext(key, value);
    };
    DistinctSubscriber.prototype._finalizeNext = function (key, value) {
        var values = this.values;
        if (!values.has(key)) {
            values.add(key);
            this.destination.next(value);
        }
    };
    return DistinctSubscriber;
}(innerSubscribe_1.SimpleOuterSubscriber));
exports.DistinctSubscriber = DistinctSubscriber;

},{"../innerSubscribe":127}],178:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
function distinctUntilChanged(compare, keySelector) {
    return function (source) { return source.lift(new DistinctUntilChangedOperator(compare, keySelector)); };
}
exports.distinctUntilChanged = distinctUntilChanged;
var DistinctUntilChangedOperator = (function () {
    function DistinctUntilChangedOperator(compare, keySelector) {
        this.compare = compare;
        this.keySelector = keySelector;
    }
    DistinctUntilChangedOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DistinctUntilChangedSubscriber(subscriber, this.compare, this.keySelector));
    };
    return DistinctUntilChangedOperator;
}());
var DistinctUntilChangedSubscriber = (function (_super) {
    __extends(DistinctUntilChangedSubscriber, _super);
    function DistinctUntilChangedSubscriber(destination, compare, keySelector) {
        var _this = _super.call(this, destination) || this;
        _this.keySelector = keySelector;
        _this.hasKey = false;
        if (typeof compare === 'function') {
            _this.compare = compare;
        }
        return _this;
    }
    DistinctUntilChangedSubscriber.prototype.compare = function (x, y) {
        return x === y;
    };
    DistinctUntilChangedSubscriber.prototype._next = function (value) {
        var key;
        try {
            var keySelector = this.keySelector;
            key = keySelector ? keySelector(value) : value;
        }
        catch (err) {
            return this.destination.error(err);
        }
        var result = false;
        if (this.hasKey) {
            try {
                var compare = this.compare;
                result = compare(this.key, key);
            }
            catch (err) {
                return this.destination.error(err);
            }
        }
        else {
            this.hasKey = true;
        }
        if (!result) {
            this.key = key;
            this.destination.next(value);
        }
    };
    return DistinctUntilChangedSubscriber;
}(Subscriber_1.Subscriber));

},{"../Subscriber":124}],179:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var distinctUntilChanged_1 = require("./distinctUntilChanged");
function distinctUntilKeyChanged(key, compare) {
    return distinctUntilChanged_1.distinctUntilChanged(function (x, y) { return compare ? compare(x[key], y[key]) : x[key] === y[key]; });
}
exports.distinctUntilKeyChanged = distinctUntilKeyChanged;

},{"./distinctUntilChanged":178}],180:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ArgumentOutOfRangeError_1 = require("../util/ArgumentOutOfRangeError");
var filter_1 = require("./filter");
var throwIfEmpty_1 = require("./throwIfEmpty");
var defaultIfEmpty_1 = require("./defaultIfEmpty");
var take_1 = require("./take");
function elementAt(index, defaultValue) {
    if (index < 0) {
        throw new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError();
    }
    var hasDefaultValue = arguments.length >= 2;
    return function (source) { return source.pipe(filter_1.filter(function (v, i) { return i === index; }), take_1.take(1), hasDefaultValue
        ? defaultIfEmpty_1.defaultIfEmpty(defaultValue)
        : throwIfEmpty_1.throwIfEmpty(function () { return new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError(); })); };
}
exports.elementAt = elementAt;

},{"../util/ArgumentOutOfRangeError":282,"./defaultIfEmpty":173,"./filter":186,"./take":239,"./throwIfEmpty":246}],181:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var concat_1 = require("../observable/concat");
var of_1 = require("../observable/of");
function endWith() {
    var array = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        array[_i] = arguments[_i];
    }
    return function (source) { return concat_1.concat(source, of_1.of.apply(void 0, array)); };
}
exports.endWith = endWith;

},{"../observable/concat":133,"../observable/of":146}],182:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
function every(predicate, thisArg) {
    return function (source) { return source.lift(new EveryOperator(predicate, thisArg, source)); };
}
exports.every = every;
var EveryOperator = (function () {
    function EveryOperator(predicate, thisArg, source) {
        this.predicate = predicate;
        this.thisArg = thisArg;
        this.source = source;
    }
    EveryOperator.prototype.call = function (observer, source) {
        return source.subscribe(new EverySubscriber(observer, this.predicate, this.thisArg, this.source));
    };
    return EveryOperator;
}());
var EverySubscriber = (function (_super) {
    __extends(EverySubscriber, _super);
    function EverySubscriber(destination, predicate, thisArg, source) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.thisArg = thisArg;
        _this.source = source;
        _this.index = 0;
        _this.thisArg = thisArg || _this;
        return _this;
    }
    EverySubscriber.prototype.notifyComplete = function (everyValueMatch) {
        this.destination.next(everyValueMatch);
        this.destination.complete();
    };
    EverySubscriber.prototype._next = function (value) {
        var result = false;
        try {
            result = this.predicate.call(this.thisArg, value, this.index++, this.source);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        if (!result) {
            this.notifyComplete(false);
        }
    };
    EverySubscriber.prototype._complete = function () {
        this.notifyComplete(true);
    };
    return EverySubscriber;
}(Subscriber_1.Subscriber));

},{"../Subscriber":124}],183:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var innerSubscribe_1 = require("../innerSubscribe");
function exhaust() {
    return function (source) { return source.lift(new SwitchFirstOperator()); };
}
exports.exhaust = exhaust;
var SwitchFirstOperator = (function () {
    function SwitchFirstOperator() {
    }
    SwitchFirstOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SwitchFirstSubscriber(subscriber));
    };
    return SwitchFirstOperator;
}());
var SwitchFirstSubscriber = (function (_super) {
    __extends(SwitchFirstSubscriber, _super);
    function SwitchFirstSubscriber(destination) {
        var _this = _super.call(this, destination) || this;
        _this.hasCompleted = false;
        _this.hasSubscription = false;
        return _this;
    }
    SwitchFirstSubscriber.prototype._next = function (value) {
        if (!this.hasSubscription) {
            this.hasSubscription = true;
            this.add(innerSubscribe_1.innerSubscribe(value, new innerSubscribe_1.SimpleInnerSubscriber(this)));
        }
    };
    SwitchFirstSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (!this.hasSubscription) {
            this.destination.complete();
        }
    };
    SwitchFirstSubscriber.prototype.notifyComplete = function () {
        this.hasSubscription = false;
        if (this.hasCompleted) {
            this.destination.complete();
        }
    };
    return SwitchFirstSubscriber;
}(innerSubscribe_1.SimpleOuterSubscriber));

},{"../innerSubscribe":127}],184:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var map_1 = require("./map");
var from_1 = require("../observable/from");
var innerSubscribe_1 = require("../innerSubscribe");
function exhaustMap(project, resultSelector) {
    if (resultSelector) {
        return function (source) { return source.pipe(exhaustMap(function (a, i) { return from_1.from(project(a, i)).pipe(map_1.map(function (b, ii) { return resultSelector(a, b, i, ii); })); })); };
    }
    return function (source) {
        return source.lift(new ExhaustMapOperator(project));
    };
}
exports.exhaustMap = exhaustMap;
var ExhaustMapOperator = (function () {
    function ExhaustMapOperator(project) {
        this.project = project;
    }
    ExhaustMapOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ExhaustMapSubscriber(subscriber, this.project));
    };
    return ExhaustMapOperator;
}());
var ExhaustMapSubscriber = (function (_super) {
    __extends(ExhaustMapSubscriber, _super);
    function ExhaustMapSubscriber(destination, project) {
        var _this = _super.call(this, destination) || this;
        _this.project = project;
        _this.hasSubscription = false;
        _this.hasCompleted = false;
        _this.index = 0;
        return _this;
    }
    ExhaustMapSubscriber.prototype._next = function (value) {
        if (!this.hasSubscription) {
            this.tryNext(value);
        }
    };
    ExhaustMapSubscriber.prototype.tryNext = function (value) {
        var result;
        var index = this.index++;
        try {
            result = this.project(value, index);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.hasSubscription = true;
        this._innerSub(result);
    };
    ExhaustMapSubscriber.prototype._innerSub = function (result) {
        var innerSubscriber = new innerSubscribe_1.SimpleInnerSubscriber(this);
        var destination = this.destination;
        destination.add(innerSubscriber);
        var innerSubscription = innerSubscribe_1.innerSubscribe(result, innerSubscriber);
        if (innerSubscription !== innerSubscriber) {
            destination.add(innerSubscription);
        }
    };
    ExhaustMapSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (!this.hasSubscription) {
            this.destination.complete();
        }
        this.unsubscribe();
    };
    ExhaustMapSubscriber.prototype.notifyNext = function (innerValue) {
        this.destination.next(innerValue);
    };
    ExhaustMapSubscriber.prototype.notifyError = function (err) {
        this.destination.error(err);
    };
    ExhaustMapSubscriber.prototype.notifyComplete = function () {
        this.hasSubscription = false;
        if (this.hasCompleted) {
            this.destination.complete();
        }
    };
    return ExhaustMapSubscriber;
}(innerSubscribe_1.SimpleOuterSubscriber));

},{"../innerSubscribe":127,"../observable/from":137,"./map":196}],185:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var innerSubscribe_1 = require("../innerSubscribe");
function expand(project, concurrent, scheduler) {
    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
    concurrent = (concurrent || 0) < 1 ? Number.POSITIVE_INFINITY : concurrent;
    return function (source) { return source.lift(new ExpandOperator(project, concurrent, scheduler)); };
}
exports.expand = expand;
var ExpandOperator = (function () {
    function ExpandOperator(project, concurrent, scheduler) {
        this.project = project;
        this.concurrent = concurrent;
        this.scheduler = scheduler;
    }
    ExpandOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ExpandSubscriber(subscriber, this.project, this.concurrent, this.scheduler));
    };
    return ExpandOperator;
}());
exports.ExpandOperator = ExpandOperator;
var ExpandSubscriber = (function (_super) {
    __extends(ExpandSubscriber, _super);
    function ExpandSubscriber(destination, project, concurrent, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.project = project;
        _this.concurrent = concurrent;
        _this.scheduler = scheduler;
        _this.index = 0;
        _this.active = 0;
        _this.hasCompleted = false;
        if (concurrent < Number.POSITIVE_INFINITY) {
            _this.buffer = [];
        }
        return _this;
    }
    ExpandSubscriber.dispatch = function (arg) {
        var subscriber = arg.subscriber, result = arg.result, value = arg.value, index = arg.index;
        subscriber.subscribeToProjection(result, value, index);
    };
    ExpandSubscriber.prototype._next = function (value) {
        var destination = this.destination;
        if (destination.closed) {
            this._complete();
            return;
        }
        var index = this.index++;
        if (this.active < this.concurrent) {
            destination.next(value);
            try {
                var project = this.project;
                var result = project(value, index);
                if (!this.scheduler) {
                    this.subscribeToProjection(result, value, index);
                }
                else {
                    var state = { subscriber: this, result: result, value: value, index: index };
                    var destination_1 = this.destination;
                    destination_1.add(this.scheduler.schedule(ExpandSubscriber.dispatch, 0, state));
                }
            }
            catch (e) {
                destination.error(e);
            }
        }
        else {
            this.buffer.push(value);
        }
    };
    ExpandSubscriber.prototype.subscribeToProjection = function (result, value, index) {
        this.active++;
        var destination = this.destination;
        destination.add(innerSubscribe_1.innerSubscribe(result, new innerSubscribe_1.SimpleInnerSubscriber(this)));
    };
    ExpandSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (this.hasCompleted && this.active === 0) {
            this.destination.complete();
        }
        this.unsubscribe();
    };
    ExpandSubscriber.prototype.notifyNext = function (innerValue) {
        this._next(innerValue);
    };
    ExpandSubscriber.prototype.notifyComplete = function () {
        var buffer = this.buffer;
        this.active--;
        if (buffer && buffer.length > 0) {
            this._next(buffer.shift());
        }
        if (this.hasCompleted && this.active === 0) {
            this.destination.complete();
        }
    };
    return ExpandSubscriber;
}(innerSubscribe_1.SimpleOuterSubscriber));
exports.ExpandSubscriber = ExpandSubscriber;

},{"../innerSubscribe":127}],186:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
function filter(predicate, thisArg) {
    return function filterOperatorFunction(source) {
        return source.lift(new FilterOperator(predicate, thisArg));
    };
}
exports.filter = filter;
var FilterOperator = (function () {
    function FilterOperator(predicate, thisArg) {
        this.predicate = predicate;
        this.thisArg = thisArg;
    }
    FilterOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg));
    };
    return FilterOperator;
}());
var FilterSubscriber = (function (_super) {
    __extends(FilterSubscriber, _super);
    function FilterSubscriber(destination, predicate, thisArg) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.thisArg = thisArg;
        _this.count = 0;
        return _this;
    }
    FilterSubscriber.prototype._next = function (value) {
        var result;
        try {
            result = this.predicate.call(this.thisArg, value, this.count++);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        if (result) {
            this.destination.next(value);
        }
    };
    return FilterSubscriber;
}(Subscriber_1.Subscriber));

},{"../Subscriber":124}],187:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
var Subscription_1 = require("../Subscription");
function finalize(callback) {
    return function (source) { return source.lift(new FinallyOperator(callback)); };
}
exports.finalize = finalize;
var FinallyOperator = (function () {
    function FinallyOperator(callback) {
        this.callback = callback;
    }
    FinallyOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new FinallySubscriber(subscriber, this.callback));
    };
    return FinallyOperator;
}());
var FinallySubscriber = (function (_super) {
    __extends(FinallySubscriber, _super);
    function FinallySubscriber(destination, callback) {
        var _this = _super.call(this, destination) || this;
        _this.add(new Subscription_1.Subscription(callback));
        return _this;
    }
    return FinallySubscriber;
}(Subscriber_1.Subscriber));

},{"../Subscriber":124,"../Subscription":125}],188:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
function find(predicate, thisArg) {
    if (typeof predicate !== 'function') {
        throw new TypeError('predicate is not a function');
    }
    return function (source) { return source.lift(new FindValueOperator(predicate, source, false, thisArg)); };
}
exports.find = find;
var FindValueOperator = (function () {
    function FindValueOperator(predicate, source, yieldIndex, thisArg) {
        this.predicate = predicate;
        this.source = source;
        this.yieldIndex = yieldIndex;
        this.thisArg = thisArg;
    }
    FindValueOperator.prototype.call = function (observer, source) {
        return source.subscribe(new FindValueSubscriber(observer, this.predicate, this.source, this.yieldIndex, this.thisArg));
    };
    return FindValueOperator;
}());
exports.FindValueOperator = FindValueOperator;
var FindValueSubscriber = (function (_super) {
    __extends(FindValueSubscriber, _super);
    function FindValueSubscriber(destination, predicate, source, yieldIndex, thisArg) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.source = source;
        _this.yieldIndex = yieldIndex;
        _this.thisArg = thisArg;
        _this.index = 0;
        return _this;
    }
    FindValueSubscriber.prototype.notifyComplete = function (value) {
        var destination = this.destination;
        destination.next(value);
        destination.complete();
        this.unsubscribe();
    };
    FindValueSubscriber.prototype._next = function (value) {
        var _a = this, predicate = _a.predicate, thisArg = _a.thisArg;
        var index = this.index++;
        try {
            var result = predicate.call(thisArg || this, value, index, this.source);
            if (result) {
                this.notifyComplete(this.yieldIndex ? index : value);
            }
        }
        catch (err) {
            this.destination.error(err);
        }
    };
    FindValueSubscriber.prototype._complete = function () {
        this.notifyComplete(this.yieldIndex ? -1 : undefined);
    };
    return FindValueSubscriber;
}(Subscriber_1.Subscriber));
exports.FindValueSubscriber = FindValueSubscriber;

},{"../Subscriber":124}],189:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var find_1 = require("../operators/find");
function findIndex(predicate, thisArg) {
    return function (source) { return source.lift(new find_1.FindValueOperator(predicate, source, true, thisArg)); };
}
exports.findIndex = findIndex;

},{"../operators/find":188}],190:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var EmptyError_1 = require("../util/EmptyError");
var filter_1 = require("./filter");
var take_1 = require("./take");
var defaultIfEmpty_1 = require("./defaultIfEmpty");
var throwIfEmpty_1 = require("./throwIfEmpty");
var identity_1 = require("../util/identity");
function first(predicate, defaultValue) {
    var hasDefaultValue = arguments.length >= 2;
    return function (source) { return source.pipe(predicate ? filter_1.filter(function (v, i) { return predicate(v, i, source); }) : identity_1.identity, take_1.take(1), hasDefaultValue ? defaultIfEmpty_1.defaultIfEmpty(defaultValue) : throwIfEmpty_1.throwIfEmpty(function () { return new EmptyError_1.EmptyError(); })); };
}
exports.first = first;

},{"../util/EmptyError":283,"../util/identity":290,"./defaultIfEmpty":173,"./filter":186,"./take":239,"./throwIfEmpty":246}],191:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
var Subscription_1 = require("../Subscription");
var Observable_1 = require("../Observable");
var Subject_1 = require("../Subject");
function groupBy(keySelector, elementSelector, durationSelector, subjectSelector) {
    return function (source) {
        return source.lift(new GroupByOperator(keySelector, elementSelector, durationSelector, subjectSelector));
    };
}
exports.groupBy = groupBy;
var GroupByOperator = (function () {
    function GroupByOperator(keySelector, elementSelector, durationSelector, subjectSelector) {
        this.keySelector = keySelector;
        this.elementSelector = elementSelector;
        this.durationSelector = durationSelector;
        this.subjectSelector = subjectSelector;
    }
    GroupByOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new GroupBySubscriber(subscriber, this.keySelector, this.elementSelector, this.durationSelector, this.subjectSelector));
    };
    return GroupByOperator;
}());
var GroupBySubscriber = (function (_super) {
    __extends(GroupBySubscriber, _super);
    function GroupBySubscriber(destination, keySelector, elementSelector, durationSelector, subjectSelector) {
        var _this = _super.call(this, destination) || this;
        _this.keySelector = keySelector;
        _this.elementSelector = elementSelector;
        _this.durationSelector = durationSelector;
        _this.subjectSelector = subjectSelector;
        _this.groups = null;
        _this.attemptedToUnsubscribe = false;
        _this.count = 0;
        return _this;
    }
    GroupBySubscriber.prototype._next = function (value) {
        var key;
        try {
            key = this.keySelector(value);
        }
        catch (err) {
            this.error(err);
            return;
        }
        this._group(value, key);
    };
    GroupBySubscriber.prototype._group = function (value, key) {
        var groups = this.groups;
        if (!groups) {
            groups = this.groups = new Map();
        }
        var group = groups.get(key);
        var element;
        if (this.elementSelector) {
            try {
                element = this.elementSelector(value);
            }
            catch (err) {
                this.error(err);
            }
        }
        else {
            element = value;
        }
        if (!group) {
            group = (this.subjectSelector ? this.subjectSelector() : new Subject_1.Subject());
            groups.set(key, group);
            var groupedObservable = new GroupedObservable(key, group, this);
            this.destination.next(groupedObservable);
            if (this.durationSelector) {
                var duration = void 0;
                try {
                    duration = this.durationSelector(new GroupedObservable(key, group));
                }
                catch (err) {
                    this.error(err);
                    return;
                }
                this.add(duration.subscribe(new GroupDurationSubscriber(key, group, this)));
            }
        }
        if (!group.closed) {
            group.next(element);
        }
    };
    GroupBySubscriber.prototype._error = function (err) {
        var groups = this.groups;
        if (groups) {
            groups.forEach(function (group, key) {
                group.error(err);
            });
            groups.clear();
        }
        this.destination.error(err);
    };
    GroupBySubscriber.prototype._complete = function () {
        var groups = this.groups;
        if (groups) {
            groups.forEach(function (group, key) {
                group.complete();
            });
            groups.clear();
        }
        this.destination.complete();
    };
    GroupBySubscriber.prototype.removeGroup = function (key) {
        this.groups.delete(key);
    };
    GroupBySubscriber.prototype.unsubscribe = function () {
        if (!this.closed) {
            this.attemptedToUnsubscribe = true;
            if (this.count === 0) {
                _super.prototype.unsubscribe.call(this);
            }
        }
    };
    return GroupBySubscriber;
}(Subscriber_1.Subscriber));
var GroupDurationSubscriber = (function (_super) {
    __extends(GroupDurationSubscriber, _super);
    function GroupDurationSubscriber(key, group, parent) {
        var _this = _super.call(this, group) || this;
        _this.key = key;
        _this.group = group;
        _this.parent = parent;
        return _this;
    }
    GroupDurationSubscriber.prototype._next = function (value) {
        this.complete();
    };
    GroupDurationSubscriber.prototype._unsubscribe = function () {
        var _a = this, parent = _a.parent, key = _a.key;
        this.key = this.parent = null;
        if (parent) {
            parent.removeGroup(key);
        }
    };
    return GroupDurationSubscriber;
}(Subscriber_1.Subscriber));
var GroupedObservable = (function (_super) {
    __extends(GroupedObservable, _super);
    function GroupedObservable(key, groupSubject, refCountSubscription) {
        var _this = _super.call(this) || this;
        _this.key = key;
        _this.groupSubject = groupSubject;
        _this.refCountSubscription = refCountSubscription;
        return _this;
    }
    GroupedObservable.prototype._subscribe = function (subscriber) {
        var subscription = new Subscription_1.Subscription();
        var _a = this, refCountSubscription = _a.refCountSubscription, groupSubject = _a.groupSubject;
        if (refCountSubscription && !refCountSubscription.closed) {
            subscription.add(new InnerRefCountSubscription(refCountSubscription));
        }
        subscription.add(groupSubject.subscribe(subscriber));
        return subscription;
    };
    return GroupedObservable;
}(Observable_1.Observable));
exports.GroupedObservable = GroupedObservable;
var InnerRefCountSubscription = (function (_super) {
    __extends(InnerRefCountSubscription, _super);
    function InnerRefCountSubscription(parent) {
        var _this = _super.call(this) || this;
        _this.parent = parent;
        parent.count++;
        return _this;
    }
    InnerRefCountSubscription.prototype.unsubscribe = function () {
        var parent = this.parent;
        if (!parent.closed && !this.closed) {
            _super.prototype.unsubscribe.call(this);
            parent.count -= 1;
            if (parent.count === 0 && parent.attemptedToUnsubscribe) {
                parent.unsubscribe();
            }
        }
    };
    return InnerRefCountSubscription;
}(Subscription_1.Subscription));

},{"../Observable":117,"../Subject":122,"../Subscriber":124,"../Subscription":125}],192:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
function ignoreElements() {
    return function ignoreElementsOperatorFunction(source) {
        return source.lift(new IgnoreElementsOperator());
    };
}
exports.ignoreElements = ignoreElements;
var IgnoreElementsOperator = (function () {
    function IgnoreElementsOperator() {
    }
    IgnoreElementsOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new IgnoreElementsSubscriber(subscriber));
    };
    return IgnoreElementsOperator;
}());
var IgnoreElementsSubscriber = (function (_super) {
    __extends(IgnoreElementsSubscriber, _super);
    function IgnoreElementsSubscriber() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    IgnoreElementsSubscriber.prototype._next = function (unused) {
    };
    return IgnoreElementsSubscriber;
}(Subscriber_1.Subscriber));

},{"../Subscriber":124}],193:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var audit_1 = require("./audit");
exports.audit = audit_1.audit;
var auditTime_1 = require("./auditTime");
exports.auditTime = auditTime_1.auditTime;
var buffer_1 = require("./buffer");
exports.buffer = buffer_1.buffer;
var bufferCount_1 = require("./bufferCount");
exports.bufferCount = bufferCount_1.bufferCount;
var bufferTime_1 = require("./bufferTime");
exports.bufferTime = bufferTime_1.bufferTime;
var bufferToggle_1 = require("./bufferToggle");
exports.bufferToggle = bufferToggle_1.bufferToggle;
var bufferWhen_1 = require("./bufferWhen");
exports.bufferWhen = bufferWhen_1.bufferWhen;
var catchError_1 = require("./catchError");
exports.catchError = catchError_1.catchError;
var combineAll_1 = require("./combineAll");
exports.combineAll = combineAll_1.combineAll;
var combineLatest_1 = require("./combineLatest");
exports.combineLatest = combineLatest_1.combineLatest;
var concat_1 = require("./concat");
exports.concat = concat_1.concat;
var concatAll_1 = require("./concatAll");
exports.concatAll = concatAll_1.concatAll;
var concatMap_1 = require("./concatMap");
exports.concatMap = concatMap_1.concatMap;
var concatMapTo_1 = require("./concatMapTo");
exports.concatMapTo = concatMapTo_1.concatMapTo;
var count_1 = require("./count");
exports.count = count_1.count;
var debounce_1 = require("./debounce");
exports.debounce = debounce_1.debounce;
var debounceTime_1 = require("./debounceTime");
exports.debounceTime = debounceTime_1.debounceTime;
var defaultIfEmpty_1 = require("./defaultIfEmpty");
exports.defaultIfEmpty = defaultIfEmpty_1.defaultIfEmpty;
var delay_1 = require("./delay");
exports.delay = delay_1.delay;
var delayWhen_1 = require("./delayWhen");
exports.delayWhen = delayWhen_1.delayWhen;
var dematerialize_1 = require("./dematerialize");
exports.dematerialize = dematerialize_1.dematerialize;
var distinct_1 = require("./distinct");
exports.distinct = distinct_1.distinct;
var distinctUntilChanged_1 = require("./distinctUntilChanged");
exports.distinctUntilChanged = distinctUntilChanged_1.distinctUntilChanged;
var distinctUntilKeyChanged_1 = require("./distinctUntilKeyChanged");
exports.distinctUntilKeyChanged = distinctUntilKeyChanged_1.distinctUntilKeyChanged;
var elementAt_1 = require("./elementAt");
exports.elementAt = elementAt_1.elementAt;
var every_1 = require("./every");
exports.every = every_1.every;
var exhaust_1 = require("./exhaust");
exports.exhaust = exhaust_1.exhaust;
var exhaustMap_1 = require("./exhaustMap");
exports.exhaustMap = exhaustMap_1.exhaustMap;
var expand_1 = require("./expand");
exports.expand = expand_1.expand;
var filter_1 = require("./filter");
exports.filter = filter_1.filter;
var finalize_1 = require("./finalize");
exports.finalize = finalize_1.finalize;
var find_1 = require("./find");
exports.find = find_1.find;
var findIndex_1 = require("./findIndex");
exports.findIndex = findIndex_1.findIndex;
var first_1 = require("./first");
exports.first = first_1.first;
var groupBy_1 = require("./groupBy");
exports.groupBy = groupBy_1.groupBy;
var ignoreElements_1 = require("./ignoreElements");
exports.ignoreElements = ignoreElements_1.ignoreElements;
var isEmpty_1 = require("./isEmpty");
exports.isEmpty = isEmpty_1.isEmpty;
var last_1 = require("./last");
exports.last = last_1.last;
var map_1 = require("./map");
exports.map = map_1.map;
var mapTo_1 = require("./mapTo");
exports.mapTo = mapTo_1.mapTo;
var materialize_1 = require("./materialize");
exports.materialize = materialize_1.materialize;
var max_1 = require("./max");
exports.max = max_1.max;
var merge_1 = require("./merge");
exports.merge = merge_1.merge;
var mergeAll_1 = require("./mergeAll");
exports.mergeAll = mergeAll_1.mergeAll;
var mergeMap_1 = require("./mergeMap");
exports.mergeMap = mergeMap_1.mergeMap;
var mergeMap_2 = require("./mergeMap");
exports.flatMap = mergeMap_2.mergeMap;
var mergeMapTo_1 = require("./mergeMapTo");
exports.mergeMapTo = mergeMapTo_1.mergeMapTo;
var mergeScan_1 = require("./mergeScan");
exports.mergeScan = mergeScan_1.mergeScan;
var min_1 = require("./min");
exports.min = min_1.min;
var multicast_1 = require("./multicast");
exports.multicast = multicast_1.multicast;
var observeOn_1 = require("./observeOn");
exports.observeOn = observeOn_1.observeOn;
var onErrorResumeNext_1 = require("./onErrorResumeNext");
exports.onErrorResumeNext = onErrorResumeNext_1.onErrorResumeNext;
var pairwise_1 = require("./pairwise");
exports.pairwise = pairwise_1.pairwise;
var partition_1 = require("./partition");
exports.partition = partition_1.partition;
var pluck_1 = require("./pluck");
exports.pluck = pluck_1.pluck;
var publish_1 = require("./publish");
exports.publish = publish_1.publish;
var publishBehavior_1 = require("./publishBehavior");
exports.publishBehavior = publishBehavior_1.publishBehavior;
var publishLast_1 = require("./publishLast");
exports.publishLast = publishLast_1.publishLast;
var publishReplay_1 = require("./publishReplay");
exports.publishReplay = publishReplay_1.publishReplay;
var race_1 = require("./race");
exports.race = race_1.race;
var reduce_1 = require("./reduce");
exports.reduce = reduce_1.reduce;
var repeat_1 = require("./repeat");
exports.repeat = repeat_1.repeat;
var repeatWhen_1 = require("./repeatWhen");
exports.repeatWhen = repeatWhen_1.repeatWhen;
var retry_1 = require("./retry");
exports.retry = retry_1.retry;
var retryWhen_1 = require("./retryWhen");
exports.retryWhen = retryWhen_1.retryWhen;
var refCount_1 = require("./refCount");
exports.refCount = refCount_1.refCount;
var sample_1 = require("./sample");
exports.sample = sample_1.sample;
var sampleTime_1 = require("./sampleTime");
exports.sampleTime = sampleTime_1.sampleTime;
var scan_1 = require("./scan");
exports.scan = scan_1.scan;
var sequenceEqual_1 = require("./sequenceEqual");
exports.sequenceEqual = sequenceEqual_1.sequenceEqual;
var share_1 = require("./share");
exports.share = share_1.share;
var shareReplay_1 = require("./shareReplay");
exports.shareReplay = shareReplay_1.shareReplay;
var single_1 = require("./single");
exports.single = single_1.single;
var skip_1 = require("./skip");
exports.skip = skip_1.skip;
var skipLast_1 = require("./skipLast");
exports.skipLast = skipLast_1.skipLast;
var skipUntil_1 = require("./skipUntil");
exports.skipUntil = skipUntil_1.skipUntil;
var skipWhile_1 = require("./skipWhile");
exports.skipWhile = skipWhile_1.skipWhile;
var startWith_1 = require("./startWith");
exports.startWith = startWith_1.startWith;
var subscribeOn_1 = require("./subscribeOn");
exports.subscribeOn = subscribeOn_1.subscribeOn;
var switchAll_1 = require("./switchAll");
exports.switchAll = switchAll_1.switchAll;
var switchMap_1 = require("./switchMap");
exports.switchMap = switchMap_1.switchMap;
var switchMapTo_1 = require("./switchMapTo");
exports.switchMapTo = switchMapTo_1.switchMapTo;
var take_1 = require("./take");
exports.take = take_1.take;
var takeLast_1 = require("./takeLast");
exports.takeLast = takeLast_1.takeLast;
var takeUntil_1 = require("./takeUntil");
exports.takeUntil = takeUntil_1.takeUntil;
var takeWhile_1 = require("./takeWhile");
exports.takeWhile = takeWhile_1.takeWhile;
var tap_1 = require("./tap");
exports.tap = tap_1.tap;
var throttle_1 = require("./throttle");
exports.throttle = throttle_1.throttle;
var throttleTime_1 = require("./throttleTime");
exports.throttleTime = throttleTime_1.throttleTime;
var timeInterval_1 = require("./timeInterval");
exports.timeInterval = timeInterval_1.timeInterval;
var timeout_1 = require("./timeout");
exports.timeout = timeout_1.timeout;
var timeoutWith_1 = require("./timeoutWith");
exports.timeoutWith = timeoutWith_1.timeoutWith;
var timestamp_1 = require("./timestamp");
exports.timestamp = timestamp_1.timestamp;
var toArray_1 = require("./toArray");
exports.toArray = toArray_1.toArray;
var window_1 = require("./window");
exports.window = window_1.window;
var windowCount_1 = require("./windowCount");
exports.windowCount = windowCount_1.windowCount;
var windowTime_1 = require("./windowTime");
exports.windowTime = windowTime_1.windowTime;
var windowToggle_1 = require("./windowToggle");
exports.windowToggle = windowToggle_1.windowToggle;
var windowWhen_1 = require("./windowWhen");
exports.windowWhen = windowWhen_1.windowWhen;
var withLatestFrom_1 = require("./withLatestFrom");
exports.withLatestFrom = withLatestFrom_1.withLatestFrom;
var zip_1 = require("./zip");
exports.zip = zip_1.zip;
var zipAll_1 = require("./zipAll");
exports.zipAll = zipAll_1.zipAll;

},{"./audit":156,"./auditTime":157,"./buffer":158,"./bufferCount":159,"./bufferTime":160,"./bufferToggle":161,"./bufferWhen":162,"./catchError":163,"./combineAll":164,"./combineLatest":165,"./concat":166,"./concatAll":167,"./concatMap":168,"./concatMapTo":169,"./count":170,"./debounce":171,"./debounceTime":172,"./defaultIfEmpty":173,"./delay":174,"./delayWhen":175,"./dematerialize":176,"./distinct":177,"./distinctUntilChanged":178,"./distinctUntilKeyChanged":179,"./elementAt":180,"./every":182,"./exhaust":183,"./exhaustMap":184,"./expand":185,"./filter":186,"./finalize":187,"./find":188,"./findIndex":189,"./first":190,"./groupBy":191,"./ignoreElements":192,"./isEmpty":194,"./last":195,"./map":196,"./mapTo":197,"./materialize":198,"./max":199,"./merge":200,"./mergeAll":201,"./mergeMap":202,"./mergeMapTo":203,"./mergeScan":204,"./min":205,"./multicast":206,"./observeOn":207,"./onErrorResumeNext":208,"./pairwise":209,"./partition":210,"./pluck":211,"./publish":212,"./publishBehavior":213,"./publishLast":214,"./publishReplay":215,"./race":216,"./reduce":217,"./refCount":218,"./repeat":219,"./repeatWhen":220,"./retry":221,"./retryWhen":222,"./sample":223,"./sampleTime":224,"./scan":225,"./sequenceEqual":226,"./share":227,"./shareReplay":228,"./single":229,"./skip":230,"./skipLast":231,"./skipUntil":232,"./skipWhile":233,"./startWith":234,"./subscribeOn":235,"./switchAll":236,"./switchMap":237,"./switchMapTo":238,"./take":239,"./takeLast":240,"./takeUntil":241,"./takeWhile":242,"./tap":243,"./throttle":244,"./throttleTime":245,"./timeInterval":247,"./timeout":248,"./timeoutWith":249,"./timestamp":250,"./toArray":251,"./window":252,"./windowCount":253,"./windowTime":254,"./windowToggle":255,"./windowWhen":256,"./withLatestFrom":257,"./zip":258,"./zipAll":259}],194:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
function isEmpty() {
    return function (source) { return source.lift(new IsEmptyOperator()); };
}
exports.isEmpty = isEmpty;
var IsEmptyOperator = (function () {
    function IsEmptyOperator() {
    }
    IsEmptyOperator.prototype.call = function (observer, source) {
        return source.subscribe(new IsEmptySubscriber(observer));
    };
    return IsEmptyOperator;
}());
var IsEmptySubscriber = (function (_super) {
    __extends(IsEmptySubscriber, _super);
    function IsEmptySubscriber(destination) {
        return _super.call(this, destination) || this;
    }
    IsEmptySubscriber.prototype.notifyComplete = function (isEmpty) {
        var destination = this.destination;
        destination.next(isEmpty);
        destination.complete();
    };
    IsEmptySubscriber.prototype._next = function (value) {
        this.notifyComplete(false);
    };
    IsEmptySubscriber.prototype._complete = function () {
        this.notifyComplete(true);
    };
    return IsEmptySubscriber;
}(Subscriber_1.Subscriber));

},{"../Subscriber":124}],195:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var EmptyError_1 = require("../util/EmptyError");
var filter_1 = require("./filter");
var takeLast_1 = require("./takeLast");
var throwIfEmpty_1 = require("./throwIfEmpty");
var defaultIfEmpty_1 = require("./defaultIfEmpty");
var identity_1 = require("../util/identity");
function last(predicate, defaultValue) {
    var hasDefaultValue = arguments.length >= 2;
    return function (source) { return source.pipe(predicate ? filter_1.filter(function (v, i) { return predicate(v, i, source); }) : identity_1.identity, takeLast_1.takeLast(1), hasDefaultValue ? defaultIfEmpty_1.defaultIfEmpty(defaultValue) : throwIfEmpty_1.throwIfEmpty(function () { return new EmptyError_1.EmptyError(); })); };
}
exports.last = last;

},{"../util/EmptyError":283,"../util/identity":290,"./defaultIfEmpty":173,"./filter":186,"./takeLast":240,"./throwIfEmpty":246}],196:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
function map(project, thisArg) {
    return function mapOperation(source) {
        if (typeof project !== 'function') {
            throw new TypeError('argument is not a function. Are you looking for `mapTo()`?');
        }
        return source.lift(new MapOperator(project, thisArg));
    };
}
exports.map = map;
var MapOperator = (function () {
    function MapOperator(project, thisArg) {
        this.project = project;
        this.thisArg = thisArg;
    }
    MapOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));
    };
    return MapOperator;
}());
exports.MapOperator = MapOperator;
var MapSubscriber = (function (_super) {
    __extends(MapSubscriber, _super);
    function MapSubscriber(destination, project, thisArg) {
        var _this = _super.call(this, destination) || this;
        _this.project = project;
        _this.count = 0;
        _this.thisArg = thisArg || _this;
        return _this;
    }
    MapSubscriber.prototype._next = function (value) {
        var result;
        try {
            result = this.project.call(this.thisArg, value, this.count++);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return MapSubscriber;
}(Subscriber_1.Subscriber));

},{"../Subscriber":124}],197:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
function mapTo(value) {
    return function (source) { return source.lift(new MapToOperator(value)); };
}
exports.mapTo = mapTo;
var MapToOperator = (function () {
    function MapToOperator(value) {
        this.value = value;
    }
    MapToOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new MapToSubscriber(subscriber, this.value));
    };
    return MapToOperator;
}());
var MapToSubscriber = (function (_super) {
    __extends(MapToSubscriber, _super);
    function MapToSubscriber(destination, value) {
        var _this = _super.call(this, destination) || this;
        _this.value = value;
        return _this;
    }
    MapToSubscriber.prototype._next = function (x) {
        this.destination.next(this.value);
    };
    return MapToSubscriber;
}(Subscriber_1.Subscriber));

},{"../Subscriber":124}],198:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
var Notification_1 = require("../Notification");
function materialize() {
    return function materializeOperatorFunction(source) {
        return source.lift(new MaterializeOperator());
    };
}
exports.materialize = materialize;
var MaterializeOperator = (function () {
    function MaterializeOperator() {
    }
    MaterializeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new MaterializeSubscriber(subscriber));
    };
    return MaterializeOperator;
}());
var MaterializeSubscriber = (function (_super) {
    __extends(MaterializeSubscriber, _super);
    function MaterializeSubscriber(destination) {
        return _super.call(this, destination) || this;
    }
    MaterializeSubscriber.prototype._next = function (value) {
        this.destination.next(Notification_1.Notification.createNext(value));
    };
    MaterializeSubscriber.prototype._error = function (err) {
        var destination = this.destination;
        destination.next(Notification_1.Notification.createError(err));
        destination.complete();
    };
    MaterializeSubscriber.prototype._complete = function () {
        var destination = this.destination;
        destination.next(Notification_1.Notification.createComplete());
        destination.complete();
    };
    return MaterializeSubscriber;
}(Subscriber_1.Subscriber));

},{"../Notification":116,"../Subscriber":124}],199:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var reduce_1 = require("./reduce");
function max(comparer) {
    var max = (typeof comparer === 'function')
        ? function (x, y) { return comparer(x, y) > 0 ? x : y; }
        : function (x, y) { return x > y ? x : y; };
    return reduce_1.reduce(max);
}
exports.max = max;

},{"./reduce":217}],200:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var merge_1 = require("../observable/merge");
function merge() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i] = arguments[_i];
    }
    return function (source) { return source.lift.call(merge_1.merge.apply(void 0, [source].concat(observables))); };
}
exports.merge = merge;

},{"../observable/merge":144}],201:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var mergeMap_1 = require("./mergeMap");
var identity_1 = require("../util/identity");
function mergeAll(concurrent) {
    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
    return mergeMap_1.mergeMap(identity_1.identity, concurrent);
}
exports.mergeAll = mergeAll;

},{"../util/identity":290,"./mergeMap":202}],202:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var map_1 = require("./map");
var from_1 = require("../observable/from");
var innerSubscribe_1 = require("../innerSubscribe");
function mergeMap(project, resultSelector, concurrent) {
    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
    if (typeof resultSelector === 'function') {
        return function (source) { return source.pipe(mergeMap(function (a, i) { return from_1.from(project(a, i)).pipe(map_1.map(function (b, ii) { return resultSelector(a, b, i, ii); })); }, concurrent)); };
    }
    else if (typeof resultSelector === 'number') {
        concurrent = resultSelector;
    }
    return function (source) { return source.lift(new MergeMapOperator(project, concurrent)); };
}
exports.mergeMap = mergeMap;
var MergeMapOperator = (function () {
    function MergeMapOperator(project, concurrent) {
        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
        this.project = project;
        this.concurrent = concurrent;
    }
    MergeMapOperator.prototype.call = function (observer, source) {
        return source.subscribe(new MergeMapSubscriber(observer, this.project, this.concurrent));
    };
    return MergeMapOperator;
}());
exports.MergeMapOperator = MergeMapOperator;
var MergeMapSubscriber = (function (_super) {
    __extends(MergeMapSubscriber, _super);
    function MergeMapSubscriber(destination, project, concurrent) {
        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
        var _this = _super.call(this, destination) || this;
        _this.project = project;
        _this.concurrent = concurrent;
        _this.hasCompleted = false;
        _this.buffer = [];
        _this.active = 0;
        _this.index = 0;
        return _this;
    }
    MergeMapSubscriber.prototype._next = function (value) {
        if (this.active < this.concurrent) {
            this._tryNext(value);
        }
        else {
            this.buffer.push(value);
        }
    };
    MergeMapSubscriber.prototype._tryNext = function (value) {
        var result;
        var index = this.index++;
        try {
            result = this.project(value, index);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.active++;
        this._innerSub(result);
    };
    MergeMapSubscriber.prototype._innerSub = function (ish) {
        var innerSubscriber = new innerSubscribe_1.SimpleInnerSubscriber(this);
        var destination = this.destination;
        destination.add(innerSubscriber);
        var innerSubscription = innerSubscribe_1.innerSubscribe(ish, innerSubscriber);
        if (innerSubscription !== innerSubscriber) {
            destination.add(innerSubscription);
        }
    };
    MergeMapSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (this.active === 0 && this.buffer.length === 0) {
            this.destination.complete();
        }
        this.unsubscribe();
    };
    MergeMapSubscriber.prototype.notifyNext = function (innerValue) {
        this.destination.next(innerValue);
    };
    MergeMapSubscriber.prototype.notifyComplete = function () {
        var buffer = this.buffer;
        this.active--;
        if (buffer.length > 0) {
            this._next(buffer.shift());
        }
        else if (this.active === 0 && this.hasCompleted) {
            this.destination.complete();
        }
    };
    return MergeMapSubscriber;
}(innerSubscribe_1.SimpleOuterSubscriber));
exports.MergeMapSubscriber = MergeMapSubscriber;
exports.flatMap = mergeMap;

},{"../innerSubscribe":127,"../observable/from":137,"./map":196}],203:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var mergeMap_1 = require("./mergeMap");
function mergeMapTo(innerObservable, resultSelector, concurrent) {
    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
    if (typeof resultSelector === 'function') {
        return mergeMap_1.mergeMap(function () { return innerObservable; }, resultSelector, concurrent);
    }
    if (typeof resultSelector === 'number') {
        concurrent = resultSelector;
    }
    return mergeMap_1.mergeMap(function () { return innerObservable; }, concurrent);
}
exports.mergeMapTo = mergeMapTo;

},{"./mergeMap":202}],204:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var innerSubscribe_1 = require("../innerSubscribe");
function mergeScan(accumulator, seed, concurrent) {
    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
    return function (source) { return source.lift(new MergeScanOperator(accumulator, seed, concurrent)); };
}
exports.mergeScan = mergeScan;
var MergeScanOperator = (function () {
    function MergeScanOperator(accumulator, seed, concurrent) {
        this.accumulator = accumulator;
        this.seed = seed;
        this.concurrent = concurrent;
    }
    MergeScanOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new MergeScanSubscriber(subscriber, this.accumulator, this.seed, this.concurrent));
    };
    return MergeScanOperator;
}());
exports.MergeScanOperator = MergeScanOperator;
var MergeScanSubscriber = (function (_super) {
    __extends(MergeScanSubscriber, _super);
    function MergeScanSubscriber(destination, accumulator, acc, concurrent) {
        var _this = _super.call(this, destination) || this;
        _this.accumulator = accumulator;
        _this.acc = acc;
        _this.concurrent = concurrent;
        _this.hasValue = false;
        _this.hasCompleted = false;
        _this.buffer = [];
        _this.active = 0;
        _this.index = 0;
        return _this;
    }
    MergeScanSubscriber.prototype._next = function (value) {
        if (this.active < this.concurrent) {
            var index = this.index++;
            var destination = this.destination;
            var ish = void 0;
            try {
                var accumulator = this.accumulator;
                ish = accumulator(this.acc, value, index);
            }
            catch (e) {
                return destination.error(e);
            }
            this.active++;
            this._innerSub(ish);
        }
        else {
            this.buffer.push(value);
        }
    };
    MergeScanSubscriber.prototype._innerSub = function (ish) {
        var innerSubscriber = new innerSubscribe_1.SimpleInnerSubscriber(this);
        var destination = this.destination;
        destination.add(innerSubscriber);
        var innerSubscription = innerSubscribe_1.innerSubscribe(ish, innerSubscriber);
        if (innerSubscription !== innerSubscriber) {
            destination.add(innerSubscription);
        }
    };
    MergeScanSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (this.active === 0 && this.buffer.length === 0) {
            if (this.hasValue === false) {
                this.destination.next(this.acc);
            }
            this.destination.complete();
        }
        this.unsubscribe();
    };
    MergeScanSubscriber.prototype.notifyNext = function (innerValue) {
        var destination = this.destination;
        this.acc = innerValue;
        this.hasValue = true;
        destination.next(innerValue);
    };
    MergeScanSubscriber.prototype.notifyComplete = function () {
        var buffer = this.buffer;
        this.active--;
        if (buffer.length > 0) {
            this._next(buffer.shift());
        }
        else if (this.active === 0 && this.hasCompleted) {
            if (this.hasValue === false) {
                this.destination.next(this.acc);
            }
            this.destination.complete();
        }
    };
    return MergeScanSubscriber;
}(innerSubscribe_1.SimpleOuterSubscriber));
exports.MergeScanSubscriber = MergeScanSubscriber;

},{"../innerSubscribe":127}],205:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var reduce_1 = require("./reduce");
function min(comparer) {
    var min = (typeof comparer === 'function')
        ? function (x, y) { return comparer(x, y) < 0 ? x : y; }
        : function (x, y) { return x < y ? x : y; };
    return reduce_1.reduce(min);
}
exports.min = min;

},{"./reduce":217}],206:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ConnectableObservable_1 = require("../observable/ConnectableObservable");
function multicast(subjectOrSubjectFactory, selector) {
    return function multicastOperatorFunction(source) {
        var subjectFactory;
        if (typeof subjectOrSubjectFactory === 'function') {
            subjectFactory = subjectOrSubjectFactory;
        }
        else {
            subjectFactory = function subjectFactory() {
                return subjectOrSubjectFactory;
            };
        }
        if (typeof selector === 'function') {
            return source.lift(new MulticastOperator(subjectFactory, selector));
        }
        var connectable = Object.create(source, ConnectableObservable_1.connectableObservableDescriptor);
        connectable.source = source;
        connectable.subjectFactory = subjectFactory;
        return connectable;
    };
}
exports.multicast = multicast;
var MulticastOperator = (function () {
    function MulticastOperator(subjectFactory, selector) {
        this.subjectFactory = subjectFactory;
        this.selector = selector;
    }
    MulticastOperator.prototype.call = function (subscriber, source) {
        var selector = this.selector;
        var subject = this.subjectFactory();
        var subscription = selector(subject).subscribe(subscriber);
        subscription.add(source.subscribe(subject));
        return subscription;
    };
    return MulticastOperator;
}());
exports.MulticastOperator = MulticastOperator;

},{"../observable/ConnectableObservable":128}],207:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
var Notification_1 = require("../Notification");
function observeOn(scheduler, delay) {
    if (delay === void 0) { delay = 0; }
    return function observeOnOperatorFunction(source) {
        return source.lift(new ObserveOnOperator(scheduler, delay));
    };
}
exports.observeOn = observeOn;
var ObserveOnOperator = (function () {
    function ObserveOnOperator(scheduler, delay) {
        if (delay === void 0) { delay = 0; }
        this.scheduler = scheduler;
        this.delay = delay;
    }
    ObserveOnOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ObserveOnSubscriber(subscriber, this.scheduler, this.delay));
    };
    return ObserveOnOperator;
}());
exports.ObserveOnOperator = ObserveOnOperator;
var ObserveOnSubscriber = (function (_super) {
    __extends(ObserveOnSubscriber, _super);
    function ObserveOnSubscriber(destination, scheduler, delay) {
        if (delay === void 0) { delay = 0; }
        var _this = _super.call(this, destination) || this;
        _this.scheduler = scheduler;
        _this.delay = delay;
        return _this;
    }
    ObserveOnSubscriber.dispatch = function (arg) {
        var notification = arg.notification, destination = arg.destination;
        notification.observe(destination);
        this.unsubscribe();
    };
    ObserveOnSubscriber.prototype.scheduleMessage = function (notification) {
        var destination = this.destination;
        destination.add(this.scheduler.schedule(ObserveOnSubscriber.dispatch, this.delay, new ObserveOnMessage(notification, this.destination)));
    };
    ObserveOnSubscriber.prototype._next = function (value) {
        this.scheduleMessage(Notification_1.Notification.createNext(value));
    };
    ObserveOnSubscriber.prototype._error = function (err) {
        this.scheduleMessage(Notification_1.Notification.createError(err));
        this.unsubscribe();
    };
    ObserveOnSubscriber.prototype._complete = function () {
        this.scheduleMessage(Notification_1.Notification.createComplete());
        this.unsubscribe();
    };
    return ObserveOnSubscriber;
}(Subscriber_1.Subscriber));
exports.ObserveOnSubscriber = ObserveOnSubscriber;
var ObserveOnMessage = (function () {
    function ObserveOnMessage(notification, destination) {
        this.notification = notification;
        this.destination = destination;
    }
    return ObserveOnMessage;
}());
exports.ObserveOnMessage = ObserveOnMessage;

},{"../Notification":116,"../Subscriber":124}],208:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var from_1 = require("../observable/from");
var isArray_1 = require("../util/isArray");
var innerSubscribe_1 = require("../innerSubscribe");
function onErrorResumeNext() {
    var nextSources = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        nextSources[_i] = arguments[_i];
    }
    if (nextSources.length === 1 && isArray_1.isArray(nextSources[0])) {
        nextSources = nextSources[0];
    }
    return function (source) { return source.lift(new OnErrorResumeNextOperator(nextSources)); };
}
exports.onErrorResumeNext = onErrorResumeNext;
function onErrorResumeNextStatic() {
    var nextSources = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        nextSources[_i] = arguments[_i];
    }
    var source = undefined;
    if (nextSources.length === 1 && isArray_1.isArray(nextSources[0])) {
        nextSources = nextSources[0];
    }
    source = nextSources.shift();
    return from_1.from(source).lift(new OnErrorResumeNextOperator(nextSources));
}
exports.onErrorResumeNextStatic = onErrorResumeNextStatic;
var OnErrorResumeNextOperator = (function () {
    function OnErrorResumeNextOperator(nextSources) {
        this.nextSources = nextSources;
    }
    OnErrorResumeNextOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new OnErrorResumeNextSubscriber(subscriber, this.nextSources));
    };
    return OnErrorResumeNextOperator;
}());
var OnErrorResumeNextSubscriber = (function (_super) {
    __extends(OnErrorResumeNextSubscriber, _super);
    function OnErrorResumeNextSubscriber(destination, nextSources) {
        var _this = _super.call(this, destination) || this;
        _this.destination = destination;
        _this.nextSources = nextSources;
        return _this;
    }
    OnErrorResumeNextSubscriber.prototype.notifyError = function () {
        this.subscribeToNextSource();
    };
    OnErrorResumeNextSubscriber.prototype.notifyComplete = function () {
        this.subscribeToNextSource();
    };
    OnErrorResumeNextSubscriber.prototype._error = function (err) {
        this.subscribeToNextSource();
        this.unsubscribe();
    };
    OnErrorResumeNextSubscriber.prototype._complete = function () {
        this.subscribeToNextSource();
        this.unsubscribe();
    };
    OnErrorResumeNextSubscriber.prototype.subscribeToNextSource = function () {
        var next = this.nextSources.shift();
        if (!!next) {
            var innerSubscriber = new innerSubscribe_1.SimpleInnerSubscriber(this);
            var destination = this.destination;
            destination.add(innerSubscriber);
            var innerSubscription = innerSubscribe_1.innerSubscribe(next, innerSubscriber);
            if (innerSubscription !== innerSubscriber) {
                destination.add(innerSubscription);
            }
        }
        else {
            this.destination.complete();
        }
    };
    return OnErrorResumeNextSubscriber;
}(innerSubscribe_1.SimpleOuterSubscriber));

},{"../innerSubscribe":127,"../observable/from":137,"../util/isArray":291}],209:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
function pairwise() {
    return function (source) { return source.lift(new PairwiseOperator()); };
}
exports.pairwise = pairwise;
var PairwiseOperator = (function () {
    function PairwiseOperator() {
    }
    PairwiseOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new PairwiseSubscriber(subscriber));
    };
    return PairwiseOperator;
}());
var PairwiseSubscriber = (function (_super) {
    __extends(PairwiseSubscriber, _super);
    function PairwiseSubscriber(destination) {
        var _this = _super.call(this, destination) || this;
        _this.hasPrev = false;
        return _this;
    }
    PairwiseSubscriber.prototype._next = function (value) {
        var pair;
        if (this.hasPrev) {
            pair = [this.prev, value];
        }
        else {
            this.hasPrev = true;
        }
        this.prev = value;
        if (pair) {
            this.destination.next(pair);
        }
    };
    return PairwiseSubscriber;
}(Subscriber_1.Subscriber));

},{"../Subscriber":124}],210:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var not_1 = require("../util/not");
var filter_1 = require("./filter");
function partition(predicate, thisArg) {
    return function (source) { return [
        filter_1.filter(predicate, thisArg)(source),
        filter_1.filter(not_1.not(predicate, thisArg))(source)
    ]; };
}
exports.partition = partition;

},{"../util/not":303,"./filter":186}],211:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var map_1 = require("./map");
function pluck() {
    var properties = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        properties[_i] = arguments[_i];
    }
    var length = properties.length;
    if (length === 0) {
        throw new Error('list of properties cannot be empty.');
    }
    return function (source) { return map_1.map(plucker(properties, length))(source); };
}
exports.pluck = pluck;
function plucker(props, length) {
    var mapper = function (x) {
        var currentProp = x;
        for (var i = 0; i < length; i++) {
            var p = currentProp != null ? currentProp[props[i]] : undefined;
            if (p !== void 0) {
                currentProp = p;
            }
            else {
                return undefined;
            }
        }
        return currentProp;
    };
    return mapper;
}

},{"./map":196}],212:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Subject_1 = require("../Subject");
var multicast_1 = require("./multicast");
function publish(selector) {
    return selector ?
        multicast_1.multicast(function () { return new Subject_1.Subject(); }, selector) :
        multicast_1.multicast(new Subject_1.Subject());
}
exports.publish = publish;

},{"../Subject":122,"./multicast":206}],213:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var BehaviorSubject_1 = require("../BehaviorSubject");
var multicast_1 = require("./multicast");
function publishBehavior(value) {
    return function (source) { return multicast_1.multicast(new BehaviorSubject_1.BehaviorSubject(value))(source); };
}
exports.publishBehavior = publishBehavior;

},{"../BehaviorSubject":114,"./multicast":206}],214:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var AsyncSubject_1 = require("../AsyncSubject");
var multicast_1 = require("./multicast");
function publishLast() {
    return function (source) { return multicast_1.multicast(new AsyncSubject_1.AsyncSubject())(source); };
}
exports.publishLast = publishLast;

},{"../AsyncSubject":113,"./multicast":206}],215:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ReplaySubject_1 = require("../ReplaySubject");
var multicast_1 = require("./multicast");
function publishReplay(bufferSize, windowTime, selectorOrScheduler, scheduler) {
    if (selectorOrScheduler && typeof selectorOrScheduler !== 'function') {
        scheduler = selectorOrScheduler;
    }
    var selector = typeof selectorOrScheduler === 'function' ? selectorOrScheduler : undefined;
    var subject = new ReplaySubject_1.ReplaySubject(bufferSize, windowTime, scheduler);
    return function (source) { return multicast_1.multicast(function () { return subject; }, selector)(source); };
}
exports.publishReplay = publishReplay;

},{"../ReplaySubject":120,"./multicast":206}],216:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var isArray_1 = require("../util/isArray");
var race_1 = require("../observable/race");
function race() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i] = arguments[_i];
    }
    return function raceOperatorFunction(source) {
        if (observables.length === 1 && isArray_1.isArray(observables[0])) {
            observables = observables[0];
        }
        return source.lift.call(race_1.race.apply(void 0, [source].concat(observables)));
    };
}
exports.race = race;

},{"../observable/race":150,"../util/isArray":291}],217:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var scan_1 = require("./scan");
var takeLast_1 = require("./takeLast");
var defaultIfEmpty_1 = require("./defaultIfEmpty");
var pipe_1 = require("../util/pipe");
function reduce(accumulator, seed) {
    if (arguments.length >= 2) {
        return function reduceOperatorFunctionWithSeed(source) {
            return pipe_1.pipe(scan_1.scan(accumulator, seed), takeLast_1.takeLast(1), defaultIfEmpty_1.defaultIfEmpty(seed))(source);
        };
    }
    return function reduceOperatorFunction(source) {
        return pipe_1.pipe(scan_1.scan(function (acc, value, index) { return accumulator(acc, value, index + 1); }), takeLast_1.takeLast(1))(source);
    };
}
exports.reduce = reduce;

},{"../util/pipe":304,"./defaultIfEmpty":173,"./scan":225,"./takeLast":240}],218:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
function refCount() {
    return function refCountOperatorFunction(source) {
        return source.lift(new RefCountOperator(source));
    };
}
exports.refCount = refCount;
var RefCountOperator = (function () {
    function RefCountOperator(connectable) {
        this.connectable = connectable;
    }
    RefCountOperator.prototype.call = function (subscriber, source) {
        var connectable = this.connectable;
        connectable._refCount++;
        var refCounter = new RefCountSubscriber(subscriber, connectable);
        var subscription = source.subscribe(refCounter);
        if (!refCounter.closed) {
            refCounter.connection = connectable.connect();
        }
        return subscription;
    };
    return RefCountOperator;
}());
var RefCountSubscriber = (function (_super) {
    __extends(RefCountSubscriber, _super);
    function RefCountSubscriber(destination, connectable) {
        var _this = _super.call(this, destination) || this;
        _this.connectable = connectable;
        return _this;
    }
    RefCountSubscriber.prototype._unsubscribe = function () {
        var connectable = this.connectable;
        if (!connectable) {
            this.connection = null;
            return;
        }
        this.connectable = null;
        var refCount = connectable._refCount;
        if (refCount <= 0) {
            this.connection = null;
            return;
        }
        connectable._refCount = refCount - 1;
        if (refCount > 1) {
            this.connection = null;
            return;
        }
        var connection = this.connection;
        var sharedConnection = connectable._connection;
        this.connection = null;
        if (sharedConnection && (!connection || sharedConnection === connection)) {
            sharedConnection.unsubscribe();
        }
    };
    return RefCountSubscriber;
}(Subscriber_1.Subscriber));

},{"../Subscriber":124}],219:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
var empty_1 = require("../observable/empty");
function repeat(count) {
    if (count === void 0) { count = -1; }
    return function (source) {
        if (count === 0) {
            return empty_1.empty();
        }
        else if (count < 0) {
            return source.lift(new RepeatOperator(-1, source));
        }
        else {
            return source.lift(new RepeatOperator(count - 1, source));
        }
    };
}
exports.repeat = repeat;
var RepeatOperator = (function () {
    function RepeatOperator(count, source) {
        this.count = count;
        this.source = source;
    }
    RepeatOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new RepeatSubscriber(subscriber, this.count, this.source));
    };
    return RepeatOperator;
}());
var RepeatSubscriber = (function (_super) {
    __extends(RepeatSubscriber, _super);
    function RepeatSubscriber(destination, count, source) {
        var _this = _super.call(this, destination) || this;
        _this.count = count;
        _this.source = source;
        return _this;
    }
    RepeatSubscriber.prototype.complete = function () {
        if (!this.isStopped) {
            var _a = this, source = _a.source, count = _a.count;
            if (count === 0) {
                return _super.prototype.complete.call(this);
            }
            else if (count > -1) {
                this.count = count - 1;
            }
            source.subscribe(this._unsubscribeAndRecycle());
        }
    };
    return RepeatSubscriber;
}(Subscriber_1.Subscriber));

},{"../Subscriber":124,"../observable/empty":135}],220:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subject_1 = require("../Subject");
var innerSubscribe_1 = require("../innerSubscribe");
function repeatWhen(notifier) {
    return function (source) { return source.lift(new RepeatWhenOperator(notifier)); };
}
exports.repeatWhen = repeatWhen;
var RepeatWhenOperator = (function () {
    function RepeatWhenOperator(notifier) {
        this.notifier = notifier;
    }
    RepeatWhenOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new RepeatWhenSubscriber(subscriber, this.notifier, source));
    };
    return RepeatWhenOperator;
}());
var RepeatWhenSubscriber = (function (_super) {
    __extends(RepeatWhenSubscriber, _super);
    function RepeatWhenSubscriber(destination, notifier, source) {
        var _this = _super.call(this, destination) || this;
        _this.notifier = notifier;
        _this.source = source;
        _this.sourceIsBeingSubscribedTo = true;
        return _this;
    }
    RepeatWhenSubscriber.prototype.notifyNext = function () {
        this.sourceIsBeingSubscribedTo = true;
        this.source.subscribe(this);
    };
    RepeatWhenSubscriber.prototype.notifyComplete = function () {
        if (this.sourceIsBeingSubscribedTo === false) {
            return _super.prototype.complete.call(this);
        }
    };
    RepeatWhenSubscriber.prototype.complete = function () {
        this.sourceIsBeingSubscribedTo = false;
        if (!this.isStopped) {
            if (!this.retries) {
                this.subscribeToRetries();
            }
            if (!this.retriesSubscription || this.retriesSubscription.closed) {
                return _super.prototype.complete.call(this);
            }
            this._unsubscribeAndRecycle();
            this.notifications.next(undefined);
        }
    };
    RepeatWhenSubscriber.prototype._unsubscribe = function () {
        var _a = this, notifications = _a.notifications, retriesSubscription = _a.retriesSubscription;
        if (notifications) {
            notifications.unsubscribe();
            this.notifications = undefined;
        }
        if (retriesSubscription) {
            retriesSubscription.unsubscribe();
            this.retriesSubscription = undefined;
        }
        this.retries = undefined;
    };
    RepeatWhenSubscriber.prototype._unsubscribeAndRecycle = function () {
        var _unsubscribe = this._unsubscribe;
        this._unsubscribe = null;
        _super.prototype._unsubscribeAndRecycle.call(this);
        this._unsubscribe = _unsubscribe;
        return this;
    };
    RepeatWhenSubscriber.prototype.subscribeToRetries = function () {
        this.notifications = new Subject_1.Subject();
        var retries;
        try {
            var notifier = this.notifier;
            retries = notifier(this.notifications);
        }
        catch (e) {
            return _super.prototype.complete.call(this);
        }
        this.retries = retries;
        this.retriesSubscription = innerSubscribe_1.innerSubscribe(retries, new innerSubscribe_1.SimpleInnerSubscriber(this));
    };
    return RepeatWhenSubscriber;
}(innerSubscribe_1.SimpleOuterSubscriber));

},{"../Subject":122,"../innerSubscribe":127}],221:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
function retry(count) {
    if (count === void 0) { count = -1; }
    return function (source) { return source.lift(new RetryOperator(count, source)); };
}
exports.retry = retry;
var RetryOperator = (function () {
    function RetryOperator(count, source) {
        this.count = count;
        this.source = source;
    }
    RetryOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new RetrySubscriber(subscriber, this.count, this.source));
    };
    return RetryOperator;
}());
var RetrySubscriber = (function (_super) {
    __extends(RetrySubscriber, _super);
    function RetrySubscriber(destination, count, source) {
        var _this = _super.call(this, destination) || this;
        _this.count = count;
        _this.source = source;
        return _this;
    }
    RetrySubscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            var _a = this, source = _a.source, count = _a.count;
            if (count === 0) {
                return _super.prototype.error.call(this, err);
            }
            else if (count > -1) {
                this.count = count - 1;
            }
            source.subscribe(this._unsubscribeAndRecycle());
        }
    };
    return RetrySubscriber;
}(Subscriber_1.Subscriber));

},{"../Subscriber":124}],222:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subject_1 = require("../Subject");
var innerSubscribe_1 = require("../innerSubscribe");
function retryWhen(notifier) {
    return function (source) { return source.lift(new RetryWhenOperator(notifier, source)); };
}
exports.retryWhen = retryWhen;
var RetryWhenOperator = (function () {
    function RetryWhenOperator(notifier, source) {
        this.notifier = notifier;
        this.source = source;
    }
    RetryWhenOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new RetryWhenSubscriber(subscriber, this.notifier, this.source));
    };
    return RetryWhenOperator;
}());
var RetryWhenSubscriber = (function (_super) {
    __extends(RetryWhenSubscriber, _super);
    function RetryWhenSubscriber(destination, notifier, source) {
        var _this = _super.call(this, destination) || this;
        _this.notifier = notifier;
        _this.source = source;
        return _this;
    }
    RetryWhenSubscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            var errors = this.errors;
            var retries = this.retries;
            var retriesSubscription = this.retriesSubscription;
            if (!retries) {
                errors = new Subject_1.Subject();
                try {
                    var notifier = this.notifier;
                    retries = notifier(errors);
                }
                catch (e) {
                    return _super.prototype.error.call(this, e);
                }
                retriesSubscription = innerSubscribe_1.innerSubscribe(retries, new innerSubscribe_1.SimpleInnerSubscriber(this));
            }
            else {
                this.errors = undefined;
                this.retriesSubscription = undefined;
            }
            this._unsubscribeAndRecycle();
            this.errors = errors;
            this.retries = retries;
            this.retriesSubscription = retriesSubscription;
            errors.next(err);
        }
    };
    RetryWhenSubscriber.prototype._unsubscribe = function () {
        var _a = this, errors = _a.errors, retriesSubscription = _a.retriesSubscription;
        if (errors) {
            errors.unsubscribe();
            this.errors = undefined;
        }
        if (retriesSubscription) {
            retriesSubscription.unsubscribe();
            this.retriesSubscription = undefined;
        }
        this.retries = undefined;
    };
    RetryWhenSubscriber.prototype.notifyNext = function () {
        var _unsubscribe = this._unsubscribe;
        this._unsubscribe = null;
        this._unsubscribeAndRecycle();
        this._unsubscribe = _unsubscribe;
        this.source.subscribe(this);
    };
    return RetryWhenSubscriber;
}(innerSubscribe_1.SimpleOuterSubscriber));

},{"../Subject":122,"../innerSubscribe":127}],223:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var innerSubscribe_1 = require("../innerSubscribe");
function sample(notifier) {
    return function (source) { return source.lift(new SampleOperator(notifier)); };
}
exports.sample = sample;
var SampleOperator = (function () {
    function SampleOperator(notifier) {
        this.notifier = notifier;
    }
    SampleOperator.prototype.call = function (subscriber, source) {
        var sampleSubscriber = new SampleSubscriber(subscriber);
        var subscription = source.subscribe(sampleSubscriber);
        subscription.add(innerSubscribe_1.innerSubscribe(this.notifier, new innerSubscribe_1.SimpleInnerSubscriber(sampleSubscriber)));
        return subscription;
    };
    return SampleOperator;
}());
var SampleSubscriber = (function (_super) {
    __extends(SampleSubscriber, _super);
    function SampleSubscriber() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.hasValue = false;
        return _this;
    }
    SampleSubscriber.prototype._next = function (value) {
        this.value = value;
        this.hasValue = true;
    };
    SampleSubscriber.prototype.notifyNext = function () {
        this.emitValue();
    };
    SampleSubscriber.prototype.notifyComplete = function () {
        this.emitValue();
    };
    SampleSubscriber.prototype.emitValue = function () {
        if (this.hasValue) {
            this.hasValue = false;
            this.destination.next(this.value);
        }
    };
    return SampleSubscriber;
}(innerSubscribe_1.SimpleOuterSubscriber));

},{"../innerSubscribe":127}],224:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
var async_1 = require("../scheduler/async");
function sampleTime(period, scheduler) {
    if (scheduler === void 0) { scheduler = async_1.async; }
    return function (source) { return source.lift(new SampleTimeOperator(period, scheduler)); };
}
exports.sampleTime = sampleTime;
var SampleTimeOperator = (function () {
    function SampleTimeOperator(period, scheduler) {
        this.period = period;
        this.scheduler = scheduler;
    }
    SampleTimeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SampleTimeSubscriber(subscriber, this.period, this.scheduler));
    };
    return SampleTimeOperator;
}());
var SampleTimeSubscriber = (function (_super) {
    __extends(SampleTimeSubscriber, _super);
    function SampleTimeSubscriber(destination, period, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.period = period;
        _this.scheduler = scheduler;
        _this.hasValue = false;
        _this.add(scheduler.schedule(dispatchNotification, period, { subscriber: _this, period: period }));
        return _this;
    }
    SampleTimeSubscriber.prototype._next = function (value) {
        this.lastValue = value;
        this.hasValue = true;
    };
    SampleTimeSubscriber.prototype.notifyNext = function () {
        if (this.hasValue) {
            this.hasValue = false;
            this.destination.next(this.lastValue);
        }
    };
    return SampleTimeSubscriber;
}(Subscriber_1.Subscriber));
function dispatchNotification(state) {
    var subscriber = state.subscriber, period = state.period;
    subscriber.notifyNext();
    this.schedule(state, period);
}

},{"../Subscriber":124,"../scheduler/async":277}],225:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
function scan(accumulator, seed) {
    var hasSeed = false;
    if (arguments.length >= 2) {
        hasSeed = true;
    }
    return function scanOperatorFunction(source) {
        return source.lift(new ScanOperator(accumulator, seed, hasSeed));
    };
}
exports.scan = scan;
var ScanOperator = (function () {
    function ScanOperator(accumulator, seed, hasSeed) {
        if (hasSeed === void 0) { hasSeed = false; }
        this.accumulator = accumulator;
        this.seed = seed;
        this.hasSeed = hasSeed;
    }
    ScanOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ScanSubscriber(subscriber, this.accumulator, this.seed, this.hasSeed));
    };
    return ScanOperator;
}());
var ScanSubscriber = (function (_super) {
    __extends(ScanSubscriber, _super);
    function ScanSubscriber(destination, accumulator, _seed, hasSeed) {
        var _this = _super.call(this, destination) || this;
        _this.accumulator = accumulator;
        _this._seed = _seed;
        _this.hasSeed = hasSeed;
        _this.index = 0;
        return _this;
    }
    Object.defineProperty(ScanSubscriber.prototype, "seed", {
        get: function () {
            return this._seed;
        },
        set: function (value) {
            this.hasSeed = true;
            this._seed = value;
        },
        enumerable: true,
        configurable: true
    });
    ScanSubscriber.prototype._next = function (value) {
        if (!this.hasSeed) {
            this.seed = value;
            this.destination.next(value);
        }
        else {
            return this._tryNext(value);
        }
    };
    ScanSubscriber.prototype._tryNext = function (value) {
        var index = this.index++;
        var result;
        try {
            result = this.accumulator(this.seed, value, index);
        }
        catch (err) {
            this.destination.error(err);
        }
        this.seed = result;
        this.destination.next(result);
    };
    return ScanSubscriber;
}(Subscriber_1.Subscriber));

},{"../Subscriber":124}],226:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
function sequenceEqual(compareTo, comparator) {
    return function (source) { return source.lift(new SequenceEqualOperator(compareTo, comparator)); };
}
exports.sequenceEqual = sequenceEqual;
var SequenceEqualOperator = (function () {
    function SequenceEqualOperator(compareTo, comparator) {
        this.compareTo = compareTo;
        this.comparator = comparator;
    }
    SequenceEqualOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SequenceEqualSubscriber(subscriber, this.compareTo, this.comparator));
    };
    return SequenceEqualOperator;
}());
exports.SequenceEqualOperator = SequenceEqualOperator;
var SequenceEqualSubscriber = (function (_super) {
    __extends(SequenceEqualSubscriber, _super);
    function SequenceEqualSubscriber(destination, compareTo, comparator) {
        var _this = _super.call(this, destination) || this;
        _this.compareTo = compareTo;
        _this.comparator = comparator;
        _this._a = [];
        _this._b = [];
        _this._oneComplete = false;
        _this.destination.add(compareTo.subscribe(new SequenceEqualCompareToSubscriber(destination, _this)));
        return _this;
    }
    SequenceEqualSubscriber.prototype._next = function (value) {
        if (this._oneComplete && this._b.length === 0) {
            this.emit(false);
        }
        else {
            this._a.push(value);
            this.checkValues();
        }
    };
    SequenceEqualSubscriber.prototype._complete = function () {
        if (this._oneComplete) {
            this.emit(this._a.length === 0 && this._b.length === 0);
        }
        else {
            this._oneComplete = true;
        }
        this.unsubscribe();
    };
    SequenceEqualSubscriber.prototype.checkValues = function () {
        var _c = this, _a = _c._a, _b = _c._b, comparator = _c.comparator;
        while (_a.length > 0 && _b.length > 0) {
            var a = _a.shift();
            var b = _b.shift();
            var areEqual = false;
            try {
                areEqual = comparator ? comparator(a, b) : a === b;
            }
            catch (e) {
                this.destination.error(e);
            }
            if (!areEqual) {
                this.emit(false);
            }
        }
    };
    SequenceEqualSubscriber.prototype.emit = function (value) {
        var destination = this.destination;
        destination.next(value);
        destination.complete();
    };
    SequenceEqualSubscriber.prototype.nextB = function (value) {
        if (this._oneComplete && this._a.length === 0) {
            this.emit(false);
        }
        else {
            this._b.push(value);
            this.checkValues();
        }
    };
    SequenceEqualSubscriber.prototype.completeB = function () {
        if (this._oneComplete) {
            this.emit(this._a.length === 0 && this._b.length === 0);
        }
        else {
            this._oneComplete = true;
        }
    };
    return SequenceEqualSubscriber;
}(Subscriber_1.Subscriber));
exports.SequenceEqualSubscriber = SequenceEqualSubscriber;
var SequenceEqualCompareToSubscriber = (function (_super) {
    __extends(SequenceEqualCompareToSubscriber, _super);
    function SequenceEqualCompareToSubscriber(destination, parent) {
        var _this = _super.call(this, destination) || this;
        _this.parent = parent;
        return _this;
    }
    SequenceEqualCompareToSubscriber.prototype._next = function (value) {
        this.parent.nextB(value);
    };
    SequenceEqualCompareToSubscriber.prototype._error = function (err) {
        this.parent.error(err);
        this.unsubscribe();
    };
    SequenceEqualCompareToSubscriber.prototype._complete = function () {
        this.parent.completeB();
        this.unsubscribe();
    };
    return SequenceEqualCompareToSubscriber;
}(Subscriber_1.Subscriber));

},{"../Subscriber":124}],227:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var multicast_1 = require("./multicast");
var refCount_1 = require("./refCount");
var Subject_1 = require("../Subject");
function shareSubjectFactory() {
    return new Subject_1.Subject();
}
function share() {
    return function (source) { return refCount_1.refCount()(multicast_1.multicast(shareSubjectFactory)(source)); };
}
exports.share = share;

},{"../Subject":122,"./multicast":206,"./refCount":218}],228:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ReplaySubject_1 = require("../ReplaySubject");
function shareReplay(configOrBufferSize, windowTime, scheduler) {
    var config;
    if (configOrBufferSize && typeof configOrBufferSize === 'object') {
        config = configOrBufferSize;
    }
    else {
        config = {
            bufferSize: configOrBufferSize,
            windowTime: windowTime,
            refCount: false,
            scheduler: scheduler
        };
    }
    return function (source) { return source.lift(shareReplayOperator(config)); };
}
exports.shareReplay = shareReplay;
function shareReplayOperator(_a) {
    var _b = _a.bufferSize, bufferSize = _b === void 0 ? Number.POSITIVE_INFINITY : _b, _c = _a.windowTime, windowTime = _c === void 0 ? Number.POSITIVE_INFINITY : _c, useRefCount = _a.refCount, scheduler = _a.scheduler;
    var subject;
    var refCount = 0;
    var subscription;
    var hasError = false;
    var isComplete = false;
    return function shareReplayOperation(source) {
        refCount++;
        var innerSub;
        if (!subject || hasError) {
            hasError = false;
            subject = new ReplaySubject_1.ReplaySubject(bufferSize, windowTime, scheduler);
            innerSub = subject.subscribe(this);
            subscription = source.subscribe({
                next: function (value) { subject.next(value); },
                error: function (err) {
                    hasError = true;
                    subject.error(err);
                },
                complete: function () {
                    isComplete = true;
                    subscription = undefined;
                    subject.complete();
                },
            });
        }
        else {
            innerSub = subject.subscribe(this);
        }
        this.add(function () {
            refCount--;
            innerSub.unsubscribe();
            if (subscription && !isComplete && useRefCount && refCount === 0) {
                subscription.unsubscribe();
                subscription = undefined;
                subject = undefined;
            }
        });
    };
}

},{"../ReplaySubject":120}],229:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
var EmptyError_1 = require("../util/EmptyError");
function single(predicate) {
    return function (source) { return source.lift(new SingleOperator(predicate, source)); };
}
exports.single = single;
var SingleOperator = (function () {
    function SingleOperator(predicate, source) {
        this.predicate = predicate;
        this.source = source;
    }
    SingleOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SingleSubscriber(subscriber, this.predicate, this.source));
    };
    return SingleOperator;
}());
var SingleSubscriber = (function (_super) {
    __extends(SingleSubscriber, _super);
    function SingleSubscriber(destination, predicate, source) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.source = source;
        _this.seenValue = false;
        _this.index = 0;
        return _this;
    }
    SingleSubscriber.prototype.applySingleValue = function (value) {
        if (this.seenValue) {
            this.destination.error('Sequence contains more than one element');
        }
        else {
            this.seenValue = true;
            this.singleValue = value;
        }
    };
    SingleSubscriber.prototype._next = function (value) {
        var index = this.index++;
        if (this.predicate) {
            this.tryNext(value, index);
        }
        else {
            this.applySingleValue(value);
        }
    };
    SingleSubscriber.prototype.tryNext = function (value, index) {
        try {
            if (this.predicate(value, index, this.source)) {
                this.applySingleValue(value);
            }
        }
        catch (err) {
            this.destination.error(err);
        }
    };
    SingleSubscriber.prototype._complete = function () {
        var destination = this.destination;
        if (this.index > 0) {
            destination.next(this.seenValue ? this.singleValue : undefined);
            destination.complete();
        }
        else {
            destination.error(new EmptyError_1.EmptyError);
        }
    };
    return SingleSubscriber;
}(Subscriber_1.Subscriber));

},{"../Subscriber":124,"../util/EmptyError":283}],230:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
function skip(count) {
    return function (source) { return source.lift(new SkipOperator(count)); };
}
exports.skip = skip;
var SkipOperator = (function () {
    function SkipOperator(total) {
        this.total = total;
    }
    SkipOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SkipSubscriber(subscriber, this.total));
    };
    return SkipOperator;
}());
var SkipSubscriber = (function (_super) {
    __extends(SkipSubscriber, _super);
    function SkipSubscriber(destination, total) {
        var _this = _super.call(this, destination) || this;
        _this.total = total;
        _this.count = 0;
        return _this;
    }
    SkipSubscriber.prototype._next = function (x) {
        if (++this.count > this.total) {
            this.destination.next(x);
        }
    };
    return SkipSubscriber;
}(Subscriber_1.Subscriber));

},{"../Subscriber":124}],231:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
var ArgumentOutOfRangeError_1 = require("../util/ArgumentOutOfRangeError");
function skipLast(count) {
    return function (source) { return source.lift(new SkipLastOperator(count)); };
}
exports.skipLast = skipLast;
var SkipLastOperator = (function () {
    function SkipLastOperator(_skipCount) {
        this._skipCount = _skipCount;
        if (this._skipCount < 0) {
            throw new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;
        }
    }
    SkipLastOperator.prototype.call = function (subscriber, source) {
        if (this._skipCount === 0) {
            return source.subscribe(new Subscriber_1.Subscriber(subscriber));
        }
        else {
            return source.subscribe(new SkipLastSubscriber(subscriber, this._skipCount));
        }
    };
    return SkipLastOperator;
}());
var SkipLastSubscriber = (function (_super) {
    __extends(SkipLastSubscriber, _super);
    function SkipLastSubscriber(destination, _skipCount) {
        var _this = _super.call(this, destination) || this;
        _this._skipCount = _skipCount;
        _this._count = 0;
        _this._ring = new Array(_skipCount);
        return _this;
    }
    SkipLastSubscriber.prototype._next = function (value) {
        var skipCount = this._skipCount;
        var count = this._count++;
        if (count < skipCount) {
            this._ring[count] = value;
        }
        else {
            var currentIndex = count % skipCount;
            var ring = this._ring;
            var oldValue = ring[currentIndex];
            ring[currentIndex] = value;
            this.destination.next(oldValue);
        }
    };
    return SkipLastSubscriber;
}(Subscriber_1.Subscriber));

},{"../Subscriber":124,"../util/ArgumentOutOfRangeError":282}],232:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var innerSubscribe_1 = require("../innerSubscribe");
function skipUntil(notifier) {
    return function (source) { return source.lift(new SkipUntilOperator(notifier)); };
}
exports.skipUntil = skipUntil;
var SkipUntilOperator = (function () {
    function SkipUntilOperator(notifier) {
        this.notifier = notifier;
    }
    SkipUntilOperator.prototype.call = function (destination, source) {
        return source.subscribe(new SkipUntilSubscriber(destination, this.notifier));
    };
    return SkipUntilOperator;
}());
var SkipUntilSubscriber = (function (_super) {
    __extends(SkipUntilSubscriber, _super);
    function SkipUntilSubscriber(destination, notifier) {
        var _this = _super.call(this, destination) || this;
        _this.hasValue = false;
        var innerSubscriber = new innerSubscribe_1.SimpleInnerSubscriber(_this);
        _this.add(innerSubscriber);
        _this.innerSubscription = innerSubscriber;
        var innerSubscription = innerSubscribe_1.innerSubscribe(notifier, innerSubscriber);
        if (innerSubscription !== innerSubscriber) {
            _this.add(innerSubscription);
            _this.innerSubscription = innerSubscription;
        }
        return _this;
    }
    SkipUntilSubscriber.prototype._next = function (value) {
        if (this.hasValue) {
            _super.prototype._next.call(this, value);
        }
    };
    SkipUntilSubscriber.prototype.notifyNext = function () {
        this.hasValue = true;
        if (this.innerSubscription) {
            this.innerSubscription.unsubscribe();
        }
    };
    SkipUntilSubscriber.prototype.notifyComplete = function () {
    };
    return SkipUntilSubscriber;
}(innerSubscribe_1.SimpleOuterSubscriber));

},{"../innerSubscribe":127}],233:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
function skipWhile(predicate) {
    return function (source) { return source.lift(new SkipWhileOperator(predicate)); };
}
exports.skipWhile = skipWhile;
var SkipWhileOperator = (function () {
    function SkipWhileOperator(predicate) {
        this.predicate = predicate;
    }
    SkipWhileOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SkipWhileSubscriber(subscriber, this.predicate));
    };
    return SkipWhileOperator;
}());
var SkipWhileSubscriber = (function (_super) {
    __extends(SkipWhileSubscriber, _super);
    function SkipWhileSubscriber(destination, predicate) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.skipping = true;
        _this.index = 0;
        return _this;
    }
    SkipWhileSubscriber.prototype._next = function (value) {
        var destination = this.destination;
        if (this.skipping) {
            this.tryCallPredicate(value);
        }
        if (!this.skipping) {
            destination.next(value);
        }
    };
    SkipWhileSubscriber.prototype.tryCallPredicate = function (value) {
        try {
            var result = this.predicate(value, this.index++);
            this.skipping = Boolean(result);
        }
        catch (err) {
            this.destination.error(err);
        }
    };
    return SkipWhileSubscriber;
}(Subscriber_1.Subscriber));

},{"../Subscriber":124}],234:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var concat_1 = require("../observable/concat");
var isScheduler_1 = require("../util/isScheduler");
function startWith() {
    var array = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        array[_i] = arguments[_i];
    }
    var scheduler = array[array.length - 1];
    if (isScheduler_1.isScheduler(scheduler)) {
        array.pop();
        return function (source) { return concat_1.concat(array, source, scheduler); };
    }
    else {
        return function (source) { return concat_1.concat(array, source); };
    }
}
exports.startWith = startWith;

},{"../observable/concat":133,"../util/isScheduler":301}],235:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var SubscribeOnObservable_1 = require("../observable/SubscribeOnObservable");
function subscribeOn(scheduler, delay) {
    if (delay === void 0) { delay = 0; }
    return function subscribeOnOperatorFunction(source) {
        return source.lift(new SubscribeOnOperator(scheduler, delay));
    };
}
exports.subscribeOn = subscribeOn;
var SubscribeOnOperator = (function () {
    function SubscribeOnOperator(scheduler, delay) {
        this.scheduler = scheduler;
        this.delay = delay;
    }
    SubscribeOnOperator.prototype.call = function (subscriber, source) {
        return new SubscribeOnObservable_1.SubscribeOnObservable(source, this.delay, this.scheduler).subscribe(subscriber);
    };
    return SubscribeOnOperator;
}());

},{"../observable/SubscribeOnObservable":129}],236:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var switchMap_1 = require("./switchMap");
var identity_1 = require("../util/identity");
function switchAll() {
    return switchMap_1.switchMap(identity_1.identity);
}
exports.switchAll = switchAll;

},{"../util/identity":290,"./switchMap":237}],237:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var map_1 = require("./map");
var from_1 = require("../observable/from");
var innerSubscribe_1 = require("../innerSubscribe");
function switchMap(project, resultSelector) {
    if (typeof resultSelector === 'function') {
        return function (source) { return source.pipe(switchMap(function (a, i) { return from_1.from(project(a, i)).pipe(map_1.map(function (b, ii) { return resultSelector(a, b, i, ii); })); })); };
    }
    return function (source) { return source.lift(new SwitchMapOperator(project)); };
}
exports.switchMap = switchMap;
var SwitchMapOperator = (function () {
    function SwitchMapOperator(project) {
        this.project = project;
    }
    SwitchMapOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SwitchMapSubscriber(subscriber, this.project));
    };
    return SwitchMapOperator;
}());
var SwitchMapSubscriber = (function (_super) {
    __extends(SwitchMapSubscriber, _super);
    function SwitchMapSubscriber(destination, project) {
        var _this = _super.call(this, destination) || this;
        _this.project = project;
        _this.index = 0;
        return _this;
    }
    SwitchMapSubscriber.prototype._next = function (value) {
        var result;
        var index = this.index++;
        try {
            result = this.project(value, index);
        }
        catch (error) {
            this.destination.error(error);
            return;
        }
        this._innerSub(result);
    };
    SwitchMapSubscriber.prototype._innerSub = function (result) {
        var innerSubscription = this.innerSubscription;
        if (innerSubscription) {
            innerSubscription.unsubscribe();
        }
        var innerSubscriber = new innerSubscribe_1.SimpleInnerSubscriber(this);
        var destination = this.destination;
        destination.add(innerSubscriber);
        this.innerSubscription = innerSubscribe_1.innerSubscribe(result, innerSubscriber);
        if (this.innerSubscription !== innerSubscriber) {
            destination.add(this.innerSubscription);
        }
    };
    SwitchMapSubscriber.prototype._complete = function () {
        var innerSubscription = this.innerSubscription;
        if (!innerSubscription || innerSubscription.closed) {
            _super.prototype._complete.call(this);
        }
        this.unsubscribe();
    };
    SwitchMapSubscriber.prototype._unsubscribe = function () {
        this.innerSubscription = undefined;
    };
    SwitchMapSubscriber.prototype.notifyComplete = function () {
        this.innerSubscription = undefined;
        if (this.isStopped) {
            _super.prototype._complete.call(this);
        }
    };
    SwitchMapSubscriber.prototype.notifyNext = function (innerValue) {
        this.destination.next(innerValue);
    };
    return SwitchMapSubscriber;
}(innerSubscribe_1.SimpleOuterSubscriber));

},{"../innerSubscribe":127,"../observable/from":137,"./map":196}],238:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var switchMap_1 = require("./switchMap");
function switchMapTo(innerObservable, resultSelector) {
    return resultSelector ? switchMap_1.switchMap(function () { return innerObservable; }, resultSelector) : switchMap_1.switchMap(function () { return innerObservable; });
}
exports.switchMapTo = switchMapTo;

},{"./switchMap":237}],239:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
var ArgumentOutOfRangeError_1 = require("../util/ArgumentOutOfRangeError");
var empty_1 = require("../observable/empty");
function take(count) {
    return function (source) {
        if (count === 0) {
            return empty_1.empty();
        }
        else {
            return source.lift(new TakeOperator(count));
        }
    };
}
exports.take = take;
var TakeOperator = (function () {
    function TakeOperator(total) {
        this.total = total;
        if (this.total < 0) {
            throw new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;
        }
    }
    TakeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new TakeSubscriber(subscriber, this.total));
    };
    return TakeOperator;
}());
var TakeSubscriber = (function (_super) {
    __extends(TakeSubscriber, _super);
    function TakeSubscriber(destination, total) {
        var _this = _super.call(this, destination) || this;
        _this.total = total;
        _this.count = 0;
        return _this;
    }
    TakeSubscriber.prototype._next = function (value) {
        var total = this.total;
        var count = ++this.count;
        if (count <= total) {
            this.destination.next(value);
            if (count === total) {
                this.destination.complete();
                this.unsubscribe();
            }
        }
    };
    return TakeSubscriber;
}(Subscriber_1.Subscriber));

},{"../Subscriber":124,"../observable/empty":135,"../util/ArgumentOutOfRangeError":282}],240:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
var ArgumentOutOfRangeError_1 = require("../util/ArgumentOutOfRangeError");
var empty_1 = require("../observable/empty");
function takeLast(count) {
    return function takeLastOperatorFunction(source) {
        if (count === 0) {
            return empty_1.empty();
        }
        else {
            return source.lift(new TakeLastOperator(count));
        }
    };
}
exports.takeLast = takeLast;
var TakeLastOperator = (function () {
    function TakeLastOperator(total) {
        this.total = total;
        if (this.total < 0) {
            throw new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;
        }
    }
    TakeLastOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new TakeLastSubscriber(subscriber, this.total));
    };
    return TakeLastOperator;
}());
var TakeLastSubscriber = (function (_super) {
    __extends(TakeLastSubscriber, _super);
    function TakeLastSubscriber(destination, total) {
        var _this = _super.call(this, destination) || this;
        _this.total = total;
        _this.ring = new Array();
        _this.count = 0;
        return _this;
    }
    TakeLastSubscriber.prototype._next = function (value) {
        var ring = this.ring;
        var total = this.total;
        var count = this.count++;
        if (ring.length < total) {
            ring.push(value);
        }
        else {
            var index = count % total;
            ring[index] = value;
        }
    };
    TakeLastSubscriber.prototype._complete = function () {
        var destination = this.destination;
        var count = this.count;
        if (count > 0) {
            var total = this.count >= this.total ? this.total : this.count;
            var ring = this.ring;
            for (var i = 0; i < total; i++) {
                var idx = (count++) % total;
                destination.next(ring[idx]);
            }
        }
        destination.complete();
    };
    return TakeLastSubscriber;
}(Subscriber_1.Subscriber));

},{"../Subscriber":124,"../observable/empty":135,"../util/ArgumentOutOfRangeError":282}],241:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var innerSubscribe_1 = require("../innerSubscribe");
function takeUntil(notifier) {
    return function (source) { return source.lift(new TakeUntilOperator(notifier)); };
}
exports.takeUntil = takeUntil;
var TakeUntilOperator = (function () {
    function TakeUntilOperator(notifier) {
        this.notifier = notifier;
    }
    TakeUntilOperator.prototype.call = function (subscriber, source) {
        var takeUntilSubscriber = new TakeUntilSubscriber(subscriber);
        var notifierSubscription = innerSubscribe_1.innerSubscribe(this.notifier, new innerSubscribe_1.SimpleInnerSubscriber(takeUntilSubscriber));
        if (notifierSubscription && !takeUntilSubscriber.seenValue) {
            takeUntilSubscriber.add(notifierSubscription);
            return source.subscribe(takeUntilSubscriber);
        }
        return takeUntilSubscriber;
    };
    return TakeUntilOperator;
}());
var TakeUntilSubscriber = (function (_super) {
    __extends(TakeUntilSubscriber, _super);
    function TakeUntilSubscriber(destination) {
        var _this = _super.call(this, destination) || this;
        _this.seenValue = false;
        return _this;
    }
    TakeUntilSubscriber.prototype.notifyNext = function () {
        this.seenValue = true;
        this.complete();
    };
    TakeUntilSubscriber.prototype.notifyComplete = function () {
    };
    return TakeUntilSubscriber;
}(innerSubscribe_1.SimpleOuterSubscriber));

},{"../innerSubscribe":127}],242:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
function takeWhile(predicate, inclusive) {
    if (inclusive === void 0) { inclusive = false; }
    return function (source) {
        return source.lift(new TakeWhileOperator(predicate, inclusive));
    };
}
exports.takeWhile = takeWhile;
var TakeWhileOperator = (function () {
    function TakeWhileOperator(predicate, inclusive) {
        this.predicate = predicate;
        this.inclusive = inclusive;
    }
    TakeWhileOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new TakeWhileSubscriber(subscriber, this.predicate, this.inclusive));
    };
    return TakeWhileOperator;
}());
var TakeWhileSubscriber = (function (_super) {
    __extends(TakeWhileSubscriber, _super);
    function TakeWhileSubscriber(destination, predicate, inclusive) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.inclusive = inclusive;
        _this.index = 0;
        return _this;
    }
    TakeWhileSubscriber.prototype._next = function (value) {
        var destination = this.destination;
        var result;
        try {
            result = this.predicate(value, this.index++);
        }
        catch (err) {
            destination.error(err);
            return;
        }
        this.nextOrComplete(value, result);
    };
    TakeWhileSubscriber.prototype.nextOrComplete = function (value, predicateResult) {
        var destination = this.destination;
        if (Boolean(predicateResult)) {
            destination.next(value);
        }
        else {
            if (this.inclusive) {
                destination.next(value);
            }
            destination.complete();
        }
    };
    return TakeWhileSubscriber;
}(Subscriber_1.Subscriber));

},{"../Subscriber":124}],243:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
var noop_1 = require("../util/noop");
var isFunction_1 = require("../util/isFunction");
function tap(nextOrObserver, error, complete) {
    return function tapOperatorFunction(source) {
        return source.lift(new DoOperator(nextOrObserver, error, complete));
    };
}
exports.tap = tap;
var DoOperator = (function () {
    function DoOperator(nextOrObserver, error, complete) {
        this.nextOrObserver = nextOrObserver;
        this.error = error;
        this.complete = complete;
    }
    DoOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new TapSubscriber(subscriber, this.nextOrObserver, this.error, this.complete));
    };
    return DoOperator;
}());
var TapSubscriber = (function (_super) {
    __extends(TapSubscriber, _super);
    function TapSubscriber(destination, observerOrNext, error, complete) {
        var _this = _super.call(this, destination) || this;
        _this._tapNext = noop_1.noop;
        _this._tapError = noop_1.noop;
        _this._tapComplete = noop_1.noop;
        _this._tapError = error || noop_1.noop;
        _this._tapComplete = complete || noop_1.noop;
        if (isFunction_1.isFunction(observerOrNext)) {
            _this._context = _this;
            _this._tapNext = observerOrNext;
        }
        else if (observerOrNext) {
            _this._context = observerOrNext;
            _this._tapNext = observerOrNext.next || noop_1.noop;
            _this._tapError = observerOrNext.error || noop_1.noop;
            _this._tapComplete = observerOrNext.complete || noop_1.noop;
        }
        return _this;
    }
    TapSubscriber.prototype._next = function (value) {
        try {
            this._tapNext.call(this._context, value);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(value);
    };
    TapSubscriber.prototype._error = function (err) {
        try {
            this._tapError.call(this._context, err);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.error(err);
    };
    TapSubscriber.prototype._complete = function () {
        try {
            this._tapComplete.call(this._context);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        return this.destination.complete();
    };
    return TapSubscriber;
}(Subscriber_1.Subscriber));

},{"../Subscriber":124,"../util/isFunction":294,"../util/noop":302}],244:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var innerSubscribe_1 = require("../innerSubscribe");
exports.defaultThrottleConfig = {
    leading: true,
    trailing: false
};
function throttle(durationSelector, config) {
    if (config === void 0) { config = exports.defaultThrottleConfig; }
    return function (source) { return source.lift(new ThrottleOperator(durationSelector, !!config.leading, !!config.trailing)); };
}
exports.throttle = throttle;
var ThrottleOperator = (function () {
    function ThrottleOperator(durationSelector, leading, trailing) {
        this.durationSelector = durationSelector;
        this.leading = leading;
        this.trailing = trailing;
    }
    ThrottleOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ThrottleSubscriber(subscriber, this.durationSelector, this.leading, this.trailing));
    };
    return ThrottleOperator;
}());
var ThrottleSubscriber = (function (_super) {
    __extends(ThrottleSubscriber, _super);
    function ThrottleSubscriber(destination, durationSelector, _leading, _trailing) {
        var _this = _super.call(this, destination) || this;
        _this.destination = destination;
        _this.durationSelector = durationSelector;
        _this._leading = _leading;
        _this._trailing = _trailing;
        _this._hasValue = false;
        return _this;
    }
    ThrottleSubscriber.prototype._next = function (value) {
        this._hasValue = true;
        this._sendValue = value;
        if (!this._throttled) {
            if (this._leading) {
                this.send();
            }
            else {
                this.throttle(value);
            }
        }
    };
    ThrottleSubscriber.prototype.send = function () {
        var _a = this, _hasValue = _a._hasValue, _sendValue = _a._sendValue;
        if (_hasValue) {
            this.destination.next(_sendValue);
            this.throttle(_sendValue);
        }
        this._hasValue = false;
        this._sendValue = undefined;
    };
    ThrottleSubscriber.prototype.throttle = function (value) {
        var duration = this.tryDurationSelector(value);
        if (!!duration) {
            this.add(this._throttled = innerSubscribe_1.innerSubscribe(duration, new innerSubscribe_1.SimpleInnerSubscriber(this)));
        }
    };
    ThrottleSubscriber.prototype.tryDurationSelector = function (value) {
        try {
            return this.durationSelector(value);
        }
        catch (err) {
            this.destination.error(err);
            return null;
        }
    };
    ThrottleSubscriber.prototype.throttlingDone = function () {
        var _a = this, _throttled = _a._throttled, _trailing = _a._trailing;
        if (_throttled) {
            _throttled.unsubscribe();
        }
        this._throttled = undefined;
        if (_trailing) {
            this.send();
        }
    };
    ThrottleSubscriber.prototype.notifyNext = function () {
        this.throttlingDone();
    };
    ThrottleSubscriber.prototype.notifyComplete = function () {
        this.throttlingDone();
    };
    return ThrottleSubscriber;
}(innerSubscribe_1.SimpleOuterSubscriber));

},{"../innerSubscribe":127}],245:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
var async_1 = require("../scheduler/async");
var throttle_1 = require("./throttle");
function throttleTime(duration, scheduler, config) {
    if (scheduler === void 0) { scheduler = async_1.async; }
    if (config === void 0) { config = throttle_1.defaultThrottleConfig; }
    return function (source) { return source.lift(new ThrottleTimeOperator(duration, scheduler, config.leading, config.trailing)); };
}
exports.throttleTime = throttleTime;
var ThrottleTimeOperator = (function () {
    function ThrottleTimeOperator(duration, scheduler, leading, trailing) {
        this.duration = duration;
        this.scheduler = scheduler;
        this.leading = leading;
        this.trailing = trailing;
    }
    ThrottleTimeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ThrottleTimeSubscriber(subscriber, this.duration, this.scheduler, this.leading, this.trailing));
    };
    return ThrottleTimeOperator;
}());
var ThrottleTimeSubscriber = (function (_super) {
    __extends(ThrottleTimeSubscriber, _super);
    function ThrottleTimeSubscriber(destination, duration, scheduler, leading, trailing) {
        var _this = _super.call(this, destination) || this;
        _this.duration = duration;
        _this.scheduler = scheduler;
        _this.leading = leading;
        _this.trailing = trailing;
        _this._hasTrailingValue = false;
        _this._trailingValue = null;
        return _this;
    }
    ThrottleTimeSubscriber.prototype._next = function (value) {
        if (this.throttled) {
            if (this.trailing) {
                this._trailingValue = value;
                this._hasTrailingValue = true;
            }
        }
        else {
            this.add(this.throttled = this.scheduler.schedule(dispatchNext, this.duration, { subscriber: this }));
            if (this.leading) {
                this.destination.next(value);
            }
            else if (this.trailing) {
                this._trailingValue = value;
                this._hasTrailingValue = true;
            }
        }
    };
    ThrottleTimeSubscriber.prototype._complete = function () {
        if (this._hasTrailingValue) {
            this.destination.next(this._trailingValue);
            this.destination.complete();
        }
        else {
            this.destination.complete();
        }
    };
    ThrottleTimeSubscriber.prototype.clearThrottle = function () {
        var throttled = this.throttled;
        if (throttled) {
            if (this.trailing && this._hasTrailingValue) {
                this.destination.next(this._trailingValue);
                this._trailingValue = null;
                this._hasTrailingValue = false;
            }
            throttled.unsubscribe();
            this.remove(throttled);
            this.throttled = null;
        }
    };
    return ThrottleTimeSubscriber;
}(Subscriber_1.Subscriber));
function dispatchNext(arg) {
    var subscriber = arg.subscriber;
    subscriber.clearThrottle();
}

},{"../Subscriber":124,"../scheduler/async":277,"./throttle":244}],246:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var EmptyError_1 = require("../util/EmptyError");
var Subscriber_1 = require("../Subscriber");
function throwIfEmpty(errorFactory) {
    if (errorFactory === void 0) { errorFactory = defaultErrorFactory; }
    return function (source) {
        return source.lift(new ThrowIfEmptyOperator(errorFactory));
    };
}
exports.throwIfEmpty = throwIfEmpty;
var ThrowIfEmptyOperator = (function () {
    function ThrowIfEmptyOperator(errorFactory) {
        this.errorFactory = errorFactory;
    }
    ThrowIfEmptyOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ThrowIfEmptySubscriber(subscriber, this.errorFactory));
    };
    return ThrowIfEmptyOperator;
}());
var ThrowIfEmptySubscriber = (function (_super) {
    __extends(ThrowIfEmptySubscriber, _super);
    function ThrowIfEmptySubscriber(destination, errorFactory) {
        var _this = _super.call(this, destination) || this;
        _this.errorFactory = errorFactory;
        _this.hasValue = false;
        return _this;
    }
    ThrowIfEmptySubscriber.prototype._next = function (value) {
        this.hasValue = true;
        this.destination.next(value);
    };
    ThrowIfEmptySubscriber.prototype._complete = function () {
        if (!this.hasValue) {
            var err = void 0;
            try {
                err = this.errorFactory();
            }
            catch (e) {
                err = e;
            }
            this.destination.error(err);
        }
        else {
            return this.destination.complete();
        }
    };
    return ThrowIfEmptySubscriber;
}(Subscriber_1.Subscriber));
function defaultErrorFactory() {
    return new EmptyError_1.EmptyError();
}

},{"../Subscriber":124,"../util/EmptyError":283}],247:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var async_1 = require("../scheduler/async");
var scan_1 = require("./scan");
var defer_1 = require("../observable/defer");
var map_1 = require("./map");
function timeInterval(scheduler) {
    if (scheduler === void 0) { scheduler = async_1.async; }
    return function (source) { return defer_1.defer(function () {
        return source.pipe(scan_1.scan(function (_a, value) {
            var current = _a.current;
            return ({ value: value, current: scheduler.now(), last: current });
        }, { current: scheduler.now(), value: undefined, last: undefined }), map_1.map(function (_a) {
            var current = _a.current, last = _a.last, value = _a.value;
            return new TimeInterval(value, current - last);
        }));
    }); };
}
exports.timeInterval = timeInterval;
var TimeInterval = (function () {
    function TimeInterval(value, interval) {
        this.value = value;
        this.interval = interval;
    }
    return TimeInterval;
}());
exports.TimeInterval = TimeInterval;

},{"../observable/defer":134,"../scheduler/async":277,"./map":196,"./scan":225}],248:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var async_1 = require("../scheduler/async");
var TimeoutError_1 = require("../util/TimeoutError");
var timeoutWith_1 = require("./timeoutWith");
var throwError_1 = require("../observable/throwError");
function timeout(due, scheduler) {
    if (scheduler === void 0) { scheduler = async_1.async; }
    return timeoutWith_1.timeoutWith(due, throwError_1.throwError(new TimeoutError_1.TimeoutError()), scheduler);
}
exports.timeout = timeout;

},{"../observable/throwError":152,"../scheduler/async":277,"../util/TimeoutError":286,"./timeoutWith":249}],249:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var async_1 = require("../scheduler/async");
var isDate_1 = require("../util/isDate");
var innerSubscribe_1 = require("../innerSubscribe");
function timeoutWith(due, withObservable, scheduler) {
    if (scheduler === void 0) { scheduler = async_1.async; }
    return function (source) {
        var absoluteTimeout = isDate_1.isDate(due);
        var waitFor = absoluteTimeout ? (+due - scheduler.now()) : Math.abs(due);
        return source.lift(new TimeoutWithOperator(waitFor, absoluteTimeout, withObservable, scheduler));
    };
}
exports.timeoutWith = timeoutWith;
var TimeoutWithOperator = (function () {
    function TimeoutWithOperator(waitFor, absoluteTimeout, withObservable, scheduler) {
        this.waitFor = waitFor;
        this.absoluteTimeout = absoluteTimeout;
        this.withObservable = withObservable;
        this.scheduler = scheduler;
    }
    TimeoutWithOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new TimeoutWithSubscriber(subscriber, this.absoluteTimeout, this.waitFor, this.withObservable, this.scheduler));
    };
    return TimeoutWithOperator;
}());
var TimeoutWithSubscriber = (function (_super) {
    __extends(TimeoutWithSubscriber, _super);
    function TimeoutWithSubscriber(destination, absoluteTimeout, waitFor, withObservable, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.absoluteTimeout = absoluteTimeout;
        _this.waitFor = waitFor;
        _this.withObservable = withObservable;
        _this.scheduler = scheduler;
        _this.scheduleTimeout();
        return _this;
    }
    TimeoutWithSubscriber.dispatchTimeout = function (subscriber) {
        var withObservable = subscriber.withObservable;
        subscriber._unsubscribeAndRecycle();
        subscriber.add(innerSubscribe_1.innerSubscribe(withObservable, new innerSubscribe_1.SimpleInnerSubscriber(subscriber)));
    };
    TimeoutWithSubscriber.prototype.scheduleTimeout = function () {
        var action = this.action;
        if (action) {
            this.action = action.schedule(this, this.waitFor);
        }
        else {
            this.add(this.action = this.scheduler.schedule(TimeoutWithSubscriber.dispatchTimeout, this.waitFor, this));
        }
    };
    TimeoutWithSubscriber.prototype._next = function (value) {
        if (!this.absoluteTimeout) {
            this.scheduleTimeout();
        }
        _super.prototype._next.call(this, value);
    };
    TimeoutWithSubscriber.prototype._unsubscribe = function () {
        this.action = undefined;
        this.scheduler = null;
        this.withObservable = null;
    };
    return TimeoutWithSubscriber;
}(innerSubscribe_1.SimpleOuterSubscriber));

},{"../innerSubscribe":127,"../scheduler/async":277,"../util/isDate":293}],250:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var async_1 = require("../scheduler/async");
var map_1 = require("./map");
function timestamp(scheduler) {
    if (scheduler === void 0) { scheduler = async_1.async; }
    return map_1.map(function (value) { return new Timestamp(value, scheduler.now()); });
}
exports.timestamp = timestamp;
var Timestamp = (function () {
    function Timestamp(value, timestamp) {
        this.value = value;
        this.timestamp = timestamp;
    }
    return Timestamp;
}());
exports.Timestamp = Timestamp;

},{"../scheduler/async":277,"./map":196}],251:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var reduce_1 = require("./reduce");
function toArrayReducer(arr, item, index) {
    if (index === 0) {
        return [item];
    }
    arr.push(item);
    return arr;
}
function toArray() {
    return reduce_1.reduce(toArrayReducer, []);
}
exports.toArray = toArray;

},{"./reduce":217}],252:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subject_1 = require("../Subject");
var innerSubscribe_1 = require("../innerSubscribe");
function window(windowBoundaries) {
    return function windowOperatorFunction(source) {
        return source.lift(new WindowOperator(windowBoundaries));
    };
}
exports.window = window;
var WindowOperator = (function () {
    function WindowOperator(windowBoundaries) {
        this.windowBoundaries = windowBoundaries;
    }
    WindowOperator.prototype.call = function (subscriber, source) {
        var windowSubscriber = new WindowSubscriber(subscriber);
        var sourceSubscription = source.subscribe(windowSubscriber);
        if (!sourceSubscription.closed) {
            windowSubscriber.add(innerSubscribe_1.innerSubscribe(this.windowBoundaries, new innerSubscribe_1.SimpleInnerSubscriber(windowSubscriber)));
        }
        return sourceSubscription;
    };
    return WindowOperator;
}());
var WindowSubscriber = (function (_super) {
    __extends(WindowSubscriber, _super);
    function WindowSubscriber(destination) {
        var _this = _super.call(this, destination) || this;
        _this.window = new Subject_1.Subject();
        destination.next(_this.window);
        return _this;
    }
    WindowSubscriber.prototype.notifyNext = function () {
        this.openWindow();
    };
    WindowSubscriber.prototype.notifyError = function (error) {
        this._error(error);
    };
    WindowSubscriber.prototype.notifyComplete = function () {
        this._complete();
    };
    WindowSubscriber.prototype._next = function (value) {
        this.window.next(value);
    };
    WindowSubscriber.prototype._error = function (err) {
        this.window.error(err);
        this.destination.error(err);
    };
    WindowSubscriber.prototype._complete = function () {
        this.window.complete();
        this.destination.complete();
    };
    WindowSubscriber.prototype._unsubscribe = function () {
        this.window = null;
    };
    WindowSubscriber.prototype.openWindow = function () {
        var prevWindow = this.window;
        if (prevWindow) {
            prevWindow.complete();
        }
        var destination = this.destination;
        var newWindow = this.window = new Subject_1.Subject();
        destination.next(newWindow);
    };
    return WindowSubscriber;
}(innerSubscribe_1.SimpleOuterSubscriber));

},{"../Subject":122,"../innerSubscribe":127}],253:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
var Subject_1 = require("../Subject");
function windowCount(windowSize, startWindowEvery) {
    if (startWindowEvery === void 0) { startWindowEvery = 0; }
    return function windowCountOperatorFunction(source) {
        return source.lift(new WindowCountOperator(windowSize, startWindowEvery));
    };
}
exports.windowCount = windowCount;
var WindowCountOperator = (function () {
    function WindowCountOperator(windowSize, startWindowEvery) {
        this.windowSize = windowSize;
        this.startWindowEvery = startWindowEvery;
    }
    WindowCountOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new WindowCountSubscriber(subscriber, this.windowSize, this.startWindowEvery));
    };
    return WindowCountOperator;
}());
var WindowCountSubscriber = (function (_super) {
    __extends(WindowCountSubscriber, _super);
    function WindowCountSubscriber(destination, windowSize, startWindowEvery) {
        var _this = _super.call(this, destination) || this;
        _this.destination = destination;
        _this.windowSize = windowSize;
        _this.startWindowEvery = startWindowEvery;
        _this.windows = [new Subject_1.Subject()];
        _this.count = 0;
        destination.next(_this.windows[0]);
        return _this;
    }
    WindowCountSubscriber.prototype._next = function (value) {
        var startWindowEvery = (this.startWindowEvery > 0) ? this.startWindowEvery : this.windowSize;
        var destination = this.destination;
        var windowSize = this.windowSize;
        var windows = this.windows;
        var len = windows.length;
        for (var i = 0; i < len && !this.closed; i++) {
            windows[i].next(value);
        }
        var c = this.count - windowSize + 1;
        if (c >= 0 && c % startWindowEvery === 0 && !this.closed) {
            windows.shift().complete();
        }
        if (++this.count % startWindowEvery === 0 && !this.closed) {
            var window_1 = new Subject_1.Subject();
            windows.push(window_1);
            destination.next(window_1);
        }
    };
    WindowCountSubscriber.prototype._error = function (err) {
        var windows = this.windows;
        if (windows) {
            while (windows.length > 0 && !this.closed) {
                windows.shift().error(err);
            }
        }
        this.destination.error(err);
    };
    WindowCountSubscriber.prototype._complete = function () {
        var windows = this.windows;
        if (windows) {
            while (windows.length > 0 && !this.closed) {
                windows.shift().complete();
            }
        }
        this.destination.complete();
    };
    WindowCountSubscriber.prototype._unsubscribe = function () {
        this.count = 0;
        this.windows = null;
    };
    return WindowCountSubscriber;
}(Subscriber_1.Subscriber));

},{"../Subject":122,"../Subscriber":124}],254:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subject_1 = require("../Subject");
var async_1 = require("../scheduler/async");
var Subscriber_1 = require("../Subscriber");
var isNumeric_1 = require("../util/isNumeric");
var isScheduler_1 = require("../util/isScheduler");
function windowTime(windowTimeSpan) {
    var scheduler = async_1.async;
    var windowCreationInterval = null;
    var maxWindowSize = Number.POSITIVE_INFINITY;
    if (isScheduler_1.isScheduler(arguments[3])) {
        scheduler = arguments[3];
    }
    if (isScheduler_1.isScheduler(arguments[2])) {
        scheduler = arguments[2];
    }
    else if (isNumeric_1.isNumeric(arguments[2])) {
        maxWindowSize = Number(arguments[2]);
    }
    if (isScheduler_1.isScheduler(arguments[1])) {
        scheduler = arguments[1];
    }
    else if (isNumeric_1.isNumeric(arguments[1])) {
        windowCreationInterval = Number(arguments[1]);
    }
    return function windowTimeOperatorFunction(source) {
        return source.lift(new WindowTimeOperator(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler));
    };
}
exports.windowTime = windowTime;
var WindowTimeOperator = (function () {
    function WindowTimeOperator(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler) {
        this.windowTimeSpan = windowTimeSpan;
        this.windowCreationInterval = windowCreationInterval;
        this.maxWindowSize = maxWindowSize;
        this.scheduler = scheduler;
    }
    WindowTimeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new WindowTimeSubscriber(subscriber, this.windowTimeSpan, this.windowCreationInterval, this.maxWindowSize, this.scheduler));
    };
    return WindowTimeOperator;
}());
var CountedSubject = (function (_super) {
    __extends(CountedSubject, _super);
    function CountedSubject() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._numberOfNextedValues = 0;
        return _this;
    }
    CountedSubject.prototype.next = function (value) {
        this._numberOfNextedValues++;
        _super.prototype.next.call(this, value);
    };
    Object.defineProperty(CountedSubject.prototype, "numberOfNextedValues", {
        get: function () {
            return this._numberOfNextedValues;
        },
        enumerable: true,
        configurable: true
    });
    return CountedSubject;
}(Subject_1.Subject));
var WindowTimeSubscriber = (function (_super) {
    __extends(WindowTimeSubscriber, _super);
    function WindowTimeSubscriber(destination, windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.destination = destination;
        _this.windowTimeSpan = windowTimeSpan;
        _this.windowCreationInterval = windowCreationInterval;
        _this.maxWindowSize = maxWindowSize;
        _this.scheduler = scheduler;
        _this.windows = [];
        var window = _this.openWindow();
        if (windowCreationInterval !== null && windowCreationInterval >= 0) {
            var closeState = { subscriber: _this, window: window, context: null };
            var creationState = { windowTimeSpan: windowTimeSpan, windowCreationInterval: windowCreationInterval, subscriber: _this, scheduler: scheduler };
            _this.add(scheduler.schedule(dispatchWindowClose, windowTimeSpan, closeState));
            _this.add(scheduler.schedule(dispatchWindowCreation, windowCreationInterval, creationState));
        }
        else {
            var timeSpanOnlyState = { subscriber: _this, window: window, windowTimeSpan: windowTimeSpan };
            _this.add(scheduler.schedule(dispatchWindowTimeSpanOnly, windowTimeSpan, timeSpanOnlyState));
        }
        return _this;
    }
    WindowTimeSubscriber.prototype._next = function (value) {
        var windows = this.windows;
        var len = windows.length;
        for (var i = 0; i < len; i++) {
            var window_1 = windows[i];
            if (!window_1.closed) {
                window_1.next(value);
                if (window_1.numberOfNextedValues >= this.maxWindowSize) {
                    this.closeWindow(window_1);
                }
            }
        }
    };
    WindowTimeSubscriber.prototype._error = function (err) {
        var windows = this.windows;
        while (windows.length > 0) {
            windows.shift().error(err);
        }
        this.destination.error(err);
    };
    WindowTimeSubscriber.prototype._complete = function () {
        var windows = this.windows;
        while (windows.length > 0) {
            var window_2 = windows.shift();
            if (!window_2.closed) {
                window_2.complete();
            }
        }
        this.destination.complete();
    };
    WindowTimeSubscriber.prototype.openWindow = function () {
        var window = new CountedSubject();
        this.windows.push(window);
        var destination = this.destination;
        destination.next(window);
        return window;
    };
    WindowTimeSubscriber.prototype.closeWindow = function (window) {
        window.complete();
        var windows = this.windows;
        windows.splice(windows.indexOf(window), 1);
    };
    return WindowTimeSubscriber;
}(Subscriber_1.Subscriber));
function dispatchWindowTimeSpanOnly(state) {
    var subscriber = state.subscriber, windowTimeSpan = state.windowTimeSpan, window = state.window;
    if (window) {
        subscriber.closeWindow(window);
    }
    state.window = subscriber.openWindow();
    this.schedule(state, windowTimeSpan);
}
function dispatchWindowCreation(state) {
    var windowTimeSpan = state.windowTimeSpan, subscriber = state.subscriber, scheduler = state.scheduler, windowCreationInterval = state.windowCreationInterval;
    var window = subscriber.openWindow();
    var action = this;
    var context = { action: action, subscription: null };
    var timeSpanState = { subscriber: subscriber, window: window, context: context };
    context.subscription = scheduler.schedule(dispatchWindowClose, windowTimeSpan, timeSpanState);
    action.add(context.subscription);
    action.schedule(state, windowCreationInterval);
}
function dispatchWindowClose(state) {
    var subscriber = state.subscriber, window = state.window, context = state.context;
    if (context && context.action && context.subscription) {
        context.action.remove(context.subscription);
    }
    subscriber.closeWindow(window);
}

},{"../Subject":122,"../Subscriber":124,"../scheduler/async":277,"../util/isNumeric":297,"../util/isScheduler":301}],255:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subject_1 = require("../Subject");
var Subscription_1 = require("../Subscription");
var OuterSubscriber_1 = require("../OuterSubscriber");
var subscribeToResult_1 = require("../util/subscribeToResult");
function windowToggle(openings, closingSelector) {
    return function (source) { return source.lift(new WindowToggleOperator(openings, closingSelector)); };
}
exports.windowToggle = windowToggle;
var WindowToggleOperator = (function () {
    function WindowToggleOperator(openings, closingSelector) {
        this.openings = openings;
        this.closingSelector = closingSelector;
    }
    WindowToggleOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new WindowToggleSubscriber(subscriber, this.openings, this.closingSelector));
    };
    return WindowToggleOperator;
}());
var WindowToggleSubscriber = (function (_super) {
    __extends(WindowToggleSubscriber, _super);
    function WindowToggleSubscriber(destination, openings, closingSelector) {
        var _this = _super.call(this, destination) || this;
        _this.openings = openings;
        _this.closingSelector = closingSelector;
        _this.contexts = [];
        _this.add(_this.openSubscription = subscribeToResult_1.subscribeToResult(_this, openings, openings));
        return _this;
    }
    WindowToggleSubscriber.prototype._next = function (value) {
        var contexts = this.contexts;
        if (contexts) {
            var len = contexts.length;
            for (var i = 0; i < len; i++) {
                contexts[i].window.next(value);
            }
        }
    };
    WindowToggleSubscriber.prototype._error = function (err) {
        var contexts = this.contexts;
        this.contexts = null;
        if (contexts) {
            var len = contexts.length;
            var index = -1;
            while (++index < len) {
                var context_1 = contexts[index];
                context_1.window.error(err);
                context_1.subscription.unsubscribe();
            }
        }
        _super.prototype._error.call(this, err);
    };
    WindowToggleSubscriber.prototype._complete = function () {
        var contexts = this.contexts;
        this.contexts = null;
        if (contexts) {
            var len = contexts.length;
            var index = -1;
            while (++index < len) {
                var context_2 = contexts[index];
                context_2.window.complete();
                context_2.subscription.unsubscribe();
            }
        }
        _super.prototype._complete.call(this);
    };
    WindowToggleSubscriber.prototype._unsubscribe = function () {
        var contexts = this.contexts;
        this.contexts = null;
        if (contexts) {
            var len = contexts.length;
            var index = -1;
            while (++index < len) {
                var context_3 = contexts[index];
                context_3.window.unsubscribe();
                context_3.subscription.unsubscribe();
            }
        }
    };
    WindowToggleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        if (outerValue === this.openings) {
            var closingNotifier = void 0;
            try {
                var closingSelector = this.closingSelector;
                closingNotifier = closingSelector(innerValue);
            }
            catch (e) {
                return this.error(e);
            }
            var window_1 = new Subject_1.Subject();
            var subscription = new Subscription_1.Subscription();
            var context_4 = { window: window_1, subscription: subscription };
            this.contexts.push(context_4);
            var innerSubscription = subscribeToResult_1.subscribeToResult(this, closingNotifier, context_4);
            if (innerSubscription.closed) {
                this.closeWindow(this.contexts.length - 1);
            }
            else {
                innerSubscription.context = context_4;
                subscription.add(innerSubscription);
            }
            this.destination.next(window_1);
        }
        else {
            this.closeWindow(this.contexts.indexOf(outerValue));
        }
    };
    WindowToggleSubscriber.prototype.notifyError = function (err) {
        this.error(err);
    };
    WindowToggleSubscriber.prototype.notifyComplete = function (inner) {
        if (inner !== this.openSubscription) {
            this.closeWindow(this.contexts.indexOf(inner.context));
        }
    };
    WindowToggleSubscriber.prototype.closeWindow = function (index) {
        if (index === -1) {
            return;
        }
        var contexts = this.contexts;
        var context = contexts[index];
        var window = context.window, subscription = context.subscription;
        contexts.splice(index, 1);
        window.complete();
        subscription.unsubscribe();
    };
    return WindowToggleSubscriber;
}(OuterSubscriber_1.OuterSubscriber));

},{"../OuterSubscriber":119,"../Subject":122,"../Subscription":125,"../util/subscribeToResult":310}],256:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subject_1 = require("../Subject");
var OuterSubscriber_1 = require("../OuterSubscriber");
var subscribeToResult_1 = require("../util/subscribeToResult");
function windowWhen(closingSelector) {
    return function windowWhenOperatorFunction(source) {
        return source.lift(new WindowOperator(closingSelector));
    };
}
exports.windowWhen = windowWhen;
var WindowOperator = (function () {
    function WindowOperator(closingSelector) {
        this.closingSelector = closingSelector;
    }
    WindowOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new WindowSubscriber(subscriber, this.closingSelector));
    };
    return WindowOperator;
}());
var WindowSubscriber = (function (_super) {
    __extends(WindowSubscriber, _super);
    function WindowSubscriber(destination, closingSelector) {
        var _this = _super.call(this, destination) || this;
        _this.destination = destination;
        _this.closingSelector = closingSelector;
        _this.openWindow();
        return _this;
    }
    WindowSubscriber.prototype.notifyNext = function (_outerValue, _innerValue, _outerIndex, _innerIndex, innerSub) {
        this.openWindow(innerSub);
    };
    WindowSubscriber.prototype.notifyError = function (error) {
        this._error(error);
    };
    WindowSubscriber.prototype.notifyComplete = function (innerSub) {
        this.openWindow(innerSub);
    };
    WindowSubscriber.prototype._next = function (value) {
        this.window.next(value);
    };
    WindowSubscriber.prototype._error = function (err) {
        this.window.error(err);
        this.destination.error(err);
        this.unsubscribeClosingNotification();
    };
    WindowSubscriber.prototype._complete = function () {
        this.window.complete();
        this.destination.complete();
        this.unsubscribeClosingNotification();
    };
    WindowSubscriber.prototype.unsubscribeClosingNotification = function () {
        if (this.closingNotification) {
            this.closingNotification.unsubscribe();
        }
    };
    WindowSubscriber.prototype.openWindow = function (innerSub) {
        if (innerSub === void 0) { innerSub = null; }
        if (innerSub) {
            this.remove(innerSub);
            innerSub.unsubscribe();
        }
        var prevWindow = this.window;
        if (prevWindow) {
            prevWindow.complete();
        }
        var window = this.window = new Subject_1.Subject();
        this.destination.next(window);
        var closingNotifier;
        try {
            var closingSelector = this.closingSelector;
            closingNotifier = closingSelector();
        }
        catch (e) {
            this.destination.error(e);
            this.window.error(e);
            return;
        }
        this.add(this.closingNotification = subscribeToResult_1.subscribeToResult(this, closingNotifier));
    };
    return WindowSubscriber;
}(OuterSubscriber_1.OuterSubscriber));

},{"../OuterSubscriber":119,"../Subject":122,"../util/subscribeToResult":310}],257:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var OuterSubscriber_1 = require("../OuterSubscriber");
var subscribeToResult_1 = require("../util/subscribeToResult");
function withLatestFrom() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    return function (source) {
        var project;
        if (typeof args[args.length - 1] === 'function') {
            project = args.pop();
        }
        var observables = args;
        return source.lift(new WithLatestFromOperator(observables, project));
    };
}
exports.withLatestFrom = withLatestFrom;
var WithLatestFromOperator = (function () {
    function WithLatestFromOperator(observables, project) {
        this.observables = observables;
        this.project = project;
    }
    WithLatestFromOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new WithLatestFromSubscriber(subscriber, this.observables, this.project));
    };
    return WithLatestFromOperator;
}());
var WithLatestFromSubscriber = (function (_super) {
    __extends(WithLatestFromSubscriber, _super);
    function WithLatestFromSubscriber(destination, observables, project) {
        var _this = _super.call(this, destination) || this;
        _this.observables = observables;
        _this.project = project;
        _this.toRespond = [];
        var len = observables.length;
        _this.values = new Array(len);
        for (var i = 0; i < len; i++) {
            _this.toRespond.push(i);
        }
        for (var i = 0; i < len; i++) {
            var observable = observables[i];
            _this.add(subscribeToResult_1.subscribeToResult(_this, observable, undefined, i));
        }
        return _this;
    }
    WithLatestFromSubscriber.prototype.notifyNext = function (_outerValue, innerValue, outerIndex) {
        this.values[outerIndex] = innerValue;
        var toRespond = this.toRespond;
        if (toRespond.length > 0) {
            var found = toRespond.indexOf(outerIndex);
            if (found !== -1) {
                toRespond.splice(found, 1);
            }
        }
    };
    WithLatestFromSubscriber.prototype.notifyComplete = function () {
    };
    WithLatestFromSubscriber.prototype._next = function (value) {
        if (this.toRespond.length === 0) {
            var args = [value].concat(this.values);
            if (this.project) {
                this._tryProject(args);
            }
            else {
                this.destination.next(args);
            }
        }
    };
    WithLatestFromSubscriber.prototype._tryProject = function (args) {
        var result;
        try {
            result = this.project.apply(this, args);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return WithLatestFromSubscriber;
}(OuterSubscriber_1.OuterSubscriber));

},{"../OuterSubscriber":119,"../util/subscribeToResult":310}],258:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var zip_1 = require("../observable/zip");
function zip() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i] = arguments[_i];
    }
    return function zipOperatorFunction(source) {
        return source.lift.call(zip_1.zip.apply(void 0, [source].concat(observables)));
    };
}
exports.zip = zip;

},{"../observable/zip":155}],259:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var zip_1 = require("../observable/zip");
function zipAll(project) {
    return function (source) { return source.lift(new zip_1.ZipOperator(project)); };
}
exports.zipAll = zipAll;

},{"../observable/zip":155}],260:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("../Observable");
var Subscription_1 = require("../Subscription");
function scheduleArray(input, scheduler) {
    return new Observable_1.Observable(function (subscriber) {
        var sub = new Subscription_1.Subscription();
        var i = 0;
        sub.add(scheduler.schedule(function () {
            if (i === input.length) {
                subscriber.complete();
                return;
            }
            subscriber.next(input[i++]);
            if (!subscriber.closed) {
                sub.add(this.schedule());
            }
        }));
        return sub;
    });
}
exports.scheduleArray = scheduleArray;

},{"../Observable":117,"../Subscription":125}],261:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("../Observable");
var Subscription_1 = require("../Subscription");
var iterator_1 = require("../symbol/iterator");
function scheduleIterable(input, scheduler) {
    if (!input) {
        throw new Error('Iterable cannot be null');
    }
    return new Observable_1.Observable(function (subscriber) {
        var sub = new Subscription_1.Subscription();
        var iterator;
        sub.add(function () {
            if (iterator && typeof iterator.return === 'function') {
                iterator.return();
            }
        });
        sub.add(scheduler.schedule(function () {
            iterator = input[iterator_1.iterator]();
            sub.add(scheduler.schedule(function () {
                if (subscriber.closed) {
                    return;
                }
                var value;
                var done;
                try {
                    var result = iterator.next();
                    value = result.value;
                    done = result.done;
                }
                catch (err) {
                    subscriber.error(err);
                    return;
                }
                if (done) {
                    subscriber.complete();
                }
                else {
                    subscriber.next(value);
                    this.schedule();
                }
            }));
        }));
        return sub;
    });
}
exports.scheduleIterable = scheduleIterable;

},{"../Observable":117,"../Subscription":125,"../symbol/iterator":279}],262:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("../Observable");
var Subscription_1 = require("../Subscription");
var observable_1 = require("../symbol/observable");
function scheduleObservable(input, scheduler) {
    return new Observable_1.Observable(function (subscriber) {
        var sub = new Subscription_1.Subscription();
        sub.add(scheduler.schedule(function () {
            var observable = input[observable_1.observable]();
            sub.add(observable.subscribe({
                next: function (value) { sub.add(scheduler.schedule(function () { return subscriber.next(value); })); },
                error: function (err) { sub.add(scheduler.schedule(function () { return subscriber.error(err); })); },
                complete: function () { sub.add(scheduler.schedule(function () { return subscriber.complete(); })); },
            }));
        }));
        return sub;
    });
}
exports.scheduleObservable = scheduleObservable;

},{"../Observable":117,"../Subscription":125,"../symbol/observable":280}],263:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("../Observable");
var Subscription_1 = require("../Subscription");
function schedulePromise(input, scheduler) {
    return new Observable_1.Observable(function (subscriber) {
        var sub = new Subscription_1.Subscription();
        sub.add(scheduler.schedule(function () { return input.then(function (value) {
            sub.add(scheduler.schedule(function () {
                subscriber.next(value);
                sub.add(scheduler.schedule(function () { return subscriber.complete(); }));
            }));
        }, function (err) {
            sub.add(scheduler.schedule(function () { return subscriber.error(err); }));
        }); }));
        return sub;
    });
}
exports.schedulePromise = schedulePromise;

},{"../Observable":117,"../Subscription":125}],264:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var scheduleObservable_1 = require("./scheduleObservable");
var schedulePromise_1 = require("./schedulePromise");
var scheduleArray_1 = require("./scheduleArray");
var scheduleIterable_1 = require("./scheduleIterable");
var isInteropObservable_1 = require("../util/isInteropObservable");
var isPromise_1 = require("../util/isPromise");
var isArrayLike_1 = require("../util/isArrayLike");
var isIterable_1 = require("../util/isIterable");
function scheduled(input, scheduler) {
    if (input != null) {
        if (isInteropObservable_1.isInteropObservable(input)) {
            return scheduleObservable_1.scheduleObservable(input, scheduler);
        }
        else if (isPromise_1.isPromise(input)) {
            return schedulePromise_1.schedulePromise(input, scheduler);
        }
        else if (isArrayLike_1.isArrayLike(input)) {
            return scheduleArray_1.scheduleArray(input, scheduler);
        }
        else if (isIterable_1.isIterable(input) || typeof input === 'string') {
            return scheduleIterable_1.scheduleIterable(input, scheduler);
        }
    }
    throw new TypeError((input !== null && typeof input || input) + ' is not observable');
}
exports.scheduled = scheduled;

},{"../util/isArrayLike":292,"../util/isInteropObservable":295,"../util/isIterable":296,"../util/isPromise":300,"./scheduleArray":260,"./scheduleIterable":261,"./scheduleObservable":262,"./schedulePromise":263}],265:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscription_1 = require("../Subscription");
var Action = (function (_super) {
    __extends(Action, _super);
    function Action(scheduler, work) {
        return _super.call(this) || this;
    }
    Action.prototype.schedule = function (state, delay) {
        if (delay === void 0) { delay = 0; }
        return this;
    };
    return Action;
}(Subscription_1.Subscription));
exports.Action = Action;

},{"../Subscription":125}],266:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var AsyncAction_1 = require("./AsyncAction");
var AnimationFrameAction = (function (_super) {
    __extends(AnimationFrameAction, _super);
    function AnimationFrameAction(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        return _this;
    }
    AnimationFrameAction.prototype.requestAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) { delay = 0; }
        if (delay !== null && delay > 0) {
            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
        }
        scheduler.actions.push(this);
        return scheduler.scheduled || (scheduler.scheduled = requestAnimationFrame(function () { return scheduler.flush(null); }));
    };
    AnimationFrameAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) { delay = 0; }
        if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {
            return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);
        }
        if (scheduler.actions.length === 0) {
            cancelAnimationFrame(id);
            scheduler.scheduled = undefined;
        }
        return undefined;
    };
    return AnimationFrameAction;
}(AsyncAction_1.AsyncAction));
exports.AnimationFrameAction = AnimationFrameAction;

},{"./AsyncAction":270}],267:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var AsyncScheduler_1 = require("./AsyncScheduler");
var AnimationFrameScheduler = (function (_super) {
    __extends(AnimationFrameScheduler, _super);
    function AnimationFrameScheduler() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    AnimationFrameScheduler.prototype.flush = function (action) {
        this.active = true;
        this.scheduled = undefined;
        var actions = this.actions;
        var error;
        var index = -1;
        var count = actions.length;
        action = action || actions.shift();
        do {
            if (error = action.execute(action.state, action.delay)) {
                break;
            }
        } while (++index < count && (action = actions.shift()));
        this.active = false;
        if (error) {
            while (++index < count && (action = actions.shift())) {
                action.unsubscribe();
            }
            throw error;
        }
    };
    return AnimationFrameScheduler;
}(AsyncScheduler_1.AsyncScheduler));
exports.AnimationFrameScheduler = AnimationFrameScheduler;

},{"./AsyncScheduler":271}],268:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Immediate_1 = require("../util/Immediate");
var AsyncAction_1 = require("./AsyncAction");
var AsapAction = (function (_super) {
    __extends(AsapAction, _super);
    function AsapAction(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        return _this;
    }
    AsapAction.prototype.requestAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) { delay = 0; }
        if (delay !== null && delay > 0) {
            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
        }
        scheduler.actions.push(this);
        return scheduler.scheduled || (scheduler.scheduled = Immediate_1.Immediate.setImmediate(scheduler.flush.bind(scheduler, null)));
    };
    AsapAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) { delay = 0; }
        if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {
            return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);
        }
        if (scheduler.actions.length === 0) {
            Immediate_1.Immediate.clearImmediate(id);
            scheduler.scheduled = undefined;
        }
        return undefined;
    };
    return AsapAction;
}(AsyncAction_1.AsyncAction));
exports.AsapAction = AsapAction;

},{"../util/Immediate":284,"./AsyncAction":270}],269:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var AsyncScheduler_1 = require("./AsyncScheduler");
var AsapScheduler = (function (_super) {
    __extends(AsapScheduler, _super);
    function AsapScheduler() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    AsapScheduler.prototype.flush = function (action) {
        this.active = true;
        this.scheduled = undefined;
        var actions = this.actions;
        var error;
        var index = -1;
        var count = actions.length;
        action = action || actions.shift();
        do {
            if (error = action.execute(action.state, action.delay)) {
                break;
            }
        } while (++index < count && (action = actions.shift()));
        this.active = false;
        if (error) {
            while (++index < count && (action = actions.shift())) {
                action.unsubscribe();
            }
            throw error;
        }
    };
    return AsapScheduler;
}(AsyncScheduler_1.AsyncScheduler));
exports.AsapScheduler = AsapScheduler;

},{"./AsyncScheduler":271}],270:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Action_1 = require("./Action");
var AsyncAction = (function (_super) {
    __extends(AsyncAction, _super);
    function AsyncAction(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        _this.pending = false;
        return _this;
    }
    AsyncAction.prototype.schedule = function (state, delay) {
        if (delay === void 0) { delay = 0; }
        if (this.closed) {
            return this;
        }
        this.state = state;
        var id = this.id;
        var scheduler = this.scheduler;
        if (id != null) {
            this.id = this.recycleAsyncId(scheduler, id, delay);
        }
        this.pending = true;
        this.delay = delay;
        this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);
        return this;
    };
    AsyncAction.prototype.requestAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) { delay = 0; }
        return setInterval(scheduler.flush.bind(scheduler, this), delay);
    };
    AsyncAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) { delay = 0; }
        if (delay !== null && this.delay === delay && this.pending === false) {
            return id;
        }
        clearInterval(id);
        return undefined;
    };
    AsyncAction.prototype.execute = function (state, delay) {
        if (this.closed) {
            return new Error('executing a cancelled action');
        }
        this.pending = false;
        var error = this._execute(state, delay);
        if (error) {
            return error;
        }
        else if (this.pending === false && this.id != null) {
            this.id = this.recycleAsyncId(this.scheduler, this.id, null);
        }
    };
    AsyncAction.prototype._execute = function (state, delay) {
        var errored = false;
        var errorValue = undefined;
        try {
            this.work(state);
        }
        catch (e) {
            errored = true;
            errorValue = !!e && e || new Error(e);
        }
        if (errored) {
            this.unsubscribe();
            return errorValue;
        }
    };
    AsyncAction.prototype._unsubscribe = function () {
        var id = this.id;
        var scheduler = this.scheduler;
        var actions = scheduler.actions;
        var index = actions.indexOf(this);
        this.work = null;
        this.state = null;
        this.pending = false;
        this.scheduler = null;
        if (index !== -1) {
            actions.splice(index, 1);
        }
        if (id != null) {
            this.id = this.recycleAsyncId(scheduler, id, null);
        }
        this.delay = null;
    };
    return AsyncAction;
}(Action_1.Action));
exports.AsyncAction = AsyncAction;

},{"./Action":265}],271:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Scheduler_1 = require("../Scheduler");
var AsyncScheduler = (function (_super) {
    __extends(AsyncScheduler, _super);
    function AsyncScheduler(SchedulerAction, now) {
        if (now === void 0) { now = Scheduler_1.Scheduler.now; }
        var _this = _super.call(this, SchedulerAction, function () {
            if (AsyncScheduler.delegate && AsyncScheduler.delegate !== _this) {
                return AsyncScheduler.delegate.now();
            }
            else {
                return now();
            }
        }) || this;
        _this.actions = [];
        _this.active = false;
        _this.scheduled = undefined;
        return _this;
    }
    AsyncScheduler.prototype.schedule = function (work, delay, state) {
        if (delay === void 0) { delay = 0; }
        if (AsyncScheduler.delegate && AsyncScheduler.delegate !== this) {
            return AsyncScheduler.delegate.schedule(work, delay, state);
        }
        else {
            return _super.prototype.schedule.call(this, work, delay, state);
        }
    };
    AsyncScheduler.prototype.flush = function (action) {
        var actions = this.actions;
        if (this.active) {
            actions.push(action);
            return;
        }
        var error;
        this.active = true;
        do {
            if (error = action.execute(action.state, action.delay)) {
                break;
            }
        } while (action = actions.shift());
        this.active = false;
        if (error) {
            while (action = actions.shift()) {
                action.unsubscribe();
            }
            throw error;
        }
    };
    return AsyncScheduler;
}(Scheduler_1.Scheduler));
exports.AsyncScheduler = AsyncScheduler;

},{"../Scheduler":121}],272:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var AsyncAction_1 = require("./AsyncAction");
var QueueAction = (function (_super) {
    __extends(QueueAction, _super);
    function QueueAction(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        return _this;
    }
    QueueAction.prototype.schedule = function (state, delay) {
        if (delay === void 0) { delay = 0; }
        if (delay > 0) {
            return _super.prototype.schedule.call(this, state, delay);
        }
        this.delay = delay;
        this.state = state;
        this.scheduler.flush(this);
        return this;
    };
    QueueAction.prototype.execute = function (state, delay) {
        return (delay > 0 || this.closed) ?
            _super.prototype.execute.call(this, state, delay) :
            this._execute(state, delay);
    };
    QueueAction.prototype.requestAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) { delay = 0; }
        if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {
            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
        }
        return scheduler.flush(this);
    };
    return QueueAction;
}(AsyncAction_1.AsyncAction));
exports.QueueAction = QueueAction;

},{"./AsyncAction":270}],273:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var AsyncScheduler_1 = require("./AsyncScheduler");
var QueueScheduler = (function (_super) {
    __extends(QueueScheduler, _super);
    function QueueScheduler() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return QueueScheduler;
}(AsyncScheduler_1.AsyncScheduler));
exports.QueueScheduler = QueueScheduler;

},{"./AsyncScheduler":271}],274:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var AsyncAction_1 = require("./AsyncAction");
var AsyncScheduler_1 = require("./AsyncScheduler");
var VirtualTimeScheduler = (function (_super) {
    __extends(VirtualTimeScheduler, _super);
    function VirtualTimeScheduler(SchedulerAction, maxFrames) {
        if (SchedulerAction === void 0) { SchedulerAction = VirtualAction; }
        if (maxFrames === void 0) { maxFrames = Number.POSITIVE_INFINITY; }
        var _this = _super.call(this, SchedulerAction, function () { return _this.frame; }) || this;
        _this.maxFrames = maxFrames;
        _this.frame = 0;
        _this.index = -1;
        return _this;
    }
    VirtualTimeScheduler.prototype.flush = function () {
        var _a = this, actions = _a.actions, maxFrames = _a.maxFrames;
        var error, action;
        while ((action = actions[0]) && action.delay <= maxFrames) {
            actions.shift();
            this.frame = action.delay;
            if (error = action.execute(action.state, action.delay)) {
                break;
            }
        }
        if (error) {
            while (action = actions.shift()) {
                action.unsubscribe();
            }
            throw error;
        }
    };
    VirtualTimeScheduler.frameTimeFactor = 10;
    return VirtualTimeScheduler;
}(AsyncScheduler_1.AsyncScheduler));
exports.VirtualTimeScheduler = VirtualTimeScheduler;
var VirtualAction = (function (_super) {
    __extends(VirtualAction, _super);
    function VirtualAction(scheduler, work, index) {
        if (index === void 0) { index = scheduler.index += 1; }
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        _this.index = index;
        _this.active = true;
        _this.index = scheduler.index = index;
        return _this;
    }
    VirtualAction.prototype.schedule = function (state, delay) {
        if (delay === void 0) { delay = 0; }
        if (!this.id) {
            return _super.prototype.schedule.call(this, state, delay);
        }
        this.active = false;
        var action = new VirtualAction(this.scheduler, this.work);
        this.add(action);
        return action.schedule(state, delay);
    };
    VirtualAction.prototype.requestAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) { delay = 0; }
        this.delay = scheduler.frame + delay;
        var actions = scheduler.actions;
        actions.push(this);
        actions.sort(VirtualAction.sortActions);
        return true;
    };
    VirtualAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) { delay = 0; }
        return undefined;
    };
    VirtualAction.prototype._execute = function (state, delay) {
        if (this.active === true) {
            return _super.prototype._execute.call(this, state, delay);
        }
    };
    VirtualAction.sortActions = function (a, b) {
        if (a.delay === b.delay) {
            if (a.index === b.index) {
                return 0;
            }
            else if (a.index > b.index) {
                return 1;
            }
            else {
                return -1;
            }
        }
        else if (a.delay > b.delay) {
            return 1;
        }
        else {
            return -1;
        }
    };
    return VirtualAction;
}(AsyncAction_1.AsyncAction));
exports.VirtualAction = VirtualAction;

},{"./AsyncAction":270,"./AsyncScheduler":271}],275:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var AnimationFrameAction_1 = require("./AnimationFrameAction");
var AnimationFrameScheduler_1 = require("./AnimationFrameScheduler");
exports.animationFrameScheduler = new AnimationFrameScheduler_1.AnimationFrameScheduler(AnimationFrameAction_1.AnimationFrameAction);
exports.animationFrame = exports.animationFrameScheduler;

},{"./AnimationFrameAction":266,"./AnimationFrameScheduler":267}],276:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var AsapAction_1 = require("./AsapAction");
var AsapScheduler_1 = require("./AsapScheduler");
exports.asapScheduler = new AsapScheduler_1.AsapScheduler(AsapAction_1.AsapAction);
exports.asap = exports.asapScheduler;

},{"./AsapAction":268,"./AsapScheduler":269}],277:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var AsyncAction_1 = require("./AsyncAction");
var AsyncScheduler_1 = require("./AsyncScheduler");
exports.asyncScheduler = new AsyncScheduler_1.AsyncScheduler(AsyncAction_1.AsyncAction);
exports.async = exports.asyncScheduler;

},{"./AsyncAction":270,"./AsyncScheduler":271}],278:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var QueueAction_1 = require("./QueueAction");
var QueueScheduler_1 = require("./QueueScheduler");
exports.queueScheduler = new QueueScheduler_1.QueueScheduler(QueueAction_1.QueueAction);
exports.queue = exports.queueScheduler;

},{"./QueueAction":272,"./QueueScheduler":273}],279:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function getSymbolIterator() {
    if (typeof Symbol !== 'function' || !Symbol.iterator) {
        return '@@iterator';
    }
    return Symbol.iterator;
}
exports.getSymbolIterator = getSymbolIterator;
exports.iterator = getSymbolIterator();
exports.$$iterator = exports.iterator;

},{}],280:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.observable = (function () { return typeof Symbol === 'function' && Symbol.observable || '@@observable'; })();

},{}],281:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.rxSubscriber = (function () {
    return typeof Symbol === 'function'
        ? Symbol('rxSubscriber')
        : '@@rxSubscriber_' + Math.random();
})();
exports.$$rxSubscriber = exports.rxSubscriber;

},{}],282:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ArgumentOutOfRangeErrorImpl = (function () {
    function ArgumentOutOfRangeErrorImpl() {
        Error.call(this);
        this.message = 'argument out of range';
        this.name = 'ArgumentOutOfRangeError';
        return this;
    }
    ArgumentOutOfRangeErrorImpl.prototype = Object.create(Error.prototype);
    return ArgumentOutOfRangeErrorImpl;
})();
exports.ArgumentOutOfRangeError = ArgumentOutOfRangeErrorImpl;

},{}],283:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var EmptyErrorImpl = (function () {
    function EmptyErrorImpl() {
        Error.call(this);
        this.message = 'no elements in sequence';
        this.name = 'EmptyError';
        return this;
    }
    EmptyErrorImpl.prototype = Object.create(Error.prototype);
    return EmptyErrorImpl;
})();
exports.EmptyError = EmptyErrorImpl;

},{}],284:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var nextHandle = 1;
var RESOLVED = (function () { return Promise.resolve(); })();
var activeHandles = {};
function findAndClearHandle(handle) {
    if (handle in activeHandles) {
        delete activeHandles[handle];
        return true;
    }
    return false;
}
exports.Immediate = {
    setImmediate: function (cb) {
        var handle = nextHandle++;
        activeHandles[handle] = true;
        RESOLVED.then(function () { return findAndClearHandle(handle) && cb(); });
        return handle;
    },
    clearImmediate: function (handle) {
        findAndClearHandle(handle);
    },
};
exports.TestTools = {
    pending: function () {
        return Object.keys(activeHandles).length;
    }
};

},{}],285:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ObjectUnsubscribedErrorImpl = (function () {
    function ObjectUnsubscribedErrorImpl() {
        Error.call(this);
        this.message = 'object unsubscribed';
        this.name = 'ObjectUnsubscribedError';
        return this;
    }
    ObjectUnsubscribedErrorImpl.prototype = Object.create(Error.prototype);
    return ObjectUnsubscribedErrorImpl;
})();
exports.ObjectUnsubscribedError = ObjectUnsubscribedErrorImpl;

},{}],286:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var TimeoutErrorImpl = (function () {
    function TimeoutErrorImpl() {
        Error.call(this);
        this.message = 'Timeout has occurred';
        this.name = 'TimeoutError';
        return this;
    }
    TimeoutErrorImpl.prototype = Object.create(Error.prototype);
    return TimeoutErrorImpl;
})();
exports.TimeoutError = TimeoutErrorImpl;

},{}],287:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var UnsubscriptionErrorImpl = (function () {
    function UnsubscriptionErrorImpl(errors) {
        Error.call(this);
        this.message = errors ?
            errors.length + " errors occurred during unsubscription:\n" + errors.map(function (err, i) { return i + 1 + ") " + err.toString(); }).join('\n  ') : '';
        this.name = 'UnsubscriptionError';
        this.errors = errors;
        return this;
    }
    UnsubscriptionErrorImpl.prototype = Object.create(Error.prototype);
    return UnsubscriptionErrorImpl;
})();
exports.UnsubscriptionError = UnsubscriptionErrorImpl;

},{}],288:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
function canReportError(observer) {
    while (observer) {
        var _a = observer, closed_1 = _a.closed, destination = _a.destination, isStopped = _a.isStopped;
        if (closed_1 || isStopped) {
            return false;
        }
        else if (destination && destination instanceof Subscriber_1.Subscriber) {
            observer = destination;
        }
        else {
            observer = null;
        }
    }
    return true;
}
exports.canReportError = canReportError;

},{"../Subscriber":124}],289:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function hostReportError(err) {
    setTimeout(function () { throw err; }, 0);
}
exports.hostReportError = hostReportError;

},{}],290:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function identity(x) {
    return x;
}
exports.identity = identity;

},{}],291:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isArray = (function () { return Array.isArray || (function (x) { return x && typeof x.length === 'number'; }); })();

},{}],292:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isArrayLike = (function (x) { return x && typeof x.length === 'number' && typeof x !== 'function'; });

},{}],293:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function isDate(value) {
    return value instanceof Date && !isNaN(+value);
}
exports.isDate = isDate;

},{}],294:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function isFunction(x) {
    return typeof x === 'function';
}
exports.isFunction = isFunction;

},{}],295:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var observable_1 = require("../symbol/observable");
function isInteropObservable(input) {
    return input && typeof input[observable_1.observable] === 'function';
}
exports.isInteropObservable = isInteropObservable;

},{"../symbol/observable":280}],296:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var iterator_1 = require("../symbol/iterator");
function isIterable(input) {
    return input && typeof input[iterator_1.iterator] === 'function';
}
exports.isIterable = isIterable;

},{"../symbol/iterator":279}],297:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var isArray_1 = require("./isArray");
function isNumeric(val) {
    return !isArray_1.isArray(val) && (val - parseFloat(val) + 1) >= 0;
}
exports.isNumeric = isNumeric;

},{"./isArray":291}],298:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function isObject(x) {
    return x !== null && typeof x === 'object';
}
exports.isObject = isObject;

},{}],299:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("../Observable");
function isObservable(obj) {
    return !!obj && (obj instanceof Observable_1.Observable || (typeof obj.lift === 'function' && typeof obj.subscribe === 'function'));
}
exports.isObservable = isObservable;

},{"../Observable":117}],300:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function isPromise(value) {
    return !!value && typeof value.subscribe !== 'function' && typeof value.then === 'function';
}
exports.isPromise = isPromise;

},{}],301:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function isScheduler(value) {
    return value && typeof value.schedule === 'function';
}
exports.isScheduler = isScheduler;

},{}],302:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function noop() { }
exports.noop = noop;

},{}],303:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function not(pred, thisArg) {
    function notPred() {
        return !(notPred.pred.apply(notPred.thisArg, arguments));
    }
    notPred.pred = pred;
    notPred.thisArg = thisArg;
    return notPred;
}
exports.not = not;

},{}],304:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var identity_1 = require("./identity");
function pipe() {
    var fns = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        fns[_i] = arguments[_i];
    }
    return pipeFromArray(fns);
}
exports.pipe = pipe;
function pipeFromArray(fns) {
    if (fns.length === 0) {
        return identity_1.identity;
    }
    if (fns.length === 1) {
        return fns[0];
    }
    return function piped(input) {
        return fns.reduce(function (prev, fn) { return fn(prev); }, input);
    };
}
exports.pipeFromArray = pipeFromArray;

},{"./identity":290}],305:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var subscribeToArray_1 = require("./subscribeToArray");
var subscribeToPromise_1 = require("./subscribeToPromise");
var subscribeToIterable_1 = require("./subscribeToIterable");
var subscribeToObservable_1 = require("./subscribeToObservable");
var isArrayLike_1 = require("./isArrayLike");
var isPromise_1 = require("./isPromise");
var isObject_1 = require("./isObject");
var iterator_1 = require("../symbol/iterator");
var observable_1 = require("../symbol/observable");
exports.subscribeTo = function (result) {
    if (!!result && typeof result[observable_1.observable] === 'function') {
        return subscribeToObservable_1.subscribeToObservable(result);
    }
    else if (isArrayLike_1.isArrayLike(result)) {
        return subscribeToArray_1.subscribeToArray(result);
    }
    else if (isPromise_1.isPromise(result)) {
        return subscribeToPromise_1.subscribeToPromise(result);
    }
    else if (!!result && typeof result[iterator_1.iterator] === 'function') {
        return subscribeToIterable_1.subscribeToIterable(result);
    }
    else {
        var value = isObject_1.isObject(result) ? 'an invalid object' : "'" + result + "'";
        var msg = "You provided " + value + " where a stream was expected."
            + ' You can provide an Observable, Promise, Array, or Iterable.';
        throw new TypeError(msg);
    }
};

},{"../symbol/iterator":279,"../symbol/observable":280,"./isArrayLike":292,"./isObject":298,"./isPromise":300,"./subscribeToArray":306,"./subscribeToIterable":307,"./subscribeToObservable":308,"./subscribeToPromise":309}],306:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.subscribeToArray = function (array) { return function (subscriber) {
    for (var i = 0, len = array.length; i < len && !subscriber.closed; i++) {
        subscriber.next(array[i]);
    }
    subscriber.complete();
}; };

},{}],307:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var iterator_1 = require("../symbol/iterator");
exports.subscribeToIterable = function (iterable) { return function (subscriber) {
    var iterator = iterable[iterator_1.iterator]();
    do {
        var item = void 0;
        try {
            item = iterator.next();
        }
        catch (err) {
            subscriber.error(err);
            return subscriber;
        }
        if (item.done) {
            subscriber.complete();
            break;
        }
        subscriber.next(item.value);
        if (subscriber.closed) {
            break;
        }
    } while (true);
    if (typeof iterator.return === 'function') {
        subscriber.add(function () {
            if (iterator.return) {
                iterator.return();
            }
        });
    }
    return subscriber;
}; };

},{"../symbol/iterator":279}],308:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var observable_1 = require("../symbol/observable");
exports.subscribeToObservable = function (obj) { return function (subscriber) {
    var obs = obj[observable_1.observable]();
    if (typeof obs.subscribe !== 'function') {
        throw new TypeError('Provided object does not correctly implement Symbol.observable');
    }
    else {
        return obs.subscribe(subscriber);
    }
}; };

},{"../symbol/observable":280}],309:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var hostReportError_1 = require("./hostReportError");
exports.subscribeToPromise = function (promise) { return function (subscriber) {
    promise.then(function (value) {
        if (!subscriber.closed) {
            subscriber.next(value);
            subscriber.complete();
        }
    }, function (err) { return subscriber.error(err); })
        .then(null, hostReportError_1.hostReportError);
    return subscriber;
}; };

},{"./hostReportError":289}],310:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var InnerSubscriber_1 = require("../InnerSubscriber");
var subscribeTo_1 = require("./subscribeTo");
var Observable_1 = require("../Observable");
function subscribeToResult(outerSubscriber, result, outerValue, outerIndex, innerSubscriber) {
    if (innerSubscriber === void 0) { innerSubscriber = new InnerSubscriber_1.InnerSubscriber(outerSubscriber, outerValue, outerIndex); }
    if (innerSubscriber.closed) {
        return undefined;
    }
    if (result instanceof Observable_1.Observable) {
        return result.subscribe(innerSubscriber);
    }
    return subscribeTo_1.subscribeTo(result)(innerSubscriber);
}
exports.subscribeToResult = subscribeToResult;

},{"../InnerSubscriber":115,"../Observable":117,"./subscribeTo":305}],311:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
var rxSubscriber_1 = require("../symbol/rxSubscriber");
var Observer_1 = require("../Observer");
function toSubscriber(nextOrObserver, error, complete) {
    if (nextOrObserver) {
        if (nextOrObserver instanceof Subscriber_1.Subscriber) {
            return nextOrObserver;
        }
        if (nextOrObserver[rxSubscriber_1.rxSubscriber]) {
            return nextOrObserver[rxSubscriber_1.rxSubscriber]();
        }
    }
    if (!nextOrObserver && !error && !complete) {
        return new Subscriber_1.Subscriber(Observer_1.empty);
    }
    return new Subscriber_1.Subscriber(nextOrObserver, error, complete);
}
exports.toSubscriber = toSubscriber;

},{"../Observer":118,"../Subscriber":124,"../symbol/rxSubscriber":281}],312:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var audit_1 = require("../internal/operators/audit");
exports.audit = audit_1.audit;
var auditTime_1 = require("../internal/operators/auditTime");
exports.auditTime = auditTime_1.auditTime;
var buffer_1 = require("../internal/operators/buffer");
exports.buffer = buffer_1.buffer;
var bufferCount_1 = require("../internal/operators/bufferCount");
exports.bufferCount = bufferCount_1.bufferCount;
var bufferTime_1 = require("../internal/operators/bufferTime");
exports.bufferTime = bufferTime_1.bufferTime;
var bufferToggle_1 = require("../internal/operators/bufferToggle");
exports.bufferToggle = bufferToggle_1.bufferToggle;
var bufferWhen_1 = require("../internal/operators/bufferWhen");
exports.bufferWhen = bufferWhen_1.bufferWhen;
var catchError_1 = require("../internal/operators/catchError");
exports.catchError = catchError_1.catchError;
var combineAll_1 = require("../internal/operators/combineAll");
exports.combineAll = combineAll_1.combineAll;
var combineLatest_1 = require("../internal/operators/combineLatest");
exports.combineLatest = combineLatest_1.combineLatest;
var concat_1 = require("../internal/operators/concat");
exports.concat = concat_1.concat;
var concatAll_1 = require("../internal/operators/concatAll");
exports.concatAll = concatAll_1.concatAll;
var concatMap_1 = require("../internal/operators/concatMap");
exports.concatMap = concatMap_1.concatMap;
var concatMapTo_1 = require("../internal/operators/concatMapTo");
exports.concatMapTo = concatMapTo_1.concatMapTo;
var count_1 = require("../internal/operators/count");
exports.count = count_1.count;
var debounce_1 = require("../internal/operators/debounce");
exports.debounce = debounce_1.debounce;
var debounceTime_1 = require("../internal/operators/debounceTime");
exports.debounceTime = debounceTime_1.debounceTime;
var defaultIfEmpty_1 = require("../internal/operators/defaultIfEmpty");
exports.defaultIfEmpty = defaultIfEmpty_1.defaultIfEmpty;
var delay_1 = require("../internal/operators/delay");
exports.delay = delay_1.delay;
var delayWhen_1 = require("../internal/operators/delayWhen");
exports.delayWhen = delayWhen_1.delayWhen;
var dematerialize_1 = require("../internal/operators/dematerialize");
exports.dematerialize = dematerialize_1.dematerialize;
var distinct_1 = require("../internal/operators/distinct");
exports.distinct = distinct_1.distinct;
var distinctUntilChanged_1 = require("../internal/operators/distinctUntilChanged");
exports.distinctUntilChanged = distinctUntilChanged_1.distinctUntilChanged;
var distinctUntilKeyChanged_1 = require("../internal/operators/distinctUntilKeyChanged");
exports.distinctUntilKeyChanged = distinctUntilKeyChanged_1.distinctUntilKeyChanged;
var elementAt_1 = require("../internal/operators/elementAt");
exports.elementAt = elementAt_1.elementAt;
var endWith_1 = require("../internal/operators/endWith");
exports.endWith = endWith_1.endWith;
var every_1 = require("../internal/operators/every");
exports.every = every_1.every;
var exhaust_1 = require("../internal/operators/exhaust");
exports.exhaust = exhaust_1.exhaust;
var exhaustMap_1 = require("../internal/operators/exhaustMap");
exports.exhaustMap = exhaustMap_1.exhaustMap;
var expand_1 = require("../internal/operators/expand");
exports.expand = expand_1.expand;
var filter_1 = require("../internal/operators/filter");
exports.filter = filter_1.filter;
var finalize_1 = require("../internal/operators/finalize");
exports.finalize = finalize_1.finalize;
var find_1 = require("../internal/operators/find");
exports.find = find_1.find;
var findIndex_1 = require("../internal/operators/findIndex");
exports.findIndex = findIndex_1.findIndex;
var first_1 = require("../internal/operators/first");
exports.first = first_1.first;
var groupBy_1 = require("../internal/operators/groupBy");
exports.groupBy = groupBy_1.groupBy;
var ignoreElements_1 = require("../internal/operators/ignoreElements");
exports.ignoreElements = ignoreElements_1.ignoreElements;
var isEmpty_1 = require("../internal/operators/isEmpty");
exports.isEmpty = isEmpty_1.isEmpty;
var last_1 = require("../internal/operators/last");
exports.last = last_1.last;
var map_1 = require("../internal/operators/map");
exports.map = map_1.map;
var mapTo_1 = require("../internal/operators/mapTo");
exports.mapTo = mapTo_1.mapTo;
var materialize_1 = require("../internal/operators/materialize");
exports.materialize = materialize_1.materialize;
var max_1 = require("../internal/operators/max");
exports.max = max_1.max;
var merge_1 = require("../internal/operators/merge");
exports.merge = merge_1.merge;
var mergeAll_1 = require("../internal/operators/mergeAll");
exports.mergeAll = mergeAll_1.mergeAll;
var mergeMap_1 = require("../internal/operators/mergeMap");
exports.mergeMap = mergeMap_1.mergeMap;
exports.flatMap = mergeMap_1.flatMap;
var mergeMapTo_1 = require("../internal/operators/mergeMapTo");
exports.mergeMapTo = mergeMapTo_1.mergeMapTo;
var mergeScan_1 = require("../internal/operators/mergeScan");
exports.mergeScan = mergeScan_1.mergeScan;
var min_1 = require("../internal/operators/min");
exports.min = min_1.min;
var multicast_1 = require("../internal/operators/multicast");
exports.multicast = multicast_1.multicast;
var observeOn_1 = require("../internal/operators/observeOn");
exports.observeOn = observeOn_1.observeOn;
var onErrorResumeNext_1 = require("../internal/operators/onErrorResumeNext");
exports.onErrorResumeNext = onErrorResumeNext_1.onErrorResumeNext;
var pairwise_1 = require("../internal/operators/pairwise");
exports.pairwise = pairwise_1.pairwise;
var partition_1 = require("../internal/operators/partition");
exports.partition = partition_1.partition;
var pluck_1 = require("../internal/operators/pluck");
exports.pluck = pluck_1.pluck;
var publish_1 = require("../internal/operators/publish");
exports.publish = publish_1.publish;
var publishBehavior_1 = require("../internal/operators/publishBehavior");
exports.publishBehavior = publishBehavior_1.publishBehavior;
var publishLast_1 = require("../internal/operators/publishLast");
exports.publishLast = publishLast_1.publishLast;
var publishReplay_1 = require("../internal/operators/publishReplay");
exports.publishReplay = publishReplay_1.publishReplay;
var race_1 = require("../internal/operators/race");
exports.race = race_1.race;
var reduce_1 = require("../internal/operators/reduce");
exports.reduce = reduce_1.reduce;
var repeat_1 = require("../internal/operators/repeat");
exports.repeat = repeat_1.repeat;
var repeatWhen_1 = require("../internal/operators/repeatWhen");
exports.repeatWhen = repeatWhen_1.repeatWhen;
var retry_1 = require("../internal/operators/retry");
exports.retry = retry_1.retry;
var retryWhen_1 = require("../internal/operators/retryWhen");
exports.retryWhen = retryWhen_1.retryWhen;
var refCount_1 = require("../internal/operators/refCount");
exports.refCount = refCount_1.refCount;
var sample_1 = require("../internal/operators/sample");
exports.sample = sample_1.sample;
var sampleTime_1 = require("../internal/operators/sampleTime");
exports.sampleTime = sampleTime_1.sampleTime;
var scan_1 = require("../internal/operators/scan");
exports.scan = scan_1.scan;
var sequenceEqual_1 = require("../internal/operators/sequenceEqual");
exports.sequenceEqual = sequenceEqual_1.sequenceEqual;
var share_1 = require("../internal/operators/share");
exports.share = share_1.share;
var shareReplay_1 = require("../internal/operators/shareReplay");
exports.shareReplay = shareReplay_1.shareReplay;
var single_1 = require("../internal/operators/single");
exports.single = single_1.single;
var skip_1 = require("../internal/operators/skip");
exports.skip = skip_1.skip;
var skipLast_1 = require("../internal/operators/skipLast");
exports.skipLast = skipLast_1.skipLast;
var skipUntil_1 = require("../internal/operators/skipUntil");
exports.skipUntil = skipUntil_1.skipUntil;
var skipWhile_1 = require("../internal/operators/skipWhile");
exports.skipWhile = skipWhile_1.skipWhile;
var startWith_1 = require("../internal/operators/startWith");
exports.startWith = startWith_1.startWith;
var subscribeOn_1 = require("../internal/operators/subscribeOn");
exports.subscribeOn = subscribeOn_1.subscribeOn;
var switchAll_1 = require("../internal/operators/switchAll");
exports.switchAll = switchAll_1.switchAll;
var switchMap_1 = require("../internal/operators/switchMap");
exports.switchMap = switchMap_1.switchMap;
var switchMapTo_1 = require("../internal/operators/switchMapTo");
exports.switchMapTo = switchMapTo_1.switchMapTo;
var take_1 = require("../internal/operators/take");
exports.take = take_1.take;
var takeLast_1 = require("../internal/operators/takeLast");
exports.takeLast = takeLast_1.takeLast;
var takeUntil_1 = require("../internal/operators/takeUntil");
exports.takeUntil = takeUntil_1.takeUntil;
var takeWhile_1 = require("../internal/operators/takeWhile");
exports.takeWhile = takeWhile_1.takeWhile;
var tap_1 = require("../internal/operators/tap");
exports.tap = tap_1.tap;
var throttle_1 = require("../internal/operators/throttle");
exports.throttle = throttle_1.throttle;
var throttleTime_1 = require("../internal/operators/throttleTime");
exports.throttleTime = throttleTime_1.throttleTime;
var throwIfEmpty_1 = require("../internal/operators/throwIfEmpty");
exports.throwIfEmpty = throwIfEmpty_1.throwIfEmpty;
var timeInterval_1 = require("../internal/operators/timeInterval");
exports.timeInterval = timeInterval_1.timeInterval;
var timeout_1 = require("../internal/operators/timeout");
exports.timeout = timeout_1.timeout;
var timeoutWith_1 = require("../internal/operators/timeoutWith");
exports.timeoutWith = timeoutWith_1.timeoutWith;
var timestamp_1 = require("../internal/operators/timestamp");
exports.timestamp = timestamp_1.timestamp;
var toArray_1 = require("../internal/operators/toArray");
exports.toArray = toArray_1.toArray;
var window_1 = require("../internal/operators/window");
exports.window = window_1.window;
var windowCount_1 = require("../internal/operators/windowCount");
exports.windowCount = windowCount_1.windowCount;
var windowTime_1 = require("../internal/operators/windowTime");
exports.windowTime = windowTime_1.windowTime;
var windowToggle_1 = require("../internal/operators/windowToggle");
exports.windowToggle = windowToggle_1.windowToggle;
var windowWhen_1 = require("../internal/operators/windowWhen");
exports.windowWhen = windowWhen_1.windowWhen;
var withLatestFrom_1 = require("../internal/operators/withLatestFrom");
exports.withLatestFrom = withLatestFrom_1.withLatestFrom;
var zip_1 = require("../internal/operators/zip");
exports.zip = zip_1.zip;
var zipAll_1 = require("../internal/operators/zipAll");
exports.zipAll = zipAll_1.zipAll;

},{"../internal/operators/audit":156,"../internal/operators/auditTime":157,"../internal/operators/buffer":158,"../internal/operators/bufferCount":159,"../internal/operators/bufferTime":160,"../internal/operators/bufferToggle":161,"../internal/operators/bufferWhen":162,"../internal/operators/catchError":163,"../internal/operators/combineAll":164,"../internal/operators/combineLatest":165,"../internal/operators/concat":166,"../internal/operators/concatAll":167,"../internal/operators/concatMap":168,"../internal/operators/concatMapTo":169,"../internal/operators/count":170,"../internal/operators/debounce":171,"../internal/operators/debounceTime":172,"../internal/operators/defaultIfEmpty":173,"../internal/operators/delay":174,"../internal/operators/delayWhen":175,"../internal/operators/dematerialize":176,"../internal/operators/distinct":177,"../internal/operators/distinctUntilChanged":178,"../internal/operators/distinctUntilKeyChanged":179,"../internal/operators/elementAt":180,"../internal/operators/endWith":181,"../internal/operators/every":182,"../internal/operators/exhaust":183,"../internal/operators/exhaustMap":184,"../internal/operators/expand":185,"../internal/operators/filter":186,"../internal/operators/finalize":187,"../internal/operators/find":188,"../internal/operators/findIndex":189,"../internal/operators/first":190,"../internal/operators/groupBy":191,"../internal/operators/ignoreElements":192,"../internal/operators/isEmpty":194,"../internal/operators/last":195,"../internal/operators/map":196,"../internal/operators/mapTo":197,"../internal/operators/materialize":198,"../internal/operators/max":199,"../internal/operators/merge":200,"../internal/operators/mergeAll":201,"../internal/operators/mergeMap":202,"../internal/operators/mergeMapTo":203,"../internal/operators/mergeScan":204,"../internal/operators/min":205,"../internal/operators/multicast":206,"../internal/operators/observeOn":207,"../internal/operators/onErrorResumeNext":208,"../internal/operators/pairwise":209,"../internal/operators/partition":210,"../internal/operators/pluck":211,"../internal/operators/publish":212,"../internal/operators/publishBehavior":213,"../internal/operators/publishLast":214,"../internal/operators/publishReplay":215,"../internal/operators/race":216,"../internal/operators/reduce":217,"../internal/operators/refCount":218,"../internal/operators/repeat":219,"../internal/operators/repeatWhen":220,"../internal/operators/retry":221,"../internal/operators/retryWhen":222,"../internal/operators/sample":223,"../internal/operators/sampleTime":224,"../internal/operators/scan":225,"../internal/operators/sequenceEqual":226,"../internal/operators/share":227,"../internal/operators/shareReplay":228,"../internal/operators/single":229,"../internal/operators/skip":230,"../internal/operators/skipLast":231,"../internal/operators/skipUntil":232,"../internal/operators/skipWhile":233,"../internal/operators/startWith":234,"../internal/operators/subscribeOn":235,"../internal/operators/switchAll":236,"../internal/operators/switchMap":237,"../internal/operators/switchMapTo":238,"../internal/operators/take":239,"../internal/operators/takeLast":240,"../internal/operators/takeUntil":241,"../internal/operators/takeWhile":242,"../internal/operators/tap":243,"../internal/operators/throttle":244,"../internal/operators/throttleTime":245,"../internal/operators/throwIfEmpty":246,"../internal/operators/timeInterval":247,"../internal/operators/timeout":248,"../internal/operators/timeoutWith":249,"../internal/operators/timestamp":250,"../internal/operators/toArray":251,"../internal/operators/window":252,"../internal/operators/windowCount":253,"../internal/operators/windowTime":254,"../internal/operators/windowToggle":255,"../internal/operators/windowWhen":256,"../internal/operators/withLatestFrom":257,"../internal/operators/zip":258,"../internal/operators/zipAll":259}],313:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var utils_1 = require("./utils");
var immutable_text_range_1 = require("./immutable-text-range");
var BasicTextBuffer = /** @class */ (function () {
    function BasicTextBuffer(originalText, lineDelimiter) {
        if (lineDelimiter === void 0) { lineDelimiter = '\n'; }
        this.originalText = originalText;
        this.lineDelimiter = lineDelimiter;
        this.init();
    }
    BasicTextBuffer.prototype.getLineCount = function () {
        return this.table.length;
    };
    BasicTextBuffer.prototype.getText = function () {
        var n = this.table.length;
        var lineBuffer = [];
        for (var line = 0; line < n; line++) {
            lineBuffer.push(this.table[line].join(''));
        }
        return lineBuffer.join(this.lineDelimiter);
    };
    BasicTextBuffer.prototype.replaceRange = function (range, text) {
        range = new immutable_text_range_1.ImmutableTextRange(utils_1.sortRange([range.start, range.end]));
        var table = this.buildTable(text, this.lineDelimiter);
        var endLine = range.end.line;
        if (this.table[range.start.line] !== undefined && this.table[endLine] !== undefined) {
            var removePosition = this.removeRange(range);
            var lastChangedLine = removePosition.line;
            if (!this.lineExists(lastChangedLine)) {
                while (!this.lineExists(lastChangedLine) && lastChangedLine > 0) {
                    lastChangedLine--;
                }
                if (this.lineExists(lastChangedLine)) {
                    this.table.push([]);
                    lastChangedLine++;
                }
                else {
                    // If text is empty
                    this.table[lastChangedLine] = [];
                }
            }
            var lastChangedCol = removePosition.column;
            var startPos = { column: lastChangedCol, line: lastChangedLine };
            var endPos = { column: 0, line: lastChangedLine };
            var n = table.length;
            for (var i = 0; i < n; i++) {
                if (n === 1) {
                    var chars = text.split('');
                    for (var j = 0; j < table[i].length; j++) {
                        endPos.column = lastChangedCol + j + 1;
                        var ch = chars[j];
                        this.table[lastChangedLine + i].splice(j + lastChangedCol, 0, ch);
                    }
                }
                else if (i === (n - 1)) {
                    endPos.line = lastChangedLine + i;
                    for (var j = 0; j < table[i].length; j++) {
                        endPos.column = lastChangedCol + j + 1;
                        var ch = table[i][j];
                        this.table[lastChangedLine + i].splice(j, 0, ch);
                    }
                }
                else {
                    if (i === 0) {
                        this.insertText(lastChangedCol, lastChangedLine, table[i].join('') + this.lineDelimiter);
                    }
                    else {
                        this.table.splice(lastChangedLine + i, 0, table[i]);
                    }
                }
            }
            var newRange = new immutable_text_range_1.ImmutableTextRange(utils_1.sortRange([startPos, endPos]));
            return newRange;
        }
        else {
            return undefined;
        }
    };
    BasicTextBuffer.prototype.removeRange = function (range) {
        range = new immutable_text_range_1.ImmutableTextRange(utils_1.sortRange([range.start, range.end]));
        var start = range.start;
        var end = range.end;
        var line = start.line;
        var startCol = start.column;
        var prefixChars = [];
        for (var i = start.line; i <= end.line; i++) {
            if (i > start.line) {
                if (this.isLineEmpty(line)) {
                    this.removeLine(line);
                }
            }
            var colEnd = (i === end.line) ? end.column : this.getColumnCount(line);
            for (var col = startCol; col < colEnd; col++) {
                this.removeColumn(startCol, line);
            }
            if (!this.isLineEmpty(line)) {
                if (i !== end.line) {
                    prefixChars = this.table[line];
                    this.removeLine(line);
                    startCol = 0;
                }
                else {
                    this.table[line] = prefixChars.concat(this.table[line]);
                }
            }
        }
        return { line: line, column: (prefixChars.length > 0) ? prefixChars.length : startCol };
    };
    BasicTextBuffer.prototype.getRangeText = function (range) {
        var linesBuffer = [];
        range = new immutable_text_range_1.ImmutableTextRange(utils_1.sortRange([range.start, range.end]));
        var start = range.start;
        var end = range.end;
        for (var line = start.line; line <= end.line; line++) {
            var colEnd = (line === end.line) ? end.column : this.getColumnCount(line);
            var chars = [];
            for (var col = start.column; col < colEnd; col++) {
                var ch = this.charAt(col, line);
                if (ch !== undefined) {
                    chars.push(ch);
                }
                else {
                    break;
                }
            }
            linesBuffer.push(chars.join(''));
        }
        return linesBuffer.join('\n');
    };
    BasicTextBuffer.prototype.removeLineRange = function (lineStart, lineEnd) {
        for (var line = lineStart; line <= lineEnd; line++) {
            this.removeLine(lineStart);
        }
    };
    BasicTextBuffer.prototype.removeFirstLine = function () {
        this.removeLine(0);
    };
    BasicTextBuffer.prototype.removeLastLine = function () {
        this.removeLine(this.getLineCount() - 1);
    };
    BasicTextBuffer.prototype.removeLine = function (line) {
        this.table.splice(line, 1);
    };
    BasicTextBuffer.prototype.isLineEmpty = function (line) {
        return this.table[line] && this.table[line].length === 0;
    };
    BasicTextBuffer.prototype.replaceTextInLine = function (line, lineText) {
        var table = this.buildTable(lineText, this.lineDelimiter);
        this.table[line] = table[0];
    };
    BasicTextBuffer.prototype.insertTextAtLine = function (line, text) {
        var table = this.buildTable(text, this.lineDelimiter);
        for (var i = 0; i < table.length; i++) {
            var chars = table[i];
            this.table.splice(line + i, 0, chars);
        }
    };
    BasicTextBuffer.prototype.lineExists = function (line) {
        return this.table[line] !== undefined;
    };
    BasicTextBuffer.prototype.getLine = function (line) {
        return this.table[line].join('');
    };
    BasicTextBuffer.prototype.getLineRange = function (lineStart, lineEnd) {
        var sb = [];
        for (var line = lineStart; line < lineEnd; line++) {
            sb.push(this.getLine(line));
        }
        return sb.join('\n');
    };
    BasicTextBuffer.prototype.columnExists = function (column, line) {
        return this.table[column][line] !== undefined;
    };
    BasicTextBuffer.prototype.getColumnCount = function (line) {
        if (this.table[line] !== undefined) {
            return this.table[line].length;
        }
        return -1;
    };
    BasicTextBuffer.prototype.charAt = function (column, line) {
        return this.table[line][column];
    };
    BasicTextBuffer.prototype.insertText = function (column, line, text) {
        var table = this.buildTable(text, this.lineDelimiter);
        if (table.length > 1) {
            var n = table.length;
            for (var i = 0; i < n; i++) {
                if (i === (n - 1)) {
                    for (var j = 0; j < table[i].length; j++) {
                        var ch = table[i][j];
                        this.table[line].splice(j, 0, ch);
                    }
                }
                else {
                    if (i === 0) {
                        var chars = [];
                        //
                        // Build up a char buffer for columns
                        // that may exist in text before the starting
                        // column.
                        //
                        for (var j = 0; j < column; j++) {
                            chars.push(this.table[line][0]);
                            this.table[line].splice(0, 1);
                        }
                        this.table.splice(line++, 0, chars.concat(table[i]));
                    }
                    else {
                        this.table.splice(line, 0, table[i]);
                        line++;
                    }
                }
            }
        }
        else if (this.table[line]) {
            var chars = text.split('');
            for (var i = 0; i < chars.length; i++) {
                var ch = chars[i];
                this.table[line].splice(column + i, 0, ch);
            }
        }
    };
    BasicTextBuffer.prototype.removeColumn = function (column, line) {
        if (this.table[line]) {
            this.table[line].splice(column, 1);
        }
    };
    BasicTextBuffer.prototype.getColumnRange = function (columnStart, columnEnd, line) {
        var sb = [];
        for (var column = columnStart; column < columnEnd; column++) {
            var ch = this.charAt(column, line);
            if (ch !== undefined) {
                sb.push(ch);
            }
            else {
                break;
            }
        }
        return sb.join('');
    };
    BasicTextBuffer.prototype.removeColumnRange = function (columnStart, columnEnd, line) {
        for (var column = columnStart; column < columnEnd; column++) {
            this.removeColumn(columnStart, line);
        }
    };
    BasicTextBuffer.prototype.init = function () {
        this.table = this.buildTable(this.originalText, this.lineDelimiter);
    };
    BasicTextBuffer.prototype.buildTable = function (text, lineDelimiter) {
        var lines = text.split(lineDelimiter);
        var n = lines.length;
        var table = [];
        for (var line = 0; line < n; line++) {
            table[line] = lines[line].split('');
        }
        return table;
    };
    return BasicTextBuffer;
}());
exports.BasicTextBuffer = BasicTextBuffer;

},{"./immutable-text-range":314,"./utils":317}],314:[function(require,module,exports){
"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var ImmutableTextRange = /** @class */ (function () {
    function ImmutableTextRange(interval) {
        var _a = __read(interval, 2), start = _a[0], end = _a[1];
        this._start = start;
        this._end = end;
    }
    Object.defineProperty(ImmutableTextRange.prototype, "start", {
        get: function () {
            return this._start;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ImmutableTextRange.prototype, "end", {
        get: function () {
            return this._end;
        },
        enumerable: true,
        configurable: true
    });
    return ImmutableTextRange;
}());
exports.ImmutableTextRange = ImmutableTextRange;

},{}],315:[function(require,module,exports){
"use strict";
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
var basic_text_buffer_1 = require("./basic-text-buffer");
var immutable_text_range_1 = require("./immutable-text-range");
__export(require("./basic-text-buffer"));
__export(require("./mutable-text-range"));
__export(require("./immutable-text-range"));
/**
 * Create a Textbuffer
 *
 * @param {string} text
 * @param {string} lineDelimiter
 * @returns {TextBuffer}
 */
function createBuffer(text, lineDelimiter) {
    if (lineDelimiter === void 0) { lineDelimiter = '\n'; }
    return new basic_text_buffer_1.BasicTextBuffer(text, lineDelimiter);
}
exports.createBuffer = createBuffer;
/**
 * Create a TextRange
 *
 * @param {TextPosition} start
 * @param {TextPosition} end
 * @returns {TextRange}
 */
function createTextRange(start, end) {
    return new immutable_text_range_1.ImmutableTextRange([start, end]);
}
exports.createTextRange = createTextRange;

},{"./basic-text-buffer":313,"./immutable-text-range":314,"./mutable-text-range":316}],316:[function(require,module,exports){
"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var utils_1 = require("./utils");
var MutableTextRange = /** @class */ (function () {
    /**
     * @param {[TextPosition , TextPosition]} interval
     * @param {TextBuffer} textBuffer
     */
    function MutableTextRange(interval, textBuffer) {
        this.textBuffer = textBuffer;
        var _a = __read(interval, 2), start = _a[0], end = _a[1];
        this.start = start;
        this.end = end;
    }
    /**
     * Change the text of the range
     *
     * @param {string} text
     */
    MutableTextRange.prototype.setText = function (text) {
        var range = this.textBuffer.replaceRange(this, text);
        this.end = range.end;
        this.start = range.start;
    };
    /**
     * Get the text of the range
     * @returns {string}
     */
    MutableTextRange.prototype.getText = function () {
        return this.textBuffer.getRangeText(this);
    };
    /**
     * Sort the range ensuring that start is less than or equal to end
     * start <= end
     *
     * @returns {MutableTextRange}
     */
    MutableTextRange.prototype.sort = function () {
        var _a = __read(utils_1.sortRange([this.start, this.end]), 2), start = _a[0], end = _a[1];
        this.start = start;
        this.end = end;
        return this;
    };
    /**
     * The range from start to end exists
     *
     * @returns {boolean}
     */
    MutableTextRange.prototype.exists = function () {
        return this.textBuffer.lineExists(this.start.line) &&
            this.textBuffer.columnExists(this.start.column, this.start.line) &&
            this.textBuffer.lineExists(this.end.line) &&
            this.textBuffer.columnExists(this.end.column, this.end.line);
    };
    return MutableTextRange;
}());
exports.MutableTextRange = MutableTextRange;

},{"./utils":317}],317:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function cmp(a, b) {
    return (a.line - b.line) || (a.column - b.column);
}
/**
 * Sort the provided range
 *
 * @param {[TextPosition , TextPosition]} range
 * @returns {[TextPosition , TextPosition]}
 */
function sortRange(range) {
    var start;
    var end;
    // range[0] is less than range[1]
    if (cmp(range[0], range[1]) < 0) {
        start = range[0];
        end = range[1];
    }
    else {
        // range[1] is less than range[0]
        start = range[1];
        end = range[0];
    }
    return [start, end];
}
exports.sortRange = sortRange;

},{}],318:[function(require,module,exports){
"use strict";
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(require("./buffer"));

},{"./buffer":315}],319:[function(require,module,exports){
// Generated from Vtl.g4 by ANTLR 4.8
// jshint ignore: start
var antlr4 = require('antlr4/index');



var serializedATN = ["\u0003\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964",
    "\u0002\u00ef\u08d7\b\u0001\u0004\u0002\t\u0002\u0004\u0003\t\u0003\u0004",
    "\u0004\t\u0004\u0004\u0005\t\u0005\u0004\u0006\t\u0006\u0004\u0007\t",
    "\u0007\u0004\b\t\b\u0004\t\t\t\u0004\n\t\n\u0004\u000b\t\u000b\u0004",
    "\f\t\f\u0004\r\t\r\u0004\u000e\t\u000e\u0004\u000f\t\u000f\u0004\u0010",
    "\t\u0010\u0004\u0011\t\u0011\u0004\u0012\t\u0012\u0004\u0013\t\u0013",
    "\u0004\u0014\t\u0014\u0004\u0015\t\u0015\u0004\u0016\t\u0016\u0004\u0017",
    "\t\u0017\u0004\u0018\t\u0018\u0004\u0019\t\u0019\u0004\u001a\t\u001a",
    "\u0004\u001b\t\u001b\u0004\u001c\t\u001c\u0004\u001d\t\u001d\u0004\u001e",
    "\t\u001e\u0004\u001f\t\u001f\u0004 \t \u0004!\t!\u0004\"\t\"\u0004#",
    "\t#\u0004$\t$\u0004%\t%\u0004&\t&\u0004\'\t\'\u0004(\t(\u0004)\t)\u0004",
    "*\t*\u0004+\t+\u0004,\t,\u0004-\t-\u0004.\t.\u0004/\t/\u00040\t0\u0004",
    "1\t1\u00042\t2\u00043\t3\u00044\t4\u00045\t5\u00046\t6\u00047\t7\u0004",
    "8\t8\u00049\t9\u0004:\t:\u0004;\t;\u0004<\t<\u0004=\t=\u0004>\t>\u0004",
    "?\t?\u0004@\t@\u0004A\tA\u0004B\tB\u0004C\tC\u0004D\tD\u0004E\tE\u0004",
    "F\tF\u0004G\tG\u0004H\tH\u0004I\tI\u0004J\tJ\u0004K\tK\u0004L\tL\u0004",
    "M\tM\u0004N\tN\u0004O\tO\u0004P\tP\u0004Q\tQ\u0004R\tR\u0004S\tS\u0004",
    "T\tT\u0004U\tU\u0004V\tV\u0004W\tW\u0004X\tX\u0004Y\tY\u0004Z\tZ\u0004",
    "[\t[\u0004\\\t\\\u0004]\t]\u0004^\t^\u0004_\t_\u0004`\t`\u0004a\ta\u0004",
    "b\tb\u0004c\tc\u0004d\td\u0004e\te\u0004f\tf\u0004g\tg\u0004h\th\u0004",
    "i\ti\u0004j\tj\u0004k\tk\u0004l\tl\u0004m\tm\u0004n\tn\u0004o\to\u0004",
    "p\tp\u0004q\tq\u0004r\tr\u0004s\ts\u0004t\tt\u0004u\tu\u0004v\tv\u0004",
    "w\tw\u0004x\tx\u0004y\ty\u0004z\tz\u0004{\t{\u0004|\t|\u0004}\t}\u0004",
    "~\t~\u0004\u007f\t\u007f\u0004\u0080\t\u0080\u0004\u0081\t\u0081\u0004",
    "\u0082\t\u0082\u0004\u0083\t\u0083\u0004\u0084\t\u0084\u0004\u0085\t",
    "\u0085\u0004\u0086\t\u0086\u0004\u0087\t\u0087\u0004\u0088\t\u0088\u0004",
    "\u0089\t\u0089\u0004\u008a\t\u008a\u0004\u008b\t\u008b\u0004\u008c\t",
    "\u008c\u0004\u008d\t\u008d\u0004\u008e\t\u008e\u0004\u008f\t\u008f\u0004",
    "\u0090\t\u0090\u0004\u0091\t\u0091\u0004\u0092\t\u0092\u0004\u0093\t",
    "\u0093\u0004\u0094\t\u0094\u0004\u0095\t\u0095\u0004\u0096\t\u0096\u0004",
    "\u0097\t\u0097\u0004\u0098\t\u0098\u0004\u0099\t\u0099\u0004\u009a\t",
    "\u009a\u0004\u009b\t\u009b\u0004\u009c\t\u009c\u0004\u009d\t\u009d\u0004",
    "\u009e\t\u009e\u0004\u009f\t\u009f\u0004\u00a0\t\u00a0\u0004\u00a1\t",
    "\u00a1\u0004\u00a2\t\u00a2\u0004\u00a3\t\u00a3\u0004\u00a4\t\u00a4\u0004",
    "\u00a5\t\u00a5\u0004\u00a6\t\u00a6\u0004\u00a7\t\u00a7\u0004\u00a8\t",
    "\u00a8\u0004\u00a9\t\u00a9\u0004\u00aa\t\u00aa\u0004\u00ab\t\u00ab\u0004",
    "\u00ac\t\u00ac\u0004\u00ad\t\u00ad\u0004\u00ae\t\u00ae\u0004\u00af\t",
    "\u00af\u0004\u00b0\t\u00b0\u0004\u00b1\t\u00b1\u0004\u00b2\t\u00b2\u0004",
    "\u00b3\t\u00b3\u0004\u00b4\t\u00b4\u0004\u00b5\t\u00b5\u0004\u00b6\t",
    "\u00b6\u0004\u00b7\t\u00b7\u0004\u00b8\t\u00b8\u0004\u00b9\t\u00b9\u0004",
    "\u00ba\t\u00ba\u0004\u00bb\t\u00bb\u0004\u00bc\t\u00bc\u0004\u00bd\t",
    "\u00bd\u0004\u00be\t\u00be\u0004\u00bf\t\u00bf\u0004\u00c0\t\u00c0\u0004",
    "\u00c1\t\u00c1\u0004\u00c2\t\u00c2\u0004\u00c3\t\u00c3\u0004\u00c4\t",
    "\u00c4\u0004\u00c5\t\u00c5\u0004\u00c6\t\u00c6\u0004\u00c7\t\u00c7\u0004",
    "\u00c8\t\u00c8\u0004\u00c9\t\u00c9\u0004\u00ca\t\u00ca\u0004\u00cb\t",
    "\u00cb\u0004\u00cc\t\u00cc\u0004\u00cd\t\u00cd\u0004\u00ce\t\u00ce\u0004",
    "\u00cf\t\u00cf\u0004\u00d0\t\u00d0\u0004\u00d1\t\u00d1\u0004\u00d2\t",
    "\u00d2\u0004\u00d3\t\u00d3\u0004\u00d4\t\u00d4\u0004\u00d5\t\u00d5\u0004",
    "\u00d6\t\u00d6\u0004\u00d7\t\u00d7\u0004\u00d8\t\u00d8\u0004\u00d9\t",
    "\u00d9\u0004\u00da\t\u00da\u0004\u00db\t\u00db\u0004\u00dc\t\u00dc\u0004",
    "\u00dd\t\u00dd\u0004\u00de\t\u00de\u0004\u00df\t\u00df\u0004\u00e0\t",
    "\u00e0\u0004\u00e1\t\u00e1\u0004\u00e2\t\u00e2\u0004\u00e3\t\u00e3\u0004",
    "\u00e4\t\u00e4\u0004\u00e5\t\u00e5\u0004\u00e6\t\u00e6\u0004\u00e7\t",
    "\u00e7\u0004\u00e8\t\u00e8\u0004\u00e9\t\u00e9\u0004\u00ea\t\u00ea\u0004",
    "\u00eb\t\u00eb\u0004\u00ec\t\u00ec\u0004\u00ed\t\u00ed\u0004\u00ee\t",
    "\u00ee\u0004\u00ef\t\u00ef\u0004\u00f0\t\u00f0\u0003\u0002\u0003\u0002",
    "\u0003\u0003\u0003\u0003\u0003\u0004\u0003\u0004\u0003\u0005\u0003\u0005",
    "\u0003\u0006\u0003\u0006\u0003\u0007\u0003\u0007\u0003\b\u0003\b\u0003",
    "\t\u0003\t\u0003\n\u0003\n\u0003\u000b\u0003\u000b\u0003\u000b\u0003",
    "\f\u0003\f\u0003\f\u0003\r\u0003\r\u0003\r\u0003\u000e\u0003\u000e\u0003",
    "\u000f\u0003\u000f\u0003\u0010\u0003\u0010\u0003\u0011\u0003\u0011\u0003",
    "\u0012\u0003\u0012\u0003\u0013\u0003\u0013\u0003\u0013\u0003\u0014\u0003",
    "\u0014\u0003\u0014\u0003\u0015\u0003\u0015\u0003\u0016\u0003\u0016\u0003",
    "\u0017\u0003\u0017\u0003\u0017\u0003\u0017\u0003\u0017\u0003\u0018\u0003",
    "\u0018\u0003\u0018\u0003\u0019\u0003\u0019\u0003\u0019\u0003\u0019\u0003",
    "\u0019\u0003\u001a\u0003\u001a\u0003\u001a\u0003\u001a\u0003\u001a\u0003",
    "\u001b\u0003\u001b\u0003\u001b\u0003\u001b\u0003\u001b\u0003\u001b\u0003",
    "\u001c\u0003\u001c\u0003\u001c\u0003\u001c\u0003\u001c\u0003\u001d\u0003",
    "\u001d\u0003\u001d\u0003\u001d\u0003\u001d\u0003\u001d\u0003\u001d\u0003",
    "\u001d\u0003\u001d\u0003\u001d\u0003\u001d\u0003\u001d\u0003\u001d\u0003",
    "\u001e\u0003\u001e\u0003\u001e\u0003\u001f\u0003\u001f\u0003\u001f\u0003",
    "\u001f\u0003\u001f\u0003 \u0003 \u0003 \u0003 \u0003 \u0003!\u0003!",
    "\u0003!\u0003!\u0003!\u0003\"\u0003\"\u0003\"\u0003\"\u0003\"\u0003",
    "\"\u0003\"\u0003\"\u0003\"\u0003#\u0003#\u0003#\u0003#\u0003#\u0003",
    "#\u0003#\u0003$\u0003$\u0003$\u0003%\u0003%\u0003%\u0003%\u0003&\u0003",
    "&\u0003&\u0003\'\u0003\'\u0003\'\u0003\'\u0003(\u0003(\u0003(\u0003",
    "(\u0003)\u0003)\u0003)\u0003)\u0003)\u0003)\u0003)\u0003)\u0003*\u0003",
    "*\u0003*\u0003+\u0003+\u0003+\u0003+\u0003+\u0003+\u0003+\u0003,\u0003",
    ",\u0003,\u0003,\u0003,\u0003-\u0003-\u0003-\u0003-\u0003-\u0003-\u0003",
    "-\u0003.\u0003.\u0003.\u0003/\u0003/\u0003/\u0003/\u0003/\u0003/\u0003",
    "0\u00030\u00030\u00030\u00030\u00031\u00031\u00031\u00031\u00031\u0003",
    "1\u00031\u00031\u00032\u00032\u00032\u00032\u00032\u00032\u00032\u0003",
    "2\u00032\u00032\u00033\u00033\u00033\u00033\u00033\u00034\u00034\u0003",
    "4\u00034\u00034\u00034\u00034\u00034\u00035\u00035\u00035\u00035\u0003",
    "5\u00035\u00035\u00035\u00035\u00036\u00036\u00036\u00036\u00036\u0003",
    "6\u00036\u00037\u00037\u00037\u00037\u00037\u00037\u00038\u00038\u0003",
    "8\u00038\u00038\u00038\u00038\u00038\u00038\u00038\u00039\u00039\u0003",
    "9\u0003:\u0003:\u0003:\u0003:\u0003:\u0003:\u0003:\u0003;\u0003;\u0003",
    ";\u0003;\u0003;\u0003;\u0003;\u0003;\u0003;\u0003;\u0003<\u0003<\u0003",
    "<\u0003<\u0003<\u0003<\u0003<\u0003<\u0003<\u0003<\u0003=\u0003=\u0003",
    "=\u0003=\u0003>\u0003>\u0003>\u0003>\u0003>\u0003?\u0003?\u0003?\u0003",
    "?\u0003?\u0003?\u0003?\u0003?\u0003?\u0003?\u0003?\u0003@\u0003@\u0003",
    "@\u0003@\u0003@\u0003@\u0003A\u0003A\u0003A\u0003B\u0003B\u0003B\u0003",
    "B\u0003B\u0003C\u0003C\u0003C\u0003C\u0003D\u0003D\u0003D\u0003D\u0003",
    "D\u0003E\u0003E\u0003E\u0003E\u0003F\u0003F\u0003F\u0003F\u0003G\u0003",
    "G\u0003G\u0003G\u0003G\u0003G\u0003H\u0003H\u0003H\u0003H\u0003H\u0003",
    "I\u0003I\u0003I\u0003I\u0003I\u0003I\u0003I\u0003I\u0003J\u0003J\u0003",
    "J\u0003J\u0003K\u0003K\u0003K\u0003K\u0003L\u0003L\u0003L\u0003M\u0003",
    "M\u0003M\u0003M\u0003N\u0003N\u0003N\u0003N\u0003N\u0003N\u0003O\u0003",
    "O\u0003O\u0003O\u0003O\u0003O\u0003P\u0003P\u0003P\u0003P\u0003P\u0003",
    "P\u0003Q\u0003Q\u0003Q\u0003Q\u0003R\u0003R\u0003R\u0003R\u0003R\u0003",
    "R\u0003R\u0003S\u0003S\u0003S\u0003T\u0003T\u0003T\u0003T\u0003T\u0003",
    "U\u0003U\u0003U\u0003U\u0003U\u0003U\u0003V\u0003V\u0003V\u0003V\u0003",
    "V\u0003V\u0003W\u0003W\u0003W\u0003W\u0003W\u0003W\u0003W\u0003X\u0003",
    "X\u0003X\u0003X\u0003Y\u0003Y\u0003Y\u0003Y\u0003Z\u0003Z\u0003Z\u0003",
    "Z\u0003Z\u0003Z\u0003Z\u0003[\u0003[\u0003[\u0003[\u0003[\u0003[\u0003",
    "\\\u0003\\\u0003\\\u0003\\\u0003\\\u0003\\\u0003\\\u0003\\\u0003\\\u0003",
    "\\\u0003\\\u0003]\u0003]\u0003]\u0003]\u0003]\u0003]\u0003]\u0003]\u0003",
    "^\u0003^\u0003^\u0003^\u0003^\u0003^\u0003^\u0003^\u0003^\u0003^\u0003",
    "_\u0003_\u0003_\u0003_\u0003_\u0003_\u0003_\u0003`\u0003`\u0003`\u0003",
    "`\u0003`\u0003`\u0003a\u0003a\u0003a\u0003a\u0003b\u0003b\u0003b\u0003",
    "b\u0003b\u0003b\u0003b\u0003b\u0003b\u0003b\u0003b\u0003b\u0003b\u0003",
    "b\u0003c\u0003c\u0003c\u0003c\u0003c\u0003c\u0003d\u0003d\u0003d\u0003",
    "d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003d\u0003",
    "d\u0003d\u0003d\u0003d\u0003e\u0003e\u0003e\u0003e\u0003e\u0003f\u0003",
    "f\u0003f\u0003f\u0003g\u0003g\u0003g\u0003g\u0003g\u0003g\u0003g\u0003",
    "g\u0003g\u0003g\u0003h\u0003h\u0003i\u0003i\u0003i\u0003i\u0003i\u0003",
    "i\u0003i\u0003i\u0003j\u0003j\u0003j\u0003j\u0003j\u0003j\u0003j\u0003",
    "j\u0003j\u0003j\u0003j\u0003j\u0003k\u0003k\u0003k\u0003k\u0003k\u0003",
    "k\u0003k\u0003k\u0003k\u0003l\u0003l\u0003l\u0003l\u0003l\u0003m\u0003",
    "m\u0003m\u0003m\u0003m\u0003m\u0003m\u0003m\u0003m\u0003m\u0003n\u0003",
    "n\u0003n\u0003n\u0003n\u0003n\u0003n\u0003n\u0003o\u0003o\u0003o\u0003",
    "o\u0003o\u0003o\u0003o\u0003o\u0003o\u0003p\u0003p\u0003p\u0003p\u0003",
    "p\u0003p\u0003p\u0003q\u0003q\u0003q\u0003r\u0003r\u0003r\u0003r\u0003",
    "r\u0003r\u0003r\u0003r\u0003r\u0003r\u0003s\u0003s\u0003s\u0003s\u0003",
    "s\u0003s\u0003s\u0003s\u0003s\u0003s\u0003s\u0003s\u0003s\u0003t\u0003",
    "t\u0003t\u0003t\u0003t\u0003t\u0003t\u0003t\u0003u\u0003u\u0003u\u0003",
    "u\u0003u\u0003v\u0003v\u0003v\u0003v\u0003w\u0003w\u0003w\u0003w\u0003",
    "w\u0003w\u0003w\u0003w\u0003w\u0003w\u0003w\u0003w\u0003w\u0003x\u0003",
    "x\u0003x\u0003x\u0003x\u0003x\u0003y\u0003y\u0003y\u0003y\u0003y\u0003",
    "y\u0003z\u0003z\u0003z\u0003z\u0003z\u0003z\u0003{\u0003{\u0003{\u0003",
    "{\u0003{\u0003{\u0003{\u0003{\u0003|\u0003|\u0003|\u0003|\u0003|\u0003",
    "}\u0003}\u0003}\u0003}\u0003}\u0003}\u0003~\u0003~\u0003~\u0003~\u0003",
    "~\u0003\u007f\u0003\u007f\u0003\u007f\u0003\u007f\u0003\u0080\u0003",
    "\u0080\u0003\u0080\u0003\u0080\u0003\u0080\u0003\u0080\u0003\u0080\u0003",
    "\u0080\u0003\u0081\u0003\u0081\u0003\u0081\u0003\u0081\u0003\u0081\u0003",
    "\u0081\u0003\u0081\u0003\u0081\u0003\u0081\u0003\u0081\u0003\u0081\u0003",
    "\u0082\u0003\u0082\u0003\u0082\u0003\u0082\u0003\u0082\u0003\u0082\u0003",
    "\u0082\u0003\u0082\u0003\u0082\u0003\u0082\u0003\u0082\u0003\u0082\u0003",
    "\u0083\u0003\u0083\u0003\u0083\u0003\u0083\u0003\u0083\u0003\u0083\u0003",
    "\u0083\u0003\u0083\u0003\u0084\u0003\u0084\u0003\u0084\u0003\u0084\u0003",
    "\u0084\u0003\u0084\u0003\u0084\u0003\u0084\u0003\u0084\u0003\u0085\u0003",
    "\u0085\u0003\u0085\u0003\u0085\u0003\u0085\u0003\u0085\u0003\u0086\u0003",
    "\u0086\u0003\u0086\u0003\u0086\u0003\u0086\u0003\u0086\u0003\u0086\u0003",
    "\u0087\u0003\u0087\u0003\u0087\u0003\u0087\u0003\u0087\u0003\u0087\u0003",
    "\u0087\u0003\u0088\u0003\u0088\u0003\u0088\u0003\u0088\u0003\u0088\u0003",
    "\u0088\u0003\u0088\u0003\u0088\u0003\u0088\u0003\u0088\u0003\u0088\u0003",
    "\u0088\u0003\u0089\u0003\u0089\u0003\u0089\u0003\u0089\u0003\u0089\u0003",
    "\u0089\u0003\u0089\u0003\u0089\u0003\u0089\u0003\u0089\u0003\u0089\u0003",
    "\u008a\u0003\u008a\u0003\u008a\u0003\u008a\u0003\u008b\u0003\u008b\u0003",
    "\u008b\u0003\u008b\u0003\u008b\u0003\u008c\u0003\u008c\u0003\u008c\u0003",
    "\u008c\u0003\u008c\u0003\u008c\u0003\u008c\u0003\u008c\u0003\u008c\u0003",
    "\u008c\u0003\u008c\u0003\u008c\u0003\u008c\u0003\u008c\u0003\u008c\u0003",
    "\u008c\u0003\u008d\u0003\u008d\u0003\u008d\u0003\u008d\u0003\u008d\u0003",
    "\u008e\u0003\u008e\u0003\u008e\u0003\u008e\u0003\u008e\u0003\u008e\u0003",
    "\u008e\u0003\u008e\u0003\u008e\u0003\u008e\u0003\u008f\u0003\u008f\u0003",
    "\u008f\u0003\u008f\u0003\u008f\u0003\u008f\u0003\u008f\u0003\u008f\u0003",
    "\u008f\u0003\u008f\u0003\u0090\u0003\u0090\u0003\u0090\u0003\u0090\u0003",
    "\u0090\u0003\u0090\u0003\u0090\u0003\u0090\u0003\u0090\u0003\u0090\u0003",
    "\u0091\u0003\u0091\u0003\u0091\u0003\u0091\u0003\u0091\u0003\u0091\u0003",
    "\u0091\u0003\u0091\u0003\u0091\u0003\u0091\u0003\u0092\u0003\u0092\u0003",
    "\u0092\u0003\u0092\u0003\u0092\u0003\u0093\u0003\u0093\u0003\u0093\u0003",
    "\u0093\u0003\u0093\u0003\u0093\u0003\u0094\u0003\u0094\u0003\u0094\u0003",
    "\u0094\u0003\u0094\u0003\u0094\u0003\u0094\u0003\u0094\u0003\u0095\u0003",
    "\u0095\u0003\u0095\u0003\u0095\u0003\u0095\u0003\u0095\u0003\u0096\u0003",
    "\u0096\u0003\u0096\u0003\u0096\u0003\u0096\u0003\u0096\u0003\u0096\u0003",
    "\u0096\u0003\u0096\u0003\u0096\u0003\u0096\u0003\u0096\u0003\u0096\u0003",
    "\u0096\u0003\u0096\u0003\u0096\u0003\u0096\u0003\u0097\u0003\u0097\u0003",
    "\u0097\u0003\u0097\u0003\u0097\u0003\u0097\u0003\u0097\u0003\u0097\u0003",
    "\u0097\u0003\u0097\u0003\u0097\u0003\u0097\u0003\u0097\u0003\u0097\u0003",
    "\u0098\u0003\u0098\u0003\u0098\u0003\u0098\u0003\u0098\u0003\u0098\u0003",
    "\u0098\u0003\u0098\u0003\u0098\u0003\u0098\u0003\u0098\u0003\u0098\u0003",
    "\u0098\u0003\u0098\u0003\u0099\u0003\u0099\u0003\u0099\u0003\u0099\u0003",
    "\u0099\u0003\u0099\u0003\u0099\u0003\u0099\u0003\u0099\u0003\u0099\u0003",
    "\u009a\u0003\u009a\u0003\u009a\u0003\u009a\u0003\u009a\u0003\u009a\u0003",
    "\u009a\u0003\u009a\u0003\u009a\u0003\u009b\u0003\u009b\u0003\u009b\u0003",
    "\u009b\u0003\u009b\u0003\u009b\u0003\u009b\u0003\u009b\u0003\u009b\u0003",
    "\u009b\u0003\u009b\u0003\u009b\u0003\u009c\u0003\u009c\u0003\u009c\u0003",
    "\u009c\u0003\u009c\u0003\u009c\u0003\u009c\u0003\u009c\u0003\u009c\u0003",
    "\u009c\u0003\u009d\u0003\u009d\u0003\u009d\u0003\u009d\u0003\u009d\u0003",
    "\u009d\u0003\u009d\u0003\u009d\u0003\u009e\u0003\u009e\u0003\u009e\u0003",
    "\u009e\u0003\u009e\u0003\u009f\u0003\u009f\u0003\u009f\u0003\u009f\u0003",
    "\u009f\u0003\u009f\u0003\u009f\u0003\u009f\u0003\u009f\u0003\u009f\u0003",
    "\u009f\u0003\u009f\u0003\u00a0\u0003\u00a0\u0003\u00a0\u0003\u00a0\u0003",
    "\u00a0\u0003\u00a0\u0003\u00a0\u0003\u00a1\u0003\u00a1\u0003\u00a1\u0003",
    "\u00a1\u0003\u00a1\u0003\u00a1\u0003\u00a1\u0003\u00a2\u0003\u00a2\u0003",
    "\u00a2\u0003\u00a2\u0003\u00a2\u0003\u00a3\u0003\u00a3\u0003\u00a3\u0003",
    "\u00a3\u0003\u00a3\u0003\u00a3\u0003\u00a3\u0003\u00a3\u0003\u00a4\u0003",
    "\u00a4\u0003\u00a4\u0003\u00a4\u0003\u00a4\u0003\u00a4\u0003\u00a5\u0003",
    "\u00a5\u0003\u00a5\u0003\u00a5\u0003\u00a5\u0003\u00a6\u0003\u00a6\u0003",
    "\u00a6\u0003\u00a6\u0003\u00a6\u0003\u00a6\u0003\u00a6\u0003\u00a7\u0003",
    "\u00a7\u0003\u00a7\u0003\u00a7\u0003\u00a7\u0003\u00a7\u0003\u00a7\u0003",
    "\u00a7\u0003\u00a7\u0003\u00a8\u0003\u00a8\u0003\u00a8\u0003\u00a8\u0003",
    "\u00a8\u0003\u00a9\u0003\u00a9\u0003\u00a9\u0003\u00aa\u0003\u00aa\u0003",
    "\u00aa\u0003\u00ab\u0003\u00ab\u0003\u00ab\u0003\u00ab\u0003\u00ab\u0003",
    "\u00ab\u0003\u00ab\u0003\u00ab\u0003\u00ab\u0003\u00ab\u0003\u00ac\u0003",
    "\u00ac\u0003\u00ac\u0003\u00ac\u0003\u00ac\u0003\u00ac\u0003\u00ac\u0003",
    "\u00ad\u0003\u00ad\u0003\u00ad\u0003\u00ae\u0003\u00ae\u0003\u00ae\u0003",
    "\u00ae\u0003\u00ae\u0003\u00af\u0003\u00af\u0003\u00af\u0003\u00af\u0003",
    "\u00af\u0003\u00b0\u0003\u00b0\u0003\u00b0\u0003\u00b0\u0003\u00b0\u0003",
    "\u00b0\u0003\u00b0\u0003\u00b0\u0003\u00b0\u0003\u00b0\u0003\u00b0\u0003",
    "\u00b1\u0003\u00b1\u0003\u00b1\u0003\u00b1\u0003\u00b1\u0003\u00b1\u0003",
    "\u00b1\u0003\u00b2\u0003\u00b2\u0003\u00b2\u0003\u00b2\u0003\u00b2\u0003",
    "\u00b2\u0003\u00b3\u0003\u00b3\u0003\u00b3\u0003\u00b3\u0003\u00b3\u0003",
    "\u00b3\u0003\u00b4\u0003\u00b4\u0003\u00b4\u0003\u00b4\u0003\u00b4\u0003",
    "\u00b4\u0003\u00b4\u0003\u00b4\u0003\u00b5\u0003\u00b5\u0003\u00b5\u0003",
    "\u00b5\u0003\u00b5\u0003\u00b5\u0003\u00b5\u0003\u00b6\u0003\u00b6\u0003",
    "\u00b6\u0003\u00b6\u0003\u00b6\u0003\u00b6\u0003\u00b6\u0003\u00b6\u0003",
    "\u00b6\u0003\u00b6\u0003\u00b6\u0003\u00b7\u0003\u00b7\u0003\u00b7\u0003",
    "\u00b7\u0003\u00b7\u0003\u00b7\u0003\u00b7\u0003\u00b7\u0003\u00b7\u0003",
    "\u00b7\u0003\u00b8\u0003\u00b8\u0003\u00b8\u0003\u00b8\u0003\u00b8\u0003",
    "\u00b8\u0003\u00b8\u0003\u00b8\u0003\u00b8\u0003\u00b8\u0003\u00b8\u0003",
    "\u00b9\u0003\u00b9\u0003\u00b9\u0003\u00b9\u0003\u00b9\u0003\u00b9\u0003",
    "\u00b9\u0003\u00b9\u0003\u00b9\u0003\u00b9\u0003\u00ba\u0003\u00ba\u0003",
    "\u00ba\u0003\u00ba\u0003\u00ba\u0003\u00ba\u0003\u00ba\u0003\u00ba\u0003",
    "\u00ba\u0003\u00ba\u0003\u00bb\u0003\u00bb\u0003\u00bb\u0003\u00bb\u0003",
    "\u00bb\u0003\u00bb\u0003\u00bb\u0003\u00bb\u0003\u00bc\u0003\u00bc\u0003",
    "\u00bc\u0003\u00bc\u0003\u00bc\u0003\u00bc\u0003\u00bc\u0003\u00bd\u0003",
    "\u00bd\u0003\u00bd\u0003\u00bd\u0003\u00bd\u0003\u00bd\u0003\u00bd\u0003",
    "\u00bd\u0003\u00bd\u0003\u00be\u0003\u00be\u0003\u00be\u0003\u00be\u0003",
    "\u00be\u0003\u00be\u0003\u00be\u0003\u00be\u0003\u00bf\u0003\u00bf\u0003",
    "\u00bf\u0003\u00bf\u0003\u00bf\u0003\u00bf\u0003\u00c0\u0003\u00c0\u0003",
    "\u00c0\u0003\u00c0\u0003\u00c0\u0003\u00c0\u0003\u00c0\u0003\u00c0\u0003",
    "\u00c0\u0003\u00c0\u0003\u00c0\u0003\u00c0\u0003\u00c1\u0003\u00c1\u0003",
    "\u00c1\u0003\u00c1\u0003\u00c1\u0003\u00c1\u0003\u00c1\u0003\u00c1\u0003",
    "\u00c2\u0003\u00c2\u0003\u00c2\u0003\u00c2\u0003\u00c3\u0003\u00c3\u0003",
    "\u00c3\u0003\u00c3\u0003\u00c3\u0003\u00c3\u0003\u00c4\u0003\u00c4\u0003",
    "\u00c4\u0003\u00c4\u0003\u00c4\u0003\u00c4\u0003\u00c4\u0003\u00c4\u0003",
    "\u00c4\u0003\u00c4\u0003\u00c4\u0003\u00c4\u0003\u00c5\u0003\u00c5\u0003",
    "\u00c5\u0003\u00c5\u0003\u00c5\u0003\u00c5\u0003\u00c5\u0003\u00c5\u0003",
    "\u00c5\u0003\u00c5\u0003\u00c5\u0003\u00c5\u0003\u00c5\u0003\u00c5\u0003",
    "\u00c5\u0003\u00c5\u0003\u00c5\u0003\u00c6\u0003\u00c6\u0003\u00c6\u0003",
    "\u00c6\u0003\u00c6\u0003\u00c6\u0003\u00c6\u0003\u00c7\u0003\u00c7\u0003",
    "\u00c7\u0003\u00c7\u0003\u00c7\u0003\u00c7\u0003\u00c7\u0003\u00c7\u0003",
    "\u00c7\u0003\u00c8\u0003\u00c8\u0003\u00c8\u0003\u00c8\u0003\u00c8\u0003",
    "\u00c8\u0003\u00c8\u0003\u00c8\u0003\u00c8\u0003\u00c9\u0003\u00c9\u0003",
    "\u00c9\u0003\u00c9\u0003\u00c9\u0003\u00ca\u0003\u00ca\u0003\u00ca\u0003",
    "\u00ca\u0003\u00ca\u0003\u00ca\u0003\u00cb\u0003\u00cb\u0003\u00cb\u0003",
    "\u00cb\u0003\u00cb\u0003\u00cb\u0003\u00cb\u0003\u00cb\u0003\u00cb\u0003",
    "\u00cb\u0003\u00cb\u0003\u00cb\u0003\u00cb\u0003\u00cc\u0003\u00cc\u0003",
    "\u00cc\u0003\u00cc\u0003\u00cc\u0003\u00cc\u0003\u00cc\u0003\u00cc\u0003",
    "\u00cc\u0003\u00cc\u0003\u00cd\u0003\u00cd\u0003\u00cd\u0003\u00cd\u0003",
    "\u00cd\u0003\u00cd\u0003\u00ce\u0003\u00ce\u0003\u00ce\u0003\u00ce\u0003",
    "\u00ce\u0003\u00ce\u0003\u00ce\u0003\u00cf\u0003\u00cf\u0003\u00cf\u0003",
    "\u00cf\u0003\u00cf\u0003\u00d0\u0003\u00d0\u0003\u00d0\u0003\u00d0\u0003",
    "\u00d0\u0003\u00d0\u0003\u00d0\u0003\u00d0\u0003\u00d0\u0003\u00d0\u0003",
    "\u00d0\u0003\u00d0\u0003\u00d0\u0003\u00d0\u0003\u00d1\u0003\u00d1\u0003",
    "\u00d1\u0003\u00d1\u0003\u00d1\u0003\u00d1\u0003\u00d1\u0003\u00d1\u0003",
    "\u00d1\u0003\u00d1\u0003\u00d1\u0003\u00d1\u0003\u00d1\u0003\u00d1\u0003",
    "\u00d1\u0003\u00d1\u0003\u00d1\u0003\u00d2\u0003\u00d2\u0003\u00d2\u0003",
    "\u00d2\u0003\u00d2\u0003\u00d2\u0003\u00d2\u0003\u00d2\u0003\u00d3\u0003",
    "\u00d3\u0003\u00d3\u0003\u00d3\u0003\u00d3\u0003\u00d3\u0003\u00d3\u0003",
    "\u00d3\u0003\u00d3\u0003\u00d3\u0003\u00d3\u0003\u00d3\u0003\u00d3\u0003",
    "\u00d3\u0003\u00d3\u0003\u00d3\u0003\u00d4\u0003\u00d4\u0003\u00d4\u0003",
    "\u00d4\u0003\u00d4\u0003\u00d4\u0003\u00d4\u0003\u00d4\u0003\u00d4\u0003",
    "\u00d4\u0003\u00d4\u0003\u00d4\u0003\u00d4\u0003\u00d4\u0003\u00d4\u0003",
    "\u00d4\u0003\u00d5\u0003\u00d5\u0003\u00d5\u0003\u00d5\u0003\u00d5\u0003",
    "\u00d5\u0003\u00d5\u0003\u00d5\u0003\u00d5\u0003\u00d6\u0003\u00d6\u0003",
    "\u00d6\u0003\u00d6\u0003\u00d6\u0003\u00d6\u0003\u00d6\u0003\u00d6\u0003",
    "\u00d6\u0003\u00d7\u0003\u00d7\u0003\u00d7\u0003\u00d7\u0003\u00d7\u0003",
    "\u00d7\u0003\u00d7\u0003\u00d7\u0003\u00d7\u0003\u00d8\u0003\u00d8\u0003",
    "\u00d8\u0003\u00d8\u0003\u00d8\u0003\u00d8\u0003\u00d8\u0003\u00d8\u0003",
    "\u00d8\u0003\u00d8\u0003\u00d8\u0003\u00d8\u0003\u00d8\u0003\u00d9\u0003",
    "\u00d9\u0003\u00d9\u0003\u00d9\u0003\u00d9\u0003\u00d9\u0003\u00d9\u0003",
    "\u00d9\u0003\u00d9\u0003\u00d9\u0003\u00d9\u0003\u00d9\u0003\u00d9\u0003",
    "\u00da\u0003\u00da\u0003\u00da\u0003\u00da\u0003\u00da\u0003\u00da\u0003",
    "\u00da\u0003\u00da\u0003\u00da\u0003\u00da\u0003\u00da\u0003\u00da\u0003",
    "\u00db\u0003\u00db\u0003\u00db\u0003\u00db\u0003\u00db\u0003\u00db\u0003",
    "\u00db\u0003\u00db\u0003\u00db\u0003\u00db\u0003\u00db\u0003\u00db\u0003",
    "\u00dc\u0003\u00dc\u0003\u00dc\u0003\u00dc\u0003\u00dc\u0003\u00dc\u0003",
    "\u00dc\u0003\u00dc\u0003\u00dc\u0003\u00dc\u0003\u00dc\u0003\u00dd\u0003",
    "\u00dd\u0003\u00dd\u0003\u00dd\u0003\u00dd\u0003\u00dd\u0003\u00dd\u0003",
    "\u00dd\u0003\u00dd\u0003\u00dd\u0003\u00dd\u0003\u00dd\u0003\u00dd\u0003",
    "\u00de\u0003\u00de\u0003\u00de\u0003\u00de\u0003\u00de\u0003\u00de\u0003",
    "\u00de\u0003\u00df\u0003\u00df\u0003\u00df\u0003\u00df\u0003\u00df\u0003",
    "\u00df\u0003\u00df\u0003\u00df\u0003\u00df\u0003\u00df\u0003\u00e0\u0003",
    "\u00e0\u0003\u00e0\u0003\u00e0\u0003\u00e0\u0003\u00e0\u0003\u00e0\u0003",
    "\u00e0\u0003\u00e0\u0003\u00e0\u0003\u00e0\u0003\u00e0\u0003\u00e0\u0003",
    "\u00e0\u0003\u00e0\u0003\u00e0\u0003\u00e0\u0003\u00e0\u0003\u00e0\u0003",
    "\u00e0\u0003\u00e0\u0003\u00e0\u0003\u00e0\u0003\u00e0\u0003\u00e0\u0003",
    "\u00e0\u0003\u00e1\u0003\u00e1\u0003\u00e1\u0003\u00e1\u0003\u00e1\u0003",
    "\u00e1\u0003\u00e1\u0003\u00e1\u0003\u00e1\u0003\u00e1\u0003\u00e1\u0003",
    "\u00e1\u0003\u00e1\u0003\u00e1\u0003\u00e1\u0003\u00e1\u0003\u00e1\u0003",
    "\u00e1\u0003\u00e1\u0003\u00e1\u0003\u00e1\u0003\u00e1\u0003\u00e1\u0003",
    "\u00e2\u0003\u00e2\u0003\u00e2\u0003\u00e2\u0003\u00e2\u0003\u00e2\u0003",
    "\u00e2\u0003\u00e2\u0003\u00e2\u0003\u00e2\u0003\u00e2\u0003\u00e2\u0003",
    "\u00e2\u0003\u00e2\u0003\u00e2\u0003\u00e2\u0003\u00e2\u0003\u00e2\u0003",
    "\u00e2\u0003\u00e2\u0003\u00e2\u0003\u00e2\u0003\u00e2\u0003\u00e2\u0003",
    "\u00e2\u0003\u00e2\u0003\u00e2\u0003\u00e2\u0003\u00e2\u0003\u00e3\u0003",
    "\u00e3\u0003\u00e3\u0003\u00e3\u0003\u00e3\u0003\u00e3\u0003\u00e3\u0003",
    "\u00e3\u0003\u00e3\u0003\u00e3\u0003\u00e3\u0003\u00e3\u0003\u00e3\u0003",
    "\u00e3\u0003\u00e3\u0003\u00e3\u0003\u00e3\u0003\u00e3\u0003\u00e3\u0003",
    "\u00e3\u0003\u00e3\u0003\u00e3\u0003\u00e3\u0003\u00e3\u0003\u00e3\u0003",
    "\u00e3\u0003\u00e4\u0003\u00e4\u0003\u00e4\u0003\u00e4\u0003\u00e5\u0003",
    "\u00e5\u0003\u00e5\u0003\u00e5\u0003\u00e5\u0003\u00e5\u0003\u00e5\u0003",
    "\u00e5\u0003\u00e5\u0003\u00e6\u0003\u00e6\u0003\u00e7\u0003\u00e7\u0003",
    "\u00e8\u0005\u00e8\u087a\n\u00e8\u0003\u00e8\u0006\u00e8\u087d\n\u00e8",
    "\r\u00e8\u000e\u00e8\u087e\u0003\u00e9\u0003\u00e9\u0003\u00e9\u0007",
    "\u00e9\u0884\n\u00e9\f\u00e9\u000e\u00e9\u0887\u000b\u00e9\u0003\u00ea",
    "\u0003\u00ea\u0003\u00ea\u0003\u00ea\u0003\u00ea\u0003\u00ea\u0003\u00ea",
    "\u0003\u00ea\u0003\u00ea\u0005\u00ea\u0892\n\u00ea\u0003\u00eb\u0003",
    "\u00eb\u0007\u00eb\u0896\n\u00eb\f\u00eb\u000e\u00eb\u0899\u000b\u00eb",
    "\u0003\u00eb\u0003\u00eb\u0003\u00ec\u0003\u00ec\u0007\u00ec\u089f\n",
    "\u00ec\f\u00ec\u000e\u00ec\u08a2\u000b\u00ec\u0003\u00ec\u0003\u00ec",
    "\u0006\u00ec\u08a6\n\u00ec\r\u00ec\u000e\u00ec\u08a7\u0003\u00ec\u0003",
    "\u00ec\u0007\u00ec\u08ac\n\u00ec\f\u00ec\u000e\u00ec\u08af\u000b\u00ec",
    "\u0003\u00ec\u0005\u00ec\u08b2\n\u00ec\u0003\u00ed\u0006\u00ed\u08b5",
    "\n\u00ed\r\u00ed\u000e\u00ed\u08b6\u0003\u00ed\u0003\u00ed\u0003\u00ee",
    "\u0003\u00ee\u0003\u00ef\u0003\u00ef\u0003\u00ef\u0003\u00ef\u0007\u00ef",
    "\u08c1\n\u00ef\f\u00ef\u000e\u00ef\u08c4\u000b\u00ef\u0003\u00ef\u0003",
    "\u00ef\u0003\u00ef\u0003\u00ef\u0003\u00ef\u0003\u00f0\u0003\u00f0\u0003",
    "\u00f0\u0003\u00f0\u0007\u00f0\u08cf\n\u00f0\f\u00f0\u000e\u00f0\u08d2",
    "\u000b\u00f0\u0003\u00f0\u0003\u00f0\u0003\u00f0\u0003\u00f0\u0005\u08ad",
    "\u08c2\u08d0\u0002\u00f1\u0003\u0003\u0005\u0004\u0007\u0005\t\u0006",
    "\u000b\u0007\r\b\u000f\t\u0011\n\u0013\u000b\u0015\f\u0017\r\u0019\u000e",
    "\u001b\u000f\u001d\u0010\u001f\u0011!\u0012#\u0013%\u0014\'\u0015)\u0016",
    "+\u0017-\u0018/\u00191\u001a3\u001b5\u001c7\u001d9\u001e;\u001f= ?!",
    "A\"C#E$G%I&K\'M(O)Q*S+U,W-Y.[/]0_1a2c3e4g5i6k7m8o9q:s;u<w=y>{?}@\u007f",
    "A\u0081B\u0083C\u0085D\u0087E\u0089F\u008bG\u008dH\u008fI\u0091J\u0093",
    "K\u0095L\u0097M\u0099N\u009bO\u009dP\u009fQ\u00a1R\u00a3S\u00a5T\u00a7",
    "U\u00a9V\u00abW\u00adX\u00afY\u00b1Z\u00b3[\u00b5\\\u00b7]\u00b9^\u00bb",
    "_\u00bd`\u00bfa\u00c1b\u00c3c\u00c5d\u00c7e\u00c9f\u00cbg\u00cdh\u00cf",
    "i\u00d1j\u00d3k\u00d5l\u00d7m\u00d9n\u00dbo\u00ddp\u00dfq\u00e1r\u00e3",
    "s\u00e5t\u00e7u\u00e9v\u00ebw\u00edx\u00efy\u00f1z\u00f3{\u00f5|\u00f7",
    "}\u00f9~\u00fb\u007f\u00fd\u0080\u00ff\u0081\u0101\u0082\u0103\u0083",
    "\u0105\u0084\u0107\u0085\u0109\u0086\u010b\u0087\u010d\u0088\u010f\u0089",
    "\u0111\u008a\u0113\u008b\u0115\u008c\u0117\u008d\u0119\u008e\u011b\u008f",
    "\u011d\u0090\u011f\u0091\u0121\u0092\u0123\u0093\u0125\u0094\u0127\u0095",
    "\u0129\u0096\u012b\u0097\u012d\u0098\u012f\u0099\u0131\u009a\u0133\u009b",
    "\u0135\u009c\u0137\u009d\u0139\u009e\u013b\u009f\u013d\u00a0\u013f\u00a1",
    "\u0141\u00a2\u0143\u00a3\u0145\u00a4\u0147\u00a5\u0149\u00a6\u014b\u00a7",
    "\u014d\u00a8\u014f\u00a9\u0151\u00aa\u0153\u00ab\u0155\u00ac\u0157\u00ad",
    "\u0159\u00ae\u015b\u00af\u015d\u00b0\u015f\u00b1\u0161\u00b2\u0163\u00b3",
    "\u0165\u00b4\u0167\u00b5\u0169\u00b6\u016b\u00b7\u016d\u00b8\u016f\u00b9",
    "\u0171\u00ba\u0173\u00bb\u0175\u00bc\u0177\u00bd\u0179\u00be\u017b\u00bf",
    "\u017d\u00c0\u017f\u00c1\u0181\u00c2\u0183\u00c3\u0185\u00c4\u0187\u00c5",
    "\u0189\u00c6\u018b\u00c7\u018d\u00c8\u018f\u00c9\u0191\u00ca\u0193\u00cb",
    "\u0195\u00cc\u0197\u00cd\u0199\u00ce\u019b\u00cf\u019d\u00d0\u019f\u00d1",
    "\u01a1\u00d2\u01a3\u00d3\u01a5\u00d4\u01a7\u00d5\u01a9\u00d6\u01ab\u00d7",
    "\u01ad\u00d8\u01af\u00d9\u01b1\u00da\u01b3\u00db\u01b5\u00dc\u01b7\u00dd",
    "\u01b9\u00de\u01bb\u00df\u01bd\u00e0\u01bf\u00e1\u01c1\u00e2\u01c3\u00e3",
    "\u01c5\u00e4\u01c7\u00e5\u01c9\u00e6\u01cb\u0002\u01cd\u0002\u01cf\u00e7",
    "\u01d1\u00e8\u01d3\u00e9\u01d5\u00ea\u01d7\u00eb\u01d9\u00ec\u01db\u00ed",
    "\u01dd\u00ee\u01df\u00ef\u0003\u0002\u0006\u0004\u0002C\\c|\u0003\u0002",
    "$$\u0007\u0002002;C\\aac|\u0005\u0002\u000b\f\u000e\u000f\"\"\u0002",
    "\u08e1\u0002\u0003\u0003\u0002\u0002\u0002\u0002\u0005\u0003\u0002\u0002",
    "\u0002\u0002\u0007\u0003\u0002\u0002\u0002\u0002\t\u0003\u0002\u0002",
    "\u0002\u0002\u000b\u0003\u0002\u0002\u0002\u0002\r\u0003\u0002\u0002",
    "\u0002\u0002\u000f\u0003\u0002\u0002\u0002\u0002\u0011\u0003\u0002\u0002",
    "\u0002\u0002\u0013\u0003\u0002\u0002\u0002\u0002\u0015\u0003\u0002\u0002",
    "\u0002\u0002\u0017\u0003\u0002\u0002\u0002\u0002\u0019\u0003\u0002\u0002",
    "\u0002\u0002\u001b\u0003\u0002\u0002\u0002\u0002\u001d\u0003\u0002\u0002",
    "\u0002\u0002\u001f\u0003\u0002\u0002\u0002\u0002!\u0003\u0002\u0002",
    "\u0002\u0002#\u0003\u0002\u0002\u0002\u0002%\u0003\u0002\u0002\u0002",
    "\u0002\'\u0003\u0002\u0002\u0002\u0002)\u0003\u0002\u0002\u0002\u0002",
    "+\u0003\u0002\u0002\u0002\u0002-\u0003\u0002\u0002\u0002\u0002/\u0003",
    "\u0002\u0002\u0002\u00021\u0003\u0002\u0002\u0002\u00023\u0003\u0002",
    "\u0002\u0002\u00025\u0003\u0002\u0002\u0002\u00027\u0003\u0002\u0002",
    "\u0002\u00029\u0003\u0002\u0002\u0002\u0002;\u0003\u0002\u0002\u0002",
    "\u0002=\u0003\u0002\u0002\u0002\u0002?\u0003\u0002\u0002\u0002\u0002",
    "A\u0003\u0002\u0002\u0002\u0002C\u0003\u0002\u0002\u0002\u0002E\u0003",
    "\u0002\u0002\u0002\u0002G\u0003\u0002\u0002\u0002\u0002I\u0003\u0002",
    "\u0002\u0002\u0002K\u0003\u0002\u0002\u0002\u0002M\u0003\u0002\u0002",
    "\u0002\u0002O\u0003\u0002\u0002\u0002\u0002Q\u0003\u0002\u0002\u0002",
    "\u0002S\u0003\u0002\u0002\u0002\u0002U\u0003\u0002\u0002\u0002\u0002",
    "W\u0003\u0002\u0002\u0002\u0002Y\u0003\u0002\u0002\u0002\u0002[\u0003",
    "\u0002\u0002\u0002\u0002]\u0003\u0002\u0002\u0002\u0002_\u0003\u0002",
    "\u0002\u0002\u0002a\u0003\u0002\u0002\u0002\u0002c\u0003\u0002\u0002",
    "\u0002\u0002e\u0003\u0002\u0002\u0002\u0002g\u0003\u0002\u0002\u0002",
    "\u0002i\u0003\u0002\u0002\u0002\u0002k\u0003\u0002\u0002\u0002\u0002",
    "m\u0003\u0002\u0002\u0002\u0002o\u0003\u0002\u0002\u0002\u0002q\u0003",
    "\u0002\u0002\u0002\u0002s\u0003\u0002\u0002\u0002\u0002u\u0003\u0002",
    "\u0002\u0002\u0002w\u0003\u0002\u0002\u0002\u0002y\u0003\u0002\u0002",
    "\u0002\u0002{\u0003\u0002\u0002\u0002\u0002}\u0003\u0002\u0002\u0002",
    "\u0002\u007f\u0003\u0002\u0002\u0002\u0002\u0081\u0003\u0002\u0002\u0002",
    "\u0002\u0083\u0003\u0002\u0002\u0002\u0002\u0085\u0003\u0002\u0002\u0002",
    "\u0002\u0087\u0003\u0002\u0002\u0002\u0002\u0089\u0003\u0002\u0002\u0002",
    "\u0002\u008b\u0003\u0002\u0002\u0002\u0002\u008d\u0003\u0002\u0002\u0002",
    "\u0002\u008f\u0003\u0002\u0002\u0002\u0002\u0091\u0003\u0002\u0002\u0002",
    "\u0002\u0093\u0003\u0002\u0002\u0002\u0002\u0095\u0003\u0002\u0002\u0002",
    "\u0002\u0097\u0003\u0002\u0002\u0002\u0002\u0099\u0003\u0002\u0002\u0002",
    "\u0002\u009b\u0003\u0002\u0002\u0002\u0002\u009d\u0003\u0002\u0002\u0002",
    "\u0002\u009f\u0003\u0002\u0002\u0002\u0002\u00a1\u0003\u0002\u0002\u0002",
    "\u0002\u00a3\u0003\u0002\u0002\u0002\u0002\u00a5\u0003\u0002\u0002\u0002",
    "\u0002\u00a7\u0003\u0002\u0002\u0002\u0002\u00a9\u0003\u0002\u0002\u0002",
    "\u0002\u00ab\u0003\u0002\u0002\u0002\u0002\u00ad\u0003\u0002\u0002\u0002",
    "\u0002\u00af\u0003\u0002\u0002\u0002\u0002\u00b1\u0003\u0002\u0002\u0002",
    "\u0002\u00b3\u0003\u0002\u0002\u0002\u0002\u00b5\u0003\u0002\u0002\u0002",
    "\u0002\u00b7\u0003\u0002\u0002\u0002\u0002\u00b9\u0003\u0002\u0002\u0002",
    "\u0002\u00bb\u0003\u0002\u0002\u0002\u0002\u00bd\u0003\u0002\u0002\u0002",
    "\u0002\u00bf\u0003\u0002\u0002\u0002\u0002\u00c1\u0003\u0002\u0002\u0002",
    "\u0002\u00c3\u0003\u0002\u0002\u0002\u0002\u00c5\u0003\u0002\u0002\u0002",
    "\u0002\u00c7\u0003\u0002\u0002\u0002\u0002\u00c9\u0003\u0002\u0002\u0002",
    "\u0002\u00cb\u0003\u0002\u0002\u0002\u0002\u00cd\u0003\u0002\u0002\u0002",
    "\u0002\u00cf\u0003\u0002\u0002\u0002\u0002\u00d1\u0003\u0002\u0002\u0002",
    "\u0002\u00d3\u0003\u0002\u0002\u0002\u0002\u00d5\u0003\u0002\u0002\u0002",
    "\u0002\u00d7\u0003\u0002\u0002\u0002\u0002\u00d9\u0003\u0002\u0002\u0002",
    "\u0002\u00db\u0003\u0002\u0002\u0002\u0002\u00dd\u0003\u0002\u0002\u0002",
    "\u0002\u00df\u0003\u0002\u0002\u0002\u0002\u00e1\u0003\u0002\u0002\u0002",
    "\u0002\u00e3\u0003\u0002\u0002\u0002\u0002\u00e5\u0003\u0002\u0002\u0002",
    "\u0002\u00e7\u0003\u0002\u0002\u0002\u0002\u00e9\u0003\u0002\u0002\u0002",
    "\u0002\u00eb\u0003\u0002\u0002\u0002\u0002\u00ed\u0003\u0002\u0002\u0002",
    "\u0002\u00ef\u0003\u0002\u0002\u0002\u0002\u00f1\u0003\u0002\u0002\u0002",
    "\u0002\u00f3\u0003\u0002\u0002\u0002\u0002\u00f5\u0003\u0002\u0002\u0002",
    "\u0002\u00f7\u0003\u0002\u0002\u0002\u0002\u00f9\u0003\u0002\u0002\u0002",
    "\u0002\u00fb\u0003\u0002\u0002\u0002\u0002\u00fd\u0003\u0002\u0002\u0002",
    "\u0002\u00ff\u0003\u0002\u0002\u0002\u0002\u0101\u0003\u0002\u0002\u0002",
    "\u0002\u0103\u0003\u0002\u0002\u0002\u0002\u0105\u0003\u0002\u0002\u0002",
    "\u0002\u0107\u0003\u0002\u0002\u0002\u0002\u0109\u0003\u0002\u0002\u0002",
    "\u0002\u010b\u0003\u0002\u0002\u0002\u0002\u010d\u0003\u0002\u0002\u0002",
    "\u0002\u010f\u0003\u0002\u0002\u0002\u0002\u0111\u0003\u0002\u0002\u0002",
    "\u0002\u0113\u0003\u0002\u0002\u0002\u0002\u0115\u0003\u0002\u0002\u0002",
    "\u0002\u0117\u0003\u0002\u0002\u0002\u0002\u0119\u0003\u0002\u0002\u0002",
    "\u0002\u011b\u0003\u0002\u0002\u0002\u0002\u011d\u0003\u0002\u0002\u0002",
    "\u0002\u011f\u0003\u0002\u0002\u0002\u0002\u0121\u0003\u0002\u0002\u0002",
    "\u0002\u0123\u0003\u0002\u0002\u0002\u0002\u0125\u0003\u0002\u0002\u0002",
    "\u0002\u0127\u0003\u0002\u0002\u0002\u0002\u0129\u0003\u0002\u0002\u0002",
    "\u0002\u012b\u0003\u0002\u0002\u0002\u0002\u012d\u0003\u0002\u0002\u0002",
    "\u0002\u012f\u0003\u0002\u0002\u0002\u0002\u0131\u0003\u0002\u0002\u0002",
    "\u0002\u0133\u0003\u0002\u0002\u0002\u0002\u0135\u0003\u0002\u0002\u0002",
    "\u0002\u0137\u0003\u0002\u0002\u0002\u0002\u0139\u0003\u0002\u0002\u0002",
    "\u0002\u013b\u0003\u0002\u0002\u0002\u0002\u013d\u0003\u0002\u0002\u0002",
    "\u0002\u013f\u0003\u0002\u0002\u0002\u0002\u0141\u0003\u0002\u0002\u0002",
    "\u0002\u0143\u0003\u0002\u0002\u0002\u0002\u0145\u0003\u0002\u0002\u0002",
    "\u0002\u0147\u0003\u0002\u0002\u0002\u0002\u0149\u0003\u0002\u0002\u0002",
    "\u0002\u014b\u0003\u0002\u0002\u0002\u0002\u014d\u0003\u0002\u0002\u0002",
    "\u0002\u014f\u0003\u0002\u0002\u0002\u0002\u0151\u0003\u0002\u0002\u0002",
    "\u0002\u0153\u0003\u0002\u0002\u0002\u0002\u0155\u0003\u0002\u0002\u0002",
    "\u0002\u0157\u0003\u0002\u0002\u0002\u0002\u0159\u0003\u0002\u0002\u0002",
    "\u0002\u015b\u0003\u0002\u0002\u0002\u0002\u015d\u0003\u0002\u0002\u0002",
    "\u0002\u015f\u0003\u0002\u0002\u0002\u0002\u0161\u0003\u0002\u0002\u0002",
    "\u0002\u0163\u0003\u0002\u0002\u0002\u0002\u0165\u0003\u0002\u0002\u0002",
    "\u0002\u0167\u0003\u0002\u0002\u0002\u0002\u0169\u0003\u0002\u0002\u0002",
    "\u0002\u016b\u0003\u0002\u0002\u0002\u0002\u016d\u0003\u0002\u0002\u0002",
    "\u0002\u016f\u0003\u0002\u0002\u0002\u0002\u0171\u0003\u0002\u0002\u0002",
    "\u0002\u0173\u0003\u0002\u0002\u0002\u0002\u0175\u0003\u0002\u0002\u0002",
    "\u0002\u0177\u0003\u0002\u0002\u0002\u0002\u0179\u0003\u0002\u0002\u0002",
    "\u0002\u017b\u0003\u0002\u0002\u0002\u0002\u017d\u0003\u0002\u0002\u0002",
    "\u0002\u017f\u0003\u0002\u0002\u0002\u0002\u0181\u0003\u0002\u0002\u0002",
    "\u0002\u0183\u0003\u0002\u0002\u0002\u0002\u0185\u0003\u0002\u0002\u0002",
    "\u0002\u0187\u0003\u0002\u0002\u0002\u0002\u0189\u0003\u0002\u0002\u0002",
    "\u0002\u018b\u0003\u0002\u0002\u0002\u0002\u018d\u0003\u0002\u0002\u0002",
    "\u0002\u018f\u0003\u0002\u0002\u0002\u0002\u0191\u0003\u0002\u0002\u0002",
    "\u0002\u0193\u0003\u0002\u0002\u0002\u0002\u0195\u0003\u0002\u0002\u0002",
    "\u0002\u0197\u0003\u0002\u0002\u0002\u0002\u0199\u0003\u0002\u0002\u0002",
    "\u0002\u019b\u0003\u0002\u0002\u0002\u0002\u019d\u0003\u0002\u0002\u0002",
    "\u0002\u019f\u0003\u0002\u0002\u0002\u0002\u01a1\u0003\u0002\u0002\u0002",
    "\u0002\u01a3\u0003\u0002\u0002\u0002\u0002\u01a5\u0003\u0002\u0002\u0002",
    "\u0002\u01a7\u0003\u0002\u0002\u0002\u0002\u01a9\u0003\u0002\u0002\u0002",
    "\u0002\u01ab\u0003\u0002\u0002\u0002\u0002\u01ad\u0003\u0002\u0002\u0002",
    "\u0002\u01af\u0003\u0002\u0002\u0002\u0002\u01b1\u0003\u0002\u0002\u0002",
    "\u0002\u01b3\u0003\u0002\u0002\u0002\u0002\u01b5\u0003\u0002\u0002\u0002",
    "\u0002\u01b7\u0003\u0002\u0002\u0002\u0002\u01b9\u0003\u0002\u0002\u0002",
    "\u0002\u01bb\u0003\u0002\u0002\u0002\u0002\u01bd\u0003\u0002\u0002\u0002",
    "\u0002\u01bf\u0003\u0002\u0002\u0002\u0002\u01c1\u0003\u0002\u0002\u0002",
    "\u0002\u01c3\u0003\u0002\u0002\u0002\u0002\u01c5\u0003\u0002\u0002\u0002",
    "\u0002\u01c7\u0003\u0002\u0002\u0002\u0002\u01c9\u0003\u0002\u0002\u0002",
    "\u0002\u01cf\u0003\u0002\u0002\u0002\u0002\u01d1\u0003\u0002\u0002\u0002",
    "\u0002\u01d3\u0003\u0002\u0002\u0002\u0002\u01d5\u0003\u0002\u0002\u0002",
    "\u0002\u01d7\u0003\u0002\u0002\u0002\u0002\u01d9\u0003\u0002\u0002\u0002",
    "\u0002\u01db\u0003\u0002\u0002\u0002\u0002\u01dd\u0003\u0002\u0002\u0002",
    "\u0002\u01df\u0003\u0002\u0002\u0002\u0003\u01e1\u0003\u0002\u0002\u0002",
    "\u0005\u01e3\u0003\u0002\u0002\u0002\u0007\u01e5\u0003\u0002\u0002\u0002",
    "\t\u01e7\u0003\u0002\u0002\u0002\u000b\u01e9\u0003\u0002\u0002\u0002",
    "\r\u01eb\u0003\u0002\u0002\u0002\u000f\u01ed\u0003\u0002\u0002\u0002",
    "\u0011\u01ef\u0003\u0002\u0002\u0002\u0013\u01f1\u0003\u0002\u0002\u0002",
    "\u0015\u01f3\u0003\u0002\u0002\u0002\u0017\u01f6\u0003\u0002\u0002\u0002",
    "\u0019\u01f9\u0003\u0002\u0002\u0002\u001b\u01fc\u0003\u0002\u0002\u0002",
    "\u001d\u01fe\u0003\u0002\u0002\u0002\u001f\u0200\u0003\u0002\u0002\u0002",
    "!\u0202\u0003\u0002\u0002\u0002#\u0204\u0003\u0002\u0002\u0002%\u0206",
    "\u0003\u0002\u0002\u0002\'\u0209\u0003\u0002\u0002\u0002)\u020c\u0003",
    "\u0002\u0002\u0002+\u020e\u0003\u0002\u0002\u0002-\u0210\u0003\u0002",
    "\u0002\u0002/\u0215\u0003\u0002\u0002\u00021\u0218\u0003\u0002\u0002",
    "\u00023\u021d\u0003\u0002\u0002\u00025\u0222\u0003\u0002\u0002\u0002",
    "7\u0228\u0003\u0002\u0002\u00029\u022d\u0003\u0002\u0002\u0002;\u023a",
    "\u0003\u0002\u0002\u0002=\u023d\u0003\u0002\u0002\u0002?\u0242\u0003",
    "\u0002\u0002\u0002A\u0247\u0003\u0002\u0002\u0002C\u024c\u0003\u0002",
    "\u0002\u0002E\u0255\u0003\u0002\u0002\u0002G\u025c\u0003\u0002\u0002",
    "\u0002I\u025f\u0003\u0002\u0002\u0002K\u0263\u0003\u0002\u0002\u0002",
    "M\u0266\u0003\u0002\u0002\u0002O\u026a\u0003\u0002\u0002\u0002Q\u026e",
    "\u0003\u0002\u0002\u0002S\u0276\u0003\u0002\u0002\u0002U\u0279\u0003",
    "\u0002\u0002\u0002W\u0280\u0003\u0002\u0002\u0002Y\u0285\u0003\u0002",
    "\u0002\u0002[\u028c\u0003\u0002\u0002\u0002]\u028f\u0003\u0002\u0002",
    "\u0002_\u0295\u0003\u0002\u0002\u0002a\u029a\u0003\u0002\u0002\u0002",
    "c\u02a2\u0003\u0002\u0002\u0002e\u02ac\u0003\u0002\u0002\u0002g\u02b1",
    "\u0003\u0002\u0002\u0002i\u02b9\u0003\u0002\u0002\u0002k\u02c2\u0003",
    "\u0002\u0002\u0002m\u02c9\u0003\u0002\u0002\u0002o\u02cf\u0003\u0002",
    "\u0002\u0002q\u02d9\u0003\u0002\u0002\u0002s\u02dc\u0003\u0002\u0002",
    "\u0002u\u02e3\u0003\u0002\u0002\u0002w\u02ed\u0003\u0002\u0002\u0002",
    "y\u02f7\u0003\u0002\u0002\u0002{\u02fb\u0003\u0002\u0002\u0002}\u0300",
    "\u0003\u0002\u0002\u0002\u007f\u030b\u0003\u0002\u0002\u0002\u0081\u0311",
    "\u0003\u0002\u0002\u0002\u0083\u0314\u0003\u0002\u0002\u0002\u0085\u0319",
    "\u0003\u0002\u0002\u0002\u0087\u031d\u0003\u0002\u0002\u0002\u0089\u0322",
    "\u0003\u0002\u0002\u0002\u008b\u0326\u0003\u0002\u0002\u0002\u008d\u032a",
    "\u0003\u0002\u0002\u0002\u008f\u0330\u0003\u0002\u0002\u0002\u0091\u0335",
    "\u0003\u0002\u0002\u0002\u0093\u033d\u0003\u0002\u0002\u0002\u0095\u0341",
    "\u0003\u0002\u0002\u0002\u0097\u0345\u0003\u0002\u0002\u0002\u0099\u0348",
    "\u0003\u0002\u0002\u0002\u009b\u034c\u0003\u0002\u0002\u0002\u009d\u0352",
    "\u0003\u0002\u0002\u0002\u009f\u0358\u0003\u0002\u0002\u0002\u00a1\u035e",
    "\u0003\u0002\u0002\u0002\u00a3\u0362\u0003\u0002\u0002\u0002\u00a5\u0369",
    "\u0003\u0002\u0002\u0002\u00a7\u036c\u0003\u0002\u0002\u0002\u00a9\u0371",
    "\u0003\u0002\u0002\u0002\u00ab\u0377\u0003\u0002\u0002\u0002\u00ad\u037d",
    "\u0003\u0002\u0002\u0002\u00af\u0384\u0003\u0002\u0002\u0002\u00b1\u0388",
    "\u0003\u0002\u0002\u0002\u00b3\u038c\u0003\u0002\u0002\u0002\u00b5\u0393",
    "\u0003\u0002\u0002\u0002\u00b7\u0399\u0003\u0002\u0002\u0002\u00b9\u03a4",
    "\u0003\u0002\u0002\u0002\u00bb\u03ac\u0003\u0002\u0002\u0002\u00bd\u03b6",
    "\u0003\u0002\u0002\u0002\u00bf\u03bd\u0003\u0002\u0002\u0002\u00c1\u03c3",
    "\u0003\u0002\u0002\u0002\u00c3\u03c7\u0003\u0002\u0002\u0002\u00c5\u03d5",
    "\u0003\u0002\u0002\u0002\u00c7\u03db\u0003\u0002\u0002\u0002\u00c9\u03ec",
    "\u0003\u0002\u0002\u0002\u00cb\u03f1\u0003\u0002\u0002\u0002\u00cd\u03f5",
    "\u0003\u0002\u0002\u0002\u00cf\u03ff\u0003\u0002\u0002\u0002\u00d1\u0401",
    "\u0003\u0002\u0002\u0002\u00d3\u0409\u0003\u0002\u0002\u0002\u00d5\u0415",
    "\u0003\u0002\u0002\u0002\u00d7\u041e\u0003\u0002\u0002\u0002\u00d9\u0423",
    "\u0003\u0002\u0002\u0002\u00db\u042d\u0003\u0002\u0002\u0002\u00dd\u0435",
    "\u0003\u0002\u0002\u0002\u00df\u043e\u0003\u0002\u0002\u0002\u00e1\u0445",
    "\u0003\u0002\u0002\u0002\u00e3\u0448\u0003\u0002\u0002\u0002\u00e5\u0452",
    "\u0003\u0002\u0002\u0002\u00e7\u045f\u0003\u0002\u0002\u0002\u00e9\u0467",
    "\u0003\u0002\u0002\u0002\u00eb\u046c\u0003\u0002\u0002\u0002\u00ed\u0470",
    "\u0003\u0002\u0002\u0002\u00ef\u047d\u0003\u0002\u0002\u0002\u00f1\u0483",
    "\u0003\u0002\u0002\u0002\u00f3\u0489\u0003\u0002\u0002\u0002\u00f5\u048f",
    "\u0003\u0002\u0002\u0002\u00f7\u0497\u0003\u0002\u0002\u0002\u00f9\u049c",
    "\u0003\u0002\u0002\u0002\u00fb\u04a2\u0003\u0002\u0002\u0002\u00fd\u04a7",
    "\u0003\u0002\u0002\u0002\u00ff\u04ab\u0003\u0002\u0002\u0002\u0101\u04b3",
    "\u0003\u0002\u0002\u0002\u0103\u04be\u0003\u0002\u0002\u0002\u0105\u04ca",
    "\u0003\u0002\u0002\u0002\u0107\u04d2\u0003\u0002\u0002\u0002\u0109\u04db",
    "\u0003\u0002\u0002\u0002\u010b\u04e1\u0003\u0002\u0002\u0002\u010d\u04e8",
    "\u0003\u0002\u0002\u0002\u010f\u04ef\u0003\u0002\u0002\u0002\u0111\u04fb",
    "\u0003\u0002\u0002\u0002\u0113\u0506\u0003\u0002\u0002\u0002\u0115\u050a",
    "\u0003\u0002\u0002\u0002\u0117\u050f\u0003\u0002\u0002\u0002\u0119\u051f",
    "\u0003\u0002\u0002\u0002\u011b\u0524\u0003\u0002\u0002\u0002\u011d\u052e",
    "\u0003\u0002\u0002\u0002\u011f\u0538\u0003\u0002\u0002\u0002\u0121\u0542",
    "\u0003\u0002\u0002\u0002\u0123\u054c\u0003\u0002\u0002\u0002\u0125\u0551",
    "\u0003\u0002\u0002\u0002\u0127\u0557\u0003\u0002\u0002\u0002\u0129\u055f",
    "\u0003\u0002\u0002\u0002\u012b\u0565\u0003\u0002\u0002\u0002\u012d\u0576",
    "\u0003\u0002\u0002\u0002\u012f\u0584\u0003\u0002\u0002\u0002\u0131\u0592",
    "\u0003\u0002\u0002\u0002\u0133\u059c\u0003\u0002\u0002\u0002\u0135\u05a5",
    "\u0003\u0002\u0002\u0002\u0137\u05b1\u0003\u0002\u0002\u0002\u0139\u05bb",
    "\u0003\u0002\u0002\u0002\u013b\u05c3\u0003\u0002\u0002\u0002\u013d\u05c8",
    "\u0003\u0002\u0002\u0002\u013f\u05d4\u0003\u0002\u0002\u0002\u0141\u05db",
    "\u0003\u0002\u0002\u0002\u0143\u05e2\u0003\u0002\u0002\u0002\u0145\u05e7",
    "\u0003\u0002\u0002\u0002\u0147\u05ef\u0003\u0002\u0002\u0002\u0149\u05f5",
    "\u0003\u0002\u0002\u0002\u014b\u05fa\u0003\u0002\u0002\u0002\u014d\u0601",
    "\u0003\u0002\u0002\u0002\u014f\u060a\u0003\u0002\u0002\u0002\u0151\u060f",
    "\u0003\u0002\u0002\u0002\u0153\u0612\u0003\u0002\u0002\u0002\u0155\u0615",
    "\u0003\u0002\u0002\u0002\u0157\u061f\u0003\u0002\u0002\u0002\u0159\u0626",
    "\u0003\u0002\u0002\u0002\u015b\u0629\u0003\u0002\u0002\u0002\u015d\u062e",
    "\u0003\u0002\u0002\u0002\u015f\u0633\u0003\u0002\u0002\u0002\u0161\u063e",
    "\u0003\u0002\u0002\u0002\u0163\u0645\u0003\u0002\u0002\u0002\u0165\u064b",
    "\u0003\u0002\u0002\u0002\u0167\u0651\u0003\u0002\u0002\u0002\u0169\u0659",
    "\u0003\u0002\u0002\u0002\u016b\u0660\u0003\u0002\u0002\u0002\u016d\u066b",
    "\u0003\u0002\u0002\u0002\u016f\u0675\u0003\u0002\u0002\u0002\u0171\u0680",
    "\u0003\u0002\u0002\u0002\u0173\u068a\u0003\u0002\u0002\u0002\u0175\u0694",
    "\u0003\u0002\u0002\u0002\u0177\u069c\u0003\u0002\u0002\u0002\u0179\u06a3",
    "\u0003\u0002\u0002\u0002\u017b\u06ac\u0003\u0002\u0002\u0002\u017d\u06b4",
    "\u0003\u0002\u0002\u0002\u017f\u06ba\u0003\u0002\u0002\u0002\u0181\u06c6",
    "\u0003\u0002\u0002\u0002\u0183\u06ce\u0003\u0002\u0002\u0002\u0185\u06d2",
    "\u0003\u0002\u0002\u0002\u0187\u06d8\u0003\u0002\u0002\u0002\u0189\u06e4",
    "\u0003\u0002\u0002\u0002\u018b\u06f5\u0003\u0002\u0002\u0002\u018d\u06fc",
    "\u0003\u0002\u0002\u0002\u018f\u0705\u0003\u0002\u0002\u0002\u0191\u070e",
    "\u0003\u0002\u0002\u0002\u0193\u0713\u0003\u0002\u0002\u0002\u0195\u0719",
    "\u0003\u0002\u0002\u0002\u0197\u0726\u0003\u0002\u0002\u0002\u0199\u0730",
    "\u0003\u0002\u0002\u0002\u019b\u0736\u0003\u0002\u0002\u0002\u019d\u073d",
    "\u0003\u0002\u0002\u0002\u019f\u0742\u0003\u0002\u0002\u0002\u01a1\u0750",
    "\u0003\u0002\u0002\u0002\u01a3\u0761\u0003\u0002\u0002\u0002\u01a5\u0769",
    "\u0003\u0002\u0002\u0002\u01a7\u0779\u0003\u0002\u0002\u0002\u01a9\u0789",
    "\u0003\u0002\u0002\u0002\u01ab\u0792\u0003\u0002\u0002\u0002\u01ad\u079b",
    "\u0003\u0002\u0002\u0002\u01af\u07a4\u0003\u0002\u0002\u0002\u01b1\u07b1",
    "\u0003\u0002\u0002\u0002\u01b3\u07be\u0003\u0002\u0002\u0002\u01b5\u07ca",
    "\u0003\u0002\u0002\u0002\u01b7\u07d6\u0003\u0002\u0002\u0002\u01b9\u07e1",
    "\u0003\u0002\u0002\u0002\u01bb\u07ee\u0003\u0002\u0002\u0002\u01bd\u07f5",
    "\u0003\u0002\u0002\u0002\u01bf\u07ff\u0003\u0002\u0002\u0002\u01c1\u0819",
    "\u0003\u0002\u0002\u0002\u01c3\u0830\u0003\u0002\u0002\u0002\u01c5\u084d",
    "\u0003\u0002\u0002\u0002\u01c7\u0867\u0003\u0002\u0002\u0002\u01c9\u086b",
    "\u0003\u0002\u0002\u0002\u01cb\u0874\u0003\u0002\u0002\u0002\u01cd\u0876",
    "\u0003\u0002\u0002\u0002\u01cf\u0879\u0003\u0002\u0002\u0002\u01d1\u0880",
    "\u0003\u0002\u0002\u0002\u01d3\u0891\u0003\u0002\u0002\u0002\u01d5\u0893",
    "\u0003\u0002\u0002\u0002\u01d7\u08b1\u0003\u0002\u0002\u0002\u01d9\u08b4",
    "\u0003\u0002\u0002\u0002\u01db\u08ba\u0003\u0002\u0002\u0002\u01dd\u08bc",
    "\u0003\u0002\u0002\u0002\u01df\u08ca\u0003\u0002\u0002\u0002\u01e1\u01e2",
    "\u0007*\u0002\u0002\u01e2\u0004\u0003\u0002\u0002\u0002\u01e3\u01e4",
    "\u0007+\u0002\u0002\u01e4\u0006\u0003\u0002\u0002\u0002\u01e5\u01e6",
    "\u0007]\u0002\u0002\u01e6\b\u0003\u0002\u0002\u0002\u01e7\u01e8\u0007",
    "_\u0002\u0002\u01e8\n\u0003\u0002\u0002\u0002\u01e9\u01ea\u0007}\u0002",
    "\u0002\u01ea\f\u0003\u0002\u0002\u0002\u01eb\u01ec\u0007\u007f\u0002",
    "\u0002\u01ec\u000e\u0003\u0002\u0002\u0002\u01ed\u01ee\u0007?\u0002",
    "\u0002\u01ee\u0010\u0003\u0002\u0002\u0002\u01ef\u01f0\u0007>\u0002",
    "\u0002\u01f0\u0012\u0003\u0002\u0002\u0002\u01f1\u01f2\u0007@\u0002",
    "\u0002\u01f2\u0014\u0003\u0002\u0002\u0002\u01f3\u01f4\u0007@\u0002",
    "\u0002\u01f4\u01f5\u0007?\u0002\u0002\u01f5\u0016\u0003\u0002\u0002",
    "\u0002\u01f6\u01f7\u0007>\u0002\u0002\u01f7\u01f8\u0007@\u0002\u0002",
    "\u01f8\u0018\u0003\u0002\u0002\u0002\u01f9\u01fa\u0007>\u0002\u0002",
    "\u01fa\u01fb\u0007?\u0002\u0002\u01fb\u001a\u0003\u0002\u0002\u0002",
    "\u01fc\u01fd\u0007-\u0002\u0002\u01fd\u001c\u0003\u0002\u0002\u0002",
    "\u01fe\u01ff\u0007/\u0002\u0002\u01ff\u001e\u0003\u0002\u0002\u0002",
    "\u0200\u0201\u0007,\u0002\u0002\u0201 \u0003\u0002\u0002\u0002\u0202",
    "\u0203\u00071\u0002\u0002\u0203\"\u0003\u0002\u0002\u0002\u0204\u0205",
    "\u0007.\u0002\u0002\u0205$\u0003\u0002\u0002\u0002\u0206\u0207\u0007",
    "/\u0002\u0002\u0207\u0208\u0007@\u0002\u0002\u0208&\u0003\u0002\u0002",
    "\u0002\u0209\u020a\u0007<\u0002\u0002\u020a\u020b\u0007?\u0002\u0002",
    "\u020b(\u0003\u0002\u0002\u0002\u020c\u020d\u0007%\u0002\u0002\u020d",
    "*\u0003\u0002\u0002\u0002\u020e\u020f\u0007<\u0002\u0002\u020f,\u0003",
    "\u0002\u0002\u0002\u0210\u0211\u0007g\u0002\u0002\u0211\u0212\u0007",
    "x\u0002\u0002\u0212\u0213\u0007c\u0002\u0002\u0213\u0214\u0007n\u0002",
    "\u0002\u0214.\u0003\u0002\u0002\u0002\u0215\u0216\u0007k\u0002\u0002",
    "\u0216\u0217\u0007h\u0002\u0002\u02170\u0003\u0002\u0002\u0002\u0218",
    "\u0219\u0007v\u0002\u0002\u0219\u021a\u0007j\u0002\u0002\u021a\u021b",
    "\u0007g\u0002\u0002\u021b\u021c\u0007p\u0002\u0002\u021c2\u0003\u0002",
    "\u0002\u0002\u021d\u021e\u0007g\u0002\u0002\u021e\u021f\u0007n\u0002",
    "\u0002\u021f\u0220\u0007u\u0002\u0002\u0220\u0221\u0007g\u0002\u0002",
    "\u02214\u0003\u0002\u0002\u0002\u0222\u0223\u0007w\u0002\u0002\u0223",
    "\u0224\u0007u\u0002\u0002\u0224\u0225\u0007k\u0002\u0002\u0225\u0226",
    "\u0007p\u0002\u0002\u0226\u0227\u0007i\u0002\u0002\u02276\u0003\u0002",
    "\u0002\u0002\u0228\u0229\u0007y\u0002\u0002\u0229\u022a\u0007k\u0002",
    "\u0002\u022a\u022b\u0007v\u0002\u0002\u022b\u022c\u0007j\u0002\u0002",
    "\u022c8\u0003\u0002\u0002\u0002\u022d\u022e\u0007e\u0002\u0002\u022e",
    "\u022f\u0007w\u0002\u0002\u022f\u0230\u0007t\u0002\u0002\u0230\u0231",
    "\u0007t\u0002\u0002\u0231\u0232\u0007g\u0002\u0002\u0232\u0233\u0007",
    "p\u0002\u0002\u0233\u0234\u0007v\u0002\u0002\u0234\u0235\u0007a\u0002",
    "\u0002\u0235\u0236\u0007f\u0002\u0002\u0236\u0237\u0007c\u0002\u0002",
    "\u0237\u0238\u0007v\u0002\u0002\u0238\u0239\u0007g\u0002\u0002\u0239",
    ":\u0003\u0002\u0002\u0002\u023a\u023b\u0007q\u0002\u0002\u023b\u023c",
    "\u0007p\u0002\u0002\u023c<\u0003\u0002\u0002\u0002\u023d\u023e\u0007",
    "f\u0002\u0002\u023e\u023f\u0007t\u0002\u0002\u023f\u0240\u0007q\u0002",
    "\u0002\u0240\u0241\u0007r\u0002\u0002\u0241>\u0003\u0002\u0002\u0002",
    "\u0242\u0243\u0007m\u0002\u0002\u0243\u0244\u0007g\u0002\u0002\u0244",
    "\u0245\u0007g\u0002\u0002\u0245\u0246\u0007r\u0002\u0002\u0246@\u0003",
    "\u0002\u0002\u0002\u0247\u0248\u0007e\u0002\u0002\u0248\u0249\u0007",
    "c\u0002\u0002\u0249\u024a\u0007n\u0002\u0002\u024a\u024b\u0007e\u0002",
    "\u0002\u024bB\u0003\u0002\u0002\u0002\u024c\u024d\u0007c\u0002\u0002",
    "\u024d\u024e\u0007v\u0002\u0002\u024e\u024f\u0007v\u0002\u0002\u024f",
    "\u0250\u0007t\u0002\u0002\u0250\u0251\u0007e\u0002\u0002\u0251\u0252",
    "\u0007c\u0002\u0002\u0252\u0253\u0007n\u0002\u0002\u0253\u0254\u0007",
    "e\u0002\u0002\u0254D\u0003\u0002\u0002\u0002\u0255\u0256\u0007t\u0002",
    "\u0002\u0256\u0257\u0007g\u0002\u0002\u0257\u0258\u0007p\u0002\u0002",
    "\u0258\u0259\u0007c\u0002\u0002\u0259\u025a\u0007o\u0002\u0002\u025a",
    "\u025b\u0007g\u0002\u0002\u025bF\u0003\u0002\u0002\u0002\u025c\u025d",
    "\u0007c\u0002\u0002\u025d\u025e\u0007u\u0002\u0002\u025eH\u0003\u0002",
    "\u0002\u0002\u025f\u0260\u0007c\u0002\u0002\u0260\u0261\u0007p\u0002",
    "\u0002\u0261\u0262\u0007f\u0002\u0002\u0262J\u0003\u0002\u0002\u0002",
    "\u0263\u0264\u0007q\u0002\u0002\u0264\u0265\u0007t\u0002\u0002\u0265",
    "L\u0003\u0002\u0002\u0002\u0266\u0267\u0007z\u0002\u0002\u0267\u0268",
    "\u0007q\u0002\u0002\u0268\u0269\u0007t\u0002\u0002\u0269N\u0003\u0002",
    "\u0002\u0002\u026a\u026b\u0007p\u0002\u0002\u026b\u026c\u0007q\u0002",
    "\u0002\u026c\u026d\u0007v\u0002\u0002\u026dP\u0003\u0002\u0002\u0002",
    "\u026e\u026f\u0007d\u0002\u0002\u026f\u0270\u0007g\u0002\u0002\u0270",
    "\u0271\u0007v\u0002\u0002\u0271\u0272\u0007y\u0002\u0002\u0272\u0273",
    "\u0007g\u0002\u0002\u0273\u0274\u0007g\u0002\u0002\u0274\u0275\u0007",
    "p\u0002\u0002\u0275R\u0003\u0002\u0002\u0002\u0276\u0277\u0007k\u0002",
    "\u0002\u0277\u0278\u0007p\u0002\u0002\u0278T\u0003\u0002\u0002\u0002",
    "\u0279\u027a\u0007p\u0002\u0002\u027a\u027b\u0007q\u0002\u0002\u027b",
    "\u027c\u0007v\u0002\u0002\u027c\u027d\u0007a\u0002\u0002\u027d\u027e",
    "\u0007k\u0002\u0002\u027e\u027f\u0007p\u0002\u0002\u027fV\u0003\u0002",
    "\u0002\u0002\u0280\u0281\u0007p\u0002\u0002\u0281\u0282\u0007w\u0002",
    "\u0002\u0282\u0283\u0007n\u0002\u0002\u0283\u0284\u0007n\u0002\u0002",
    "\u0284X\u0003\u0002\u0002\u0002\u0285\u0286\u0007k\u0002\u0002\u0286",
    "\u0287\u0007u\u0002\u0002\u0287\u0288\u0007p\u0002\u0002\u0288\u0289",
    "\u0007w\u0002\u0002\u0289\u028a\u0007n\u0002\u0002\u028a\u028b\u0007",
    "n\u0002\u0002\u028bZ\u0003\u0002\u0002\u0002\u028c\u028d\u0007g\u0002",
    "\u0002\u028d\u028e\u0007z\u0002\u0002\u028e\\\u0003\u0002\u0002\u0002",
    "\u028f\u0290\u0007w\u0002\u0002\u0290\u0291\u0007p\u0002\u0002\u0291",
    "\u0292\u0007k\u0002\u0002\u0292\u0293\u0007q\u0002\u0002\u0293\u0294",
    "\u0007p\u0002\u0002\u0294^\u0003\u0002\u0002\u0002\u0295\u0296\u0007",
    "f\u0002\u0002\u0296\u0297\u0007k\u0002\u0002\u0297\u0298\u0007h\u0002",
    "\u0002\u0298\u0299\u0007h\u0002\u0002\u0299`\u0003\u0002\u0002\u0002",
    "\u029a\u029b\u0007u\u0002\u0002\u029b\u029c\u0007{\u0002\u0002\u029c",
    "\u029d\u0007o\u0002\u0002\u029d\u029e\u0007f\u0002\u0002\u029e\u029f",
    "\u0007k\u0002\u0002\u029f\u02a0\u0007h\u0002\u0002\u02a0\u02a1\u0007",
    "h\u0002\u0002\u02a1b\u0003\u0002\u0002\u0002\u02a2\u02a3\u0007k\u0002",
    "\u0002\u02a3\u02a4\u0007p\u0002\u0002\u02a4\u02a5\u0007v\u0002\u0002",
    "\u02a5\u02a6\u0007g\u0002\u0002\u02a6\u02a7\u0007t\u0002\u0002\u02a7",
    "\u02a8\u0007u\u0002\u0002\u02a8\u02a9\u0007g\u0002\u0002\u02a9\u02aa",
    "\u0007e\u0002\u0002\u02aa\u02ab\u0007v\u0002\u0002\u02abd\u0003\u0002",
    "\u0002\u0002\u02ac\u02ad\u0007m\u0002\u0002\u02ad\u02ae\u0007g\u0002",
    "\u0002\u02ae\u02af\u0007{\u0002\u0002\u02af\u02b0\u0007u\u0002\u0002",
    "\u02b0f\u0003\u0002\u0002\u0002\u02b1\u02b2\u0007k\u0002\u0002\u02b2",
    "\u02b3\u0007p\u0002\u0002\u02b3\u02b4\u0007v\u0002\u0002\u02b4\u02b5",
    "\u0007{\u0002\u0002\u02b5\u02b6\u0007g\u0002\u0002\u02b6\u02b7\u0007",
    "c\u0002\u0002\u02b7\u02b8\u0007t\u0002\u0002\u02b8h\u0003\u0002\u0002",
    "\u0002\u02b9\u02ba\u0007k\u0002\u0002\u02ba\u02bb\u0007p\u0002\u0002",
    "\u02bb\u02bc\u0007v\u0002\u0002\u02bc\u02bd\u0007o\u0002\u0002\u02bd",
    "\u02be\u0007q\u0002\u0002\u02be\u02bf\u0007p\u0002\u0002\u02bf\u02c0",
    "\u0007v\u0002\u0002\u02c0\u02c1\u0007j\u0002\u0002\u02c1j\u0003\u0002",
    "\u0002\u0002\u02c2\u02c3\u0007k\u0002\u0002\u02c3\u02c4\u0007p\u0002",
    "\u0002\u02c4\u02c5\u0007v\u0002\u0002\u02c5\u02c6\u0007f\u0002\u0002",
    "\u02c6\u02c7\u0007c\u0002\u0002\u02c7\u02c8\u0007{\u0002\u0002\u02c8",
    "l\u0003\u0002\u0002\u0002\u02c9\u02ca\u0007e\u0002\u0002\u02ca\u02cb",
    "\u0007j\u0002\u0002\u02cb\u02cc\u0007g\u0002\u0002\u02cc\u02cd\u0007",
    "e\u0002\u0002\u02cd\u02ce\u0007m\u0002\u0002\u02cen\u0003\u0002\u0002",
    "\u0002\u02cf\u02d0\u0007g\u0002\u0002\u02d0\u02d1\u0007z\u0002\u0002",
    "\u02d1\u02d2\u0007k\u0002\u0002\u02d2\u02d3\u0007u\u0002\u0002\u02d3",
    "\u02d4\u0007v\u0002\u0002\u02d4\u02d5\u0007u\u0002\u0002\u02d5\u02d6",
    "\u0007a\u0002\u0002\u02d6\u02d7\u0007k\u0002\u0002\u02d7\u02d8\u0007",
    "p\u0002\u0002\u02d8p\u0003\u0002\u0002\u0002\u02d9\u02da\u0007v\u0002",
    "\u0002\u02da\u02db\u0007q\u0002\u0002\u02dbr\u0003\u0002\u0002\u0002",
    "\u02dc\u02dd\u0007t\u0002\u0002\u02dd\u02de\u0007g\u0002\u0002\u02de",
    "\u02df\u0007v\u0002\u0002\u02df\u02e0\u0007w\u0002\u0002\u02e0\u02e1",
    "\u0007t\u0002\u0002\u02e1\u02e2\u0007p\u0002\u0002\u02e2t\u0003\u0002",
    "\u0002\u0002\u02e3\u02e4\u0007k\u0002\u0002\u02e4\u02e5\u0007o\u0002",
    "\u0002\u02e5\u02e6\u0007d\u0002\u0002\u02e6\u02e7\u0007c\u0002\u0002",
    "\u02e7\u02e8\u0007n\u0002\u0002\u02e8\u02e9\u0007c\u0002\u0002\u02e9",
    "\u02ea\u0007p\u0002\u0002\u02ea\u02eb\u0007e\u0002\u0002\u02eb\u02ec",
    "\u0007g\u0002\u0002\u02ecv\u0003\u0002\u0002\u0002\u02ed\u02ee\u0007",
    "g\u0002\u0002\u02ee\u02ef\u0007t\u0002\u0002\u02ef\u02f0\u0007t\u0002",
    "\u0002\u02f0\u02f1\u0007q\u0002\u0002\u02f1\u02f2\u0007t\u0002\u0002",
    "\u02f2\u02f3\u0007e\u0002\u0002\u02f3\u02f4\u0007q\u0002\u0002\u02f4",
    "\u02f5\u0007f\u0002\u0002\u02f5\u02f6\u0007g\u0002\u0002\u02f6x\u0003",
    "\u0002\u0002\u0002\u02f7\u02f8\u0007c\u0002\u0002\u02f8\u02f9\u0007",
    "n\u0002\u0002\u02f9\u02fa\u0007n\u0002\u0002\u02faz\u0003\u0002\u0002",
    "\u0002\u02fb\u02fc\u0007c\u0002\u0002\u02fc\u02fd\u0007i\u0002\u0002",
    "\u02fd\u02fe\u0007i\u0002\u0002\u02fe\u02ff\u0007t\u0002\u0002\u02ff",
    "|\u0003\u0002\u0002\u0002\u0300\u0301\u0007g\u0002\u0002\u0301\u0302",
    "\u0007t\u0002\u0002\u0302\u0303\u0007t\u0002\u0002\u0303\u0304\u0007",
    "q\u0002\u0002\u0304\u0305\u0007t\u0002\u0002\u0305\u0306\u0007n\u0002",
    "\u0002\u0306\u0307\u0007g\u0002\u0002\u0307\u0308\u0007x\u0002\u0002",
    "\u0308\u0309\u0007g\u0002\u0002\u0309\u030a\u0007n\u0002\u0002\u030a",
    "~\u0003\u0002\u0002\u0002\u030b\u030c\u0007q\u0002\u0002\u030c\u030d",
    "\u0007t\u0002\u0002\u030d\u030e\u0007f\u0002\u0002\u030e\u030f\u0007",
    "g\u0002\u0002\u030f\u0310\u0007t\u0002\u0002\u0310\u0080\u0003\u0002",
    "\u0002\u0002\u0311\u0312\u0007d\u0002\u0002\u0312\u0313\u0007{\u0002",
    "\u0002\u0313\u0082\u0003\u0002\u0002\u0002\u0314\u0315\u0007t\u0002",
    "\u0002\u0315\u0316\u0007c\u0002\u0002\u0316\u0317\u0007p\u0002\u0002",
    "\u0317\u0318\u0007m\u0002\u0002\u0318\u0084\u0003\u0002\u0002\u0002",
    "\u0319\u031a\u0007c\u0002\u0002\u031a\u031b\u0007u\u0002\u0002\u031b",
    "\u031c\u0007e\u0002\u0002\u031c\u0086\u0003\u0002\u0002\u0002\u031d",
    "\u031e\u0007f\u0002\u0002\u031e\u031f\u0007g\u0002\u0002\u031f\u0320",
    "\u0007u\u0002\u0002\u0320\u0321\u0007e\u0002\u0002\u0321\u0088\u0003",
    "\u0002\u0002\u0002\u0322\u0323\u0007o\u0002\u0002\u0323\u0324\u0007",
    "k\u0002\u0002\u0324\u0325\u0007p\u0002\u0002\u0325\u008a\u0003\u0002",
    "\u0002\u0002\u0326\u0327\u0007o\u0002\u0002\u0327\u0328\u0007c\u0002",
    "\u0002\u0328\u0329\u0007z\u0002\u0002\u0329\u008c\u0003\u0002\u0002",
    "\u0002\u032a\u032b\u0007h\u0002\u0002\u032b\u032c\u0007k\u0002\u0002",
    "\u032c\u032d\u0007t\u0002\u0002\u032d\u032e\u0007u\u0002\u0002\u032e",
    "\u032f\u0007v\u0002\u0002\u032f\u008e\u0003\u0002\u0002\u0002\u0330",
    "\u0331\u0007n\u0002\u0002\u0331\u0332\u0007c\u0002\u0002\u0332\u0333",
    "\u0007u\u0002\u0002\u0333\u0334\u0007v\u0002\u0002\u0334\u0090\u0003",
    "\u0002\u0002\u0002\u0335\u0336\u0007k\u0002\u0002\u0336\u0337\u0007",
    "p\u0002\u0002\u0337\u0338\u0007f\u0002\u0002\u0338\u0339\u0007g\u0002",
    "\u0002\u0339\u033a\u0007z\u0002\u0002\u033a\u033b\u0007q\u0002\u0002",
    "\u033b\u033c\u0007h\u0002\u0002\u033c\u0092\u0003\u0002\u0002\u0002",
    "\u033d\u033e\u0007c\u0002\u0002\u033e\u033f\u0007d\u0002\u0002\u033f",
    "\u0340\u0007u\u0002\u0002\u0340\u0094\u0003\u0002\u0002\u0002\u0341",
    "\u0342\u0007m\u0002\u0002\u0342\u0343\u0007g\u0002\u0002\u0343\u0344",
    "\u0007{\u0002\u0002\u0344\u0096\u0003\u0002\u0002\u0002\u0345\u0346",
    "\u0007n\u0002\u0002\u0346\u0347\u0007p\u0002\u0002\u0347\u0098\u0003",
    "\u0002\u0002\u0002\u0348\u0349\u0007n\u0002\u0002\u0349\u034a\u0007",
    "q\u0002\u0002\u034a\u034b\u0007i\u0002\u0002\u034b\u009a\u0003\u0002",
    "\u0002\u0002\u034c\u034d\u0007v\u0002\u0002\u034d\u034e\u0007t\u0002",
    "\u0002\u034e\u034f\u0007w\u0002\u0002\u034f\u0350\u0007p\u0002\u0002",
    "\u0350\u0351\u0007e\u0002\u0002\u0351\u009c\u0003\u0002\u0002\u0002",
    "\u0352\u0353\u0007t\u0002\u0002\u0353\u0354\u0007q\u0002\u0002\u0354",
    "\u0355\u0007w\u0002\u0002\u0355\u0356\u0007p\u0002\u0002\u0356\u0357",
    "\u0007f\u0002\u0002\u0357\u009e\u0003\u0002\u0002\u0002\u0358\u0359",
    "\u0007r\u0002\u0002\u0359\u035a\u0007q\u0002\u0002\u035a\u035b\u0007",
    "y\u0002\u0002\u035b\u035c\u0007g\u0002\u0002\u035c\u035d\u0007t\u0002",
    "\u0002\u035d\u00a0\u0003\u0002\u0002\u0002\u035e\u035f\u0007o\u0002",
    "\u0002\u035f\u0360\u0007q\u0002\u0002\u0360\u0361\u0007f\u0002\u0002",
    "\u0361\u00a2\u0003\u0002\u0002\u0002\u0362\u0363\u0007n\u0002\u0002",
    "\u0363\u0364\u0007g\u0002\u0002\u0364\u0365\u0007p\u0002\u0002\u0365",
    "\u0366\u0007i\u0002\u0002\u0366\u0367\u0007v\u0002\u0002\u0367\u0368",
    "\u0007j\u0002\u0002\u0368\u00a4\u0003\u0002\u0002\u0002\u0369\u036a",
    "\u0007~\u0002\u0002\u036a\u036b\u0007~\u0002\u0002\u036b\u00a6\u0003",
    "\u0002\u0002\u0002\u036c\u036d\u0007v\u0002\u0002\u036d\u036e\u0007",
    "t\u0002\u0002\u036e\u036f\u0007k\u0002\u0002\u036f\u0370\u0007o\u0002",
    "\u0002\u0370\u00a8\u0003\u0002\u0002\u0002\u0371\u0372\u0007w\u0002",
    "\u0002\u0372\u0373\u0007r\u0002\u0002\u0373\u0374\u0007r\u0002\u0002",
    "\u0374\u0375\u0007g\u0002\u0002\u0375\u0376\u0007t\u0002\u0002\u0376",
    "\u00aa\u0003\u0002\u0002\u0002\u0377\u0378\u0007n\u0002\u0002\u0378",
    "\u0379\u0007q\u0002\u0002\u0379\u037a\u0007y\u0002\u0002\u037a\u037b",
    "\u0007g\u0002\u0002\u037b\u037c\u0007t\u0002\u0002\u037c\u00ac\u0003",
    "\u0002\u0002\u0002\u037d\u037e\u0007u\u0002\u0002\u037e\u037f\u0007",
    "w\u0002\u0002\u037f\u0380\u0007d\u0002\u0002\u0380\u0381\u0007u\u0002",
    "\u0002\u0381\u0382\u0007v\u0002\u0002\u0382\u0383\u0007t\u0002\u0002",
    "\u0383\u00ae\u0003\u0002\u0002\u0002\u0384\u0385\u0007u\u0002\u0002",
    "\u0385\u0386\u0007w\u0002\u0002\u0386\u0387\u0007o\u0002\u0002\u0387",
    "\u00b0\u0003\u0002\u0002\u0002\u0388\u0389\u0007c\u0002\u0002\u0389",
    "\u038a\u0007x\u0002\u0002\u038a\u038b\u0007i\u0002\u0002\u038b\u00b2",
    "\u0003\u0002\u0002\u0002\u038c\u038d\u0007o\u0002\u0002\u038d\u038e",
    "\u0007g\u0002\u0002\u038e\u038f\u0007f\u0002\u0002\u038f\u0390\u0007",
    "k\u0002\u0002\u0390\u0391\u0007c\u0002\u0002\u0391\u0392\u0007p\u0002",
    "\u0002\u0392\u00b4\u0003\u0002\u0002\u0002\u0393\u0394\u0007e\u0002",
    "\u0002\u0394\u0395\u0007q\u0002\u0002\u0395\u0396\u0007w\u0002\u0002",
    "\u0396\u0397\u0007p\u0002\u0002\u0397\u0398\u0007v\u0002\u0002\u0398",
    "\u00b6\u0003\u0002\u0002\u0002\u0399\u039a\u0007k\u0002\u0002\u039a",
    "\u039b\u0007f\u0002\u0002\u039b\u039c\u0007g\u0002\u0002\u039c\u039d",
    "\u0007p\u0002\u0002\u039d\u039e\u0007v\u0002\u0002\u039e\u039f\u0007",
    "k\u0002\u0002\u039f\u03a0\u0007h\u0002\u0002\u03a0\u03a1\u0007k\u0002",
    "\u0002\u03a1\u03a2\u0007g\u0002\u0002\u03a2\u03a3\u0007t\u0002\u0002",
    "\u03a3\u00b8\u0003\u0002\u0002\u0002\u03a4\u03a5\u0007o\u0002\u0002",
    "\u03a5\u03a6\u0007g\u0002\u0002\u03a6\u03a7\u0007c\u0002\u0002\u03a7",
    "\u03a8\u0007u\u0002\u0002\u03a8\u03a9\u0007w\u0002\u0002\u03a9\u03aa",
    "\u0007t\u0002\u0002\u03aa\u03ab\u0007g\u0002\u0002\u03ab\u00ba\u0003",
    "\u0002\u0002\u0002\u03ac\u03ad\u0007c\u0002\u0002\u03ad\u03ae\u0007",
    "v\u0002\u0002\u03ae\u03af\u0007v\u0002\u0002\u03af\u03b0\u0007t\u0002",
    "\u0002\u03b0\u03b1\u0007k\u0002\u0002\u03b1\u03b2\u0007d\u0002\u0002",
    "\u03b2\u03b3\u0007w\u0002\u0002\u03b3\u03b4\u0007v\u0002\u0002\u03b4",
    "\u03b5\u0007g\u0002\u0002\u03b5\u00bc\u0003\u0002\u0002\u0002\u03b6",
    "\u03b7\u0007h\u0002\u0002\u03b7\u03b8\u0007k\u0002\u0002\u03b8\u03b9",
    "\u0007n\u0002\u0002\u03b9\u03ba\u0007v\u0002\u0002\u03ba\u03bb\u0007",
    "g\u0002\u0002\u03bb\u03bc\u0007t\u0002\u0002\u03bc\u00be\u0003\u0002",
    "\u0002\u0002\u03bd\u03be\u0007o\u0002\u0002\u03be\u03bf\u0007g\u0002",
    "\u0002\u03bf\u03c0\u0007t\u0002\u0002\u03c0\u03c1\u0007i\u0002\u0002",
    "\u03c1\u03c2\u0007g\u0002\u0002\u03c2\u00c0\u0003\u0002\u0002\u0002",
    "\u03c3\u03c4\u0007g\u0002\u0002\u03c4\u03c5\u0007z\u0002\u0002\u03c5",
    "\u03c6\u0007r\u0002\u0002\u03c6\u00c2\u0003\u0002\u0002\u0002\u03c7",
    "\u03c8\u0007e\u0002\u0002\u03c8\u03c9\u0007q\u0002\u0002\u03c9\u03ca",
    "\u0007o\u0002\u0002\u03ca\u03cb\u0007r\u0002\u0002\u03cb\u03cc\u0007",
    "q\u0002\u0002\u03cc\u03cd\u0007p\u0002\u0002\u03cd\u03ce\u0007g\u0002",
    "\u0002\u03ce\u03cf\u0007p\u0002\u0002\u03cf\u03d0\u0007v\u0002\u0002",
    "\u03d0\u03d1\u0007T\u0002\u0002\u03d1\u03d2\u0007q\u0002\u0002\u03d2",
    "\u03d3\u0007n\u0002\u0002\u03d3\u03d4\u0007g\u0002\u0002\u03d4\u00c4",
    "\u0003\u0002\u0002\u0002\u03d5\u03d6\u0007x\u0002\u0002\u03d6\u03d7",
    "\u0007k\u0002\u0002\u03d7\u03d8\u0007t\u0002\u0002\u03d8\u03d9\u0007",
    "c\u0002\u0002\u03d9\u03da\u0007n\u0002\u0002\u03da\u00c6\u0003\u0002",
    "\u0002\u0002\u03db\u03dc\u0007o\u0002\u0002\u03dc\u03dd\u0007c\u0002",
    "\u0002\u03dd\u03de\u0007v\u0002\u0002\u03de\u03df\u0007e\u0002\u0002",
    "\u03df\u03e0\u0007j\u0002\u0002\u03e0\u03e1\u0007a\u0002\u0002\u03e1",
    "\u03e2\u0007e\u0002\u0002\u03e2\u03e3\u0007j\u0002\u0002\u03e3\u03e4",
    "\u0007c\u0002\u0002\u03e4\u03e5\u0007t\u0002\u0002\u03e5\u03e6\u0007",
    "c\u0002\u0002\u03e6\u03e7\u0007e\u0002\u0002\u03e7\u03e8\u0007v\u0002",
    "\u0002\u03e8\u03e9\u0007g\u0002\u0002\u03e9\u03ea\u0007t\u0002\u0002",
    "\u03ea\u03eb\u0007u\u0002\u0002\u03eb\u00c8\u0003\u0002\u0002\u0002",
    "\u03ec\u03ed\u0007v\u0002\u0002\u03ed\u03ee\u0007{\u0002\u0002\u03ee",
    "\u03ef\u0007r\u0002\u0002\u03ef\u03f0\u0007g\u0002\u0002\u03f0\u00ca",
    "\u0003\u0002\u0002\u0002\u03f1\u03f2\u0007p\u0002\u0002\u03f2\u03f3",
    "\u0007x\u0002\u0002\u03f3\u03f4\u0007n\u0002\u0002\u03f4\u00cc\u0003",
    "\u0002\u0002\u0002\u03f5\u03f6\u0007j\u0002\u0002\u03f6\u03f7\u0007",
    "k\u0002\u0002\u03f7\u03f8\u0007g\u0002\u0002\u03f8\u03f9\u0007t\u0002",
    "\u0002\u03f9\u03fa\u0007c\u0002\u0002\u03fa\u03fb\u0007t\u0002\u0002",
    "\u03fb\u03fc\u0007e\u0002\u0002\u03fc\u03fd\u0007j\u0002\u0002\u03fd",
    "\u03fe\u0007{\u0002\u0002\u03fe\u00ce\u0003\u0002\u0002\u0002\u03ff",
    "\u0400\u0007a\u0002\u0002\u0400\u00d0\u0003\u0002\u0002\u0002\u0401",
    "\u0402\u0007k\u0002\u0002\u0402\u0403\u0007p\u0002\u0002\u0403\u0404",
    "\u0007x\u0002\u0002\u0404\u0405\u0007c\u0002\u0002\u0405\u0406\u0007",
    "n\u0002\u0002\u0406\u0407\u0007k\u0002\u0002\u0407\u0408\u0007f\u0002",
    "\u0002\u0408\u00d2\u0003\u0002\u0002\u0002\u0409\u040a\u0007x\u0002",
    "\u0002\u040a\u040b\u0007c\u0002\u0002\u040b\u040c\u0007n\u0002\u0002",
    "\u040c\u040d\u0007w\u0002\u0002\u040d\u040e\u0007g\u0002\u0002\u040e",
    "\u040f\u0007f\u0002\u0002\u040f\u0410\u0007q\u0002\u0002\u0410\u0411",
    "\u0007o\u0002\u0002\u0411\u0412\u0007c\u0002\u0002\u0412\u0413\u0007",
    "k\u0002\u0002\u0413\u0414\u0007p\u0002\u0002\u0414\u00d4\u0003\u0002",
    "\u0002\u0002\u0415\u0416\u0007x\u0002\u0002\u0416\u0417\u0007c\u0002",
    "\u0002\u0417\u0418\u0007t\u0002\u0002\u0418\u0419\u0007k\u0002\u0002",
    "\u0419\u041a\u0007c\u0002\u0002\u041a\u041b\u0007d\u0002\u0002\u041b",
    "\u041c\u0007n\u0002\u0002\u041c\u041d\u0007g\u0002\u0002\u041d\u00d6",
    "\u0003\u0002\u0002\u0002\u041e\u041f\u0007f\u0002\u0002\u041f\u0420",
    "\u0007c\u0002\u0002\u0420\u0421\u0007v\u0002\u0002\u0421\u0422\u0007",
    "c\u0002\u0002\u0422\u00d8\u0003\u0002\u0002\u0002\u0423\u0424\u0007",
    "u\u0002\u0002\u0424\u0425\u0007v\u0002\u0002\u0425\u0426\u0007t\u0002",
    "\u0002\u0426\u0427\u0007w\u0002\u0002\u0427\u0428\u0007e\u0002\u0002",
    "\u0428\u0429\u0007v\u0002\u0002\u0429\u042a\u0007w\u0002\u0002\u042a",
    "\u042b\u0007t\u0002\u0002\u042b\u042c\u0007g\u0002\u0002\u042c\u00da",
    "\u0003\u0002\u0002\u0002\u042d\u042e\u0007f\u0002\u0002\u042e\u042f",
    "\u0007c\u0002\u0002\u042f\u0430\u0007v\u0002\u0002\u0430\u0431\u0007",
    "c\u0002\u0002\u0431\u0432\u0007u\u0002\u0002\u0432\u0433\u0007g\u0002",
    "\u0002\u0433\u0434\u0007v\u0002\u0002\u0434\u00dc\u0003\u0002\u0002",
    "\u0002\u0435\u0436\u0007q\u0002\u0002\u0436\u0437\u0007r\u0002\u0002",
    "\u0437\u0438\u0007g\u0002\u0002\u0438\u0439\u0007t\u0002\u0002\u0439",
    "\u043a\u0007c\u0002\u0002\u043a\u043b\u0007v\u0002\u0002\u043b\u043c",
    "\u0007q\u0002\u0002\u043c\u043d\u0007t\u0002\u0002\u043d\u00de\u0003",
    "\u0002\u0002\u0002\u043e\u043f\u0007f\u0002\u0002\u043f\u0440\u0007",
    "g\u0002\u0002\u0440\u0441\u0007h\u0002\u0002\u0441\u0442\u0007k\u0002",
    "\u0002\u0442\u0443\u0007p\u0002\u0002\u0443\u0444\u0007g\u0002\u0002",
    "\u0444\u00e0\u0003\u0002\u0002\u0002\u0445\u0446\u0007>\u0002\u0002",
    "\u0446\u0447\u0007/\u0002\u0002\u0447\u00e2\u0003\u0002\u0002\u0002",
    "\u0448\u0449\u0007f\u0002\u0002\u0449\u044a\u0007c\u0002\u0002\u044a",
    "\u044b\u0007v\u0002\u0002\u044b\u044c\u0007c\u0002\u0002\u044c\u044d",
    "\u0007r\u0002\u0002\u044d\u044e\u0007q\u0002\u0002\u044e\u044f\u0007",
    "k\u0002\u0002\u044f\u0450\u0007p\u0002\u0002\u0450\u0451\u0007v\u0002",
    "\u0002\u0451\u00e4\u0003\u0002\u0002\u0002\u0452\u0453\u0007j\u0002",
    "\u0002\u0453\u0454\u0007k\u0002\u0002\u0454\u0455\u0007g\u0002\u0002",
    "\u0455\u0456\u0007t\u0002\u0002\u0456\u0457\u0007c\u0002\u0002\u0457",
    "\u0458\u0007t\u0002\u0002\u0458\u0459\u0007e\u0002\u0002\u0459\u045a",
    "\u0007j\u0002\u0002\u045a\u045b\u0007k\u0002\u0002\u045b\u045c\u0007",
    "e\u0002\u0002\u045c\u045d\u0007c\u0002\u0002\u045d\u045e\u0007n\u0002",
    "\u0002\u045e\u00e6\u0003\u0002\u0002\u0002\u045f\u0460\u0007t\u0002",
    "\u0002\u0460\u0461\u0007w\u0002\u0002\u0461\u0462\u0007n\u0002\u0002",
    "\u0462\u0463\u0007g\u0002\u0002\u0463\u0464\u0007u\u0002\u0002\u0464",
    "\u0465\u0007g\u0002\u0002\u0465\u0466\u0007v\u0002\u0002\u0466\u00e8",
    "\u0003\u0002\u0002\u0002\u0467\u0468\u0007t\u0002\u0002\u0468\u0469",
    "\u0007w\u0002\u0002\u0469\u046a\u0007n\u0002\u0002\u046a\u046b\u0007",
    "g\u0002\u0002\u046b\u00ea\u0003\u0002\u0002\u0002\u046c\u046d\u0007",
    "g\u0002\u0002\u046d\u046e\u0007p\u0002\u0002\u046e\u046f\u0007f\u0002",
    "\u0002\u046f\u00ec\u0003\u0002\u0002\u0002\u0470\u0471\u0007c\u0002",
    "\u0002\u0471\u0472\u0007n\u0002\u0002\u0472\u0473\u0007v\u0002\u0002",
    "\u0473\u0474\u0007g\u0002\u0002\u0474\u0475\u0007t\u0002\u0002\u0475",
    "\u0476\u0007F\u0002\u0002\u0476\u0477\u0007c\u0002\u0002\u0477\u0478",
    "\u0007v\u0002\u0002\u0478\u0479\u0007c\u0002\u0002\u0479\u047a\u0007",
    "u\u0002\u0002\u047a\u047b\u0007g\u0002\u0002\u047b\u047c\u0007v\u0002",
    "\u0002\u047c\u00ee\u0003\u0002\u0002\u0002\u047d\u047e\u0007n\u0002",
    "\u0002\u047e\u047f\u0007v\u0002\u0002\u047f\u0480\u0007t\u0002\u0002",
    "\u0480\u0481\u0007k\u0002\u0002\u0481\u0482\u0007o\u0002\u0002\u0482",
    "\u00f0\u0003\u0002\u0002\u0002\u0483\u0484\u0007t\u0002\u0002\u0484",
    "\u0485\u0007v\u0002\u0002\u0485\u0486\u0007t\u0002\u0002\u0486\u0487",
    "\u0007k\u0002\u0002\u0487\u0488\u0007o\u0002\u0002\u0488\u00f2\u0003",
    "\u0002\u0002\u0002\u0489\u048a\u0007k\u0002\u0002\u048a\u048b\u0007",
    "p\u0002\u0002\u048b\u048c\u0007u\u0002\u0002\u048c\u048d\u0007v\u0002",
    "\u0002\u048d\u048e\u0007t\u0002\u0002\u048e\u00f4\u0003\u0002\u0002",
    "\u0002\u048f\u0490\u0007t\u0002\u0002\u0490\u0491\u0007g\u0002\u0002",
    "\u0491\u0492\u0007r\u0002\u0002\u0492\u0493\u0007n\u0002\u0002\u0493",
    "\u0494\u0007c\u0002\u0002\u0494\u0495\u0007e\u0002\u0002\u0495\u0496",
    "\u0007g\u0002\u0002\u0496\u00f6\u0003\u0002\u0002\u0002\u0497\u0498",
    "\u0007e\u0002\u0002\u0498\u0499\u0007g\u0002\u0002\u0499\u049a\u0007",
    "k\u0002\u0002\u049a\u049b\u0007n\u0002\u0002\u049b\u00f8\u0003\u0002",
    "\u0002\u0002\u049c\u049d\u0007h\u0002\u0002\u049d\u049e\u0007n\u0002",
    "\u0002\u049e\u049f\u0007q\u0002\u0002\u049f\u04a0\u0007q\u0002\u0002",
    "\u04a0\u04a1\u0007t\u0002\u0002\u04a1\u00fa\u0003\u0002\u0002\u0002",
    "\u04a2\u04a3\u0007u\u0002\u0002\u04a3\u04a4\u0007s\u0002\u0002\u04a4",
    "\u04a5\u0007t\u0002\u0002\u04a5\u04a6\u0007v\u0002\u0002\u04a6\u00fc",
    "\u0003\u0002\u0002\u0002\u04a7\u04a8\u0007c\u0002\u0002\u04a8\u04a9",
    "\u0007p\u0002\u0002\u04a9\u04aa\u0007{\u0002\u0002\u04aa\u00fe\u0003",
    "\u0002\u0002\u0002\u04ab\u04ac\u0007u\u0002\u0002\u04ac\u04ad\u0007",
    "g\u0002\u0002\u04ad\u04ae\u0007v\u0002\u0002\u04ae\u04af\u0007f\u0002",
    "\u0002\u04af\u04b0\u0007k\u0002\u0002\u04b0\u04b1\u0007h\u0002\u0002",
    "\u04b1\u04b2\u0007h\u0002\u0002\u04b2\u0100\u0003\u0002\u0002\u0002",
    "\u04b3\u04b4\u0007u\u0002\u0002\u04b4\u04b5\u0007v\u0002\u0002\u04b5",
    "\u04b6\u0007f\u0002\u0002\u04b6\u04b7\u0007f\u0002\u0002\u04b7\u04b8",
    "\u0007g\u0002\u0002\u04b8\u04b9\u0007x\u0002\u0002\u04b9\u04ba\u0007",
    "a\u0002\u0002\u04ba\u04bb\u0007r\u0002\u0002\u04bb\u04bc\u0007q\u0002",
    "\u0002\u04bc\u04bd\u0007r\u0002\u0002\u04bd\u0102\u0003\u0002\u0002",
    "\u0002\u04be\u04bf\u0007u\u0002\u0002\u04bf\u04c0\u0007v\u0002\u0002",
    "\u04c0\u04c1\u0007f\u0002\u0002\u04c1\u04c2\u0007f\u0002\u0002\u04c2",
    "\u04c3\u0007g\u0002\u0002\u04c3\u04c4\u0007x\u0002\u0002\u04c4\u04c5",
    "\u0007a\u0002\u0002\u04c5\u04c6\u0007u\u0002\u0002\u04c6\u04c7\u0007",
    "c\u0002\u0002\u04c7\u04c8\u0007o\u0002\u0002\u04c8\u04c9\u0007r\u0002",
    "\u0002\u04c9\u0104\u0003\u0002\u0002\u0002\u04ca\u04cb\u0007x\u0002",
    "\u0002\u04cb\u04cc\u0007c\u0002\u0002\u04cc\u04cd\u0007t\u0002\u0002",
    "\u04cd\u04ce\u0007a\u0002\u0002\u04ce\u04cf\u0007r\u0002\u0002\u04cf",
    "\u04d0\u0007q\u0002\u0002\u04d0\u04d1\u0007r\u0002\u0002\u04d1\u0106",
    "\u0003\u0002\u0002\u0002\u04d2\u04d3\u0007x\u0002\u0002\u04d3\u04d4",
    "\u0007c\u0002\u0002\u04d4\u04d5\u0007t\u0002\u0002\u04d5\u04d6\u0007",
    "a\u0002\u0002\u04d6\u04d7\u0007u\u0002\u0002\u04d7\u04d8\u0007c\u0002",
    "\u0002\u04d8\u04d9\u0007o\u0002\u0002\u04d9\u04da\u0007r\u0002\u0002",
    "\u04da\u0108\u0003\u0002\u0002\u0002\u04db\u04dc\u0007i\u0002\u0002",
    "\u04dc\u04dd\u0007t\u0002\u0002\u04dd\u04de\u0007q\u0002\u0002\u04de",
    "\u04df\u0007w\u0002\u0002\u04df\u04e0\u0007r\u0002\u0002\u04e0\u010a",
    "\u0003\u0002\u0002\u0002\u04e1\u04e2\u0007g\u0002\u0002\u04e2\u04e3",
    "\u0007z\u0002\u0002\u04e3\u04e4\u0007e\u0002\u0002\u04e4\u04e5\u0007",
    "g\u0002\u0002\u04e5\u04e6\u0007r\u0002\u0002\u04e6\u04e7\u0007v\u0002",
    "\u0002\u04e7\u010c\u0003\u0002\u0002\u0002\u04e8\u04e9\u0007j\u0002",
    "\u0002\u04e9\u04ea\u0007c\u0002\u0002\u04ea\u04eb\u0007x\u0002\u0002",
    "\u04eb\u04ec\u0007k\u0002\u0002\u04ec\u04ed\u0007p\u0002\u0002\u04ed",
    "\u04ee\u0007i\u0002\u0002\u04ee\u010e\u0003\u0002\u0002\u0002\u04ef",
    "\u04f0\u0007h\u0002\u0002\u04f0\u04f1\u0007k\u0002\u0002\u04f1\u04f2",
    "\u0007t\u0002\u0002\u04f2\u04f3\u0007u\u0002\u0002\u04f3\u04f4\u0007",
    "v\u0002\u0002\u04f4\u04f5\u0007a\u0002\u0002\u04f5\u04f6\u0007x\u0002",
    "\u0002\u04f6\u04f7\u0007c\u0002\u0002\u04f7\u04f8\u0007n\u0002\u0002",
    "\u04f8\u04f9\u0007w\u0002\u0002\u04f9\u04fa\u0007g\u0002\u0002\u04fa",
    "\u0110\u0003\u0002\u0002\u0002\u04fb\u04fc\u0007n\u0002\u0002\u04fc",
    "\u04fd\u0007c\u0002\u0002\u04fd\u04fe\u0007u\u0002\u0002\u04fe\u04ff",
    "\u0007v\u0002\u0002\u04ff\u0500\u0007a\u0002\u0002\u0500\u0501\u0007",
    "x\u0002\u0002\u0501\u0502\u0007c\u0002\u0002\u0502\u0503\u0007n\u0002",
    "\u0002\u0503\u0504\u0007w\u0002\u0002\u0504\u0505\u0007g\u0002\u0002",
    "\u0505\u0112\u0003\u0002\u0002\u0002\u0506\u0507\u0007n\u0002\u0002",
    "\u0507\u0508\u0007c\u0002\u0002\u0508\u0509\u0007i\u0002\u0002\u0509",
    "\u0114\u0003\u0002\u0002\u0002\u050a\u050b\u0007n\u0002\u0002\u050b",
    "\u050c\u0007g\u0002\u0002\u050c\u050d\u0007c\u0002\u0002\u050d\u050e",
    "\u0007f\u0002\u0002\u050e\u0116\u0003\u0002\u0002\u0002\u050f\u0510",
    "\u0007t\u0002\u0002\u0510\u0511\u0007c\u0002\u0002\u0511\u0512\u0007",
    "v\u0002\u0002\u0512\u0513\u0007k\u0002\u0002\u0513\u0514\u0007q\u0002",
    "\u0002\u0514\u0515\u0007a\u0002\u0002\u0515\u0516\u0007v\u0002\u0002",
    "\u0516\u0517\u0007q\u0002\u0002\u0517\u0518\u0007a\u0002\u0002\u0518",
    "\u0519\u0007t\u0002\u0002\u0519\u051a\u0007g\u0002\u0002\u051a\u051b",
    "\u0007r\u0002\u0002\u051b\u051c\u0007q\u0002\u0002\u051c\u051d\u0007",
    "t\u0002\u0002\u051d\u051e\u0007v\u0002\u0002\u051e\u0118\u0003\u0002",
    "\u0002\u0002\u051f\u0520\u0007q\u0002\u0002\u0520\u0521\u0007x\u0002",
    "\u0002\u0521\u0522\u0007g\u0002\u0002\u0522\u0523\u0007t\u0002\u0002",
    "\u0523\u011a\u0003\u0002\u0002\u0002\u0524\u0525\u0007r\u0002\u0002",
    "\u0525\u0526\u0007t\u0002\u0002\u0526\u0527\u0007g\u0002\u0002\u0527",
    "\u0528\u0007e\u0002\u0002\u0528\u0529\u0007g\u0002\u0002\u0529\u052a",
    "\u0007f\u0002\u0002\u052a\u052b\u0007k\u0002\u0002\u052b\u052c\u0007",
    "p\u0002\u0002\u052c\u052d\u0007i\u0002\u0002\u052d\u011c\u0003\u0002",
    "\u0002\u0002\u052e\u052f\u0007h\u0002\u0002\u052f\u0530\u0007q\u0002",
    "\u0002\u0530\u0531\u0007n\u0002\u0002\u0531\u0532\u0007n\u0002\u0002",
    "\u0532\u0533\u0007q\u0002\u0002\u0533\u0534\u0007y\u0002\u0002\u0534",
    "\u0535\u0007k\u0002\u0002\u0535\u0536\u0007p\u0002\u0002\u0536\u0537",
    "\u0007i\u0002\u0002\u0537\u011e\u0003\u0002\u0002\u0002\u0538\u0539",
    "\u0007w\u0002\u0002\u0539\u053a\u0007p\u0002\u0002\u053a\u053b\u0007",
    "d\u0002\u0002\u053b\u053c\u0007q\u0002\u0002\u053c\u053d\u0007w\u0002",
    "\u0002\u053d\u053e\u0007p\u0002\u0002\u053e\u053f\u0007f\u0002\u0002",
    "\u053f\u0540\u0007g\u0002\u0002\u0540\u0541\u0007f\u0002\u0002\u0541",
    "\u0120\u0003\u0002\u0002\u0002\u0542\u0543\u0007r\u0002\u0002\u0543",
    "\u0544\u0007c\u0002\u0002\u0544\u0545\u0007t\u0002\u0002\u0545\u0546",
    "\u0007v\u0002\u0002\u0546\u0547\u0007k\u0002\u0002\u0547\u0548\u0007",
    "v\u0002\u0002\u0548\u0549\u0007k\u0002\u0002\u0549\u054a\u0007q\u0002",
    "\u0002\u054a\u054b\u0007p\u0002\u0002\u054b\u0122\u0003\u0002\u0002",
    "\u0002\u054c\u054d\u0007t\u0002\u0002\u054d\u054e\u0007q\u0002\u0002",
    "\u054e\u054f\u0007y\u0002\u0002\u054f\u0550\u0007u\u0002\u0002\u0550",
    "\u0124\u0003\u0002\u0002\u0002\u0551\u0552\u0007t\u0002\u0002\u0552",
    "\u0553\u0007c\u0002\u0002\u0553\u0554\u0007p\u0002\u0002\u0554\u0555",
    "\u0007i\u0002\u0002\u0555\u0556\u0007g\u0002\u0002\u0556\u0126\u0003",
    "\u0002\u0002\u0002\u0557\u0558\u0007e\u0002\u0002\u0558\u0559\u0007",
    "w\u0002\u0002\u0559\u055a\u0007t\u0002\u0002\u055a\u055b\u0007t\u0002",
    "\u0002\u055b\u055c\u0007g\u0002\u0002\u055c\u055d\u0007p\u0002\u0002",
    "\u055d\u055e\u0007v\u0002\u0002\u055e\u0128\u0003\u0002\u0002\u0002",
    "\u055f\u0560\u0007x\u0002\u0002\u0560\u0561\u0007c\u0002\u0002\u0561",
    "\u0562\u0007n\u0002\u0002\u0562\u0563\u0007k\u0002\u0002\u0563\u0564",
    "\u0007f\u0002\u0002\u0564\u012a\u0003\u0002\u0002\u0002\u0565\u0566",
    "\u0007h\u0002\u0002\u0566\u0567\u0007k\u0002\u0002\u0567\u0568\u0007",
    "n\u0002\u0002\u0568\u0569\u0007n\u0002\u0002\u0569\u056a\u0007a\u0002",
    "\u0002\u056a\u056b\u0007v\u0002\u0002\u056b\u056c\u0007k\u0002\u0002",
    "\u056c\u056d\u0007o\u0002\u0002\u056d\u056e\u0007g\u0002\u0002\u056e",
    "\u056f\u0007a\u0002\u0002\u056f\u0570\u0007u\u0002\u0002\u0570\u0571",
    "\u0007g\u0002\u0002\u0571\u0572\u0007t\u0002\u0002\u0572\u0573\u0007",
    "k\u0002\u0002\u0573\u0574\u0007g\u0002\u0002\u0574\u0575\u0007u\u0002",
    "\u0002\u0575\u012c\u0003\u0002\u0002\u0002\u0576\u0577\u0007h\u0002",
    "\u0002\u0577\u0578\u0007n\u0002\u0002\u0578\u0579\u0007q\u0002\u0002",
    "\u0579\u057a\u0007y\u0002\u0002\u057a\u057b\u0007a\u0002\u0002\u057b",
    "\u057c\u0007v\u0002\u0002\u057c\u057d\u0007q\u0002\u0002\u057d\u057e",
    "\u0007a\u0002\u0002\u057e\u057f\u0007u\u0002\u0002\u057f\u0580\u0007",
    "v\u0002\u0002\u0580\u0581\u0007q\u0002\u0002\u0581\u0582\u0007e\u0002",
    "\u0002\u0582\u0583\u0007m\u0002\u0002\u0583\u012e\u0003\u0002\u0002",
    "\u0002\u0584\u0585\u0007u\u0002\u0002\u0585\u0586\u0007v\u0002\u0002",
    "\u0586\u0587\u0007q\u0002\u0002\u0587\u0588\u0007e\u0002\u0002\u0588",
    "\u0589\u0007m\u0002\u0002\u0589\u058a\u0007a\u0002\u0002\u058a\u058b",
    "\u0007v\u0002\u0002\u058b\u058c\u0007q\u0002\u0002\u058c\u058d\u0007",
    "a\u0002\u0002\u058d\u058e\u0007h\u0002\u0002\u058e\u058f\u0007n\u0002",
    "\u0002\u058f\u0590\u0007q\u0002\u0002\u0590\u0591\u0007y\u0002\u0002",
    "\u0591\u0130\u0003\u0002\u0002\u0002\u0592\u0593\u0007v\u0002\u0002",
    "\u0593\u0594\u0007k\u0002\u0002\u0594\u0595\u0007o\u0002\u0002\u0595",
    "\u0596\u0007g\u0002\u0002\u0596\u0597\u0007u\u0002\u0002\u0597\u0598",
    "\u0007j\u0002\u0002\u0598\u0599\u0007k\u0002\u0002\u0599\u059a\u0007",
    "h\u0002\u0002\u059a\u059b\u0007v\u0002\u0002\u059b\u0132\u0003\u0002",
    "\u0002\u0002\u059c\u059d\u0007o\u0002\u0002\u059d\u059e\u0007g\u0002",
    "\u0002\u059e\u059f\u0007c\u0002\u0002\u059f\u05a0\u0007u\u0002\u0002",
    "\u05a0\u05a1\u0007w\u0002\u0002\u05a1\u05a2\u0007t\u0002\u0002\u05a2",
    "\u05a3\u0007g\u0002\u0002\u05a3\u05a4\u0007u\u0002\u0002\u05a4\u0134",
    "\u0003\u0002\u0002\u0002\u05a5\u05a6\u0007p\u0002\u0002\u05a6\u05a7",
    "\u0007q\u0002\u0002\u05a7\u05a8\u0007a\u0002\u0002\u05a8\u05a9\u0007",
    "o\u0002\u0002\u05a9\u05aa\u0007g\u0002\u0002\u05aa\u05ab\u0007c\u0002",
    "\u0002\u05ab\u05ac\u0007u\u0002\u0002\u05ac\u05ad\u0007w\u0002\u0002",
    "\u05ad\u05ae\u0007t\u0002\u0002\u05ae\u05af\u0007g\u0002\u0002\u05af",
    "\u05b0\u0007u\u0002\u0002\u05b0\u0136\u0003\u0002\u0002\u0002\u05b1",
    "\u05b2\u0007e\u0002\u0002\u05b2\u05b3\u0007q\u0002\u0002\u05b3\u05b4",
    "\u0007p\u0002\u0002\u05b4\u05b5\u0007f\u0002\u0002\u05b5\u05b6\u0007",
    "k\u0002\u0002\u05b6\u05b7\u0007v\u0002\u0002\u05b7\u05b8\u0007k\u0002",
    "\u0002\u05b8\u05b9\u0007q\u0002\u0002\u05b9\u05ba\u0007p\u0002\u0002",
    "\u05ba\u0138\u0003\u0002\u0002\u0002\u05bb\u05bc\u0007d\u0002\u0002",
    "\u05bc\u05bd\u0007q\u0002\u0002\u05bd\u05be\u0007q\u0002\u0002\u05be",
    "\u05bf\u0007n\u0002\u0002\u05bf\u05c0\u0007g\u0002\u0002\u05c0\u05c1",
    "\u0007c\u0002\u0002\u05c1\u05c2\u0007p\u0002\u0002\u05c2\u013a\u0003",
    "\u0002\u0002\u0002\u05c3\u05c4\u0007f\u0002\u0002\u05c4\u05c5\u0007",
    "c\u0002\u0002\u05c5\u05c6\u0007v\u0002\u0002\u05c6\u05c7\u0007g\u0002",
    "\u0002\u05c7\u013c\u0003\u0002\u0002\u0002\u05c8\u05c9\u0007v\u0002",
    "\u0002\u05c9\u05ca\u0007k\u0002\u0002\u05ca\u05cb\u0007o\u0002\u0002",
    "\u05cb\u05cc\u0007g\u0002\u0002\u05cc\u05cd\u0007a\u0002\u0002\u05cd",
    "\u05ce\u0007r\u0002\u0002\u05ce\u05cf\u0007g\u0002\u0002\u05cf\u05d0",
    "\u0007t\u0002\u0002\u05d0\u05d1\u0007k\u0002\u0002\u05d1\u05d2\u0007",
    "q\u0002\u0002\u05d2\u05d3\u0007f\u0002\u0002\u05d3\u013e\u0003\u0002",
    "\u0002\u0002\u05d4\u05d5\u0007p\u0002\u0002\u05d5\u05d6\u0007w\u0002",
    "\u0002\u05d6\u05d7\u0007o\u0002\u0002\u05d7\u05d8\u0007d\u0002\u0002",
    "\u05d8\u05d9\u0007g\u0002\u0002\u05d9\u05da\u0007t\u0002\u0002\u05da",
    "\u0140\u0003\u0002\u0002\u0002\u05db\u05dc\u0007u\u0002\u0002\u05dc",
    "\u05dd\u0007v\u0002\u0002\u05dd\u05de\u0007t\u0002\u0002\u05de\u05df",
    "\u0007k\u0002\u0002\u05df\u05e0\u0007p\u0002\u0002\u05e0\u05e1\u0007",
    "i\u0002\u0002\u05e1\u0142\u0003\u0002\u0002\u0002\u05e2\u05e3\u0007",
    "v\u0002\u0002\u05e3\u05e4\u0007k\u0002\u0002\u05e4\u05e5\u0007o\u0002",
    "\u0002\u05e5\u05e6\u0007g\u0002\u0002\u05e6\u0144\u0003\u0002\u0002",
    "\u0002\u05e7\u05e8\u0007k\u0002\u0002\u05e8\u05e9\u0007p\u0002\u0002",
    "\u05e9\u05ea\u0007v\u0002\u0002\u05ea\u05eb\u0007g\u0002\u0002\u05eb",
    "\u05ec\u0007i\u0002\u0002\u05ec\u05ed\u0007g\u0002\u0002\u05ed\u05ee",
    "\u0007t\u0002\u0002\u05ee\u0146\u0003\u0002\u0002\u0002\u05ef\u05f0",
    "\u0007h\u0002\u0002\u05f0\u05f1\u0007n\u0002\u0002\u05f1\u05f2\u0007",
    "q\u0002\u0002\u05f2\u05f3\u0007c\u0002\u0002\u05f3\u05f4\u0007v\u0002",
    "\u0002\u05f4\u0148\u0003\u0002\u0002\u0002\u05f5\u05f6\u0007n\u0002",
    "\u0002\u05f6\u05f7\u0007k\u0002\u0002\u05f7\u05f8\u0007u\u0002\u0002",
    "\u05f8\u05f9\u0007v\u0002\u0002\u05f9\u014a\u0003\u0002\u0002\u0002",
    "\u05fa\u05fb\u0007t\u0002\u0002\u05fb\u05fc\u0007g\u0002\u0002\u05fc",
    "\u05fd\u0007e\u0002\u0002\u05fd\u05fe\u0007q\u0002\u0002\u05fe\u05ff",
    "\u0007t\u0002\u0002\u05ff\u0600\u0007f\u0002\u0002\u0600\u014c\u0003",
    "\u0002\u0002\u0002\u0601\u0602\u0007t\u0002\u0002\u0602\u0603\u0007",
    "g\u0002\u0002\u0603\u0604\u0007u\u0002\u0002\u0604\u0605\u0007v\u0002",
    "\u0002\u0605\u0606\u0007t\u0002\u0002\u0606\u0607\u0007k\u0002\u0002",
    "\u0607\u0608\u0007e\u0002\u0002\u0608\u0609\u0007v\u0002\u0002\u0609",
    "\u014e\u0003\u0002\u0002\u0002\u060a\u060b\u0007{\u0002\u0002\u060b",
    "\u060c\u0007{\u0002\u0002\u060c\u060d\u0007{\u0002\u0002\u060d\u060e",
    "\u0007{\u0002\u0002\u060e\u0150\u0003\u0002\u0002\u0002\u060f\u0610",
    "\u0007o\u0002\u0002\u0610\u0611\u0007o\u0002\u0002\u0611\u0152\u0003",
    "\u0002\u0002\u0002\u0612\u0613\u0007f\u0002\u0002\u0613\u0614\u0007",
    "f\u0002\u0002\u0614\u0154\u0003\u0002\u0002\u0002\u0615\u0616\u0007",
    "o\u0002\u0002\u0616\u0617\u0007c\u0002\u0002\u0617\u0618\u0007z\u0002",
    "\u0002\u0618\u0619\u0007N\u0002\u0002\u0619\u061a\u0007g\u0002\u0002",
    "\u061a\u061b\u0007p\u0002\u0002\u061b\u061c\u0007i\u0002\u0002\u061c",
    "\u061d\u0007v\u0002\u0002\u061d\u061e\u0007j\u0002\u0002\u061e\u0156",
    "\u0003\u0002\u0002\u0002\u061f\u0620\u0007t\u0002\u0002\u0620\u0621",
    "\u0007g\u0002\u0002\u0621\u0622\u0007i\u0002\u0002\u0622\u0623\u0007",
    "g\u0002\u0002\u0623\u0624\u0007z\u0002\u0002\u0624\u0625\u0007r\u0002",
    "\u0002\u0625\u0158\u0003\u0002\u0002\u0002\u0626\u0627\u0007k\u0002",
    "\u0002\u0627\u0628\u0007u\u0002\u0002\u0628\u015a\u0003\u0002\u0002",
    "\u0002\u0629\u062a\u0007y\u0002\u0002\u062a\u062b\u0007j\u0002\u0002",
    "\u062b\u062c\u0007g\u0002\u0002\u062c\u062d\u0007p\u0002\u0002\u062d",
    "\u015c\u0003\u0002\u0002\u0002\u062e\u062f\u0007h\u0002\u0002\u062f",
    "\u0630\u0007t\u0002\u0002\u0630\u0631\u0007q\u0002\u0002\u0631\u0632",
    "\u0007o\u0002\u0002\u0632\u015e\u0003\u0002\u0002\u0002\u0633\u0634",
    "\u0007c\u0002\u0002\u0634\u0635\u0007i\u0002\u0002\u0635\u0636\u0007",
    "i\u0002\u0002\u0636\u0637\u0007t\u0002\u0002\u0637\u0638\u0007g\u0002",
    "\u0002\u0638\u0639\u0007i\u0002\u0002\u0639\u063a\u0007c\u0002\u0002",
    "\u063a\u063b\u0007v\u0002\u0002\u063b\u063c\u0007g\u0002\u0002\u063c",
    "\u063d\u0007u\u0002\u0002\u063d\u0160\u0003\u0002\u0002\u0002\u063e",
    "\u063f\u0007r\u0002\u0002\u063f\u0640\u0007q\u0002\u0002\u0640\u0641",
    "\u0007k\u0002\u0002\u0641\u0642\u0007p\u0002\u0002\u0642\u0643\u0007",
    "v\u0002\u0002\u0643\u0644\u0007u\u0002\u0002\u0644\u0162\u0003\u0002",
    "\u0002\u0002\u0645\u0646\u0007r\u0002\u0002\u0646\u0647\u0007q\u0002",
    "\u0002\u0647\u0648\u0007k\u0002\u0002\u0648\u0649\u0007p\u0002\u0002",
    "\u0649\u064a\u0007v\u0002\u0002\u064a\u0164\u0003\u0002\u0002\u0002",
    "\u064b\u064c\u0007v\u0002\u0002\u064c\u064d\u0007q\u0002\u0002\u064d",
    "\u064e\u0007v\u0002\u0002\u064e\u064f\u0007c\u0002\u0002\u064f\u0650",
    "\u0007n\u0002\u0002\u0650\u0166\u0003\u0002\u0002\u0002\u0651\u0652",
    "\u0007r\u0002\u0002\u0652\u0653\u0007c\u0002\u0002\u0653\u0654\u0007",
    "t\u0002\u0002\u0654\u0655\u0007v\u0002\u0002\u0655\u0656\u0007k\u0002",
    "\u0002\u0656\u0657\u0007c\u0002\u0002\u0657\u0658\u0007n\u0002\u0002",
    "\u0658\u0168\u0003\u0002\u0002\u0002\u0659\u065a\u0007c\u0002\u0002",
    "\u065a\u065b\u0007n\u0002\u0002\u065b\u065c\u0007y\u0002\u0002\u065c",
    "\u065d\u0007c\u0002\u0002\u065d\u065e\u0007{\u0002\u0002\u065e\u065f",
    "\u0007u\u0002\u0002\u065f\u016a\u0003\u0002\u0002\u0002\u0660\u0661",
    "\u0007k\u0002\u0002\u0661\u0662\u0007p\u0002\u0002\u0662\u0663\u0007",
    "p\u0002\u0002\u0663\u0664\u0007g\u0002\u0002\u0664\u0665\u0007t\u0002",
    "\u0002\u0665\u0666\u0007a\u0002\u0002\u0666\u0667\u0007l\u0002\u0002",
    "\u0667\u0668\u0007q\u0002\u0002\u0668\u0669\u0007k\u0002\u0002\u0669",
    "\u066a\u0007p\u0002\u0002\u066a\u016c\u0003\u0002\u0002\u0002\u066b",
    "\u066c\u0007n\u0002\u0002\u066c\u066d\u0007g\u0002\u0002\u066d\u066e",
    "\u0007h\u0002\u0002\u066e\u066f\u0007v\u0002\u0002\u066f\u0670\u0007",
    "a\u0002\u0002\u0670\u0671\u0007l\u0002\u0002\u0671\u0672\u0007q\u0002",
    "\u0002\u0672\u0673\u0007k\u0002\u0002\u0673\u0674\u0007p\u0002\u0002",
    "\u0674\u016e\u0003\u0002\u0002\u0002\u0675\u0676\u0007e\u0002\u0002",
    "\u0676\u0677\u0007t\u0002\u0002\u0677\u0678\u0007q\u0002\u0002\u0678",
    "\u0679\u0007u\u0002\u0002\u0679\u067a\u0007u\u0002\u0002\u067a\u067b",
    "\u0007a\u0002\u0002\u067b\u067c\u0007l\u0002\u0002\u067c\u067d\u0007",
    "q\u0002\u0002\u067d\u067e\u0007k\u0002\u0002\u067e\u067f\u0007p\u0002",
    "\u0002\u067f\u0170\u0003\u0002\u0002\u0002\u0680\u0681\u0007h\u0002",
    "\u0002\u0681\u0682\u0007w\u0002\u0002\u0682\u0683\u0007n\u0002\u0002",
    "\u0683\u0684\u0007n\u0002\u0002\u0684\u0685\u0007a\u0002\u0002\u0685",
    "\u0686\u0007l\u0002\u0002\u0686\u0687\u0007q\u0002\u0002\u0687\u0688",
    "\u0007k\u0002\u0002\u0688\u0689\u0007p\u0002\u0002\u0689\u0172\u0003",
    "\u0002\u0002\u0002\u068a\u068b\u0007o\u0002\u0002\u068b\u068c\u0007",
    "c\u0002\u0002\u068c\u068d\u0007r\u0002\u0002\u068d\u068e\u0007u\u0002",
    "\u0002\u068e\u068f\u0007a\u0002\u0002\u068f\u0690\u0007h\u0002\u0002",
    "\u0690\u0691\u0007t\u0002\u0002\u0691\u0692\u0007q\u0002\u0002\u0692",
    "\u0693\u0007o\u0002\u0002\u0693\u0174\u0003\u0002\u0002\u0002\u0694",
    "\u0695\u0007o\u0002\u0002\u0695\u0696\u0007c\u0002\u0002\u0696\u0697",
    "\u0007r\u0002\u0002\u0697\u0698\u0007u\u0002\u0002\u0698\u0699\u0007",
    "a\u0002\u0002\u0699\u069a\u0007v\u0002\u0002\u069a\u069b\u0007q\u0002",
    "\u0002\u069b\u0176\u0003\u0002\u0002\u0002\u069c\u069d\u0007o\u0002",
    "\u0002\u069d\u069e\u0007c\u0002\u0002\u069e\u069f\u0007r\u0002\u0002",
    "\u069f\u06a0\u0007a\u0002\u0002\u06a0\u06a1\u0007v\u0002\u0002\u06a1",
    "\u06a2\u0007q\u0002\u0002\u06a2\u0178\u0003\u0002\u0002\u0002\u06a3",
    "\u06a4\u0007o\u0002\u0002\u06a4\u06a5\u0007c\u0002\u0002\u06a5\u06a6",
    "\u0007r\u0002\u0002\u06a6\u06a7\u0007a\u0002\u0002\u06a7\u06a8\u0007",
    "h\u0002\u0002\u06a8\u06a9\u0007t\u0002\u0002\u06a9\u06aa\u0007q\u0002",
    "\u0002\u06aa\u06ab\u0007o\u0002\u0002\u06ab\u017a\u0003\u0002\u0002",
    "\u0002\u06ac\u06ad\u0007t\u0002\u0002\u06ad\u06ae\u0007g\u0002\u0002",
    "\u06ae\u06af\u0007v\u0002\u0002\u06af\u06b0\u0007w\u0002\u0002\u06b0",
    "\u06b1\u0007t\u0002\u0002\u06b1\u06b2\u0007p\u0002\u0002\u06b2\u06b3",
    "\u0007u\u0002\u0002\u06b3\u017c\u0003\u0002\u0002\u0002\u06b4\u06b5",
    "\u0007r\u0002\u0002\u06b5\u06b6\u0007k\u0002\u0002\u06b6\u06b7\u0007",
    "x\u0002\u0002\u06b7\u06b8\u0007q\u0002\u0002\u06b8\u06b9\u0007v\u0002",
    "\u0002\u06b9\u017e\u0003\u0002\u0002\u0002\u06ba\u06bb\u0007e\u0002",
    "\u0002\u06bb\u06bc\u0007w\u0002\u0002\u06bc\u06bd\u0007u\u0002\u0002",
    "\u06bd\u06be\u0007v\u0002\u0002\u06be\u06bf\u0007q\u0002\u0002\u06bf",
    "\u06c0\u0007o\u0002\u0002\u06c0\u06c1\u0007R\u0002\u0002\u06c1\u06c2",
    "\u0007k\u0002\u0002\u06c2\u06c3\u0007x\u0002\u0002\u06c3\u06c4\u0007",
    "q\u0002\u0002\u06c4\u06c5\u0007v\u0002\u0002\u06c5\u0180\u0003\u0002",
    "\u0002\u0002\u06c6\u06c7\u0007w\u0002\u0002\u06c7\u06c8\u0007p\u0002",
    "\u0002\u06c8\u06c9\u0007r\u0002\u0002\u06c9\u06ca\u0007k\u0002\u0002",
    "\u06ca\u06cb\u0007x\u0002\u0002\u06cb\u06cc\u0007q\u0002\u0002\u06cc",
    "\u06cd\u0007v\u0002\u0002\u06cd\u0182\u0003\u0002\u0002\u0002\u06ce",
    "\u06cf\u0007u\u0002\u0002\u06cf\u06d0\u0007w\u0002\u0002\u06d0\u06d1",
    "\u0007d\u0002\u0002\u06d1\u0184\u0003\u0002\u0002\u0002\u06d2\u06d3",
    "\u0007c\u0002\u0002\u06d3\u06d4\u0007r\u0002\u0002\u06d4\u06d5\u0007",
    "r\u0002\u0002\u06d5\u06d6\u0007n\u0002\u0002\u06d6\u06d7\u0007{\u0002",
    "\u0002\u06d7\u0186\u0003\u0002\u0002\u0002\u06d8\u06d9\u0007e\u0002",
    "\u0002\u06d9\u06da\u0007q\u0002\u0002\u06da\u06db\u0007p\u0002\u0002",
    "\u06db\u06dc\u0007f\u0002\u0002\u06dc\u06dd\u0007k\u0002\u0002\u06dd",
    "\u06de\u0007v\u0002\u0002\u06de\u06df\u0007k\u0002\u0002\u06df\u06e0",
    "\u0007q\u0002\u0002\u06e0\u06e1\u0007p\u0002\u0002\u06e1\u06e2\u0007",
    "g\u0002\u0002\u06e2\u06e3\u0007f\u0002\u0002\u06e3\u0188\u0003\u0002",
    "\u0002\u0002\u06e4\u06e5\u0007r\u0002\u0002\u06e5\u06e6\u0007g\u0002",
    "\u0002\u06e6\u06e7\u0007t\u0002\u0002\u06e7\u06e8\u0007k\u0002\u0002",
    "\u06e8\u06e9\u0007q\u0002\u0002\u06e9\u06ea\u0007f\u0002\u0002\u06ea",
    "\u06eb\u0007a\u0002\u0002\u06eb\u06ec\u0007k\u0002\u0002\u06ec\u06ed",
    "\u0007p\u0002\u0002\u06ed\u06ee\u0007f\u0002\u0002\u06ee\u06ef\u0007",
    "k\u0002\u0002\u06ef\u06f0\u0007e\u0002\u0002\u06f0\u06f1\u0007c\u0002",
    "\u0002\u06f1\u06f2\u0007v\u0002\u0002\u06f2\u06f3\u0007q\u0002\u0002",
    "\u06f3\u06f4\u0007t\u0002\u0002\u06f4\u018a\u0003\u0002\u0002\u0002",
    "\u06f5\u06f6\u0007u\u0002\u0002\u06f6\u06f7\u0007k\u0002\u0002\u06f7",
    "\u06f8\u0007p\u0002\u0002\u06f8\u06f9\u0007i\u0002\u0002\u06f9\u06fa",
    "\u0007n\u0002\u0002\u06fa\u06fb\u0007g\u0002\u0002\u06fb\u018c\u0003",
    "\u0002\u0002\u0002\u06fc\u06fd\u0007f\u0002\u0002\u06fd\u06fe\u0007",
    "w\u0002\u0002\u06fe\u06ff\u0007t\u0002\u0002\u06ff\u0700\u0007c\u0002",
    "\u0002\u0700\u0701\u0007v\u0002\u0002\u0701\u0702\u0007k\u0002\u0002",
    "\u0702\u0703\u0007q\u0002\u0002\u0703\u0704\u0007p\u0002\u0002\u0704",
    "\u018e\u0003\u0002\u0002\u0002\u0705\u0706\u0007v\u0002\u0002\u0706",
    "\u0707\u0007k\u0002\u0002\u0707\u0708\u0007o\u0002\u0002\u0708\u0709",
    "\u0007g\u0002\u0002\u0709\u070a\u0007a\u0002\u0002\u070a\u070b\u0007",
    "c\u0002\u0002\u070b\u070c\u0007i\u0002\u0002\u070c\u070d\u0007i\u0002",
    "\u0002\u070d\u0190\u0003\u0002\u0002\u0002\u070e\u070f\u0007w\u0002",
    "\u0002\u070f\u0710\u0007p\u0002\u0002\u0710\u0711\u0007k\u0002\u0002",
    "\u0711\u0712\u0007v\u0002\u0002\u0712\u0192\u0003\u0002\u0002\u0002",
    "\u0713\u0714\u0007X\u0002\u0002\u0714\u0715\u0007c\u0002\u0002\u0715",
    "\u0716\u0007n\u0002\u0002\u0716\u0717\u0007w\u0002\u0002\u0717\u0718",
    "\u0007g\u0002\u0002\u0718\u0194\u0003\u0002\u0002\u0002\u0719\u071a",
    "\u0007x\u0002\u0002\u071a\u071b\u0007c\u0002\u0002\u071b\u071c\u0007",
    "n\u0002\u0002\u071c\u071d\u0007w\u0002\u0002\u071d\u071e\u0007g\u0002",
    "\u0002\u071e\u071f\u0007f\u0002\u0002\u071f\u0720\u0007q\u0002\u0002",
    "\u0720\u0721\u0007o\u0002\u0002\u0721\u0722\u0007c\u0002\u0002\u0722",
    "\u0723\u0007k\u0002\u0002\u0723\u0724\u0007p\u0002\u0002\u0724\u0725",
    "\u0007u\u0002\u0002\u0725\u0196\u0003\u0002\u0002\u0002\u0726\u0727",
    "\u0007x\u0002\u0002\u0727\u0728\u0007c\u0002\u0002\u0728\u0729\u0007",
    "t\u0002\u0002\u0729\u072a\u0007k\u0002\u0002\u072a\u072b\u0007c\u0002",
    "\u0002\u072b\u072c\u0007d\u0002\u0002\u072c\u072d\u0007n\u0002\u0002",
    "\u072d\u072e\u0007g\u0002\u0002\u072e\u072f\u0007u\u0002\u0002\u072f",
    "\u0198\u0003\u0002\u0002\u0002\u0730\u0731\u0007k\u0002\u0002\u0731",
    "\u0732\u0007p\u0002\u0002\u0732\u0733\u0007r\u0002\u0002\u0733\u0734",
    "\u0007w\u0002\u0002\u0734\u0735\u0007v\u0002\u0002\u0735\u019a\u0003",
    "\u0002\u0002\u0002\u0736\u0737\u0007q\u0002\u0002\u0737\u0738\u0007",
    "w\u0002\u0002\u0738\u0739\u0007v\u0002\u0002\u0739\u073a\u0007r\u0002",
    "\u0002\u073a\u073b\u0007w\u0002\u0002\u073b\u073c\u0007v\u0002\u0002",
    "\u073c\u019c\u0003\u0002\u0002\u0002\u073d\u073e\u0007e\u0002\u0002",
    "\u073e\u073f\u0007c\u0002\u0002\u073f\u0740\u0007u\u0002\u0002\u0740",
    "\u0741\u0007v\u0002\u0002\u0741\u019e\u0003\u0002\u0002\u0002\u0742",
    "\u0743\u0007t\u0002\u0002\u0743\u0744\u0007w\u0002\u0002\u0744\u0745",
    "\u0007n\u0002\u0002\u0745\u0746\u0007g\u0002\u0002\u0746\u0747\u0007",
    "a\u0002\u0002\u0747\u0748\u0007r\u0002\u0002\u0748\u0749\u0007t\u0002",
    "\u0002\u0749\u074a\u0007k\u0002\u0002\u074a\u074b\u0007q\u0002\u0002",
    "\u074b\u074c\u0007t\u0002\u0002\u074c\u074d\u0007k\u0002\u0002\u074d",
    "\u074e\u0007v\u0002\u0002\u074e\u074f\u0007{\u0002\u0002\u074f\u01a0",
    "\u0003\u0002\u0002\u0002\u0750\u0751\u0007f\u0002\u0002\u0751\u0752",
    "\u0007c\u0002\u0002\u0752\u0753\u0007v\u0002\u0002\u0753\u0754\u0007",
    "c\u0002\u0002\u0754\u0755\u0007u\u0002\u0002\u0755\u0756\u0007g\u0002",
    "\u0002\u0756\u0757\u0007v\u0002\u0002\u0757\u0758\u0007a\u0002\u0002",
    "\u0758\u0759\u0007r\u0002\u0002\u0759\u075a\u0007t\u0002\u0002\u075a",
    "\u075b\u0007k\u0002\u0002\u075b\u075c\u0007q\u0002\u0002\u075c\u075d",
    "\u0007t\u0002\u0002\u075d\u075e\u0007k\u0002\u0002\u075e\u075f\u0007",
    "v\u0002\u0002\u075f\u0760\u0007{\u0002\u0002\u0760\u01a2\u0003\u0002",
    "\u0002\u0002\u0761\u0762\u0007f\u0002\u0002\u0762\u0763\u0007g\u0002",
    "\u0002\u0763\u0764\u0007h\u0002\u0002\u0764\u0765\u0007c\u0002\u0002",
    "\u0765\u0766\u0007w\u0002\u0002\u0766\u0767\u0007n\u0002\u0002\u0767",
    "\u0768\u0007v\u0002\u0002\u0768\u01a4\u0003\u0002\u0002\u0002\u0769",
    "\u076a\u0007e\u0002\u0002\u076a\u076b\u0007j\u0002\u0002\u076b\u076c",
    "\u0007g\u0002\u0002\u076c\u076d\u0007e\u0002\u0002\u076d\u076e\u0007",
    "m\u0002\u0002\u076e\u076f\u0007a\u0002\u0002\u076f\u0770\u0007f\u0002",
    "\u0002\u0770\u0771\u0007c\u0002\u0002\u0771\u0772\u0007v\u0002\u0002",
    "\u0772\u0773\u0007c\u0002\u0002\u0773\u0774\u0007r\u0002\u0002\u0774",
    "\u0775\u0007q\u0002\u0002\u0775\u0776\u0007k\u0002\u0002\u0776\u0777",
    "\u0007p\u0002\u0002\u0777\u0778\u0007v\u0002\u0002\u0778\u01a6\u0003",
    "\u0002\u0002\u0002\u0779\u077a\u0007e\u0002\u0002\u077a\u077b\u0007",
    "j\u0002\u0002\u077b\u077c\u0007g\u0002\u0002\u077c\u077d\u0007e\u0002",
    "\u0002\u077d\u077e\u0007m\u0002\u0002\u077e\u077f\u0007a\u0002\u0002",
    "\u077f\u0780\u0007j\u0002\u0002\u0780\u0781\u0007k\u0002\u0002\u0781",
    "\u0782\u0007g\u0002\u0002\u0782\u0783\u0007t\u0002\u0002\u0783\u0784",
    "\u0007c\u0002\u0002\u0784\u0785\u0007t\u0002\u0002\u0785\u0786\u0007",
    "e\u0002\u0002\u0786\u0787\u0007j\u0002\u0002\u0787\u0788\u0007{\u0002",
    "\u0002\u0788\u01a8\u0003\u0002\u0002\u0002\u0789\u078a\u0007e\u0002",
    "\u0002\u078a\u078b\u0007q\u0002\u0002\u078b\u078c\u0007o\u0002\u0002",
    "\u078c\u078d\u0007r\u0002\u0002\u078d\u078e\u0007w\u0002\u0002\u078e",
    "\u078f\u0007v\u0002\u0002\u078f\u0790\u0007g\u0002\u0002\u0790\u0791",
    "\u0007f\u0002\u0002\u0791\u01aa\u0003\u0002\u0002\u0002\u0792\u0793",
    "\u0007p\u0002\u0002\u0793\u0794\u0007q\u0002\u0002\u0794\u0795\u0007",
    "p\u0002\u0002\u0795\u0796\u0007a\u0002\u0002\u0796\u0797\u0007p\u0002",
    "\u0002\u0797\u0798\u0007w\u0002\u0002\u0798\u0799\u0007n\u0002\u0002",
    "\u0799\u079a\u0007n\u0002\u0002\u079a\u01ac\u0003\u0002\u0002\u0002",
    "\u079b\u079c\u0007p\u0002\u0002\u079c\u079d\u0007q\u0002\u0002\u079d",
    "\u079e\u0007p\u0002\u0002\u079e\u079f\u0007a\u0002\u0002\u079f\u07a0",
    "\u0007|\u0002\u0002\u07a0\u07a1\u0007g\u0002\u0002\u07a1\u07a2\u0007",
    "t\u0002\u0002\u07a2\u07a3\u0007q\u0002\u0002\u07a3\u01ae\u0003\u0002",
    "\u0002\u0002\u07a4\u07a5\u0007r\u0002\u0002\u07a5\u07a6\u0007c\u0002",
    "\u0002\u07a6\u07a7\u0007t\u0002\u0002\u07a7\u07a8\u0007v\u0002\u0002",
    "\u07a8\u07a9\u0007k\u0002\u0002\u07a9\u07aa\u0007c\u0002\u0002\u07aa",
    "\u07ab\u0007n\u0002\u0002\u07ab\u07ac\u0007a\u0002\u0002\u07ac\u07ad",
    "\u0007p\u0002\u0002\u07ad\u07ae\u0007w\u0002\u0002\u07ae\u07af\u0007",
    "n\u0002\u0002\u07af\u07b0\u0007n\u0002\u0002\u07b0\u01b0\u0003\u0002",
    "\u0002\u0002\u07b1\u07b2\u0007r\u0002\u0002\u07b2\u07b3\u0007c\u0002",
    "\u0002\u07b3\u07b4\u0007t\u0002\u0002\u07b4\u07b5\u0007v\u0002\u0002",
    "\u07b5\u07b6\u0007k\u0002\u0002\u07b6\u07b7\u0007c\u0002\u0002\u07b7",
    "\u07b8\u0007n\u0002\u0002\u07b8\u07b9\u0007a\u0002\u0002\u07b9\u07ba",
    "\u0007|\u0002\u0002\u07ba\u07bb\u0007g\u0002\u0002\u07bb\u07bc\u0007",
    "t\u0002\u0002\u07bc\u07bd\u0007q\u0002\u0002\u07bd\u01b2\u0003\u0002",
    "\u0002\u0002\u07be\u07bf\u0007c\u0002\u0002\u07bf\u07c0\u0007n\u0002",
    "\u0002\u07c0\u07c1\u0007y\u0002\u0002\u07c1\u07c2\u0007c\u0002\u0002",
    "\u07c2\u07c3\u0007{\u0002\u0002\u07c3\u07c4\u0007u\u0002\u0002\u07c4",
    "\u07c5\u0007a\u0002\u0002\u07c5\u07c6\u0007p\u0002\u0002\u07c6\u07c7",
    "\u0007w\u0002\u0002\u07c7\u07c8\u0007n\u0002\u0002\u07c8\u07c9\u0007",
    "n\u0002\u0002\u07c9\u01b4\u0003\u0002\u0002\u0002\u07ca\u07cb\u0007",
    "c\u0002\u0002\u07cb\u07cc\u0007n\u0002\u0002\u07cc\u07cd\u0007y\u0002",
    "\u0002\u07cd\u07ce\u0007c\u0002\u0002\u07ce\u07cf\u0007{\u0002\u0002",
    "\u07cf\u07d0\u0007u\u0002\u0002\u07d0\u07d1\u0007a\u0002\u0002\u07d1",
    "\u07d2\u0007|\u0002\u0002\u07d2\u07d3\u0007g\u0002\u0002\u07d3\u07d4",
    "\u0007t\u0002\u0002\u07d4\u07d5\u0007q\u0002\u0002\u07d5\u01b6\u0003",
    "\u0002\u0002\u0002\u07d6\u07d7\u0007e\u0002\u0002\u07d7\u07d8\u0007",
    "q\u0002\u0002\u07d8\u07d9\u0007o\u0002\u0002\u07d9\u07da\u0007r\u0002",
    "\u0002\u07da\u07db\u0007q\u0002\u0002\u07db\u07dc\u0007p\u0002\u0002",
    "\u07dc\u07dd\u0007g\u0002\u0002\u07dd\u07de\u0007p\u0002\u0002\u07de",
    "\u07df\u0007v\u0002\u0002\u07df\u07e0\u0007u\u0002\u0002\u07e0\u01b8",
    "\u0003\u0002\u0002\u0002\u07e1\u07e2\u0007c\u0002\u0002\u07e2\u07e3",
    "\u0007n\u0002\u0002\u07e3\u07e4\u0007n\u0002\u0002\u07e4\u07e5\u0007",
    "a\u0002\u0002\u07e5\u07e6\u0007o\u0002\u0002\u07e6\u07e7\u0007g\u0002",
    "\u0002\u07e7\u07e8\u0007c\u0002\u0002\u07e8\u07e9\u0007u\u0002\u0002",
    "\u07e9\u07ea\u0007w\u0002\u0002\u07ea\u07eb\u0007t\u0002\u0002\u07eb",
    "\u07ec\u0007g\u0002\u0002\u07ec\u07ed\u0007u\u0002\u0002\u07ed\u01ba",
    "\u0003\u0002\u0002\u0002\u07ee\u07ef\u0007u\u0002\u0002\u07ef\u07f0",
    "\u0007e\u0002\u0002\u07f0\u07f1\u0007c\u0002\u0002\u07f1\u07f2\u0007",
    "n\u0002\u0002\u07f2\u07f3\u0007c\u0002\u0002\u07f3\u07f4\u0007t\u0002",
    "\u0002\u07f4\u01bc\u0003\u0002\u0002\u0002\u07f5\u07f6\u0007e\u0002",
    "\u0002\u07f6\u07f7\u0007q\u0002\u0002\u07f7\u07f8\u0007o\u0002\u0002",
    "\u07f8\u07f9\u0007r\u0002\u0002\u07f9\u07fa\u0007q\u0002\u0002\u07fa",
    "\u07fb\u0007p\u0002\u0002\u07fb\u07fc\u0007g\u0002\u0002\u07fc\u07fd",
    "\u0007p\u0002\u0002\u07fd\u07fe\u0007v\u0002\u0002\u07fe\u01be\u0003",
    "\u0002\u0002\u0002\u07ff\u0800\u0007f\u0002\u0002\u0800\u0801\u0007",
    "c\u0002\u0002\u0801\u0802\u0007v\u0002\u0002\u0802\u0803\u0007c\u0002",
    "\u0002\u0803\u0804\u0007r\u0002\u0002\u0804\u0805\u0007q\u0002\u0002",
    "\u0805\u0806\u0007k\u0002\u0002\u0806\u0807\u0007p\u0002\u0002\u0807",
    "\u0808\u0007v\u0002\u0002\u0808\u0809\u0007a\u0002\u0002\u0809\u080a",
    "\u0007q\u0002\u0002\u080a\u080b\u0007p\u0002\u0002\u080b\u080c\u0007",
    "a\u0002\u0002\u080c\u080d\u0007x\u0002\u0002\u080d\u080e\u0007c\u0002",
    "\u0002\u080e\u080f\u0007n\u0002\u0002\u080f\u0810\u0007w\u0002\u0002",
    "\u0810\u0811\u0007g\u0002\u0002\u0811\u0812\u0007f\u0002\u0002\u0812",
    "\u0813\u0007q\u0002\u0002\u0813\u0814\u0007o\u0002\u0002\u0814\u0815",
    "\u0007c\u0002\u0002\u0815\u0816\u0007k\u0002\u0002\u0816\u0817\u0007",
    "p\u0002\u0002\u0817\u0818\u0007u\u0002\u0002\u0818\u01c0\u0003\u0002",
    "\u0002\u0002\u0819\u081a\u0007f\u0002\u0002\u081a\u081b\u0007c\u0002",
    "\u0002\u081b\u081c\u0007v\u0002\u0002\u081c\u081d\u0007c\u0002\u0002",
    "\u081d\u081e\u0007r\u0002\u0002\u081e\u081f\u0007q\u0002\u0002\u081f",
    "\u0820\u0007k\u0002\u0002\u0820\u0821\u0007p\u0002\u0002\u0821\u0822",
    "\u0007v\u0002\u0002\u0822\u0823\u0007a\u0002\u0002\u0823\u0824\u0007",
    "q\u0002\u0002\u0824\u0825\u0007p\u0002\u0002\u0825\u0826\u0007a\u0002",
    "\u0002\u0826\u0827\u0007x\u0002\u0002\u0827\u0828\u0007c\u0002\u0002",
    "\u0828\u0829\u0007t\u0002\u0002\u0829\u082a\u0007k\u0002\u0002\u082a",
    "\u082b\u0007c\u0002\u0002\u082b\u082c\u0007d\u0002\u0002\u082c\u082d",
    "\u0007n\u0002\u0002\u082d\u082e\u0007g\u0002\u0002\u082e\u082f\u0007",
    "u\u0002\u0002\u082f\u01c2\u0003\u0002\u0002\u0002\u0830\u0831\u0007",
    "j\u0002\u0002\u0831\u0832\u0007k\u0002\u0002\u0832\u0833\u0007g\u0002",
    "\u0002\u0833\u0834\u0007t\u0002\u0002\u0834\u0835\u0007c\u0002\u0002",
    "\u0835\u0836\u0007t\u0002\u0002\u0836\u0837\u0007e\u0002\u0002\u0837",
    "\u0838\u0007j\u0002\u0002\u0838\u0839\u0007k\u0002\u0002\u0839\u083a",
    "\u0007e\u0002\u0002\u083a\u083b\u0007c\u0002\u0002\u083b\u083c\u0007",
    "n\u0002\u0002\u083c\u083d\u0007a\u0002\u0002\u083d\u083e\u0007q\u0002",
    "\u0002\u083e\u083f\u0007p\u0002\u0002\u083f\u0840\u0007a\u0002\u0002",
    "\u0840\u0841\u0007x\u0002\u0002\u0841\u0842\u0007c\u0002\u0002\u0842",
    "\u0843\u0007n\u0002\u0002\u0843\u0844\u0007w\u0002\u0002\u0844\u0845",
    "\u0007g\u0002\u0002\u0845\u0846\u0007f\u0002\u0002\u0846\u0847\u0007",
    "q\u0002\u0002\u0847\u0848\u0007o\u0002\u0002\u0848\u0849\u0007c\u0002",
    "\u0002\u0849\u084a\u0007k\u0002\u0002\u084a\u084b\u0007p\u0002\u0002",
    "\u084b\u084c\u0007u\u0002\u0002\u084c\u01c4\u0003\u0002\u0002\u0002",
    "\u084d\u084e\u0007j\u0002\u0002\u084e\u084f\u0007k\u0002\u0002\u084f",
    "\u0850\u0007g\u0002\u0002\u0850\u0851\u0007t\u0002\u0002\u0851\u0852",
    "\u0007c\u0002\u0002\u0852\u0853\u0007t\u0002\u0002\u0853\u0854\u0007",
    "e\u0002\u0002\u0854\u0855\u0007j\u0002\u0002\u0855\u0856\u0007k\u0002",
    "\u0002\u0856\u0857\u0007e\u0002\u0002\u0857\u0858\u0007c\u0002\u0002",
    "\u0858\u0859\u0007n\u0002\u0002\u0859\u085a\u0007a\u0002\u0002\u085a",
    "\u085b\u0007q\u0002\u0002\u085b\u085c\u0007p\u0002\u0002\u085c\u085d",
    "\u0007a\u0002\u0002\u085d\u085e\u0007x\u0002\u0002\u085e\u085f\u0007",
    "c\u0002\u0002\u085f\u0860\u0007t\u0002\u0002\u0860\u0861\u0007k\u0002",
    "\u0002\u0861\u0862\u0007c\u0002\u0002\u0862\u0863\u0007d\u0002\u0002",
    "\u0863\u0864\u0007n\u0002\u0002\u0864\u0865\u0007g\u0002\u0002\u0865",
    "\u0866\u0007u\u0002\u0002\u0866\u01c6\u0003\u0002\u0002\u0002\u0867",
    "\u0868\u0007u\u0002\u0002\u0868\u0869\u0007g\u0002\u0002\u0869\u086a",
    "\u0007v\u0002\u0002\u086a\u01c8\u0003\u0002\u0002\u0002\u086b\u086c",
    "\u0007n\u0002\u0002\u086c\u086d\u0007c\u0002\u0002\u086d\u086e\u0007",
    "p\u0002\u0002\u086e\u086f\u0007i\u0002\u0002\u086f\u0870\u0007w\u0002",
    "\u0002\u0870\u0871\u0007c\u0002\u0002\u0871\u0872\u0007i\u0002\u0002",
    "\u0872\u0873\u0007g\u0002\u0002\u0873\u01ca\u0003\u0002\u0002\u0002",
    "\u0874\u0875\t\u0002\u0002\u0002\u0875\u01cc\u0003\u0002\u0002\u0002",
    "\u0876\u0877\u00042;\u0002\u0877\u01ce\u0003\u0002\u0002\u0002\u0878",
    "\u087a\u0005\u001d\u000f\u0002\u0879\u0878\u0003\u0002\u0002\u0002\u0879",
    "\u087a\u0003\u0002\u0002\u0002\u087a\u087c\u0003\u0002\u0002\u0002\u087b",
    "\u087d\u0005\u01cd\u00e7\u0002\u087c\u087b\u0003\u0002\u0002\u0002\u087d",
    "\u087e\u0003\u0002\u0002\u0002\u087e\u087c\u0003\u0002\u0002\u0002\u087e",
    "\u087f\u0003\u0002\u0002\u0002\u087f\u01d0\u0003\u0002\u0002\u0002\u0880",
    "\u0881\u0005\u01cf\u00e8\u0002\u0881\u0885\u00070\u0002\u0002\u0882",
    "\u0884\u0005\u01cf\u00e8\u0002\u0883\u0882\u0003\u0002\u0002\u0002\u0884",
    "\u0887\u0003\u0002\u0002\u0002\u0885\u0883\u0003\u0002\u0002\u0002\u0885",
    "\u0886\u0003\u0002\u0002\u0002\u0886\u01d2\u0003\u0002\u0002\u0002\u0887",
    "\u0885\u0003\u0002\u0002\u0002\u0888\u0889\u0007v\u0002\u0002\u0889",
    "\u088a\u0007t\u0002\u0002\u088a\u088b\u0007w\u0002\u0002\u088b\u0892",
    "\u0007g\u0002\u0002\u088c\u088d\u0007h\u0002\u0002\u088d\u088e\u0007",
    "c\u0002\u0002\u088e\u088f\u0007n\u0002\u0002\u088f\u0890\u0007u\u0002",
    "\u0002\u0890\u0892\u0007g\u0002\u0002\u0891\u0888\u0003\u0002\u0002",
    "\u0002\u0891\u088c\u0003\u0002\u0002\u0002\u0892\u01d4\u0003\u0002\u0002",
    "\u0002\u0893\u0897\u0007$\u0002\u0002\u0894\u0896\n\u0003\u0002\u0002",
    "\u0895\u0894\u0003\u0002\u0002\u0002\u0896\u0899\u0003\u0002\u0002\u0002",
    "\u0897\u0895\u0003\u0002\u0002\u0002\u0897\u0898\u0003\u0002\u0002\u0002",
    "\u0898\u089a\u0003\u0002\u0002\u0002\u0899\u0897\u0003\u0002\u0002\u0002",
    "\u089a\u089b\u0007$\u0002\u0002\u089b\u01d6\u0003\u0002\u0002\u0002",
    "\u089c\u08a0\u0005\u01cb\u00e6\u0002\u089d\u089f\t\u0004\u0002\u0002",
    "\u089e\u089d\u0003\u0002\u0002\u0002\u089f\u08a2\u0003\u0002\u0002\u0002",
    "\u08a0\u089e\u0003\u0002\u0002\u0002\u08a0\u08a1\u0003\u0002\u0002\u0002",
    "\u08a1\u08b2\u0003\u0002\u0002\u0002\u08a2\u08a0\u0003\u0002\u0002\u0002",
    "\u08a3\u08a5\u0005\u01cd\u00e7\u0002\u08a4\u08a6\t\u0004\u0002\u0002",
    "\u08a5\u08a4\u0003\u0002\u0002\u0002\u08a6\u08a7\u0003\u0002\u0002\u0002",
    "\u08a7\u08a5\u0003\u0002\u0002\u0002\u08a7\u08a8\u0003\u0002\u0002\u0002",
    "\u08a8\u08b2\u0003\u0002\u0002\u0002\u08a9\u08ad\u0007)\u0002\u0002",
    "\u08aa\u08ac\u000b\u0002\u0002\u0002\u08ab\u08aa\u0003\u0002\u0002\u0002",
    "\u08ac\u08af\u0003\u0002\u0002\u0002\u08ad\u08ae\u0003\u0002\u0002\u0002",
    "\u08ad\u08ab\u0003\u0002\u0002\u0002\u08ae\u08b0\u0003\u0002\u0002\u0002",
    "\u08af\u08ad\u0003\u0002\u0002\u0002\u08b0\u08b2\u0007)\u0002\u0002",
    "\u08b1\u089c\u0003\u0002\u0002\u0002\u08b1\u08a3\u0003\u0002\u0002\u0002",
    "\u08b1\u08a9\u0003\u0002\u0002\u0002\u08b2\u01d8\u0003\u0002\u0002\u0002",
    "\u08b3\u08b5\t\u0005\u0002\u0002\u08b4\u08b3\u0003\u0002\u0002\u0002",
    "\u08b5\u08b6\u0003\u0002\u0002\u0002\u08b6\u08b4\u0003\u0002\u0002\u0002",
    "\u08b6\u08b7\u0003\u0002\u0002\u0002\u08b7\u08b8\u0003\u0002\u0002\u0002",
    "\u08b8\u08b9\b\u00ed\u0002\u0002\u08b9\u01da\u0003\u0002\u0002\u0002",
    "\u08ba\u08bb\u0007=\u0002\u0002\u08bb\u01dc\u0003\u0002\u0002\u0002",
    "\u08bc\u08bd\u00071\u0002\u0002\u08bd\u08be\u0007,\u0002\u0002\u08be",
    "\u08c2\u0003\u0002\u0002\u0002\u08bf\u08c1\u000b\u0002\u0002\u0002\u08c0",
    "\u08bf\u0003\u0002\u0002\u0002\u08c1\u08c4\u0003\u0002\u0002\u0002\u08c2",
    "\u08c3\u0003\u0002\u0002\u0002\u08c2\u08c0\u0003\u0002\u0002\u0002\u08c3",
    "\u08c5\u0003\u0002\u0002\u0002\u08c4\u08c2\u0003\u0002\u0002\u0002\u08c5",
    "\u08c6\u0007,\u0002\u0002\u08c6\u08c7\u00071\u0002\u0002\u08c7\u08c8",
    "\u0003\u0002\u0002\u0002\u08c8\u08c9\b\u00ef\u0003\u0002\u08c9\u01de",
    "\u0003\u0002\u0002\u0002\u08ca\u08cb\u00071\u0002\u0002\u08cb\u08cc",
    "\u00071\u0002\u0002\u08cc\u08d0\u0003\u0002\u0002\u0002\u08cd\u08cf",
    "\u000b\u0002\u0002\u0002\u08ce\u08cd\u0003\u0002\u0002\u0002\u08cf\u08d2",
    "\u0003\u0002\u0002\u0002\u08d0\u08d1\u0003\u0002\u0002\u0002\u08d0\u08ce",
    "\u0003\u0002\u0002\u0002\u08d1\u08d3\u0003\u0002\u0002\u0002\u08d2\u08d0",
    "\u0003\u0002\u0002\u0002\u08d3\u08d4\u0007\f\u0002\u0002\u08d4\u08d5",
    "\u0003\u0002\u0002\u0002\u08d5\u08d6\b\u00f0\u0003\u0002\u08d6\u01e0",
    "\u0003\u0002\u0002\u0002\u000f\u0002\u0879\u087e\u0885\u0891\u0897\u08a0",
    "\u08a7\u08ad\u08b1\u08b6\u08c2\u08d0\u0004\u0002\u0003\u0002\u0002\u0004",
    "\u0002"].join("");


var atn = new antlr4.atn.ATNDeserializer().deserialize(serializedATN);

var decisionsToDFA = atn.decisionToState.map( function(ds, index) { return new antlr4.dfa.DFA(ds, index); });

function VtlLexer(input) {
	antlr4.Lexer.call(this, input);
    this._interp = new antlr4.atn.LexerATNSimulator(this, atn, decisionsToDFA, new antlr4.PredictionContextCache());
    return this;
}

VtlLexer.prototype = Object.create(antlr4.Lexer.prototype);
VtlLexer.prototype.constructor = VtlLexer;

Object.defineProperty(VtlLexer.prototype, "atn", {
        get : function() {
                return atn;
        }
});

VtlLexer.EOF = antlr4.Token.EOF;
VtlLexer.LPAREN = 1;
VtlLexer.RPAREN = 2;
VtlLexer.QLPAREN = 3;
VtlLexer.QRPAREN = 4;
VtlLexer.GLPAREN = 5;
VtlLexer.GRPAREN = 6;
VtlLexer.EQ = 7;
VtlLexer.LT = 8;
VtlLexer.MT = 9;
VtlLexer.ME = 10;
VtlLexer.NEQ = 11;
VtlLexer.LE = 12;
VtlLexer.PLUS = 13;
VtlLexer.MINUS = 14;
VtlLexer.MUL = 15;
VtlLexer.DIV = 16;
VtlLexer.COMMA = 17;
VtlLexer.POINTER = 18;
VtlLexer.ASSIGN = 19;
VtlLexer.MEMBERSHIP = 20;
VtlLexer.COLON = 21;
VtlLexer.EVAL = 22;
VtlLexer.IF = 23;
VtlLexer.THEN = 24;
VtlLexer.ELSE = 25;
VtlLexer.USING = 26;
VtlLexer.WITH = 27;
VtlLexer.CURRENT_DATE = 28;
VtlLexer.ON = 29;
VtlLexer.DROP = 30;
VtlLexer.KEEP = 31;
VtlLexer.CALC = 32;
VtlLexer.ATTRCALC = 33;
VtlLexer.RENAME = 34;
VtlLexer.AS = 35;
VtlLexer.AND = 36;
VtlLexer.OR = 37;
VtlLexer.XOR = 38;
VtlLexer.NOT = 39;
VtlLexer.BETWEEN = 40;
VtlLexer.IN = 41;
VtlLexer.NOT_IN = 42;
VtlLexer.NULL_CONSTANT = 43;
VtlLexer.ISNULL = 44;
VtlLexer.EX = 45;
VtlLexer.UNION = 46;
VtlLexer.DIFF = 47;
VtlLexer.SYMDIFF = 48;
VtlLexer.INTERSECT = 49;
VtlLexer.KEYS = 50;
VtlLexer.INTYEAR = 51;
VtlLexer.INTMONTH = 52;
VtlLexer.INTDAY = 53;
VtlLexer.CHECK = 54;
VtlLexer.EXISTS_IN = 55;
VtlLexer.TO = 56;
VtlLexer.RETURN = 57;
VtlLexer.IMBALANCE = 58;
VtlLexer.ERRORCODE = 59;
VtlLexer.ALL = 60;
VtlLexer.AGGREGATE = 61;
VtlLexer.ERRORLEVEL = 62;
VtlLexer.ORDER = 63;
VtlLexer.BY = 64;
VtlLexer.RANK = 65;
VtlLexer.ASC = 66;
VtlLexer.DESC = 67;
VtlLexer.MIN = 68;
VtlLexer.MAX = 69;
VtlLexer.FIRST = 70;
VtlLexer.LAST = 71;
VtlLexer.INDEXOF = 72;
VtlLexer.ABS = 73;
VtlLexer.KEY = 74;
VtlLexer.LN = 75;
VtlLexer.LOG = 76;
VtlLexer.TRUNC = 77;
VtlLexer.ROUND = 78;
VtlLexer.POWER = 79;
VtlLexer.MOD = 80;
VtlLexer.LEN = 81;
VtlLexer.CONCAT = 82;
VtlLexer.TRIM = 83;
VtlLexer.UCASE = 84;
VtlLexer.LCASE = 85;
VtlLexer.SUBSTR = 86;
VtlLexer.SUM = 87;
VtlLexer.AVG = 88;
VtlLexer.MEDIAN = 89;
VtlLexer.COUNT = 90;
VtlLexer.DIMENSION = 91;
VtlLexer.MEASURE = 92;
VtlLexer.ATTRIBUTE = 93;
VtlLexer.FILTER = 94;
VtlLexer.MERGE = 95;
VtlLexer.EXP = 96;
VtlLexer.ROLE = 97;
VtlLexer.VIRAL = 98;
VtlLexer.CHARSET_MATCH = 99;
VtlLexer.TYPE = 100;
VtlLexer.NVL = 101;
VtlLexer.HIERARCHY = 102;
VtlLexer.OPTIONAL = 103;
VtlLexer.INVALID = 104;
VtlLexer.VALUE_DOMAIN = 105;
VtlLexer.VARIABLE = 106;
VtlLexer.DATA = 107;
VtlLexer.STRUCTURE = 108;
VtlLexer.DATASET = 109;
VtlLexer.OPERATOR = 110;
VtlLexer.DEFINE = 111;
VtlLexer.PUT_SYMBOL = 112;
VtlLexer.DATAPOINT = 113;
VtlLexer.HIERARCHICAL = 114;
VtlLexer.RULESET = 115;
VtlLexer.RULE = 116;
VtlLexer.END = 117;
VtlLexer.ALTER_DATASET = 118;
VtlLexer.LTRIM = 119;
VtlLexer.RTRIM = 120;
VtlLexer.INSTR = 121;
VtlLexer.REPLACE = 122;
VtlLexer.CEIL = 123;
VtlLexer.FLOOR = 124;
VtlLexer.SQRT = 125;
VtlLexer.ANY = 126;
VtlLexer.SETDIFF = 127;
VtlLexer.STDDEV_POP = 128;
VtlLexer.STDDEV_SAMP = 129;
VtlLexer.VAR_POP = 130;
VtlLexer.VAR_SAMP = 131;
VtlLexer.GROUP = 132;
VtlLexer.EXCEPT = 133;
VtlLexer.HAVING = 134;
VtlLexer.FIRST_VALUE = 135;
VtlLexer.LAST_VALUE = 136;
VtlLexer.LAG = 137;
VtlLexer.LEAD = 138;
VtlLexer.RATIO_TO_REPORT = 139;
VtlLexer.OVER = 140;
VtlLexer.PRECEDING = 141;
VtlLexer.FOLLOWING = 142;
VtlLexer.UNBOUNDED = 143;
VtlLexer.PARTITION = 144;
VtlLexer.ROWS = 145;
VtlLexer.RANGE = 146;
VtlLexer.CURRENT = 147;
VtlLexer.VALID = 148;
VtlLexer.FILL_TIME_SERIES = 149;
VtlLexer.FLOW_TO_STOCK = 150;
VtlLexer.STOCK_TO_FLOW = 151;
VtlLexer.TIMESHIFT = 152;
VtlLexer.MEASURES = 153;
VtlLexer.NO_MEASURES = 154;
VtlLexer.CONDITION = 155;
VtlLexer.BOOLEAN = 156;
VtlLexer.DATE = 157;
VtlLexer.TIME_PERIOD = 158;
VtlLexer.NUMBER = 159;
VtlLexer.STRING = 160;
VtlLexer.TIME = 161;
VtlLexer.INTEGER = 162;
VtlLexer.FLOAT = 163;
VtlLexer.LIST = 164;
VtlLexer.RECORD = 165;
VtlLexer.RESTRICT = 166;
VtlLexer.YYYY = 167;
VtlLexer.MM = 168;
VtlLexer.DD = 169;
VtlLexer.MAX_LENGTH = 170;
VtlLexer.REGEXP = 171;
VtlLexer.IS = 172;
VtlLexer.WHEN = 173;
VtlLexer.FROM = 174;
VtlLexer.AGGREGATES = 175;
VtlLexer.POINTS = 176;
VtlLexer.POINT = 177;
VtlLexer.TOTAL = 178;
VtlLexer.PARTIAL = 179;
VtlLexer.ALWAYS = 180;
VtlLexer.INNER_JOIN = 181;
VtlLexer.LEFT_JOIN = 182;
VtlLexer.CROSS_JOIN = 183;
VtlLexer.FULL_JOIN = 184;
VtlLexer.MAPS_FROM = 185;
VtlLexer.MAPS_TO = 186;
VtlLexer.MAP_TO = 187;
VtlLexer.MAP_FROM = 188;
VtlLexer.RETURNS = 189;
VtlLexer.PIVOT = 190;
VtlLexer.CUSTOMPIVOT = 191;
VtlLexer.UNPIVOT = 192;
VtlLexer.SUBSPACE = 193;
VtlLexer.APPLY = 194;
VtlLexer.CONDITIONED = 195;
VtlLexer.PERIOD_INDICATOR = 196;
VtlLexer.SINGLE = 197;
VtlLexer.DURATION = 198;
VtlLexer.TIME_AGG = 199;
VtlLexer.UNIT = 200;
VtlLexer.VALUE = 201;
VtlLexer.VALUEDOMAINS = 202;
VtlLexer.VARIABLES = 203;
VtlLexer.INPUT = 204;
VtlLexer.OUTPUT = 205;
VtlLexer.CAST = 206;
VtlLexer.RULE_PRIORITY = 207;
VtlLexer.DATASET_PRIORITY = 208;
VtlLexer.DEFAULT = 209;
VtlLexer.CHECK_DATAPOINT = 210;
VtlLexer.CHECK_HIERARCHY = 211;
VtlLexer.COMPUTED = 212;
VtlLexer.NON_NULL = 213;
VtlLexer.NON_ZERO = 214;
VtlLexer.PARTIAL_NULL = 215;
VtlLexer.PARTIAL_ZERO = 216;
VtlLexer.ALWAYS_NULL = 217;
VtlLexer.ALWAYS_ZERO = 218;
VtlLexer.COMPONENTS = 219;
VtlLexer.ALL_MEASURES = 220;
VtlLexer.SCALAR = 221;
VtlLexer.COMPONENT = 222;
VtlLexer.DATAPOINT_ON_VD = 223;
VtlLexer.DATAPOINT_ON_VAR = 224;
VtlLexer.HIERARCHICAL_ON_VD = 225;
VtlLexer.HIERARCHICAL_ON_VAR = 226;
VtlLexer.SET = 227;
VtlLexer.LANGUAGE = 228;
VtlLexer.INTEGER_CONSTANT = 229;
VtlLexer.NUMBER_CONSTANT = 230;
VtlLexer.BOOLEAN_CONSTANT = 231;
VtlLexer.STRING_CONSTANT = 232;
VtlLexer.IDENTIFIER = 233;
VtlLexer.WS = 234;
VtlLexer.EOL = 235;
VtlLexer.ML_COMMENT = 236;
VtlLexer.SL_COMMENT = 237;

VtlLexer.prototype.channelNames = [ "DEFAULT_TOKEN_CHANNEL", "HIDDEN" ];

VtlLexer.prototype.modeNames = [ "DEFAULT_MODE" ];

VtlLexer.prototype.literalNames = [ null, "'('", "')'", "'['", "']'", "'{'", 
                                    "'}'", "'='", "'<'", "'>'", "'>='", 
                                    "'<>'", "'<='", "'+'", "'-'", "'*'", 
                                    "'/'", "','", "'->'", "':='", "'#'", 
                                    "':'", "'eval'", "'if'", "'then'", "'else'", 
                                    "'using'", "'with'", "'current_date'", 
                                    "'on'", "'drop'", "'keep'", "'calc'", 
                                    "'attrcalc'", "'rename'", "'as'", "'and'", 
                                    "'or'", "'xor'", "'not'", "'between'", 
                                    "'in'", "'not_in'", "'null'", "'isnull'", 
                                    "'ex'", "'union'", "'diff'", "'symdiff'", 
                                    "'intersect'", "'keys'", "'intyear'", 
                                    "'intmonth'", "'intday'", "'check'", 
                                    "'exists_in'", "'to'", "'return'", "'imbalance'", 
                                    "'errorcode'", "'all'", "'aggr'", "'errorlevel'", 
                                    "'order'", "'by'", "'rank'", "'asc'", 
                                    "'desc'", "'min'", "'max'", "'first'", 
                                    "'last'", "'indexof'", "'abs'", "'key'", 
                                    "'ln'", "'log'", "'trunc'", "'round'", 
                                    "'power'", "'mod'", "'length'", "'||'", 
                                    "'trim'", "'upper'", "'lower'", "'substr'", 
                                    "'sum'", "'avg'", "'median'", "'count'", 
                                    "'identifier'", "'measure'", "'attribute'", 
                                    "'filter'", "'merge'", "'exp'", "'componentRole'", 
                                    "'viral'", "'match_characters'", "'type'", 
                                    "'nvl'", "'hierarchy'", "'_'", "'invalid'", 
                                    "'valuedomain'", "'variable'", "'data'", 
                                    "'structure'", "'dataset'", "'operator'", 
                                    "'define'", "'<-'", "'datapoint'", "'hierarchical'", 
                                    "'ruleset'", "'rule'", "'end'", "'alterDataset'", 
                                    "'ltrim'", "'rtrim'", "'instr'", "'replace'", 
                                    "'ceil'", "'floor'", "'sqrt'", "'any'", 
                                    "'setdiff'", "'stddev_pop'", "'stddev_samp'", 
                                    "'var_pop'", "'var_samp'", "'group'", 
                                    "'except'", "'having'", "'first_value'", 
                                    "'last_value'", "'lag'", "'lead'", "'ratio_to_report'", 
                                    "'over'", "'preceding'", "'following'", 
                                    "'unbounded'", "'partition'", "'rows'", 
                                    "'range'", "'current'", "'valid'", "'fill_time_series'", 
                                    "'flow_to_stock'", "'stock_to_flow'", 
                                    "'timeshift'", "'measures'", "'no_measures'", 
                                    "'condition'", "'boolean'", "'date'", 
                                    "'time_period'", "'number'", "'string'", 
                                    "'time'", "'integer'", "'float'", "'list'", 
                                    "'record'", "'restrict'", "'yyyy'", 
                                    "'mm'", "'dd'", "'maxLength'", "'regexp'", 
                                    "'is'", "'when'", "'from'", "'aggregates'", 
                                    "'points'", "'point'", "'total'", "'partial'", 
                                    "'always'", "'inner_join'", "'left_join'", 
                                    "'cross_join'", "'full_join'", "'maps_from'", 
                                    "'maps_to'", "'map_to'", "'map_from'", 
                                    "'returns'", "'pivot'", "'customPivot'", 
                                    "'unpivot'", "'sub'", "'apply'", "'conditioned'", 
                                    "'period_indicator'", "'single'", "'duration'", 
                                    "'time_agg'", "'unit'", "'Value'", "'valuedomains'", 
                                    "'variables'", "'input'", "'output'", 
                                    "'cast'", "'rule_priority'", "'dataset_priority'", 
                                    "'default'", "'check_datapoint'", "'check_hierarchy'", 
                                    "'computed'", "'non_null'", "'non_zero'", 
                                    "'partial_null'", "'partial_zero'", 
                                    "'always_null'", "'always_zero'", "'components'", 
                                    "'all_measures'", "'scalar'", "'component'", 
                                    "'datapoint_on_valuedomains'", "'datapoint_on_variables'", 
                                    "'hierarchical_on_valuedomains'", "'hierarchical_on_variables'", 
                                    "'set'", "'language'", null, null, null, 
                                    null, null, null, "';'" ];

VtlLexer.prototype.symbolicNames = [ null, "LPAREN", "RPAREN", "QLPAREN", 
                                     "QRPAREN", "GLPAREN", "GRPAREN", "EQ", 
                                     "LT", "MT", "ME", "NEQ", "LE", "PLUS", 
                                     "MINUS", "MUL", "DIV", "COMMA", "POINTER", 
                                     "ASSIGN", "MEMBERSHIP", "COLON", "EVAL", 
                                     "IF", "THEN", "ELSE", "USING", "WITH", 
                                     "CURRENT_DATE", "ON", "DROP", "KEEP", 
                                     "CALC", "ATTRCALC", "RENAME", "AS", 
                                     "AND", "OR", "XOR", "NOT", "BETWEEN", 
                                     "IN", "NOT_IN", "NULL_CONSTANT", "ISNULL", 
                                     "EX", "UNION", "DIFF", "SYMDIFF", "INTERSECT", 
                                     "KEYS", "INTYEAR", "INTMONTH", "INTDAY", 
                                     "CHECK", "EXISTS_IN", "TO", "RETURN", 
                                     "IMBALANCE", "ERRORCODE", "ALL", "AGGREGATE", 
                                     "ERRORLEVEL", "ORDER", "BY", "RANK", 
                                     "ASC", "DESC", "MIN", "MAX", "FIRST", 
                                     "LAST", "INDEXOF", "ABS", "KEY", "LN", 
                                     "LOG", "TRUNC", "ROUND", "POWER", "MOD", 
                                     "LEN", "CONCAT", "TRIM", "UCASE", "LCASE", 
                                     "SUBSTR", "SUM", "AVG", "MEDIAN", "COUNT", 
                                     "DIMENSION", "MEASURE", "ATTRIBUTE", 
                                     "FILTER", "MERGE", "EXP", "ROLE", "VIRAL", 
                                     "CHARSET_MATCH", "TYPE", "NVL", "HIERARCHY", 
                                     "OPTIONAL", "INVALID", "VALUE_DOMAIN", 
                                     "VARIABLE", "DATA", "STRUCTURE", "DATASET", 
                                     "OPERATOR", "DEFINE", "PUT_SYMBOL", 
                                     "DATAPOINT", "HIERARCHICAL", "RULESET", 
                                     "RULE", "END", "ALTER_DATASET", "LTRIM", 
                                     "RTRIM", "INSTR", "REPLACE", "CEIL", 
                                     "FLOOR", "SQRT", "ANY", "SETDIFF", 
                                     "STDDEV_POP", "STDDEV_SAMP", "VAR_POP", 
                                     "VAR_SAMP", "GROUP", "EXCEPT", "HAVING", 
                                     "FIRST_VALUE", "LAST_VALUE", "LAG", 
                                     "LEAD", "RATIO_TO_REPORT", "OVER", 
                                     "PRECEDING", "FOLLOWING", "UNBOUNDED", 
                                     "PARTITION", "ROWS", "RANGE", "CURRENT", 
                                     "VALID", "FILL_TIME_SERIES", "FLOW_TO_STOCK", 
                                     "STOCK_TO_FLOW", "TIMESHIFT", "MEASURES", 
                                     "NO_MEASURES", "CONDITION", "BOOLEAN", 
                                     "DATE", "TIME_PERIOD", "NUMBER", "STRING", 
                                     "TIME", "INTEGER", "FLOAT", "LIST", 
                                     "RECORD", "RESTRICT", "YYYY", "MM", 
                                     "DD", "MAX_LENGTH", "REGEXP", "IS", 
                                     "WHEN", "FROM", "AGGREGATES", "POINTS", 
                                     "POINT", "TOTAL", "PARTIAL", "ALWAYS", 
                                     "INNER_JOIN", "LEFT_JOIN", "CROSS_JOIN", 
                                     "FULL_JOIN", "MAPS_FROM", "MAPS_TO", 
                                     "MAP_TO", "MAP_FROM", "RETURNS", "PIVOT", 
                                     "CUSTOMPIVOT", "UNPIVOT", "SUBSPACE", 
                                     "APPLY", "CONDITIONED", "PERIOD_INDICATOR", 
                                     "SINGLE", "DURATION", "TIME_AGG", "UNIT", 
                                     "VALUE", "VALUEDOMAINS", "VARIABLES", 
                                     "INPUT", "OUTPUT", "CAST", "RULE_PRIORITY", 
                                     "DATASET_PRIORITY", "DEFAULT", "CHECK_DATAPOINT", 
                                     "CHECK_HIERARCHY", "COMPUTED", "NON_NULL", 
                                     "NON_ZERO", "PARTIAL_NULL", "PARTIAL_ZERO", 
                                     "ALWAYS_NULL", "ALWAYS_ZERO", "COMPONENTS", 
                                     "ALL_MEASURES", "SCALAR", "COMPONENT", 
                                     "DATAPOINT_ON_VD", "DATAPOINT_ON_VAR", 
                                     "HIERARCHICAL_ON_VD", "HIERARCHICAL_ON_VAR", 
                                     "SET", "LANGUAGE", "INTEGER_CONSTANT", 
                                     "NUMBER_CONSTANT", "BOOLEAN_CONSTANT", 
                                     "STRING_CONSTANT", "IDENTIFIER", "WS", 
                                     "EOL", "ML_COMMENT", "SL_COMMENT" ];

VtlLexer.prototype.ruleNames = [ "LPAREN", "RPAREN", "QLPAREN", "QRPAREN", 
                                 "GLPAREN", "GRPAREN", "EQ", "LT", "MT", 
                                 "ME", "NEQ", "LE", "PLUS", "MINUS", "MUL", 
                                 "DIV", "COMMA", "POINTER", "ASSIGN", "MEMBERSHIP", 
                                 "COLON", "EVAL", "IF", "THEN", "ELSE", 
                                 "USING", "WITH", "CURRENT_DATE", "ON", 
                                 "DROP", "KEEP", "CALC", "ATTRCALC", "RENAME", 
                                 "AS", "AND", "OR", "XOR", "NOT", "BETWEEN", 
                                 "IN", "NOT_IN", "NULL_CONSTANT", "ISNULL", 
                                 "EX", "UNION", "DIFF", "SYMDIFF", "INTERSECT", 
                                 "KEYS", "INTYEAR", "INTMONTH", "INTDAY", 
                                 "CHECK", "EXISTS_IN", "TO", "RETURN", "IMBALANCE", 
                                 "ERRORCODE", "ALL", "AGGREGATE", "ERRORLEVEL", 
                                 "ORDER", "BY", "RANK", "ASC", "DESC", "MIN", 
                                 "MAX", "FIRST", "LAST", "INDEXOF", "ABS", 
                                 "KEY", "LN", "LOG", "TRUNC", "ROUND", "POWER", 
                                 "MOD", "LEN", "CONCAT", "TRIM", "UCASE", 
                                 "LCASE", "SUBSTR", "SUM", "AVG", "MEDIAN", 
                                 "COUNT", "DIMENSION", "MEASURE", "ATTRIBUTE", 
                                 "FILTER", "MERGE", "EXP", "ROLE", "VIRAL", 
                                 "CHARSET_MATCH", "TYPE", "NVL", "HIERARCHY", 
                                 "OPTIONAL", "INVALID", "VALUE_DOMAIN", 
                                 "VARIABLE", "DATA", "STRUCTURE", "DATASET", 
                                 "OPERATOR", "DEFINE", "PUT_SYMBOL", "DATAPOINT", 
                                 "HIERARCHICAL", "RULESET", "RULE", "END", 
                                 "ALTER_DATASET", "LTRIM", "RTRIM", "INSTR", 
                                 "REPLACE", "CEIL", "FLOOR", "SQRT", "ANY", 
                                 "SETDIFF", "STDDEV_POP", "STDDEV_SAMP", 
                                 "VAR_POP", "VAR_SAMP", "GROUP", "EXCEPT", 
                                 "HAVING", "FIRST_VALUE", "LAST_VALUE", 
                                 "LAG", "LEAD", "RATIO_TO_REPORT", "OVER", 
                                 "PRECEDING", "FOLLOWING", "UNBOUNDED", 
                                 "PARTITION", "ROWS", "RANGE", "CURRENT", 
                                 "VALID", "FILL_TIME_SERIES", "FLOW_TO_STOCK", 
                                 "STOCK_TO_FLOW", "TIMESHIFT", "MEASURES", 
                                 "NO_MEASURES", "CONDITION", "BOOLEAN", 
                                 "DATE", "TIME_PERIOD", "NUMBER", "STRING", 
                                 "TIME", "INTEGER", "FLOAT", "LIST", "RECORD", 
                                 "RESTRICT", "YYYY", "MM", "DD", "MAX_LENGTH", 
                                 "REGEXP", "IS", "WHEN", "FROM", "AGGREGATES", 
                                 "POINTS", "POINT", "TOTAL", "PARTIAL", 
                                 "ALWAYS", "INNER_JOIN", "LEFT_JOIN", "CROSS_JOIN", 
                                 "FULL_JOIN", "MAPS_FROM", "MAPS_TO", "MAP_TO", 
                                 "MAP_FROM", "RETURNS", "PIVOT", "CUSTOMPIVOT", 
                                 "UNPIVOT", "SUBSPACE", "APPLY", "CONDITIONED", 
                                 "PERIOD_INDICATOR", "SINGLE", "DURATION", 
                                 "TIME_AGG", "UNIT", "VALUE", "VALUEDOMAINS", 
                                 "VARIABLES", "INPUT", "OUTPUT", "CAST", 
                                 "RULE_PRIORITY", "DATASET_PRIORITY", "DEFAULT", 
                                 "CHECK_DATAPOINT", "CHECK_HIERARCHY", "COMPUTED", 
                                 "NON_NULL", "NON_ZERO", "PARTIAL_NULL", 
                                 "PARTIAL_ZERO", "ALWAYS_NULL", "ALWAYS_ZERO", 
                                 "COMPONENTS", "ALL_MEASURES", "SCALAR", 
                                 "COMPONENT", "DATAPOINT_ON_VD", "DATAPOINT_ON_VAR", 
                                 "HIERARCHICAL_ON_VD", "HIERARCHICAL_ON_VAR", 
                                 "SET", "LANGUAGE", "LETTER", "DIGITS0_9", 
                                 "INTEGER_CONSTANT", "NUMBER_CONSTANT", 
                                 "BOOLEAN_CONSTANT", "STRING_CONSTANT", 
                                 "IDENTIFIER", "WS", "EOL", "ML_COMMENT", 
                                 "SL_COMMENT" ];

VtlLexer.prototype.grammarFileName = "Vtl.g4";


exports.VtlLexer = VtlLexer;


},{"antlr4/index":84}],320:[function(require,module,exports){
// Generated from Vtl.g4 by ANTLR 4.8
// jshint ignore: start
var antlr4 = require('antlr4/index');
var grammarFileName = "Vtl.g4";


var serializedATN = ["\u0003\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964",
    "\u0003\u00ef\u068b\u0004\u0002\t\u0002\u0004\u0003\t\u0003\u0004\u0004",
    "\t\u0004\u0004\u0005\t\u0005\u0004\u0006\t\u0006\u0004\u0007\t\u0007",
    "\u0004\b\t\b\u0004\t\t\t\u0004\n\t\n\u0004\u000b\t\u000b\u0004\f\t\f",
    "\u0004\r\t\r\u0004\u000e\t\u000e\u0004\u000f\t\u000f\u0004\u0010\t\u0010",
    "\u0004\u0011\t\u0011\u0004\u0012\t\u0012\u0004\u0013\t\u0013\u0004\u0014",
    "\t\u0014\u0004\u0015\t\u0015\u0004\u0016\t\u0016\u0004\u0017\t\u0017",
    "\u0004\u0018\t\u0018\u0004\u0019\t\u0019\u0004\u001a\t\u001a\u0004\u001b",
    "\t\u001b\u0004\u001c\t\u001c\u0004\u001d\t\u001d\u0004\u001e\t\u001e",
    "\u0004\u001f\t\u001f\u0004 \t \u0004!\t!\u0004\"\t\"\u0004#\t#\u0004",
    "$\t$\u0004%\t%\u0004&\t&\u0004\'\t\'\u0004(\t(\u0004)\t)\u0004*\t*\u0004",
    "+\t+\u0004,\t,\u0004-\t-\u0004.\t.\u0004/\t/\u00040\t0\u00041\t1\u0004",
    "2\t2\u00043\t3\u00044\t4\u00045\t5\u00046\t6\u00047\t7\u00048\t8\u0004",
    "9\t9\u0004:\t:\u0004;\t;\u0004<\t<\u0004=\t=\u0004>\t>\u0004?\t?\u0004",
    "@\t@\u0004A\tA\u0004B\tB\u0004C\tC\u0004D\tD\u0004E\tE\u0004F\tF\u0004",
    "G\tG\u0004H\tH\u0004I\tI\u0004J\tJ\u0004K\tK\u0004L\tL\u0004M\tM\u0004",
    "N\tN\u0004O\tO\u0004P\tP\u0004Q\tQ\u0004R\tR\u0004S\tS\u0004T\tT\u0004",
    "U\tU\u0004V\tV\u0004W\tW\u0004X\tX\u0004Y\tY\u0004Z\tZ\u0004[\t[\u0004",
    "\\\t\\\u0004]\t]\u0004^\t^\u0004_\t_\u0004`\t`\u0004a\ta\u0004b\tb\u0004",
    "c\tc\u0004d\td\u0004e\te\u0004f\tf\u0004g\tg\u0004h\th\u0004i\ti\u0004",
    "j\tj\u0004k\tk\u0004l\tl\u0003\u0002\u0003\u0002\u0003\u0002\u0007\u0002",
    "\u00dc\n\u0002\f\u0002\u000e\u0002\u00df\u000b\u0002\u0003\u0002\u0003",
    "\u0002\u0003\u0003\u0003\u0003\u0003\u0003\u0003\u0003\u0003\u0003\u0003",
    "\u0003\u0003\u0003\u0003\u0003\u0003\u0003\u0005\u0003\u00ec\n\u0003",
    "\u0003\u0004\u0003\u0004\u0003\u0004\u0003\u0004\u0003\u0004\u0003\u0004",
    "\u0003\u0004\u0003\u0004\u0003\u0004\u0003\u0004\u0003\u0004\u0003\u0004",
    "\u0003\u0004\u0003\u0004\u0003\u0004\u0003\u0004\u0003\u0004\u0005\u0004",
    "\u00ff\n\u0004\u0003\u0004\u0003\u0004\u0003\u0004\u0003\u0004\u0003",
    "\u0004\u0003\u0004\u0003\u0004\u0003\u0004\u0003\u0004\u0003\u0004\u0003",
    "\u0004\u0003\u0004\u0003\u0004\u0003\u0004\u0003\u0004\u0003\u0004\u0003",
    "\u0004\u0003\u0004\u0003\u0004\u0003\u0004\u0003\u0004\u0003\u0004\u0003",
    "\u0004\u0003\u0004\u0003\u0004\u0003\u0004\u0003\u0004\u0007\u0004\u011c",
    "\n\u0004\f\u0004\u000e\u0004\u011f\u000b\u0004\u0003\u0005\u0003\u0005",
    "\u0003\u0005\u0003\u0005\u0003\u0005\u0003\u0005\u0003\u0005\u0003\u0005",
    "\u0003\u0005\u0003\u0005\u0003\u0005\u0003\u0005\u0003\u0005\u0003\u0005",
    "\u0003\u0005\u0003\u0005\u0003\u0005\u0005\u0005\u0132\n\u0005\u0003",
    "\u0005\u0003\u0005\u0003\u0005\u0003\u0005\u0003\u0005\u0003\u0005\u0003",
    "\u0005\u0003\u0005\u0003\u0005\u0003\u0005\u0003\u0005\u0003\u0005\u0003",
    "\u0005\u0003\u0005\u0003\u0005\u0003\u0005\u0003\u0005\u0003\u0005\u0003",
    "\u0005\u0007\u0005\u0147\n\u0005\f\u0005\u000e\u0005\u014a\u000b\u0005",
    "\u0003\u0006\u0003\u0006\u0003\u0006\u0003\u0006\u0003\u0006\u0003\u0006",
    "\u0003\u0006\u0003\u0006\u0005\u0006\u0154\n\u0006\u0003\u0007\u0003",
    "\u0007\u0003\u0007\u0003\u0007\u0003\u0007\u0003\u0007\u0003\u0007\u0003",
    "\u0007\u0003\u0007\u0003\u0007\u0003\u0007\u0003\u0007\u0005\u0007\u0162",
    "\n\u0007\u0003\b\u0003\b\u0003\b\u0003\b\u0003\b\u0003\b\u0003\b\u0005",
    "\b\u016b\n\b\u0003\t\u0003\t\u0003\t\u0003\t\u0007\t\u0171\n\t\f\t\u000e",
    "\t\u0174\u000b\t\u0003\n\u0003\n\u0003\n\u0003\n\u0005\n\u017a\n\n\u0005",
    "\n\u017c\n\n\u0003\u000b\u0003\u000b\u0003\u000b\u0003\f\u0003\f\u0003",
    "\f\u0003\f\u0007\f\u0185\n\f\f\f\u000e\f\u0188\u000b\f\u0003\r\u0003",
    "\r\u0003\r\u0003\r\u0007\r\u018e\n\r\f\r\u000e\r\u0191\u000b\r\u0003",
    "\u000e\u0003\u000e\u0003\u000e\u0003\u000e\u0003\u000e\u0003\u000f\u0003",
    "\u000f\u0003\u000f\u0003\u000f\u0007\u000f\u019c\n\u000f\f\u000f\u000e",
    "\u000f\u019f\u000b\u000f\u0003\u0010\u0003\u0010\u0003\u0010\u0003\u0010",
    "\u0003\u0010\u0003\u0010\u0003\u0010\u0003\u0010\u0003\u0010\u0003\u0010",
    "\u0003\u0010\u0003\u0010\u0005\u0010\u01ad\n\u0010\u0003\u0011\u0003",
    "\u0011\u0003\u0011\u0003\u0011\u0003\u0011\u0003\u0011\u0003\u0011\u0007",
    "\u0011\u01b6\n\u0011\f\u0011\u000e\u0011\u01b9\u000b\u0011\u0005\u0011",
    "\u01bb\n\u0011\u0003\u0011\u0003\u0011\u0003\u0011\u0005\u0011\u01c0",
    "\n\u0011\u0003\u0011\u0003\u0011\u0003\u0011\u0003\u0011\u0003\u0011",
    "\u0003\u0011\u0003\u0011\u0003\u0011\u0003\u0011\u0003\u0011\u0003\u0011",
    "\u0003\u0011\u0003\u0011\u0003\u0011\u0003\u0011\u0003\u0011\u0003\u0011",
    "\u0003\u0011\u0003\u0011\u0003\u0011\u0003\u0011\u0003\u0011\u0003\u0011",
    "\u0003\u0011\u0003\u0011\u0003\u0011\u0003\u0011\u0003\u0011\u0003\u0011",
    "\u0003\u0011\u0003\u0011\u0005\u0011\u01e1\n\u0011\u0003\u0012\u0003",
    "\u0012\u0003\u0012\u0003\u0012\u0003\u0012\u0007\u0012\u01e8\n\u0012",
    "\f\u0012\u000e\u0012\u01eb\u000b\u0012\u0005\u0012\u01ed\n\u0012\u0003",
    "\u0012\u0003\u0012\u0003\u0012\u0003\u0012\u0003\u0012\u0003\u0012\u0003",
    "\u0012\u0003\u0012\u0005\u0012\u01f7\n\u0012\u0003\u0012\u0003\u0012",
    "\u0003\u0012\u0005\u0012\u01fc\n\u0012\u0007\u0012\u01fe\n\u0012\f\u0012",
    "\u000e\u0012\u0201\u000b\u0012\u0003\u0012\u0003\u0012\u0003\u0012\u0005",
    "\u0012\u0206\n\u0012\u0003\u0012\u0003\u0012\u0005\u0012\u020a\n\u0012",
    "\u0003\u0012\u0003\u0012\u0003\u0012\u0003\u0012\u0003\u0012\u0003\u0012",
    "\u0003\u0012\u0003\u0012\u0005\u0012\u0214\n\u0012\u0003\u0012\u0003",
    "\u0012\u0005\u0012\u0218\n\u0012\u0003\u0012\u0003\u0012\u0005\u0012",
    "\u021c\n\u0012\u0003\u0013\u0003\u0013\u0003\u0013\u0003\u0013\u0003",
    "\u0013\u0007\u0013\u0223\n\u0013\f\u0013\u000e\u0013\u0226\u000b\u0013",
    "\u0005\u0013\u0228\n\u0013\u0003\u0013\u0003\u0013\u0003\u0013\u0003",
    "\u0013\u0003\u0013\u0003\u0013\u0003\u0013\u0003\u0013\u0005\u0013\u0232",
    "\n\u0013\u0003\u0013\u0003\u0013\u0005\u0013\u0236\n\u0013\u0003\u0013",
    "\u0003\u0013\u0003\u0013\u0003\u0013\u0003\u0013\u0003\u0013\u0003\u0013",
    "\u0003\u0013\u0005\u0013\u0240\n\u0013\u0003\u0013\u0003\u0013\u0003",
    "\u0013\u0005\u0013\u0245\n\u0013\u0007\u0013\u0247\n\u0013\f\u0013\u000e",
    "\u0013\u024a\u000b\u0013\u0003\u0013\u0003\u0013\u0003\u0013\u0005\u0013",
    "\u024f\n\u0013\u0003\u0013\u0003\u0013\u0005\u0013\u0253\n\u0013\u0003",
    "\u0013\u0003\u0013\u0005\u0013\u0257\n\u0013\u0003\u0014\u0003\u0014",
    "\u0003\u0014\u0005\u0014\u025c\n\u0014\u0003\u0015\u0003\u0015\u0003",
    "\u0015\u0005\u0015\u0261\n\u0015\u0003\u0016\u0003\u0016\u0003\u0016",
    "\u0003\u0016\u0003\u0016\u0003\u0016\u0003\u0016\u0003\u0016\u0003\u0016",
    "\u0003\u0016\u0003\u0016\u0003\u0016\u0003\u0016\u0003\u0016\u0005\u0016",
    "\u0271\n\u0016\u0003\u0016\u0003\u0016\u0005\u0016\u0275\n\u0016\u0003",
    "\u0016\u0003\u0016\u0003\u0016\u0003\u0016\u0003\u0016\u0003\u0016\u0003",
    "\u0016\u0003\u0016\u0003\u0016\u0005\u0016\u0280\n\u0016\u0003\u0016",
    "\u0003\u0016\u0003\u0016\u0003\u0016\u0003\u0016\u0003\u0016\u0003\u0016",
    "\u0003\u0016\u0003\u0016\u0005\u0016\u028b\n\u0016\u0003\u0016\u0003",
    "\u0016\u0005\u0016\u028f\n\u0016\u0003\u0016\u0003\u0016\u0005\u0016",
    "\u0293\n\u0016\u0003\u0017\u0003\u0017\u0003\u0017\u0003\u0017\u0003",
    "\u0017\u0003\u0017\u0003\u0017\u0003\u0017\u0003\u0017\u0003\u0017\u0003",
    "\u0017\u0003\u0017\u0003\u0017\u0003\u0017\u0005\u0017\u02a3\n\u0017",
    "\u0003\u0017\u0003\u0017\u0005\u0017\u02a7\n\u0017\u0003\u0017\u0003",
    "\u0017\u0003\u0017\u0003\u0017\u0003\u0017\u0003\u0017\u0003\u0017\u0003",
    "\u0017\u0003\u0017\u0005\u0017\u02b2\n\u0017\u0003\u0017\u0003\u0017",
    "\u0003\u0017\u0003\u0017\u0003\u0017\u0003\u0017\u0003\u0017\u0003\u0017",
    "\u0003\u0017\u0005\u0017\u02bd\n\u0017\u0003\u0017\u0003\u0017\u0005",
    "\u0017\u02c1\n\u0017\u0003\u0017\u0003\u0017\u0005\u0017\u02c5\n\u0017",
    "\u0003\u0018\u0003\u0018\u0003\u0018\u0003\u0018\u0003\u0018\u0003\u0018",
    "\u0003\u0018\u0003\u0018\u0003\u0018\u0003\u0018\u0005\u0018\u02d1\n",
    "\u0018\u0003\u0018\u0003\u0018\u0003\u0018\u0003\u0018\u0003\u0018\u0003",
    "\u0018\u0003\u0018\u0003\u0018\u0003\u0018\u0005\u0018\u02dc\n\u0018",
    "\u0003\u0019\u0003\u0019\u0003\u0019\u0003\u0019\u0003\u0019\u0003\u0019",
    "\u0003\u0019\u0003\u0019\u0003\u0019\u0003\u0019\u0005\u0019\u02e8\n",
    "\u0019\u0003\u0019\u0003\u0019\u0003\u0019\u0003\u0019\u0003\u0019\u0003",
    "\u0019\u0003\u0019\u0003\u0019\u0003\u0019\u0005\u0019\u02f3\n\u0019",
    "\u0003\u001a\u0003\u001a\u0003\u001a\u0003\u001a\u0003\u001a\u0003\u001a",
    "\u0003\u001a\u0003\u001a\u0003\u001a\u0003\u001a\u0003\u001a\u0003\u001a",
    "\u0003\u001a\u0003\u001a\u0003\u001a\u0003\u001a\u0003\u001a\u0003\u001a",
    "\u0003\u001a\u0003\u001a\u0003\u001a\u0003\u001a\u0003\u001a\u0003\u001a",
    "\u0003\u001a\u0003\u001a\u0003\u001a\u0003\u001a\u0005\u001a\u0311\n",
    "\u001a\u0003\u001a\u0003\u001a\u0005\u001a\u0315\n\u001a\u0003\u001b",
    "\u0003\u001b\u0003\u001b\u0003\u001b\u0003\u001b\u0003\u001b\u0003\u001b",
    "\u0003\u001b\u0003\u001b\u0003\u001b\u0003\u001b\u0003\u001b\u0003\u001b",
    "\u0003\u001b\u0003\u001b\u0003\u001b\u0003\u001b\u0003\u001b\u0003\u001b",
    "\u0003\u001b\u0003\u001b\u0005\u001b\u032c\n\u001b\u0003\u001c\u0003",
    "\u001c\u0003\u001c\u0005\u001c\u0331\n\u001c\u0003\u001c\u0003\u001c",
    "\u0003\u001c\u0003\u001c\u0003\u001c\u0003\u001c\u0005\u001c\u0339\n",
    "\u001c\u0003\u001c\u0003\u001c\u0003\u001c\u0003\u001c\u0003\u001c\u0003",
    "\u001c\u0003\u001c\u0003\u001c\u0003\u001c\u0003\u001c\u0003\u001c\u0003",
    "\u001c\u0003\u001c\u0003\u001c\u0003\u001c\u0003\u001c\u0003\u001c\u0003",
    "\u001c\u0003\u001c\u0005\u001c\u034e\n\u001c\u0003\u001c\u0003\u001c",
    "\u0005\u001c\u0352\n\u001c\u0003\u001c\u0003\u001c\u0005\u001c\u0356",
    "\n\u001c\u0003\u001c\u0003\u001c\u0003\u001c\u0003\u001c\u0005\u001c",
    "\u035c\n\u001c\u0003\u001d\u0003\u001d\u0003\u001d\u0005\u001d\u0361",
    "\n\u001d\u0003\u001d\u0003\u001d\u0003\u001d\u0003\u001d\u0003\u001d",
    "\u0003\u001d\u0005\u001d\u0369\n\u001d\u0003\u001d\u0003\u001d\u0003",
    "\u001d\u0003\u001d\u0003\u001d\u0003\u001d\u0003\u001d\u0003\u001d\u0003",
    "\u001d\u0003\u001d\u0003\u001d\u0003\u001d\u0003\u001d\u0003\u001d\u0003",
    "\u001d\u0003\u001d\u0003\u001d\u0003\u001d\u0003\u001d\u0005\u001d\u037e",
    "\n\u001d\u0003\u001d\u0003\u001d\u0005\u001d\u0382\n\u001d\u0003\u001d",
    "\u0003\u001d\u0005\u001d\u0386\n\u001d\u0003\u001d\u0003\u001d\u0003",
    "\u001d\u0003\u001d\u0005\u001d\u038c\n\u001d\u0003\u001e\u0003\u001e",
    "\u0003\u001e\u0003\u001e\u0003\u001e\u0006\u001e\u0393\n\u001e\r\u001e",
    "\u000e\u001e\u0394\u0003\u001e\u0003\u001e\u0003\u001e\u0003\u001e\u0003",
    "\u001e\u0003\u001e\u0003\u001e\u0006\u001e\u039e\n\u001e\r\u001e\u000e",
    "\u001e\u039f\u0003\u001e\u0003\u001e\u0003\u001e\u0003\u001e\u0003\u001e",
    "\u0003\u001e\u0003\u001e\u0003\u001e\u0003\u001e\u0005\u001e\u03ab\n",
    "\u001e\u0003\u001f\u0003\u001f\u0003\u001f\u0003\u001f\u0003\u001f\u0003",
    "\u001f\u0005\u001f\u03b3\n\u001f\u0003\u001f\u0003\u001f\u0005\u001f",
    "\u03b7\n\u001f\u0003\u001f\u0005\u001f\u03ba\n\u001f\u0003\u001f\u0005",
    "\u001f\u03bd\n\u001f\u0003\u001f\u0005\u001f\u03c0\n\u001f\u0003\u001f",
    "\u0003\u001f\u0003 \u0003 \u0003 \u0003 \u0003 \u0003 \u0003 \u0003",
    " \u0003 \u0007 \u03cd\n \f \u000e \u03d0\u000b \u0005 \u03d2\n \u0003",
    " \u0005 \u03d5\n \u0003 \u0003 \u0003 \u0003 \u0003 \u0003 \u0003 \u0003",
    " \u0005 \u03df\n \u0003 \u0003 \u0005 \u03e3\n \u0003 \u0005 \u03e6",
    "\n \u0003 \u0005 \u03e9\n \u0003 \u0005 \u03ec\n \u0003 \u0003 \u0003",
    " \u0003 \u0003 \u0003 \u0005 \u03f4\n \u0003 \u0005 \u03f7\n \u0003",
    " \u0005 \u03fa\n \u0003 \u0005 \u03fd\n \u0003 \u0003 \u0005 \u0401",
    "\n \u0003!\u0003!\u0003!\u0003!\u0003!\u0003!\u0003!\u0003\"\u0003\"",
    "\u0003\"\u0003\"\u0003\"\u0003\"\u0003\"\u0003#\u0003#\u0003#\u0003",
    "#\u0003#\u0003#\u0003#\u0003#\u0005#\u0419\n#\u0003$\u0003$\u0003$\u0003",
    "$\u0003$\u0005$\u0420\n$\u0005$\u0422\n$\u0003$\u0003$\u0003%\u0003",
    "%\u0003%\u0003%\u0003%\u0003%\u0005%\u042c\n%\u0003%\u0005%\u042f\n",
    "%\u0003%\u0005%\u0432\n%\u0003%\u0003%\u0003%\u0003%\u0003%\u0003%\u0003",
    "%\u0003%\u0003%\u0005%\u043d\n%\u0005%\u043f\n%\u0003%\u0003%\u0003",
    "%\u0005%\u0444\n%\u0003%\u0003%\u0003%\u0003%\u0003%\u0003%\u0003%\u0003",
    "%\u0003%\u0003%\u0003%\u0003%\u0003%\u0003%\u0005%\u0454\n%\u0003&\u0003",
    "&\u0003&\u0003&\u0003&\u0003&\u0005&\u045c\n&\u0003&\u0005&\u045f\n",
    "&\u0003&\u0005&\u0462\n&\u0003&\u0003&\u0003&\u0003&\u0003&\u0003&\u0003",
    "&\u0003&\u0003&\u0005&\u046d\n&\u0005&\u046f\n&\u0003&\u0003&\u0003",
    "&\u0005&\u0474\n&\u0003&\u0003&\u0003&\u0003&\u0003&\u0003&\u0003&\u0003",
    "&\u0003&\u0003&\u0005&\u0480\n&\u0003&\u0003&\u0003&\u0003&\u0003&\u0003",
    "&\u0003&\u0003&\u0003&\u0003&\u0003&\u0003&\u0003&\u0003&\u0005&\u0490",
    "\n&\u0003\'\u0003\'\u0003\'\u0003\'\u0003(\u0003(\u0003(\u0007(\u0499",
    "\n(\f(\u000e(\u049c\u000b(\u0003)\u0005)\u049f\n)\u0003)\u0003)\u0003",
    ")\u0003)\u0003*\u0005*\u04a6\n*\u0003*\u0003*\u0003*\u0003*\u0003+\u0003",
    "+\u0003+\u0003+\u0003,\u0003,\u0003,\u0007,\u04b3\n,\f,\u000e,\u04b6",
    "\u000b,\u0003-\u0003-\u0003-\u0007-\u04bb\n-\f-\u000e-\u04be\u000b-",
    "\u0003-\u0003-\u0003-\u0003-\u0007-\u04c4\n-\f-\u000e-\u04c7\u000b-",
    "\u0005-\u04c9\n-\u0003.\u0003.\u0003.\u0005.\u04ce\n.\u0003/\u0005/",
    "\u04d1\n/\u0003/\u0003/\u0003/\u0005/\u04d6\n/\u0003/\u0005/\u04d9\n",
    "/\u0003/\u0005/\u04dc\n/\u00030\u00030\u00030\u00031\u00031\u00031\u0003",
    "1\u00031\u00071\u04e6\n1\f1\u000e1\u04e9\u000b1\u00032\u00032\u0003",
    "2\u00032\u00032\u00072\u04f0\n2\f2\u000e2\u04f3\u000b2\u00033\u0003",
    "3\u00053\u04f7\n3\u00034\u00034\u00034\u00054\u04fc\n4\u00034\u0003",
    "4\u00034\u00034\u00034\u00035\u00035\u00036\u00036\u00036\u00036\u0003",
    "6\u00036\u00036\u00036\u00036\u00036\u00036\u00056\u0510\n6\u00037\u0003",
    "7\u00037\u00037\u00037\u00077\u0517\n7\f7\u000e7\u051a\u000b7\u0003",
    "7\u00037\u00037\u00057\u051f\n7\u00038\u00038\u00038\u00039\u00039\u0003",
    "9\u00039\u00059\u0528\n9\u0003:\u0003:\u0003:\u0005:\u052d\n:\u0003",
    ";\u0003;\u0005;\u0531\n;\u0003<\u0003<\u0003<\u0003<\u0003<\u0005<\u0538",
    "\n<\u0003=\u0003=\u0003=\u0005=\u053d\n=\u0003>\u0003>\u0005>\u0541",
    "\n>\u0003>\u0005>\u0544\n>\u0003>\u0005>\u0547\n>\u0003>\u0005>\u054a",
    "\n>\u0003?\u0003?\u0003?\u0003?\u0003?\u0005?\u0551\n?\u0003@\u0003",
    "@\u0003@\u0003@\u0003@\u0007@\u0558\n@\f@\u000e@\u055b\u000b@\u0003",
    "@\u0003@\u0005@\u055f\n@\u0003A\u0003A\u0003A\u0003A\u0003A\u0005A\u0566",
    "\nA\u0003B\u0003B\u0003B\u0003B\u0003B\u0003B\u0007B\u056e\nB\fB\u000e",
    "B\u0571\u000bB\u0003B\u0003B\u0005B\u0575\nB\u0003B\u0003B\u0003B\u0003",
    "B\u0003B\u0007B\u057c\nB\fB\u000eB\u057f\u000bB\u0003B\u0003B\u0005",
    "B\u0583\nB\u0005B\u0585\nB\u0003C\u0003C\u0003C\u0003C\u0003C\u0003",
    "C\u0003C\u0003C\u0007C\u058f\nC\fC\u000eC\u0592\u000bC\u0003C\u0003",
    "C\u0005C\u0596\nC\u0003C\u0005C\u0599\nC\u0003C\u0003C\u0003C\u0003",
    "C\u0003C\u0003C\u0003C\u0007C\u05a2\nC\fC\u000eC\u05a5\u000bC\u0003",
    "C\u0003C\u0005C\u05a9\nC\u0003C\u0003C\u0005C\u05ad\nC\u0005C\u05af",
    "\nC\u0003D\u0003D\u0003E\u0003E\u0003F\u0003F\u0003F\u0003F\u0007F\u05b9",
    "\nF\fF\u000eF\u05bc\u000bF\u0003G\u0003G\u0003G\u0005G\u05c1\nG\u0003",
    "H\u0003H\u0003H\u0007H\u05c6\nH\fH\u000eH\u05c9\u000bH\u0003I\u0003",
    "I\u0005I\u05cd\nI\u0003I\u0003I\u0003I\u0003I\u0005I\u05d3\nI\u0003",
    "I\u0003I\u0005I\u05d7\nI\u0003I\u0005I\u05da\nI\u0003J\u0003J\u0003",
    "J\u0007J\u05df\nJ\fJ\u000eJ\u05e2\u000bJ\u0003K\u0003K\u0005K\u05e6",
    "\nK\u0003K\u0003K\u0005K\u05ea\nK\u0003K\u0005K\u05ed\nK\u0003L\u0003",
    "L\u0003L\u0005L\u05f2\nL\u0003L\u0003L\u0003L\u0003M\u0003M\u0003M\u0007",
    "M\u05fa\nM\fM\u000eM\u05fd\u000bM\u0003N\u0003N\u0003N\u0003N\u0005",
    "N\u0603\nN\u0003N\u0003N\u0005N\u0607\nN\u0003N\u0003N\u0007N\u060b",
    "\nN\fN\u000eN\u060e\u000bN\u0003O\u0005O\u0611\nO\u0003O\u0003O\u0003",
    "O\u0003O\u0003O\u0005O\u0618\nO\u0003P\u0003P\u0003Q\u0003Q\u0003Q\u0003",
    "Q\u0003Q\u0003Q\u0003Q\u0003Q\u0007Q\u0624\nQ\fQ\u000eQ\u0627\u000b",
    "Q\u0003Q\u0003Q\u0005Q\u062b\nQ\u0003R\u0003R\u0003R\u0005R\u0630\n",
    "R\u0003S\u0003S\u0005S\u0634\nS\u0003T\u0003T\u0003U\u0003U\u0003V\u0003",
    "V\u0003V\u0003V\u0007V\u063e\nV\fV\u000eV\u0641\u000bV\u0003W\u0003",
    "W\u0003X\u0003X\u0003X\u0003Y\u0003Y\u0003Z\u0003Z\u0003[\u0003[\u0003",
    "\\\u0003\\\u0003]\u0003]\u0003^\u0003^\u0003^\u0005^\u0655\n^\u0003",
    "_\u0003_\u0003_\u0003_\u0007_\u065b\n_\f_\u000e_\u065e\u000b_\u0003",
    "_\u0003_\u0003_\u0005_\u0663\n_\u0003`\u0003`\u0003`\u0003a\u0003a\u0003",
    "a\u0003b\u0003b\u0003c\u0003c\u0005c\u066f\nc\u0003d\u0003d\u0005d\u0673",
    "\nd\u0003e\u0003e\u0003e\u0003e\u0003e\u0005e\u067a\ne\u0003f\u0003",
    "f\u0003f\u0003g\u0003g\u0003h\u0003h\u0003i\u0003i\u0003j\u0003j\u0003",
    "k\u0003k\u0003l\u0003l\u0003l\u0002\u0004\u0006\bm\u0002\u0004\u0006",
    "\b\n\f\u000e\u0010\u0012\u0014\u0016\u0018\u001a\u001c\u001e \"$&(*",
    ",.02468:<>@BDFHJLNPRTVXZ\\^`bdfhjlnprtvxz|~\u0080\u0082\u0084\u0086",
    "\u0088\u008a\u008c\u008e\u0090\u0092\u0094\u0096\u0098\u009a\u009c\u009e",
    "\u00a0\u00a2\u00a4\u00a6\u00a8\u00aa\u00ac\u00ae\u00b0\u00b2\u00b4\u00b6",
    "\u00b8\u00ba\u00bc\u00be\u00c0\u00c2\u00c4\u00c6\u00c8\u00ca\u00cc\u00ce",
    "\u00d0\u00d2\u00d4\u00d6\u0002\'\u0004\u0002\u000f\u0010))\u0003\u0002",
    "\u0011\u0012\u0004\u0002\u000f\u0010TT\u0003\u0002\'(\u0003\u0002+,",
    "\u0003\u0002 !\u0004\u0002\u00c0\u00c0\u00c2\u00c2\u0003\u0002\u00b7",
    "\u00b8\u0003\u0002\u00b9\u00ba\u0005\u0002SSUWyz\u0006\u0002KKMMbb}",
    "\u007f\u0003\u0002OP\u0004\u0002NNQR\u0004\u0002>>\u00c7\u00c7\u0003",
    "\u0002\u0098\u0099\u0004\u0002ii\u00ea\u00ea\u0003\u0002HI\u0004\u0002",
    "22\u0081\u0081\u0004\u0002>>jj\u0005\u0002FGY\\\u0082\u0085\u0006\u0002",
    "FGY\\\u0082\u0085\u0089\u008a\u0003\u0002\u008b\u008c\u0003\u0002DE",
    "\u0004\u0002BB\u0087\u0087\u0003\u0002kl\u0003\u0002\u000f\u0010\u0004",
    "\u0002\u00e7\u00e8\u00eb\u00eb\u0004\u0002\u000f\u000f\u0011\u0011\u0005",
    "\u0002>>jj\u00de\u00de\u0003\u0002\u00d7\u00dc\u0004\u0002oo\u00d2\u00d2",
    "\u0005\u0002oovv\u00d1\u00d1\u0004\u0002>>\u00d6\u00d6\u0003\u0002\t",
    "\u000e\u0004\u0002--\u00e7\u00ea\u0005\u0002\u009e\u00a4\u00c8\u00c8",
    "\u00df\u00df\u0004\u0002>>\u00e9\u00e9\u0002\u072e\u0002\u00dd\u0003",
    "\u0002\u0002\u0002\u0004\u00eb\u0003\u0002\u0002\u0002\u0006\u00fe\u0003",
    "\u0002\u0002\u0002\b\u0131\u0003\u0002\u0002\u0002\n\u0153\u0003\u0002",
    "\u0002\u0002\f\u0161\u0003\u0002\u0002\u0002\u000e\u016a\u0003\u0002",
    "\u0002\u0002\u0010\u016c\u0003\u0002\u0002\u0002\u0012\u0175\u0003\u0002",
    "\u0002\u0002\u0014\u017d\u0003\u0002\u0002\u0002\u0016\u0180\u0003\u0002",
    "\u0002\u0002\u0018\u0189\u0003\u0002\u0002\u0002\u001a\u0192\u0003\u0002",
    "\u0002\u0002\u001c\u0197\u0003\u0002\u0002\u0002\u001e\u01ac\u0003\u0002",
    "\u0002\u0002 \u01e0\u0003\u0002\u0002\u0002\"\u021b\u0003\u0002\u0002",
    "\u0002$\u0256\u0003\u0002\u0002\u0002&\u025b\u0003\u0002\u0002\u0002",
    "(\u0260\u0003\u0002\u0002\u0002*\u0292\u0003\u0002\u0002\u0002,\u02c4",
    "\u0003\u0002\u0002\u0002.\u02db\u0003\u0002\u0002\u00020\u02f2\u0003",
    "\u0002\u0002\u00022\u0314\u0003\u0002\u0002\u00024\u032b\u0003\u0002",
    "\u0002\u00026\u035b\u0003\u0002\u0002\u00028\u038b\u0003\u0002\u0002",
    "\u0002:\u03aa\u0003\u0002\u0002\u0002<\u03ac\u0003\u0002\u0002\u0002",
    ">\u0400\u0003\u0002\u0002\u0002@\u0402\u0003\u0002\u0002\u0002B\u0409",
    "\u0003\u0002\u0002\u0002D\u0418\u0003\u0002\u0002\u0002F\u041a\u0003",
    "\u0002\u0002\u0002H\u0453\u0003\u0002\u0002\u0002J\u048f\u0003\u0002",
    "\u0002\u0002L\u0491\u0003\u0002\u0002\u0002N\u0495\u0003\u0002\u0002",
    "\u0002P\u049e\u0003\u0002\u0002\u0002R\u04a5\u0003\u0002\u0002\u0002",
    "T\u04ab\u0003\u0002\u0002\u0002V\u04af\u0003\u0002\u0002\u0002X\u04b7",
    "\u0003\u0002\u0002\u0002Z\u04ca\u0003\u0002\u0002\u0002\\\u04d0\u0003",
    "\u0002\u0002\u0002^\u04dd\u0003\u0002\u0002\u0002`\u04e0\u0003\u0002",
    "\u0002\u0002b\u04ea\u0003\u0002\u0002\u0002d\u04f4\u0003\u0002\u0002",
    "\u0002f\u04fb\u0003\u0002\u0002\u0002h\u0502\u0003\u0002\u0002\u0002",
    "j\u050f\u0003\u0002\u0002\u0002l\u051e\u0003\u0002\u0002\u0002n\u0520",
    "\u0003\u0002\u0002\u0002p\u0523\u0003\u0002\u0002\u0002r\u052c\u0003",
    "\u0002\u0002\u0002t\u0530\u0003\u0002\u0002\u0002v\u0537\u0003\u0002",
    "\u0002\u0002x\u053c\u0003\u0002\u0002\u0002z\u0540\u0003\u0002\u0002",
    "\u0002|\u054b\u0003\u0002\u0002\u0002~\u0552\u0003\u0002\u0002\u0002",
    "\u0080\u0560\u0003\u0002\u0002\u0002\u0082\u0584\u0003\u0002\u0002\u0002",
    "\u0084\u05ae\u0003\u0002\u0002\u0002\u0086\u05b0\u0003\u0002\u0002\u0002",
    "\u0088\u05b2\u0003\u0002\u0002\u0002\u008a\u05b4\u0003\u0002\u0002\u0002",
    "\u008c\u05bd\u0003\u0002\u0002\u0002\u008e\u05c2\u0003\u0002\u0002\u0002",
    "\u0090\u05cc\u0003\u0002\u0002\u0002\u0092\u05db\u0003\u0002\u0002\u0002",
    "\u0094\u05e5\u0003\u0002\u0002\u0002\u0096\u05ee\u0003\u0002\u0002\u0002",
    "\u0098\u05f6\u0003\u0002\u0002\u0002\u009a\u0602\u0003\u0002\u0002\u0002",
    "\u009c\u0610\u0003\u0002\u0002\u0002\u009e\u0619\u0003\u0002\u0002\u0002",
    "\u00a0\u062a\u0003\u0002\u0002\u0002\u00a2\u062c\u0003\u0002\u0002\u0002",
    "\u00a4\u0631\u0003\u0002\u0002\u0002\u00a6\u0635\u0003\u0002\u0002\u0002",
    "\u00a8\u0637\u0003\u0002\u0002\u0002\u00aa\u0639\u0003\u0002\u0002\u0002",
    "\u00ac\u0642\u0003\u0002\u0002\u0002\u00ae\u0644\u0003\u0002\u0002\u0002",
    "\u00b0\u0647\u0003\u0002\u0002\u0002\u00b2\u0649\u0003\u0002\u0002\u0002",
    "\u00b4\u064b\u0003\u0002\u0002\u0002\u00b6\u064d\u0003\u0002\u0002\u0002",
    "\u00b8\u064f\u0003\u0002\u0002\u0002\u00ba\u0651\u0003\u0002\u0002\u0002",
    "\u00bc\u0662\u0003\u0002\u0002\u0002\u00be\u0664\u0003\u0002\u0002\u0002",
    "\u00c0\u0667\u0003\u0002\u0002\u0002\u00c2\u066a\u0003\u0002\u0002\u0002",
    "\u00c4\u066e\u0003\u0002\u0002\u0002\u00c6\u0672\u0003\u0002\u0002\u0002",
    "\u00c8\u0679\u0003\u0002\u0002\u0002\u00ca\u067b\u0003\u0002\u0002\u0002",
    "\u00cc\u067e\u0003\u0002\u0002\u0002\u00ce\u0680\u0003\u0002\u0002\u0002",
    "\u00d0\u0682\u0003\u0002\u0002\u0002\u00d2\u0684\u0003\u0002\u0002\u0002",
    "\u00d4\u0686\u0003\u0002\u0002\u0002\u00d6\u0688\u0003\u0002\u0002\u0002",
    "\u00d8\u00d9\u0005\u0004\u0003\u0002\u00d9\u00da\u0007\u00ed\u0002\u0002",
    "\u00da\u00dc\u0003\u0002\u0002\u0002\u00db\u00d8\u0003\u0002\u0002\u0002",
    "\u00dc\u00df\u0003\u0002\u0002\u0002\u00dd\u00db\u0003\u0002\u0002\u0002",
    "\u00dd\u00de\u0003\u0002\u0002\u0002\u00de\u00e0\u0003\u0002\u0002\u0002",
    "\u00df\u00dd\u0003\u0002\u0002\u0002\u00e0\u00e1\u0007\u0002\u0002\u0003",
    "\u00e1\u0003\u0003\u0002\u0002\u0002\u00e2\u00e3\u0005\u00b6\\\u0002",
    "\u00e3\u00e4\u0007\u0015\u0002\u0002\u00e4\u00e5\u0005\u0006\u0004\u0002",
    "\u00e5\u00ec\u0003\u0002\u0002\u0002\u00e6\u00e7\u0005\u00b6\\\u0002",
    "\u00e7\u00e8\u0007r\u0002\u0002\u00e8\u00e9\u0005\u0006\u0004\u0002",
    "\u00e9\u00ec\u0003\u0002\u0002\u0002\u00ea\u00ec\u0005 \u0011\u0002",
    "\u00eb\u00e2\u0003\u0002\u0002\u0002\u00eb\u00e6\u0003\u0002\u0002\u0002",
    "\u00eb\u00ea\u0003\u0002\u0002\u0002\u00ec\u0005\u0003\u0002\u0002\u0002",
    "\u00ed\u00ee\b\u0004\u0001\u0002\u00ee\u00ef\u0007\u0003\u0002\u0002",
    "\u00ef\u00f0\u0005\u0006\u0004\u0002\u00f0\u00f1\u0007\u0004\u0002\u0002",
    "\u00f1\u00ff\u0003\u0002\u0002\u0002\u00f2\u00ff\u0005\f\u0007\u0002",
    "\u00f3\u00f4\t\u0002\u0002\u0002\u00f4\u00ff\u0005\u0006\u0004\f\u00f5",
    "\u00f6\u0007\u0019\u0002\u0002\u00f6\u00f7\u0005\u0006\u0004\u0002\u00f7",
    "\u00f8\u0007\u001a\u0002\u0002\u00f8\u00f9\u0005\u0006\u0004\u0002\u00f9",
    "\u00fa\u0007\u001b\u0002\u0002\u00fa\u00fb\u0005\u0006\u0004\u0005\u00fb",
    "\u00ff\u0003\u0002\u0002\u0002\u00fc\u00ff\u0005\u00d2j\u0002\u00fd",
    "\u00ff\u0005\u00b6\\\u0002\u00fe\u00ed\u0003\u0002\u0002\u0002\u00fe",
    "\u00f2\u0003\u0002\u0002\u0002\u00fe\u00f3\u0003\u0002\u0002\u0002\u00fe",
    "\u00f5\u0003\u0002\u0002\u0002\u00fe\u00fc\u0003\u0002\u0002\u0002\u00fe",
    "\u00fd\u0003\u0002\u0002\u0002\u00ff\u011d\u0003\u0002\u0002\u0002\u0100",
    "\u0101\f\u000b\u0002\u0002\u0101\u0102\t\u0003\u0002\u0002\u0102\u011c",
    "\u0005\u0006\u0004\f\u0103\u0104\f\n\u0002\u0002\u0104\u0105\t\u0004",
    "\u0002\u0002\u0105\u011c\u0005\u0006\u0004\u000b\u0106\u0107\f\t\u0002",
    "\u0002\u0107\u0108\u0005\u00c2b\u0002\u0108\u0109\u0005\u0006\u0004",
    "\n\u0109\u011c\u0003\u0002\u0002\u0002\u010a\u010b\f\u0007\u0002\u0002",
    "\u010b\u010c\u0007&\u0002\u0002\u010c\u011c\u0005\u0006\u0004\b\u010d",
    "\u010e\f\u0006\u0002\u0002\u010e\u010f\t\u0005\u0002\u0002\u010f\u011c",
    "\u0005\u0006\u0004\u0007\u0110\u0111\f\u000e\u0002\u0002\u0111\u0112",
    "\u0007\u0005\u0002\u0002\u0112\u0113\u0005\u000e\b\u0002\u0113\u0114",
    "\u0007\u0006\u0002\u0002\u0114\u011c\u0003\u0002\u0002\u0002\u0115\u0116",
    "\f\r\u0002\u0002\u0116\u0117\u0007\u0016\u0002\u0002\u0117\u011c\u0005",
    "\u00b8]\u0002\u0118\u0119\f\b\u0002\u0002\u0119\u011a\t\u0006\u0002",
    "\u0002\u011a\u011c\u0005\u00bc_\u0002\u011b\u0100\u0003\u0002\u0002",
    "\u0002\u011b\u0103\u0003\u0002\u0002\u0002\u011b\u0106\u0003\u0002\u0002",
    "\u0002\u011b\u010a\u0003\u0002\u0002\u0002\u011b\u010d\u0003\u0002\u0002",
    "\u0002\u011b\u0110\u0003\u0002\u0002\u0002\u011b\u0115\u0003\u0002\u0002",
    "\u0002\u011b\u0118\u0003\u0002\u0002\u0002\u011c\u011f\u0003\u0002\u0002",
    "\u0002\u011d\u011b\u0003\u0002\u0002\u0002\u011d\u011e\u0003\u0002\u0002",
    "\u0002\u011e\u0007\u0003\u0002\u0002\u0002\u011f\u011d\u0003\u0002\u0002",
    "\u0002\u0120\u0121\b\u0005\u0001\u0002\u0121\u0122\u0007\u0003\u0002",
    "\u0002\u0122\u0123\u0005\b\u0005\u0002\u0123\u0124\u0007\u0004\u0002",
    "\u0002\u0124\u0132\u0003\u0002\u0002\u0002\u0125\u0132\u0005\n\u0006",
    "\u0002\u0126\u0127\t\u0002\u0002\u0002\u0127\u0132\u0005\b\u0005\f\u0128",
    "\u0129\u0007\u0019\u0002\u0002\u0129\u012a\u0005\b\u0005\u0002\u012a",
    "\u012b\u0007\u001a\u0002\u0002\u012b\u012c\u0005\b\u0005\u0002\u012c",
    "\u012d\u0007\u001b\u0002\u0002\u012d\u012e\u0005\b\u0005\u0005\u012e",
    "\u0132\u0003\u0002\u0002\u0002\u012f\u0132\u0005\u00d2j\u0002\u0130",
    "\u0132\u0005\u00ba^\u0002\u0131\u0120\u0003\u0002\u0002\u0002\u0131",
    "\u0125\u0003\u0002\u0002\u0002\u0131\u0126\u0003\u0002\u0002\u0002\u0131",
    "\u0128\u0003\u0002\u0002\u0002\u0131\u012f\u0003\u0002\u0002\u0002\u0131",
    "\u0130\u0003\u0002\u0002\u0002\u0132\u0148\u0003\u0002\u0002\u0002\u0133",
    "\u0134\f\u000b\u0002\u0002\u0134\u0135\t\u0003\u0002\u0002\u0135\u0147",
    "\u0005\b\u0005\f\u0136\u0137\f\n\u0002\u0002\u0137\u0138\t\u0004\u0002",
    "\u0002\u0138\u0147\u0005\b\u0005\u000b\u0139\u013a\f\t\u0002\u0002\u013a",
    "\u013b\u0005\u00c2b\u0002\u013b\u013c\u0005\b\u0005\n\u013c\u0147\u0003",
    "\u0002\u0002\u0002\u013d\u013e\f\u0007\u0002\u0002\u013e\u013f\u0007",
    "&\u0002\u0002\u013f\u0147\u0005\b\u0005\b\u0140\u0141\f\u0006\u0002",
    "\u0002\u0141\u0142\t\u0005\u0002\u0002\u0142\u0147\u0005\b\u0005\u0007",
    "\u0143\u0144\f\b\u0002\u0002\u0144\u0145\t\u0006\u0002\u0002\u0145\u0147",
    "\u0005\u00bc_\u0002\u0146\u0133\u0003\u0002\u0002\u0002\u0146\u0136",
    "\u0003\u0002\u0002\u0002\u0146\u0139\u0003\u0002\u0002\u0002\u0146\u013d",
    "\u0003\u0002\u0002\u0002\u0146\u0140\u0003\u0002\u0002\u0002\u0146\u0143",
    "\u0003\u0002\u0002\u0002\u0147\u014a\u0003\u0002\u0002\u0002\u0148\u0146",
    "\u0003\u0002\u0002\u0002\u0148\u0149\u0003\u0002\u0002\u0002\u0149\t",
    "\u0003\u0002\u0002\u0002\u014a\u0148\u0003\u0002\u0002\u0002\u014b\u0154",
    "\u0005$\u0013\u0002\u014c\u0154\u0005,\u0017\u0002\u014d\u0154\u0005",
    "0\u0019\u0002\u014e\u0154\u00054\u001b\u0002\u014f\u0154\u00058\u001d",
    "\u0002\u0150\u0154\u0005B\"\u0002\u0151\u0154\u0005D#\u0002\u0152\u0154",
    "\u0005J&\u0002\u0153\u014b\u0003\u0002\u0002\u0002\u0153\u014c\u0003",
    "\u0002\u0002\u0002\u0153\u014d\u0003\u0002\u0002\u0002\u0153\u014e\u0003",
    "\u0002\u0002\u0002\u0153\u014f\u0003\u0002\u0002\u0002\u0153\u0150\u0003",
    "\u0002\u0002\u0002\u0153\u0151\u0003\u0002\u0002\u0002\u0153\u0152\u0003",
    "\u0002\u0002\u0002\u0154\u000b\u0003\u0002\u0002\u0002\u0155\u0162\u0005",
    "\u001e\u0010\u0002\u0156\u0162\u0005\"\u0012\u0002\u0157\u0162\u0005",
    "*\u0016\u0002\u0158\u0162\u0005.\u0018\u0002\u0159\u0162\u00052\u001a",
    "\u0002\u015a\u0162\u00056\u001c\u0002\u015b\u0162\u0005:\u001e\u0002",
    "\u015c\u0162\u0005<\u001f\u0002\u015d\u0162\u0005> \u0002\u015e\u0162",
    "\u0005@!\u0002\u015f\u0162\u0005F$\u0002\u0160\u0162\u0005H%\u0002\u0161",
    "\u0155\u0003\u0002\u0002\u0002\u0161\u0156\u0003\u0002\u0002\u0002\u0161",
    "\u0157\u0003\u0002\u0002\u0002\u0161\u0158\u0003\u0002\u0002\u0002\u0161",
    "\u0159\u0003\u0002\u0002\u0002\u0161\u015a\u0003\u0002\u0002\u0002\u0161",
    "\u015b\u0003\u0002\u0002\u0002\u0161\u015c\u0003\u0002\u0002\u0002\u0161",
    "\u015d\u0003\u0002\u0002\u0002\u0161\u015e\u0003\u0002\u0002\u0002\u0161",
    "\u015f\u0003\u0002\u0002\u0002\u0161\u0160\u0003\u0002\u0002\u0002\u0162",
    "\r\u0003\u0002\u0002\u0002\u0163\u016b\u0005\u0010\t\u0002\u0164\u016b",
    "\u0005\u0012\n\u0002\u0165\u016b\u0005\u0014\u000b\u0002\u0166\u016b",
    "\u0005\u0016\f\u0002\u0167\u016b\u0005\u0018\r\u0002\u0168\u016b\u0005",
    "\u001a\u000e\u0002\u0169\u016b\u0005\u001c\u000f\u0002\u016a\u0163\u0003",
    "\u0002\u0002\u0002\u016a\u0164\u0003\u0002\u0002\u0002\u016a\u0165\u0003",
    "\u0002\u0002\u0002\u016a\u0166\u0003\u0002\u0002\u0002\u016a\u0167\u0003",
    "\u0002\u0002\u0002\u016a\u0168\u0003\u0002\u0002\u0002\u016a\u0169\u0003",
    "\u0002\u0002\u0002\u016b\u000f\u0003\u0002\u0002\u0002\u016c\u016d\u0007",
    "$\u0002\u0002\u016d\u0172\u0005L\'\u0002\u016e\u016f\u0007\u0013\u0002",
    "\u0002\u016f\u0171\u0005L\'\u0002\u0170\u016e\u0003\u0002\u0002\u0002",
    "\u0171\u0174\u0003\u0002\u0002\u0002\u0172\u0170\u0003\u0002\u0002\u0002",
    "\u0172\u0173\u0003\u0002\u0002\u0002\u0173\u0011\u0003\u0002\u0002\u0002",
    "\u0174\u0172\u0003\u0002\u0002\u0002\u0175\u0176\u0007?\u0002\u0002",
    "\u0176\u017b\u0005N(\u0002\u0177\u0179\u0005l7\u0002\u0178\u017a\u0005",
    "n8\u0002\u0179\u0178\u0003\u0002\u0002\u0002\u0179\u017a\u0003\u0002",
    "\u0002\u0002\u017a\u017c\u0003\u0002\u0002\u0002\u017b\u0177\u0003\u0002",
    "\u0002\u0002\u017b\u017c\u0003\u0002\u0002\u0002\u017c\u0013\u0003\u0002",
    "\u0002\u0002\u017d\u017e\u0007`\u0002\u0002\u017e\u017f\u0005\b\u0005",
    "\u0002\u017f\u0015\u0003\u0002\u0002\u0002\u0180\u0181\u0007\"\u0002",
    "\u0002\u0181\u0186\u0005R*\u0002\u0182\u0183\u0007\u0013\u0002\u0002",
    "\u0183\u0185\u0005R*\u0002\u0184\u0182\u0003\u0002\u0002\u0002\u0185",
    "\u0188\u0003\u0002\u0002\u0002\u0186\u0184\u0003\u0002\u0002\u0002\u0186",
    "\u0187\u0003\u0002\u0002\u0002\u0187\u0017\u0003\u0002\u0002\u0002\u0188",
    "\u0186\u0003\u0002\u0002\u0002\u0189\u018a\t\u0007\u0002\u0002\u018a",
    "\u018f\u0005\u00ba^\u0002\u018b\u018c\u0007\u0013\u0002\u0002\u018c",
    "\u018e\u0005\u00ba^\u0002\u018d\u018b\u0003\u0002\u0002\u0002\u018e",
    "\u0191\u0003\u0002\u0002\u0002\u018f\u018d\u0003\u0002\u0002\u0002\u018f",
    "\u0190\u0003\u0002\u0002\u0002\u0190\u0019\u0003\u0002\u0002\u0002\u0191",
    "\u018f\u0003\u0002\u0002\u0002\u0192\u0193\t\b\u0002\u0002\u0193\u0194",
    "\u0005\u00ba^\u0002\u0194\u0195\u0007\u0013\u0002\u0002\u0195\u0196",
    "\u0005\u00ba^\u0002\u0196\u001b\u0003\u0002\u0002\u0002\u0197\u0198",
    "\u0007\u00c3\u0002\u0002\u0198\u019d\u0005T+\u0002\u0199\u019a\u0007",
    "\u0013\u0002\u0002\u019a\u019c\u0005T+\u0002\u019b\u0199\u0003\u0002",
    "\u0002\u0002\u019c\u019f\u0003\u0002\u0002\u0002\u019d\u019b\u0003\u0002",
    "\u0002\u0002\u019d\u019e\u0003\u0002\u0002\u0002\u019e\u001d\u0003\u0002",
    "\u0002\u0002\u019f\u019d\u0003\u0002\u0002\u0002\u01a0\u01a1\t\t\u0002",
    "\u0002\u01a1\u01a2\u0007\u0003\u0002\u0002\u01a2\u01a3\u0005X-\u0002",
    "\u01a3\u01a4\u0005\\/\u0002\u01a4\u01a5\u0007\u0004\u0002\u0002\u01a5",
    "\u01ad\u0003\u0002\u0002\u0002\u01a6\u01a7\t\n\u0002\u0002\u01a7\u01a8",
    "\u0007\u0003\u0002\u0002\u01a8\u01a9\u0005V,\u0002\u01a9\u01aa\u0005",
    "\\/\u0002\u01aa\u01ab\u0007\u0004\u0002\u0002\u01ab\u01ad\u0003\u0002",
    "\u0002\u0002\u01ac\u01a0\u0003\u0002\u0002\u0002\u01ac\u01a6\u0003\u0002",
    "\u0002\u0002\u01ad\u001f\u0003\u0002\u0002\u0002\u01ae\u01af\u0007q",
    "\u0002\u0002\u01af\u01b0\u0007p\u0002\u0002\u01b0\u01b1\u0005\u00ce",
    "h\u0002\u01b1\u01ba\u0007\u0003\u0002\u0002\u01b2\u01b7\u0005p9\u0002",
    "\u01b3\u01b4\u0007\u0013\u0002\u0002\u01b4\u01b6\u0005p9\u0002\u01b5",
    "\u01b3\u0003\u0002\u0002\u0002\u01b6\u01b9\u0003\u0002\u0002\u0002\u01b7",
    "\u01b5\u0003\u0002\u0002\u0002\u01b7\u01b8\u0003\u0002\u0002\u0002\u01b8",
    "\u01bb\u0003\u0002\u0002\u0002\u01b9\u01b7\u0003\u0002\u0002\u0002\u01ba",
    "\u01b2\u0003\u0002\u0002\u0002\u01ba\u01bb\u0003\u0002\u0002\u0002\u01bb",
    "\u01bc\u0003\u0002\u0002\u0002\u01bc\u01bf\u0007\u0004\u0002\u0002\u01bd",
    "\u01be\u0007\u00bf\u0002\u0002\u01be\u01c0\u0005r:\u0002\u01bf\u01bd",
    "\u0003\u0002\u0002\u0002\u01bf\u01c0\u0003\u0002\u0002\u0002\u01c0\u01c1",
    "\u0003\u0002\u0002\u0002\u01c1\u01c2\u0007\u00ae\u0002\u0002\u01c2\u01c3",
    "\u0005\u0006\u0004\u0002\u01c3\u01c4\u0007w\u0002\u0002\u01c4\u01c5",
    "\u0007p\u0002\u0002\u01c5\u01e1\u0003\u0002\u0002\u0002\u01c6\u01c7",
    "\u0007q\u0002\u0002\u01c7\u01c8\u0007s\u0002\u0002\u01c8\u01c9\u0007",
    "u\u0002\u0002\u01c9\u01ca\u0005\u0088E\u0002\u01ca\u01cb\u0007\u0003",
    "\u0002\u0002\u01cb\u01cc\u0005\u008aF\u0002\u01cc\u01cd\u0007\u0004",
    "\u0002\u0002\u01cd\u01ce\u0007\u00ae\u0002\u0002\u01ce\u01cf\u0005\u008e",
    "H\u0002\u01cf\u01d0\u0007w\u0002\u0002\u01d0\u01d1\u0007s\u0002\u0002",
    "\u01d1\u01d2\u0007u\u0002\u0002\u01d2\u01e1\u0003\u0002\u0002\u0002",
    "\u01d3\u01d4\u0007q\u0002\u0002\u01d4\u01d5\u0007t\u0002\u0002\u01d5",
    "\u01d6\u0007u\u0002\u0002\u01d6\u01d7\u0005\u0088E\u0002\u01d7\u01d8",
    "\u0007\u0003\u0002\u0002\u01d8\u01d9\u0005\u0096L\u0002\u01d9\u01da",
    "\u0007\u0004\u0002\u0002\u01da\u01db\u0007\u00ae\u0002\u0002\u01db\u01dc",
    "\u0005\u0092J\u0002\u01dc\u01dd\u0007w\u0002\u0002\u01dd\u01de\u0007",
    "t\u0002\u0002\u01de\u01df\u0007u\u0002\u0002\u01df\u01e1\u0003\u0002",
    "\u0002\u0002\u01e0\u01ae\u0003\u0002\u0002\u0002\u01e0\u01c6\u0003\u0002",
    "\u0002\u0002\u01e0\u01d3\u0003\u0002\u0002\u0002\u01e1!\u0003\u0002",
    "\u0002\u0002\u01e2\u01e3\u0005\u00ceh\u0002\u01e3\u01ec\u0007\u0003",
    "\u0002\u0002\u01e4\u01e9\u0005(\u0015\u0002\u01e5\u01e6\u0007\u0013",
    "\u0002\u0002\u01e6\u01e8\u0005(\u0015\u0002\u01e7\u01e5\u0003\u0002",
    "\u0002\u0002\u01e8\u01eb\u0003\u0002\u0002\u0002\u01e9\u01e7\u0003\u0002",
    "\u0002\u0002\u01e9\u01ea\u0003\u0002\u0002\u0002\u01ea\u01ed\u0003\u0002",
    "\u0002\u0002\u01eb\u01e9\u0003\u0002\u0002\u0002\u01ec\u01e4\u0003\u0002",
    "\u0002\u0002\u01ec\u01ed\u0003\u0002\u0002\u0002\u01ed\u01ee\u0003\u0002",
    "\u0002\u0002\u01ee\u01ef\u0007\u0004\u0002\u0002\u01ef\u021c\u0003\u0002",
    "\u0002\u0002\u01f0\u01f1\u0007\u0018\u0002\u0002\u01f1\u01f2\u0007\u0003",
    "\u0002\u0002\u01f2\u01f3\u0005\u00d0i\u0002\u01f3\u01f6\u0007\u0003",
    "\u0002\u0002\u01f4\u01f7\u0005\u00b6\\\u0002\u01f5\u01f7\u0005\u00d2",
    "j\u0002\u01f6\u01f4\u0003\u0002\u0002\u0002\u01f6\u01f5\u0003\u0002",
    "\u0002\u0002\u01f6\u01f7\u0003\u0002\u0002\u0002\u01f7\u01ff\u0003\u0002",
    "\u0002\u0002\u01f8\u01fb\u0007\u0013\u0002\u0002\u01f9\u01fc\u0005\u00b6",
    "\\\u0002\u01fa\u01fc\u0005\u00d2j\u0002\u01fb\u01f9\u0003\u0002\u0002",
    "\u0002\u01fb\u01fa\u0003\u0002\u0002\u0002\u01fc\u01fe\u0003\u0002\u0002",
    "\u0002\u01fd\u01f8\u0003\u0002\u0002\u0002\u01fe\u0201\u0003\u0002\u0002",
    "\u0002\u01ff\u01fd\u0003\u0002\u0002\u0002\u01ff\u0200\u0003\u0002\u0002",
    "\u0002\u0200\u0202\u0003\u0002\u0002\u0002\u0201\u01ff\u0003\u0002\u0002",
    "\u0002\u0202\u0205\u0007\u0004\u0002\u0002\u0203\u0204\u0007\u00e6\u0002",
    "\u0002\u0204\u0206\u0007\u00ea\u0002\u0002\u0205\u0203\u0003\u0002\u0002",
    "\u0002\u0205\u0206\u0003\u0002\u0002\u0002\u0206\u0209\u0003\u0002\u0002",
    "\u0002\u0207\u0208\u0007\u00bf\u0002\u0002\u0208\u020a\u0005~@\u0002",
    "\u0209\u0207\u0003\u0002\u0002\u0002\u0209\u020a\u0003\u0002\u0002\u0002",
    "\u020a\u020b\u0003\u0002\u0002\u0002\u020b\u020c\u0007\u0004\u0002\u0002",
    "\u020c\u021c\u0003\u0002\u0002\u0002\u020d\u020e\u0007\u00d0\u0002\u0002",
    "\u020e\u020f\u0007\u0003\u0002\u0002\u020f\u0210\u0005\u0006\u0004\u0002",
    "\u0210\u0213\u0007\u0013\u0002\u0002\u0211\u0214\u0005\u00d4k\u0002",
    "\u0212\u0214\u0005\u0086D\u0002\u0213\u0211\u0003\u0002\u0002\u0002",
    "\u0213\u0212\u0003\u0002\u0002\u0002\u0214\u0217\u0003\u0002\u0002\u0002",
    "\u0215\u0216\u0007\u0013\u0002\u0002\u0216\u0218\u0007\u00ea\u0002\u0002",
    "\u0217\u0215\u0003\u0002\u0002\u0002\u0217\u0218\u0003\u0002\u0002\u0002",
    "\u0218\u0219\u0003\u0002\u0002\u0002\u0219\u021a\u0007\u0004\u0002\u0002",
    "\u021a\u021c\u0003\u0002\u0002\u0002\u021b\u01e2\u0003\u0002\u0002\u0002",
    "\u021b\u01f0\u0003\u0002\u0002\u0002\u021b\u020d\u0003\u0002\u0002\u0002",
    "\u021c#\u0003\u0002\u0002\u0002\u021d\u021e\u0005\u00ceh\u0002\u021e",
    "\u0227\u0007\u0003\u0002\u0002\u021f\u0224\u0005&\u0014\u0002\u0220",
    "\u0221\u0007\u0013\u0002\u0002\u0221\u0223\u0005&\u0014\u0002\u0222",
    "\u0220\u0003\u0002\u0002\u0002\u0223\u0226\u0003\u0002\u0002\u0002\u0224",
    "\u0222\u0003\u0002\u0002\u0002\u0224\u0225\u0003\u0002\u0002\u0002\u0225",
    "\u0228\u0003\u0002\u0002\u0002\u0226\u0224\u0003\u0002\u0002\u0002\u0227",
    "\u021f\u0003\u0002\u0002\u0002\u0227\u0228\u0003\u0002\u0002\u0002\u0228",
    "\u0229\u0003\u0002\u0002\u0002\u0229\u022a\u0007\u0004\u0002\u0002\u022a",
    "\u0257\u0003\u0002\u0002\u0002\u022b\u022c\u0007\u00d0\u0002\u0002\u022c",
    "\u022d\u0007\u0003\u0002\u0002\u022d\u022e\u0005\b\u0005\u0002\u022e",
    "\u0231\u0007\u0013\u0002\u0002\u022f\u0232\u0005\u00d4k\u0002\u0230",
    "\u0232\u0005\u0086D\u0002\u0231\u022f\u0003\u0002\u0002\u0002\u0231",
    "\u0230\u0003\u0002\u0002\u0002\u0232\u0235\u0003\u0002\u0002\u0002\u0233",
    "\u0234\u0007\u0013\u0002\u0002\u0234\u0236\u0007\u00ea\u0002\u0002\u0235",
    "\u0233\u0003\u0002\u0002\u0002\u0235\u0236\u0003\u0002\u0002\u0002\u0236",
    "\u0237\u0003\u0002\u0002\u0002\u0237\u0238\u0007\u0004\u0002\u0002\u0238",
    "\u0257\u0003\u0002\u0002\u0002\u0239\u023a\u0007\u0018\u0002\u0002\u023a",
    "\u023b\u0007\u0003\u0002\u0002\u023b\u023c\u0005\u00d0i\u0002\u023c",
    "\u023f\u0007\u0003\u0002\u0002\u023d\u0240\u0005\u00ba^\u0002\u023e",
    "\u0240\u0005\u00d2j\u0002\u023f\u023d\u0003\u0002\u0002\u0002\u023f",
    "\u023e\u0003\u0002\u0002\u0002\u023f\u0240\u0003\u0002\u0002\u0002\u0240",
    "\u0248\u0003\u0002\u0002\u0002\u0241\u0244\u0007\u0013\u0002\u0002\u0242",
    "\u0245\u0005\u00ba^\u0002\u0243\u0245\u0005\u00d2j\u0002\u0244\u0242",
    "\u0003\u0002\u0002\u0002\u0244\u0243\u0003\u0002\u0002\u0002\u0245\u0247",
    "\u0003\u0002\u0002\u0002\u0246\u0241\u0003\u0002\u0002\u0002\u0247\u024a",
    "\u0003\u0002\u0002\u0002\u0248\u0246\u0003\u0002\u0002\u0002\u0248\u0249",
    "\u0003\u0002\u0002\u0002\u0249\u024b\u0003\u0002\u0002\u0002\u024a\u0248",
    "\u0003\u0002\u0002\u0002\u024b\u024e\u0007\u0004\u0002\u0002\u024c\u024d",
    "\u0007\u00e6\u0002\u0002\u024d\u024f\u0007\u00ea\u0002\u0002\u024e\u024c",
    "\u0003\u0002\u0002\u0002\u024e\u024f\u0003\u0002\u0002\u0002\u024f\u0252",
    "\u0003\u0002\u0002\u0002\u0250\u0251\u0007\u00bf\u0002\u0002\u0251\u0253",
    "\u0005t;\u0002\u0252\u0250\u0003\u0002\u0002\u0002\u0252\u0253\u0003",
    "\u0002\u0002\u0002\u0253\u0254\u0003\u0002\u0002\u0002\u0254\u0255\u0007",
    "\u0004\u0002\u0002\u0255\u0257\u0003\u0002\u0002\u0002\u0256\u021d\u0003",
    "\u0002\u0002\u0002\u0256\u022b\u0003\u0002\u0002\u0002\u0256\u0239\u0003",
    "\u0002\u0002\u0002\u0257%\u0003\u0002\u0002\u0002\u0258\u025c\u0005",
    "\u00ba^\u0002\u0259\u025c\u0005\u00d2j\u0002\u025a\u025c\u0007i\u0002",
    "\u0002\u025b\u0258\u0003\u0002\u0002\u0002\u025b\u0259\u0003\u0002\u0002",
    "\u0002\u025b\u025a\u0003\u0002\u0002\u0002\u025c\'\u0003\u0002\u0002",
    "\u0002\u025d\u0261\u0005\u00b6\\\u0002\u025e\u0261\u0005\u00d2j\u0002",
    "\u025f\u0261\u0007i\u0002\u0002\u0260\u025d\u0003\u0002\u0002\u0002",
    "\u0260\u025e\u0003\u0002\u0002\u0002\u0260\u025f\u0003\u0002\u0002\u0002",
    "\u0261)\u0003\u0002\u0002\u0002\u0262\u0263\t\u000b\u0002\u0002\u0263",
    "\u0264\u0007\u0003\u0002\u0002\u0264\u0265\u0005\u0006\u0004\u0002\u0265",
    "\u0266\u0007\u0004\u0002\u0002\u0266\u0293\u0003\u0002\u0002\u0002\u0267",
    "\u0268\u0007X\u0002\u0002\u0268\u0269\u0007\u0003\u0002\u0002\u0269",
    "\u0274\u0005\u0006\u0004\u0002\u026a\u026b\u0007\u0013\u0002\u0002\u026b",
    "\u026c\u0005\u00c4c\u0002\u026c\u026d\u0003\u0002\u0002\u0002\u026d",
    "\u026e\u0007\u0013\u0002\u0002\u026e\u026f\u0005\u00c4c\u0002\u026f",
    "\u0271\u0003\u0002\u0002\u0002\u0270\u026a\u0003\u0002\u0002\u0002\u0270",
    "\u0271\u0003\u0002\u0002\u0002\u0271\u0275\u0003\u0002\u0002\u0002\u0272",
    "\u0273\u0007\u0013\u0002\u0002\u0273\u0275\u0005\u00c4c\u0002\u0274",
    "\u0270\u0003\u0002\u0002\u0002\u0274\u0272\u0003\u0002\u0002\u0002\u0275",
    "\u0276\u0003\u0002\u0002\u0002\u0276\u0277\u0007\u0004\u0002\u0002\u0277",
    "\u0293\u0003\u0002\u0002\u0002\u0278\u0279\u0007|\u0002\u0002\u0279",
    "\u027a\u0007\u0003\u0002\u0002\u027a\u027b\u0005\u0006\u0004\u0002\u027b",
    "\u027c\u0007\u0013\u0002\u0002\u027c\u027f\u0005\u0006\u0004\u0002\u027d",
    "\u027e\u0007\u0013\u0002\u0002\u027e\u0280\u0005\u00c4c\u0002\u027f",
    "\u027d\u0003\u0002\u0002\u0002\u027f\u0280\u0003\u0002\u0002\u0002\u0280",
    "\u0281\u0003\u0002\u0002\u0002\u0281\u0282\u0007\u0004\u0002\u0002\u0282",
    "\u0293\u0003\u0002\u0002\u0002\u0283\u0284\u0007{\u0002\u0002\u0284",
    "\u0285\u0007\u0003\u0002\u0002\u0285\u0286\u0005\u0006\u0004\u0002\u0286",
    "\u0287\u0007\u0013\u0002\u0002\u0287\u028a\u0005\u0006\u0004\u0002\u0288",
    "\u0289\u0007\u0013\u0002\u0002\u0289\u028b\u0005\u00c4c\u0002\u028a",
    "\u0288\u0003\u0002\u0002\u0002\u028a\u028b\u0003\u0002\u0002\u0002\u028b",
    "\u028e\u0003\u0002\u0002\u0002\u028c\u028d\u0007\u0013\u0002\u0002\u028d",
    "\u028f\u0005\u00c4c\u0002\u028e\u028c\u0003\u0002\u0002\u0002\u028e",
    "\u028f\u0003\u0002\u0002\u0002\u028f\u0290\u0003\u0002\u0002\u0002\u0290",
    "\u0291\u0007\u0004\u0002\u0002\u0291\u0293\u0003\u0002\u0002\u0002\u0292",
    "\u0262\u0003\u0002\u0002\u0002\u0292\u0267\u0003\u0002\u0002\u0002\u0292",
    "\u0278\u0003\u0002\u0002\u0002\u0292\u0283\u0003\u0002\u0002\u0002\u0293",
    "+\u0003\u0002\u0002\u0002\u0294\u0295\t\u000b\u0002\u0002\u0295\u0296",
    "\u0007\u0003\u0002\u0002\u0296\u0297\u0005\b\u0005\u0002\u0297\u0298",
    "\u0007\u0004\u0002\u0002\u0298\u02c5\u0003\u0002\u0002\u0002\u0299\u029a",
    "\u0007X\u0002\u0002\u029a\u029b\u0007\u0003\u0002\u0002\u029b\u02a6",
    "\u0005\b\u0005\u0002\u029c\u029d\u0007\u0013\u0002\u0002\u029d\u029e",
    "\u0005\u00c6d\u0002\u029e\u029f\u0003\u0002\u0002\u0002\u029f\u02a0",
    "\u0007\u0013\u0002\u0002\u02a0\u02a1\u0005\u00c6d\u0002\u02a1\u02a3",
    "\u0003\u0002\u0002\u0002\u02a2\u029c\u0003\u0002\u0002\u0002\u02a2\u02a3",
    "\u0003\u0002\u0002\u0002\u02a3\u02a7\u0003\u0002\u0002\u0002\u02a4\u02a5",
    "\u0007\u0013\u0002\u0002\u02a5\u02a7\u0005\u00c6d\u0002\u02a6\u02a2",
    "\u0003\u0002\u0002\u0002\u02a6\u02a4\u0003\u0002\u0002\u0002\u02a7\u02a8",
    "\u0003\u0002\u0002\u0002\u02a8\u02a9\u0007\u0004\u0002\u0002\u02a9\u02c5",
    "\u0003\u0002\u0002\u0002\u02aa\u02ab\u0007|\u0002\u0002\u02ab\u02ac",
    "\u0007\u0003\u0002\u0002\u02ac\u02ad\u0005\b\u0005\u0002\u02ad\u02ae",
    "\u0007\u0013\u0002\u0002\u02ae\u02b1\u0005\b\u0005\u0002\u02af\u02b0",
    "\u0007\u0013\u0002\u0002\u02b0\u02b2\u0005\u00c6d\u0002\u02b1\u02af",
    "\u0003\u0002\u0002\u0002\u02b1\u02b2\u0003\u0002\u0002\u0002\u02b2\u02b3",
    "\u0003\u0002\u0002\u0002\u02b3\u02b4\u0007\u0004\u0002\u0002\u02b4\u02c5",
    "\u0003\u0002\u0002\u0002\u02b5\u02b6\u0007{\u0002\u0002\u02b6\u02b7",
    "\u0007\u0003\u0002\u0002\u02b7\u02b8\u0005\b\u0005\u0002\u02b8\u02b9",
    "\u0007\u0013\u0002\u0002\u02b9\u02bc\u0005\b\u0005\u0002\u02ba\u02bb",
    "\u0007\u0013\u0002\u0002\u02bb\u02bd\u0005\u00c6d\u0002\u02bc\u02ba",
    "\u0003\u0002\u0002\u0002\u02bc\u02bd\u0003\u0002\u0002\u0002\u02bd\u02c0",
    "\u0003\u0002\u0002\u0002\u02be\u02bf\u0007\u0013\u0002\u0002\u02bf\u02c1",
    "\u0005\u00c6d\u0002\u02c0\u02be\u0003\u0002\u0002\u0002\u02c0\u02c1",
    "\u0003\u0002\u0002\u0002\u02c1\u02c2\u0003\u0002\u0002\u0002\u02c2\u02c3",
    "\u0007\u0004\u0002\u0002\u02c3\u02c5\u0003\u0002\u0002\u0002\u02c4\u0294",
    "\u0003\u0002\u0002\u0002\u02c4\u0299\u0003\u0002\u0002\u0002\u02c4\u02aa",
    "\u0003\u0002\u0002\u0002\u02c4\u02b5\u0003\u0002\u0002\u0002\u02c5-",
    "\u0003\u0002\u0002\u0002\u02c6\u02c7\t\f\u0002\u0002\u02c7\u02c8\u0007",
    "\u0003\u0002\u0002\u02c8\u02c9\u0005\u0006\u0004\u0002\u02c9\u02ca\u0007",
    "\u0004\u0002\u0002\u02ca\u02dc\u0003\u0002\u0002\u0002\u02cb\u02cc\t",
    "\r\u0002\u0002\u02cc\u02cd\u0007\u0003\u0002\u0002\u02cd\u02d0\u0005",
    "\u0006\u0004\u0002\u02ce\u02cf\u0007\u0013\u0002\u0002\u02cf\u02d1\u0005",
    "\u00c4c\u0002\u02d0\u02ce\u0003\u0002\u0002\u0002\u02d0\u02d1\u0003",
    "\u0002\u0002\u0002\u02d1\u02d2\u0003\u0002\u0002\u0002\u02d2\u02d3\u0007",
    "\u0004\u0002\u0002\u02d3\u02dc\u0003\u0002\u0002\u0002\u02d4\u02d5\t",
    "\u000e\u0002\u0002\u02d5\u02d6\u0007\u0003\u0002\u0002\u02d6\u02d7\u0005",
    "\u0006\u0004\u0002\u02d7\u02d8\u0007\u0013\u0002\u0002\u02d8\u02d9\u0005",
    "\u0006\u0004\u0002\u02d9\u02da\u0007\u0004\u0002\u0002\u02da\u02dc\u0003",
    "\u0002\u0002\u0002\u02db\u02c6\u0003\u0002\u0002\u0002\u02db\u02cb\u0003",
    "\u0002\u0002\u0002\u02db\u02d4\u0003\u0002\u0002\u0002\u02dc/\u0003",
    "\u0002\u0002\u0002\u02dd\u02de\t\f\u0002\u0002\u02de\u02df\u0007\u0003",
    "\u0002\u0002\u02df\u02e0\u0005\b\u0005\u0002\u02e0\u02e1\u0007\u0004",
    "\u0002\u0002\u02e1\u02f3\u0003\u0002\u0002\u0002\u02e2\u02e3\t\r\u0002",
    "\u0002\u02e3\u02e4\u0007\u0003\u0002\u0002\u02e4\u02e7\u0005\b\u0005",
    "\u0002\u02e5\u02e6\u0007\u0013\u0002\u0002\u02e6\u02e8\u0005\u00c6d",
    "\u0002\u02e7\u02e5\u0003\u0002\u0002\u0002\u02e7\u02e8\u0003\u0002\u0002",
    "\u0002\u02e8\u02e9\u0003\u0002\u0002\u0002\u02e9\u02ea\u0007\u0004\u0002",
    "\u0002\u02ea\u02f3\u0003\u0002\u0002\u0002\u02eb\u02ec\t\u000e\u0002",
    "\u0002\u02ec\u02ed\u0007\u0003\u0002\u0002\u02ed\u02ee\u0005\b\u0005",
    "\u0002\u02ee\u02ef\u0007\u0013\u0002\u0002\u02ef\u02f0\u0005\b\u0005",
    "\u0002\u02f0\u02f1\u0007\u0004\u0002\u0002\u02f1\u02f3\u0003\u0002\u0002",
    "\u0002\u02f2\u02dd\u0003\u0002\u0002\u0002\u02f2\u02e2\u0003\u0002\u0002",
    "\u0002\u02f2\u02eb\u0003\u0002\u0002\u0002\u02f31\u0003\u0002\u0002",
    "\u0002\u02f4\u02f5\u0007*\u0002\u0002\u02f5\u02f6\u0007\u0003\u0002",
    "\u0002\u02f6\u02f7\u0005\u0006\u0004\u0002\u02f7\u02f8\u0007\u0013\u0002",
    "\u0002\u02f8\u02f9\u0005\u0006\u0004\u0002\u02f9\u02fa\u0007\u0013\u0002",
    "\u0002\u02fa\u02fb\u0005\u0006\u0004\u0002\u02fb\u02fc\u0007\u0004\u0002",
    "\u0002\u02fc\u0315\u0003\u0002\u0002\u0002\u02fd\u02fe\u0007e\u0002",
    "\u0002\u02fe\u02ff\u0007\u0003\u0002\u0002\u02ff\u0300\u0005\u0006\u0004",
    "\u0002\u0300\u0301\u0007\u0013\u0002\u0002\u0301\u0302\u0005\u0006\u0004",
    "\u0002\u0302\u0303\u0007\u0004\u0002\u0002\u0303\u0315\u0003\u0002\u0002",
    "\u0002\u0304\u0305\u0007.\u0002\u0002\u0305\u0306\u0007\u0003\u0002",
    "\u0002\u0306\u0307\u0005\u0006\u0004\u0002\u0307\u0308\u0007\u0004\u0002",
    "\u0002\u0308\u0315\u0003\u0002\u0002\u0002\u0309\u030a\u00079\u0002",
    "\u0002\u030a\u030b\u0007\u0003\u0002\u0002\u030b\u030c\u0005\u0006\u0004",
    "\u0002\u030c\u030d\u0007\u0013\u0002\u0002\u030d\u0310\u0005\u0006\u0004",
    "\u0002\u030e\u030f\u0007\u0013\u0002\u0002\u030f\u0311\u0005\u00d6l",
    "\u0002\u0310\u030e\u0003\u0002\u0002\u0002\u0310\u0311\u0003\u0002\u0002",
    "\u0002\u0311\u0312\u0003\u0002\u0002\u0002\u0312\u0313\u0007\u0004\u0002",
    "\u0002\u0313\u0315\u0003\u0002\u0002\u0002\u0314\u02f4\u0003\u0002\u0002",
    "\u0002\u0314\u02fd\u0003\u0002\u0002\u0002\u0314\u0304\u0003\u0002\u0002",
    "\u0002\u0314\u0309\u0003\u0002\u0002\u0002\u03153\u0003\u0002\u0002",
    "\u0002\u0316\u0317\u0007*\u0002\u0002\u0317\u0318\u0007\u0003\u0002",
    "\u0002\u0318\u0319\u0005\b\u0005\u0002\u0319\u031a\u0007\u0013\u0002",
    "\u0002\u031a\u031b\u0005\b\u0005\u0002\u031b\u031c\u0007\u0013\u0002",
    "\u0002\u031c\u031d\u0005\b\u0005\u0002\u031d\u031e\u0007\u0004\u0002",
    "\u0002\u031e\u032c\u0003\u0002\u0002\u0002\u031f\u0320\u0007e\u0002",
    "\u0002\u0320\u0321\u0007\u0003\u0002\u0002\u0321\u0322\u0005\b\u0005",
    "\u0002\u0322\u0323\u0007\u0013\u0002\u0002\u0323\u0324\u0005\b\u0005",
    "\u0002\u0324\u0325\u0007\u0004\u0002\u0002\u0325\u032c\u0003\u0002\u0002",
    "\u0002\u0326\u0327\u0007.\u0002\u0002\u0327\u0328\u0007\u0003\u0002",
    "\u0002\u0328\u0329\u0005\b\u0005\u0002\u0329\u032a\u0007\u0004\u0002",
    "\u0002\u032a\u032c\u0003\u0002\u0002\u0002\u032b\u0316\u0003\u0002\u0002",
    "\u0002\u032b\u031f\u0003\u0002\u0002\u0002\u032b\u0326\u0003\u0002\u0002",
    "\u0002\u032c5\u0003\u0002\u0002\u0002\u032d\u032e\u0007\u00c6\u0002",
    "\u0002\u032e\u0330\u0007\u0003\u0002\u0002\u032f\u0331\u0005\u0006\u0004",
    "\u0002\u0330\u032f\u0003\u0002\u0002\u0002\u0330\u0331\u0003\u0002\u0002",
    "\u0002\u0331\u0332\u0003\u0002\u0002\u0002\u0332\u035c\u0007\u0004\u0002",
    "\u0002\u0333\u0334\u0007\u0097\u0002\u0002\u0334\u0335\u0007\u0003\u0002",
    "\u0002\u0335\u0338\u0005\u0006\u0004\u0002\u0336\u0337\u0007\u0013\u0002",
    "\u0002\u0337\u0339\t\u000f\u0002\u0002\u0338\u0336\u0003\u0002\u0002",
    "\u0002\u0338\u0339\u0003\u0002\u0002\u0002\u0339\u033a\u0003\u0002\u0002",
    "\u0002\u033a\u033b\u0007\u0004\u0002\u0002\u033b\u035c\u0003\u0002\u0002",
    "\u0002\u033c\u033d\t\u0010\u0002\u0002\u033d\u033e\u0007\u0003\u0002",
    "\u0002\u033e\u033f\u0005\u0006\u0004\u0002\u033f\u0340\u0007\u0004\u0002",
    "\u0002\u0340\u035c\u0003\u0002\u0002\u0002\u0341\u0342\u0007\u009a\u0002",
    "\u0002\u0342\u0343\u0007\u0003\u0002\u0002\u0343\u0344\u0005\u0006\u0004",
    "\u0002\u0344\u0345\u0007\u0013\u0002\u0002\u0345\u0346\u0005h5\u0002",
    "\u0346\u0347\u0007\u0004\u0002\u0002\u0347\u035c\u0003\u0002\u0002\u0002",
    "\u0348\u0349\u0007\u00c9\u0002\u0002\u0349\u034a\u0007\u0003\u0002\u0002",
    "\u034a\u034d\u0007\u00ea\u0002\u0002\u034b\u034c\u0007\u0013\u0002\u0002",
    "\u034c\u034e\t\u0011\u0002\u0002\u034d\u034b\u0003\u0002\u0002\u0002",
    "\u034d\u034e\u0003\u0002\u0002\u0002\u034e\u0351\u0003\u0002\u0002\u0002",
    "\u034f\u0350\u0007\u0013\u0002\u0002\u0350\u0352\u0005\u00c4c\u0002",
    "\u0351\u034f\u0003\u0002\u0002\u0002\u0351\u0352\u0003\u0002\u0002\u0002",
    "\u0352\u0355\u0003\u0002\u0002\u0002\u0353\u0354\u0007\u0013\u0002\u0002",
    "\u0354\u0356\t\u0012\u0002\u0002\u0355\u0353\u0003\u0002\u0002\u0002",
    "\u0355\u0356\u0003\u0002\u0002\u0002\u0356\u0357\u0003\u0002\u0002\u0002",
    "\u0357\u035c\u0007\u0004\u0002\u0002\u0358\u0359\u0007\u001e\u0002\u0002",
    "\u0359\u035a\u0007\u0003\u0002\u0002\u035a\u035c\u0007\u0004\u0002\u0002",
    "\u035b\u032d\u0003\u0002\u0002\u0002\u035b\u0333\u0003\u0002\u0002\u0002",
    "\u035b\u033c\u0003\u0002\u0002\u0002\u035b\u0341\u0003\u0002\u0002\u0002",
    "\u035b\u0348\u0003\u0002\u0002\u0002\u035b\u0358\u0003\u0002\u0002\u0002",
    "\u035c7\u0003\u0002\u0002\u0002\u035d\u035e\u0007\u00c6\u0002\u0002",
    "\u035e\u0360\u0007\u0003\u0002\u0002\u035f\u0361\u0005\b\u0005\u0002",
    "\u0360\u035f\u0003\u0002\u0002\u0002\u0360\u0361\u0003\u0002\u0002\u0002",
    "\u0361\u0362\u0003\u0002\u0002\u0002\u0362\u038c\u0007\u0004\u0002\u0002",
    "\u0363\u0364\u0007\u0097\u0002\u0002\u0364\u0365\u0007\u0003\u0002\u0002",
    "\u0365\u0368\u0005\b\u0005\u0002\u0366\u0367\u0007\u0013\u0002\u0002",
    "\u0367\u0369\t\u000f\u0002\u0002\u0368\u0366\u0003\u0002\u0002\u0002",
    "\u0368\u0369\u0003\u0002\u0002\u0002\u0369\u036a\u0003\u0002\u0002\u0002",
    "\u036a\u036b\u0007\u0004\u0002\u0002\u036b\u038c\u0003\u0002\u0002\u0002",
    "\u036c\u036d\t\u0010\u0002\u0002\u036d\u036e\u0007\u0003\u0002\u0002",
    "\u036e\u036f\u0005\b\u0005\u0002\u036f\u0370\u0007\u0004\u0002\u0002",
    "\u0370\u038c\u0003\u0002\u0002\u0002\u0371\u0372\u0007\u009a\u0002\u0002",
    "\u0372\u0373\u0007\u0003\u0002\u0002\u0373\u0374\u0005\b\u0005\u0002",
    "\u0374\u0375\u0007\u0013\u0002\u0002\u0375\u0376\u0005h5\u0002\u0376",
    "\u0377\u0007\u0004\u0002\u0002\u0377\u038c\u0003\u0002\u0002\u0002\u0378",
    "\u0379\u0007\u00c9\u0002\u0002\u0379\u037a\u0007\u0003\u0002\u0002\u037a",
    "\u037d\u0007\u00ea\u0002\u0002\u037b\u037c\u0007\u0013\u0002\u0002\u037c",
    "\u037e\t\u0011\u0002\u0002\u037d\u037b\u0003\u0002\u0002\u0002\u037d",
    "\u037e\u0003\u0002\u0002\u0002\u037e\u0381\u0003\u0002\u0002\u0002\u037f",
    "\u0380\u0007\u0013\u0002\u0002\u0380\u0382\u0005\u00c6d\u0002\u0381",
    "\u037f\u0003\u0002\u0002\u0002\u0381\u0382\u0003\u0002\u0002\u0002\u0382",
    "\u0385\u0003\u0002\u0002\u0002\u0383\u0384\u0007\u0013\u0002\u0002\u0384",
    "\u0386\t\u0012\u0002\u0002\u0385\u0383\u0003\u0002\u0002\u0002\u0385",
    "\u0386\u0003\u0002\u0002\u0002\u0386\u0387\u0003\u0002\u0002\u0002\u0387",
    "\u038c\u0007\u0004\u0002\u0002\u0388\u0389\u0007\u001e\u0002\u0002\u0389",
    "\u038a\u0007\u0003\u0002\u0002\u038a\u038c\u0007\u0004\u0002\u0002\u038b",
    "\u035d\u0003\u0002\u0002\u0002\u038b\u0363\u0003\u0002\u0002\u0002\u038b",
    "\u036c\u0003\u0002\u0002\u0002\u038b\u0371\u0003\u0002\u0002\u0002\u038b",
    "\u0378\u0003\u0002\u0002\u0002\u038b\u0388\u0003\u0002\u0002\u0002\u038c",
    "9\u0003\u0002\u0002\u0002\u038d\u038e\u00070\u0002\u0002\u038e\u038f",
    "\u0007\u0003\u0002\u0002\u038f\u0392\u0005\u0006\u0004\u0002\u0390\u0391",
    "\u0007\u0013\u0002\u0002\u0391\u0393\u0005\u0006\u0004\u0002\u0392\u0390",
    "\u0003\u0002\u0002\u0002\u0393\u0394\u0003\u0002\u0002\u0002\u0394\u0392",
    "\u0003\u0002\u0002\u0002\u0394\u0395\u0003\u0002\u0002\u0002\u0395\u0396",
    "\u0003\u0002\u0002\u0002\u0396\u0397\u0007\u0004\u0002\u0002\u0397\u03ab",
    "\u0003\u0002\u0002\u0002\u0398\u0399\u00073\u0002\u0002\u0399\u039a",
    "\u0007\u0003\u0002\u0002\u039a\u039d\u0005\u0006\u0004\u0002\u039b\u039c",
    "\u0007\u0013\u0002\u0002\u039c\u039e\u0005\u0006\u0004\u0002\u039d\u039b",
    "\u0003\u0002\u0002\u0002\u039e\u039f\u0003\u0002\u0002\u0002\u039f\u039d",
    "\u0003\u0002\u0002\u0002\u039f\u03a0\u0003\u0002\u0002\u0002\u03a0\u03a1",
    "\u0003\u0002\u0002\u0002\u03a1\u03a2\u0007\u0004\u0002\u0002\u03a2\u03ab",
    "\u0003\u0002\u0002\u0002\u03a3\u03a4\t\u0013\u0002\u0002\u03a4\u03a5",
    "\u0007\u0003\u0002\u0002\u03a5\u03a6\u0005\u0006\u0004\u0002\u03a6\u03a7",
    "\u0007\u0013\u0002\u0002\u03a7\u03a8\u0005\u0006\u0004\u0002\u03a8\u03a9",
    "\u0007\u0004\u0002\u0002\u03a9\u03ab\u0003\u0002\u0002\u0002\u03aa\u038d",
    "\u0003\u0002\u0002\u0002\u03aa\u0398\u0003\u0002\u0002\u0002\u03aa\u03a3",
    "\u0003\u0002\u0002\u0002\u03ab;\u0003\u0002\u0002\u0002\u03ac\u03ad",
    "\u0007h\u0002\u0002\u03ad\u03ae\u0007\u0003\u0002\u0002\u03ae\u03af",
    "\u0005\u0006\u0004\u0002\u03af\u03b0\u0007\u0013\u0002\u0002\u03b0\u03b2",
    "\u0007\u00eb\u0002\u0002\u03b1\u03b3\u0005\u00aaV\u0002\u03b2\u03b1",
    "\u0003\u0002\u0002\u0002\u03b2\u03b3\u0003\u0002\u0002\u0002\u03b3\u03b6",
    "\u0003\u0002\u0002\u0002\u03b4\u03b5\u0007v\u0002\u0002\u03b5\u03b7",
    "\u0005\u00ba^\u0002\u03b6\u03b4\u0003\u0002\u0002\u0002\u03b6\u03b7",
    "\u0003\u0002\u0002\u0002\u03b7\u03b9\u0003\u0002\u0002\u0002\u03b8\u03ba",
    "\u0005\u00a8U\u0002\u03b9\u03b8\u0003\u0002\u0002\u0002\u03b9\u03ba",
    "\u0003\u0002\u0002\u0002\u03ba\u03bc\u0003\u0002\u0002\u0002\u03bb\u03bd",
    "\u0005\u00b0Y\u0002\u03bc\u03bb\u0003\u0002\u0002\u0002\u03bc\u03bd",
    "\u0003\u0002\u0002\u0002\u03bd\u03bf\u0003\u0002\u0002\u0002\u03be\u03c0",
    "\u0005\u00b2Z\u0002\u03bf\u03be\u0003\u0002\u0002\u0002\u03bf\u03c0",
    "\u0003\u0002\u0002\u0002\u03c0\u03c1\u0003\u0002\u0002\u0002\u03c1\u03c2",
    "\u0007\u0004\u0002\u0002\u03c2=\u0003\u0002\u0002\u0002\u03c3\u03c4",
    "\u0007\u00d4\u0002\u0002\u03c4\u03c5\u0007\u0003\u0002\u0002\u03c5\u03c6",
    "\u0005\u0006\u0004\u0002\u03c6\u03c7\u0007\u0013\u0002\u0002\u03c7\u03d1",
    "\u0007\u00eb\u0002\u0002\u03c8\u03c9\u0007\u00dd\u0002\u0002\u03c9\u03ce",
    "\u0005\u00ba^\u0002\u03ca\u03cb\u0007\u0013\u0002\u0002\u03cb\u03cd",
    "\u0005\u00ba^\u0002\u03cc\u03ca\u0003\u0002\u0002\u0002\u03cd\u03d0",
    "\u0003\u0002\u0002\u0002\u03ce\u03cc\u0003\u0002\u0002\u0002\u03ce\u03cf",
    "\u0003\u0002\u0002\u0002\u03cf\u03d2\u0003\u0002\u0002\u0002\u03d0\u03ce",
    "\u0003\u0002\u0002\u0002\u03d1\u03c8\u0003\u0002\u0002\u0002\u03d1\u03d2",
    "\u0003\u0002\u0002\u0002\u03d2\u03d4\u0003\u0002\u0002\u0002\u03d3\u03d5",
    "\u0005\u00a6T\u0002\u03d4\u03d3\u0003\u0002\u0002\u0002\u03d4\u03d5",
    "\u0003\u0002\u0002\u0002\u03d5\u03d6\u0003\u0002\u0002\u0002\u03d6\u03d7",
    "\u0007\u0004\u0002\u0002\u03d7\u0401\u0003\u0002\u0002\u0002\u03d8\u03d9",
    "\u0007\u00d5\u0002\u0002\u03d9\u03da\u0007\u0003\u0002\u0002\u03da\u03db",
    "\u0005\u0006\u0004\u0002\u03db\u03dc\u0007\u0013\u0002\u0002\u03dc\u03de",
    "\u0007\u00eb\u0002\u0002\u03dd\u03df\u0005\u00aaV\u0002\u03de\u03dd",
    "\u0003\u0002\u0002\u0002\u03de\u03df\u0003\u0002\u0002\u0002\u03df\u03e2",
    "\u0003\u0002\u0002\u0002\u03e0\u03e1\u0007v\u0002\u0002\u03e1\u03e3",
    "\u0005\u00ba^\u0002\u03e2\u03e0\u0003\u0002\u0002\u0002\u03e2\u03e3",
    "\u0003\u0002\u0002\u0002\u03e3\u03e5\u0003\u0002\u0002\u0002\u03e4\u03e6",
    "\u0005\u00a8U\u0002\u03e5\u03e4\u0003\u0002\u0002\u0002\u03e5\u03e6",
    "\u0003\u0002\u0002\u0002\u03e6\u03e8\u0003\u0002\u0002\u0002\u03e7\u03e9",
    "\u0005\u00acW\u0002\u03e8\u03e7\u0003\u0002\u0002\u0002\u03e8\u03e9",
    "\u0003\u0002\u0002\u0002\u03e9\u03eb\u0003\u0002\u0002\u0002\u03ea\u03ec",
    "\u0005\u00a6T\u0002\u03eb\u03ea\u0003\u0002\u0002\u0002\u03eb\u03ec",
    "\u0003\u0002\u0002\u0002\u03ec\u03ed\u0003\u0002\u0002\u0002\u03ed\u03ee",
    "\u0007\u0004\u0002\u0002\u03ee\u0401\u0003\u0002\u0002\u0002\u03ef\u03f0",
    "\u00078\u0002\u0002\u03f0\u03f1\u0007\u0003\u0002\u0002\u03f1\u03f3",
    "\u0005\u0006\u0004\u0002\u03f2\u03f4\u0005\u00be`\u0002\u03f3\u03f2",
    "\u0003\u0002\u0002\u0002\u03f3\u03f4\u0003\u0002\u0002\u0002\u03f4\u03f6",
    "\u0003\u0002\u0002\u0002\u03f5\u03f7\u0005\u00c0a\u0002\u03f6\u03f5",
    "\u0003\u0002\u0002\u0002\u03f6\u03f7\u0003\u0002\u0002\u0002\u03f7\u03f9",
    "\u0003\u0002\u0002\u0002\u03f8\u03fa\u0005\u00aeX\u0002\u03f9\u03f8",
    "\u0003\u0002\u0002\u0002\u03f9\u03fa\u0003\u0002\u0002\u0002\u03fa\u03fc",
    "\u0003\u0002\u0002\u0002\u03fb\u03fd\t\u0014\u0002\u0002\u03fc\u03fb",
    "\u0003\u0002\u0002\u0002\u03fc\u03fd\u0003\u0002\u0002\u0002\u03fd\u03fe",
    "\u0003\u0002\u0002\u0002\u03fe\u03ff\u0007\u0004\u0002\u0002\u03ff\u0401",
    "\u0003\u0002\u0002\u0002\u0400\u03c3\u0003\u0002\u0002\u0002\u0400\u03d8",
    "\u0003\u0002\u0002\u0002\u0400\u03ef\u0003\u0002\u0002\u0002\u0401?",
    "\u0003\u0002\u0002\u0002\u0402\u0403\u0007g\u0002\u0002\u0403\u0404",
    "\u0007\u0003\u0002\u0002\u0404\u0405\u0005\u0006\u0004\u0002\u0405\u0406",
    "\u0007\u0013\u0002\u0002\u0406\u0407\u0005\u0006\u0004\u0002\u0407\u0408",
    "\u0007\u0004\u0002\u0002\u0408A\u0003\u0002\u0002\u0002\u0409\u040a",
    "\u0007g\u0002\u0002\u040a\u040b\u0007\u0003\u0002\u0002\u040b\u040c",
    "\u0005\b\u0005\u0002\u040c\u040d\u0007\u0013\u0002\u0002\u040d\u040e",
    "\u0005\b\u0005\u0002\u040e\u040f\u0007\u0004\u0002\u0002\u040fC\u0003",
    "\u0002\u0002\u0002\u0410\u0411\t\u0015\u0002\u0002\u0411\u0412\u0007",
    "\u0003\u0002\u0002\u0412\u0413\u0005\b\u0005\u0002\u0413\u0414\u0007",
    "\u0004\u0002\u0002\u0414\u0419\u0003\u0002\u0002\u0002\u0415\u0416\u0007",
    "\\\u0002\u0002\u0416\u0417\u0007\u0003\u0002\u0002\u0417\u0419\u0007",
    "\u0004\u0002\u0002\u0418\u0410\u0003\u0002\u0002\u0002\u0418\u0415\u0003",
    "\u0002\u0002\u0002\u0419E\u0003\u0002\u0002\u0002\u041a\u041b\t\u0015",
    "\u0002\u0002\u041b\u041c\u0007\u0003\u0002\u0002\u041c\u0421\u0005\u0006",
    "\u0004\u0002\u041d\u041f\u0005l7\u0002\u041e\u0420\u0005n8\u0002\u041f",
    "\u041e\u0003\u0002\u0002\u0002\u041f\u0420\u0003\u0002\u0002\u0002\u0420",
    "\u0422\u0003\u0002\u0002\u0002\u0421\u041d\u0003\u0002\u0002\u0002\u0421",
    "\u0422\u0003\u0002\u0002\u0002\u0422\u0423\u0003\u0002\u0002\u0002\u0423",
    "\u0424\u0007\u0004\u0002\u0002\u0424G\u0003\u0002\u0002\u0002\u0425",
    "\u0426\t\u0016\u0002\u0002\u0426\u0427\u0007\u0003\u0002\u0002\u0427",
    "\u0428\u0005\u0006\u0004\u0002\u0428\u0429\u0007\u008e\u0002\u0002\u0429",
    "\u042b\u0007\u0003\u0002\u0002\u042a\u042c\u0005`1\u0002\u042b\u042a",
    "\u0003\u0002\u0002\u0002\u042b\u042c\u0003\u0002\u0002\u0002\u042c\u042e",
    "\u0003\u0002\u0002\u0002\u042d\u042f\u0005b2\u0002\u042e\u042d\u0003",
    "\u0002\u0002\u0002\u042e\u042f\u0003\u0002\u0002\u0002\u042f\u0431\u0003",
    "\u0002\u0002\u0002\u0430\u0432\u0005f4\u0002\u0431\u0430\u0003\u0002",
    "\u0002\u0002\u0431\u0432\u0003\u0002\u0002\u0002\u0432\u0433\u0003\u0002",
    "\u0002\u0002\u0433\u0434\u0007\u0004\u0002\u0002\u0434\u0435\u0007\u0004",
    "\u0002\u0002\u0435\u0454\u0003\u0002\u0002\u0002\u0436\u0437\t\u0017",
    "\u0002\u0002\u0437\u0438\u0007\u0003\u0002\u0002\u0438\u043e\u0005\u0006",
    "\u0004\u0002\u0439\u043a\u0007\u0013\u0002\u0002\u043a\u043c\u0005h",
    "5\u0002\u043b\u043d\u0005\u00d2j\u0002\u043c\u043b\u0003\u0002\u0002",
    "\u0002\u043c\u043d\u0003\u0002\u0002\u0002\u043d\u043f\u0003\u0002\u0002",
    "\u0002\u043e\u0439\u0003\u0002\u0002\u0002\u043e\u043f\u0003\u0002\u0002",
    "\u0002\u043f\u0440\u0003\u0002\u0002\u0002\u0440\u0441\u0007\u008e\u0002",
    "\u0002\u0441\u0443\u0007\u0003\u0002\u0002\u0442\u0444\u0005`1\u0002",
    "\u0443\u0442\u0003\u0002\u0002\u0002\u0443\u0444\u0003\u0002\u0002\u0002",
    "\u0444\u0445\u0003\u0002\u0002\u0002\u0445\u0446\u0005b2\u0002\u0446",
    "\u0447\u0003\u0002\u0002\u0002\u0447\u0448\u0007\u0004\u0002\u0002\u0448",
    "\u0449\u0007\u0004\u0002\u0002\u0449\u0454\u0003\u0002\u0002\u0002\u044a",
    "\u044b\u0007\u008d\u0002\u0002\u044b\u044c\u0007\u0003\u0002\u0002\u044c",
    "\u044d\u0005\u0006\u0004\u0002\u044d\u044e\u0007\u008e\u0002\u0002\u044e",
    "\u044f\u0007\u0003\u0002\u0002\u044f\u0450\u0005`1\u0002\u0450\u0451",
    "\u0007\u0004\u0002\u0002\u0451\u0452\u0007\u0004\u0002\u0002\u0452\u0454",
    "\u0003\u0002\u0002\u0002\u0453\u0425\u0003\u0002\u0002\u0002\u0453\u0436",
    "\u0003\u0002\u0002\u0002\u0453\u044a\u0003\u0002\u0002\u0002\u0454I",
    "\u0003\u0002\u0002\u0002\u0455\u0456\t\u0016\u0002\u0002\u0456\u0457",
    "\u0007\u0003\u0002\u0002\u0457\u0458\u0005\b\u0005\u0002\u0458\u0459",
    "\u0007\u008e\u0002\u0002\u0459\u045b\u0007\u0003\u0002\u0002\u045a\u045c",
    "\u0005`1\u0002\u045b\u045a\u0003\u0002\u0002\u0002\u045b\u045c\u0003",
    "\u0002\u0002\u0002\u045c\u045e\u0003\u0002\u0002\u0002\u045d\u045f\u0005",
    "b2\u0002\u045e\u045d\u0003\u0002\u0002\u0002\u045e\u045f\u0003\u0002",
    "\u0002\u0002\u045f\u0461\u0003\u0002\u0002\u0002\u0460\u0462\u0005f",
    "4\u0002\u0461\u0460\u0003\u0002\u0002\u0002\u0461\u0462\u0003\u0002",
    "\u0002\u0002\u0462\u0463\u0003\u0002\u0002\u0002\u0463\u0464\u0007\u0004",
    "\u0002\u0002\u0464\u0465\u0007\u0004\u0002\u0002\u0465\u0490\u0003\u0002",
    "\u0002\u0002\u0466\u0467\t\u0017\u0002\u0002\u0467\u0468\u0007\u0003",
    "\u0002\u0002\u0468\u046e\u0005\b\u0005\u0002\u0469\u046a\u0007\u0013",
    "\u0002\u0002\u046a\u046c\u0005h5\u0002\u046b\u046d\u0005\u00d2j\u0002",
    "\u046c\u046b\u0003\u0002\u0002\u0002\u046c\u046d\u0003\u0002\u0002\u0002",
    "\u046d\u046f\u0003\u0002\u0002\u0002\u046e\u0469\u0003\u0002\u0002\u0002",
    "\u046e\u046f\u0003\u0002\u0002\u0002\u046f\u0470\u0003\u0002\u0002\u0002",
    "\u0470\u0471\u0007\u008e\u0002\u0002\u0471\u0473\u0007\u0003\u0002\u0002",
    "\u0472\u0474\u0005`1\u0002\u0473\u0472\u0003\u0002\u0002\u0002\u0473",
    "\u0474\u0003\u0002\u0002\u0002\u0474\u0475\u0003\u0002\u0002\u0002\u0475",
    "\u0476\u0005b2\u0002\u0476\u0477\u0003\u0002\u0002\u0002\u0477\u0478",
    "\u0007\u0004\u0002\u0002\u0478\u0479\u0007\u0004\u0002\u0002\u0479\u0490",
    "\u0003\u0002\u0002\u0002\u047a\u047b\u0007C\u0002\u0002\u047b\u047c",
    "\u0007\u0003\u0002\u0002\u047c\u047d\u0007\u008e\u0002\u0002\u047d\u047f",
    "\u0007\u0003\u0002\u0002\u047e\u0480\u0005`1\u0002\u047f\u047e\u0003",
    "\u0002\u0002\u0002\u047f\u0480\u0003\u0002\u0002\u0002\u0480\u0481\u0003",
    "\u0002\u0002\u0002\u0481\u0482\u0005b2\u0002\u0482\u0483\u0003\u0002",
    "\u0002\u0002\u0483\u0484\u0007\u0004\u0002\u0002\u0484\u0485\u0007\u0004",
    "\u0002\u0002\u0485\u0490\u0003\u0002\u0002\u0002\u0486\u0487\u0007\u008d",
    "\u0002\u0002\u0487\u0488\u0007\u0003\u0002\u0002\u0488\u0489\u0005\b",
    "\u0005\u0002\u0489\u048a\u0007\u008e\u0002\u0002\u048a\u048b\u0007\u0003",
    "\u0002\u0002\u048b\u048c\u0005`1\u0002\u048c\u048d\u0007\u0004\u0002",
    "\u0002\u048d\u048e\u0007\u0004\u0002\u0002\u048e\u0490\u0003\u0002\u0002",
    "\u0002\u048f\u0455\u0003\u0002\u0002\u0002\u048f\u0466\u0003\u0002\u0002",
    "\u0002\u048f\u047a\u0003\u0002\u0002\u0002\u048f\u0486\u0003\u0002\u0002",
    "\u0002\u0490K\u0003\u0002\u0002\u0002\u0491\u0492\u0005\u00ba^\u0002",
    "\u0492\u0493\u0007:\u0002\u0002\u0493\u0494\u0005\u00ba^\u0002\u0494",
    "M\u0003\u0002\u0002\u0002\u0495\u049a\u0005P)\u0002\u0496\u0497\u0007",
    "\u0013\u0002\u0002\u0497\u0499\u0005P)\u0002\u0498\u0496\u0003\u0002",
    "\u0002\u0002\u0499\u049c\u0003\u0002\u0002\u0002\u049a\u0498\u0003\u0002",
    "\u0002\u0002\u049a\u049b\u0003\u0002\u0002\u0002\u049bO\u0003\u0002",
    "\u0002\u0002\u049c\u049a\u0003\u0002\u0002\u0002\u049d\u049f\u0005\u00c8",
    "e\u0002\u049e\u049d\u0003\u0002\u0002\u0002\u049e\u049f\u0003\u0002",
    "\u0002\u0002\u049f\u04a0\u0003\u0002\u0002\u0002\u04a0\u04a1\u0005\u00ba",
    "^\u0002\u04a1\u04a2\u0007\u0015\u0002\u0002\u04a2\u04a3\u0005D#\u0002",
    "\u04a3Q\u0003\u0002\u0002\u0002\u04a4\u04a6\u0005\u00c8e\u0002\u04a5",
    "\u04a4\u0003\u0002\u0002\u0002\u04a5\u04a6\u0003\u0002\u0002\u0002\u04a6",
    "\u04a7\u0003\u0002\u0002\u0002\u04a7\u04a8\u0005\u00ba^\u0002\u04a8",
    "\u04a9\u0007\u0015\u0002\u0002\u04a9\u04aa\u0005\b\u0005\u0002\u04aa",
    "S\u0003\u0002\u0002\u0002\u04ab\u04ac\u0005\u00ba^\u0002\u04ac\u04ad",
    "\u0007\t\u0002\u0002\u04ad\u04ae\u0005\u00d2j\u0002\u04aeU\u0003\u0002",
    "\u0002\u0002\u04af\u04b4\u0005Z.\u0002\u04b0\u04b1\u0007\u0013\u0002",
    "\u0002\u04b1\u04b3\u0005Z.\u0002\u04b2\u04b0\u0003\u0002\u0002\u0002",
    "\u04b3\u04b6\u0003\u0002\u0002\u0002\u04b4\u04b2\u0003\u0002\u0002\u0002",
    "\u04b4\u04b5\u0003\u0002\u0002\u0002\u04b5W\u0003\u0002\u0002\u0002",
    "\u04b6\u04b4\u0003\u0002\u0002\u0002\u04b7\u04bc\u0005Z.\u0002\u04b8",
    "\u04b9\u0007\u0013\u0002\u0002\u04b9\u04bb\u0005Z.\u0002\u04ba\u04b8",
    "\u0003\u0002\u0002\u0002\u04bb\u04be\u0003\u0002\u0002\u0002\u04bc\u04ba",
    "\u0003\u0002\u0002\u0002\u04bc\u04bd\u0003\u0002\u0002\u0002\u04bd\u04c8",
    "\u0003\u0002\u0002\u0002\u04be\u04bc\u0003\u0002\u0002\u0002\u04bf\u04c0",
    "\u0007\u001c\u0002\u0002\u04c0\u04c5\u0005\u00ba^\u0002\u04c1\u04c2",
    "\u0007\u0013\u0002\u0002\u04c2\u04c4\u0005\u00ba^\u0002\u04c3\u04c1",
    "\u0003\u0002\u0002\u0002\u04c4\u04c7\u0003\u0002\u0002\u0002\u04c5\u04c3",
    "\u0003\u0002\u0002\u0002\u04c5\u04c6\u0003\u0002\u0002\u0002\u04c6\u04c9",
    "\u0003\u0002\u0002\u0002\u04c7\u04c5\u0003\u0002\u0002\u0002\u04c8\u04bf",
    "\u0003\u0002\u0002\u0002\u04c8\u04c9\u0003\u0002\u0002\u0002\u04c9Y",
    "\u0003\u0002\u0002\u0002\u04ca\u04cd\u0005\u0006\u0004\u0002\u04cb\u04cc",
    "\u0007%\u0002\u0002\u04cc\u04ce\u0005\u00b4[\u0002\u04cd\u04cb\u0003",
    "\u0002\u0002\u0002\u04cd\u04ce\u0003\u0002\u0002\u0002\u04ce[\u0003",
    "\u0002\u0002\u0002\u04cf\u04d1\u0005\u0014\u000b\u0002\u04d0\u04cf\u0003",
    "\u0002\u0002\u0002\u04d0\u04d1\u0003\u0002\u0002\u0002\u04d1\u04d5\u0003",
    "\u0002\u0002\u0002\u04d2\u04d6\u0005\u0016\f\u0002\u04d3\u04d6\u0005",
    "^0\u0002\u04d4\u04d6\u0005\u0012\n\u0002\u04d5\u04d2\u0003\u0002\u0002",
    "\u0002\u04d5\u04d3\u0003\u0002\u0002\u0002\u04d5\u04d4\u0003\u0002\u0002",
    "\u0002\u04d5\u04d6\u0003\u0002\u0002\u0002\u04d6\u04d8\u0003\u0002\u0002",
    "\u0002\u04d7\u04d9\u0005\u0018\r\u0002\u04d8\u04d7\u0003\u0002\u0002",
    "\u0002\u04d8\u04d9\u0003\u0002\u0002\u0002\u04d9\u04db\u0003\u0002\u0002",
    "\u0002\u04da\u04dc\u0005\u0010\t\u0002\u04db\u04da\u0003\u0002\u0002",
    "\u0002\u04db\u04dc\u0003\u0002\u0002\u0002\u04dc]\u0003\u0002\u0002",
    "\u0002\u04dd\u04de\u0007\u00c4\u0002\u0002\u04de\u04df\u0005\u0006\u0004",
    "\u0002\u04df_\u0003\u0002\u0002\u0002\u04e0\u04e1\u0007\u0092\u0002",
    "\u0002\u04e1\u04e2\u0007B\u0002\u0002\u04e2\u04e7\u0005\u00ba^\u0002",
    "\u04e3\u04e4\u0007\u0013\u0002\u0002\u04e4\u04e6\u0005\u00ba^\u0002",
    "\u04e5\u04e3\u0003\u0002\u0002\u0002\u04e6\u04e9\u0003\u0002\u0002\u0002",
    "\u04e7\u04e5\u0003\u0002\u0002\u0002\u04e7\u04e8\u0003\u0002\u0002\u0002",
    "\u04e8a\u0003\u0002\u0002\u0002\u04e9\u04e7\u0003\u0002\u0002\u0002",
    "\u04ea\u04eb\u0007A\u0002\u0002\u04eb\u04ec\u0007B\u0002\u0002\u04ec",
    "\u04f1\u0005d3\u0002\u04ed\u04ee\u0007\u0013\u0002\u0002\u04ee\u04f0",
    "\u0005d3\u0002\u04ef\u04ed\u0003\u0002\u0002\u0002\u04f0\u04f3\u0003",
    "\u0002\u0002\u0002\u04f1\u04ef\u0003\u0002\u0002\u0002\u04f1\u04f2\u0003",
    "\u0002\u0002\u0002\u04f2c\u0003\u0002\u0002\u0002\u04f3\u04f1\u0003",
    "\u0002\u0002\u0002\u04f4\u04f6\u0005\u00ba^\u0002\u04f5\u04f7\t\u0018",
    "\u0002\u0002\u04f6\u04f5\u0003\u0002\u0002\u0002\u04f6\u04f7\u0003\u0002",
    "\u0002\u0002\u04f7e\u0003\u0002\u0002\u0002\u04f8\u04f9\u0007m\u0002",
    "\u0002\u04f9\u04fc\u0007\u00b2\u0002\u0002\u04fa\u04fc\u0007\u0094\u0002",
    "\u0002\u04fb\u04f8\u0003\u0002\u0002\u0002\u04fb\u04fa\u0003\u0002\u0002",
    "\u0002\u04fc\u04fd\u0003\u0002\u0002\u0002\u04fd\u04fe\u0007*\u0002",
    "\u0002\u04fe\u04ff\u0005j6\u0002\u04ff\u0500\u0007&\u0002\u0002\u0500",
    "\u0501\u0005j6\u0002\u0501g\u0003\u0002\u0002\u0002\u0502\u0503\u0007",
    "\u00e7\u0002\u0002\u0503i\u0003\u0002\u0002\u0002\u0504\u0505\u0007",
    "\u00e7\u0002\u0002\u0505\u0510\u0007\u008f\u0002\u0002\u0506\u0507\u0007",
    "\u00e7\u0002\u0002\u0507\u0510\u0007\u0090\u0002\u0002\u0508\u0509\u0007",
    "\u0095\u0002\u0002\u0509\u050a\u0007m\u0002\u0002\u050a\u0510\u0007",
    "\u00b3\u0002\u0002\u050b\u050c\u0007\u0091\u0002\u0002\u050c\u0510\u0007",
    "\u008f\u0002\u0002\u050d\u050e\u0007\u0091\u0002\u0002\u050e\u0510\u0007",
    "\u0090\u0002\u0002\u050f\u0504\u0003\u0002\u0002\u0002\u050f\u0506\u0003",
    "\u0002\u0002\u0002\u050f\u0508\u0003\u0002\u0002\u0002\u050f\u050b\u0003",
    "\u0002\u0002\u0002\u050f\u050d\u0003\u0002\u0002\u0002\u0510k\u0003",
    "\u0002\u0002\u0002\u0511\u0512\u0007\u0086\u0002\u0002\u0512\u0513\t",
    "\u0019\u0002\u0002\u0513\u0518\u0005\u00ba^\u0002\u0514\u0515\u0007",
    "\u0013\u0002\u0002\u0515\u0517\u0005\u00ba^\u0002\u0516\u0514\u0003",
    "\u0002\u0002\u0002\u0517\u051a\u0003\u0002\u0002\u0002\u0518\u0516\u0003",
    "\u0002\u0002\u0002\u0518\u0519\u0003\u0002\u0002\u0002\u0519\u051f\u0003",
    "\u0002\u0002\u0002\u051a\u0518\u0003\u0002\u0002\u0002\u051b\u051c\u0007",
    "\u0086\u0002\u0002\u051c\u051d\u0007>\u0002\u0002\u051d\u051f\u0005",
    "\b\u0005\u0002\u051e\u0511\u0003\u0002\u0002\u0002\u051e\u051b\u0003",
    "\u0002\u0002\u0002\u051fm\u0003\u0002\u0002\u0002\u0520\u0521\u0007",
    "\u0088\u0002\u0002\u0521\u0522\u0005\b\u0005\u0002\u0522o\u0003\u0002",
    "\u0002\u0002\u0523\u0524\u0005\u00b6\\\u0002\u0524\u0527\u0005v<\u0002",
    "\u0525\u0526\u0007\u00d3\u0002\u0002\u0526\u0528\u0005\u00d2j\u0002",
    "\u0527\u0525\u0003\u0002\u0002\u0002\u0527\u0528\u0003\u0002\u0002\u0002",
    "\u0528q\u0003\u0002\u0002\u0002\u0529\u052d\u0005z>\u0002\u052a\u052d",
    "\u0005~@\u0002\u052b\u052d\u0005|?\u0002\u052c\u0529\u0003\u0002\u0002",
    "\u0002\u052c\u052a\u0003\u0002\u0002\u0002\u052c\u052b\u0003\u0002\u0002",
    "\u0002\u052ds\u0003\u0002\u0002\u0002\u052e\u0531\u0005|?\u0002\u052f",
    "\u0531\u0005z>\u0002\u0530\u052e\u0003\u0002\u0002\u0002\u0530\u052f",
    "\u0003\u0002\u0002\u0002\u0531u\u0003\u0002\u0002\u0002\u0532\u0538",
    "\u0005z>\u0002\u0533\u0538\u0005~@\u0002\u0534\u0538\u0005\u0080A\u0002",
    "\u0535\u0538\u0005x=\u0002\u0536\u0538\u0005|?\u0002\u0537\u0532\u0003",
    "\u0002\u0002\u0002\u0537\u0533\u0003\u0002\u0002\u0002\u0537\u0534\u0003",
    "\u0002\u0002\u0002\u0537\u0535\u0003\u0002\u0002\u0002\u0537\u0536\u0003",
    "\u0002\u0002\u0002\u0538w\u0003\u0002\u0002\u0002\u0539\u053d\u0007",
    "u\u0002\u0002\u053a\u053d\u0005\u0082B\u0002\u053b\u053d\u0005\u0084",
    "C\u0002\u053c\u0539\u0003\u0002\u0002\u0002\u053c\u053a\u0003\u0002",
    "\u0002\u0002\u053c\u053b\u0003\u0002\u0002\u0002\u053dy\u0003\u0002",
    "\u0002\u0002\u053e\u0541\u0005\u00d4k\u0002\u053f\u0541\u0005\u0086",
    "D\u0002\u0540\u053e\u0003\u0002\u0002\u0002\u0540\u053f\u0003\u0002",
    "\u0002\u0002\u0541\u0543\u0003\u0002\u0002\u0002\u0542\u0544\u0005\u00a0",
    "Q\u0002\u0543\u0542\u0003\u0002\u0002\u0002\u0543\u0544\u0003\u0002",
    "\u0002\u0002\u0544\u0549\u0003\u0002\u0002\u0002\u0545\u0547\u0007)",
    "\u0002\u0002\u0546\u0545\u0003\u0002\u0002\u0002\u0546\u0547\u0003\u0002",
    "\u0002\u0002\u0547\u0548\u0003\u0002\u0002\u0002\u0548\u054a\u0007-",
    "\u0002\u0002\u0549\u0546\u0003\u0002\u0002\u0002\u0549\u054a\u0003\u0002",
    "\u0002\u0002\u054a{\u0003\u0002\u0002\u0002\u054b\u0550\u0005\u00c8",
    "e\u0002\u054c\u054d\u0007\n\u0002\u0002\u054d\u054e\u0005z>\u0002\u054e",
    "\u054f\u0007\u000b\u0002\u0002\u054f\u0551\u0003\u0002\u0002\u0002\u0550",
    "\u054c\u0003\u0002\u0002\u0002\u0550\u0551\u0003\u0002\u0002\u0002\u0551",
    "}\u0003\u0002\u0002\u0002\u0552\u055e\u0007o\u0002\u0002\u0553\u0554",
    "\u0007\u0007\u0002\u0002\u0554\u0559\u0005\u00a2R\u0002\u0555\u0556",
    "\u0007\u0013\u0002\u0002\u0556\u0558\u0005\u00a2R\u0002\u0557\u0555",
    "\u0003\u0002\u0002\u0002\u0558\u055b\u0003\u0002\u0002\u0002\u0559\u0557",
    "\u0003\u0002\u0002\u0002\u0559\u055a\u0003\u0002\u0002\u0002\u055a\u055c",
    "\u0003\u0002\u0002\u0002\u055b\u0559\u0003\u0002\u0002\u0002\u055c\u055d",
    "\u0007\b\u0002\u0002\u055d\u055f\u0003\u0002\u0002\u0002\u055e\u0553",
    "\u0003\u0002\u0002\u0002\u055e\u055f\u0003\u0002\u0002\u0002\u055f\u007f",
    "\u0003\u0002\u0002\u0002\u0560\u0565\u0007\u00e5\u0002\u0002\u0561\u0562",
    "\u0007\n\u0002\u0002\u0562\u0563\u0005z>\u0002\u0563\u0564\u0007\u000b",
    "\u0002\u0002\u0564\u0566\u0003\u0002\u0002\u0002\u0565\u0561\u0003\u0002",
    "\u0002\u0002\u0565\u0566\u0003\u0002\u0002\u0002\u0566\u0081\u0003\u0002",
    "\u0002\u0002\u0567\u0585\u0007s\u0002\u0002\u0568\u0574\u0007\u00e1",
    "\u0002\u0002\u0569\u056a\u0007\u0007\u0002\u0002\u056a\u056f\u0005\u0086",
    "D\u0002\u056b\u056c\u0007\u0011\u0002\u0002\u056c\u056e\u0005\u0086",
    "D\u0002\u056d\u056b\u0003\u0002\u0002\u0002\u056e\u0571\u0003\u0002",
    "\u0002\u0002\u056f\u056d\u0003\u0002\u0002\u0002\u056f\u0570\u0003\u0002",
    "\u0002\u0002\u0570\u0572\u0003\u0002\u0002\u0002\u0571\u056f\u0003\u0002",
    "\u0002\u0002\u0572\u0573\u0007\b\u0002\u0002\u0573\u0575\u0003\u0002",
    "\u0002\u0002\u0574\u0569\u0003\u0002\u0002\u0002\u0574\u0575\u0003\u0002",
    "\u0002\u0002\u0575\u0585\u0003\u0002\u0002\u0002\u0576\u0582\u0007\u00e2",
    "\u0002\u0002\u0577\u0578\u0007\u0007\u0002\u0002\u0578\u057d\u0005\u00b6",
    "\\\u0002\u0579\u057a\u0007\u0011\u0002\u0002\u057a\u057c\u0005\u00b6",
    "\\\u0002\u057b\u0579\u0003\u0002\u0002\u0002\u057c\u057f\u0003\u0002",
    "\u0002\u0002\u057d\u057b\u0003\u0002\u0002\u0002\u057d\u057e\u0003\u0002",
    "\u0002\u0002\u057e\u0580\u0003\u0002\u0002\u0002\u057f\u057d\u0003\u0002",
    "\u0002\u0002\u0580\u0581\u0007\b\u0002\u0002\u0581\u0583\u0003\u0002",
    "\u0002\u0002\u0582\u0577\u0003\u0002\u0002\u0002\u0582\u0583\u0003\u0002",
    "\u0002\u0002\u0583\u0585\u0003\u0002\u0002\u0002\u0584\u0567\u0003\u0002",
    "\u0002\u0002\u0584\u0568\u0003\u0002\u0002\u0002\u0584\u0576\u0003\u0002",
    "\u0002\u0002\u0585\u0083\u0003\u0002\u0002\u0002\u0586\u05af\u0007t",
    "\u0002\u0002\u0587\u0598\u0007\u00e3\u0002\u0002\u0588\u0589\u0007\u0007",
    "\u0002\u0002\u0589\u0595\u0007\u00eb\u0002\u0002\u058a\u058b\u0007\u0003",
    "\u0002\u0002\u058b\u0590\u0005\u0086D\u0002\u058c\u058d\u0007\u0011",
    "\u0002\u0002\u058d\u058f\u0005\u0086D\u0002\u058e\u058c\u0003\u0002",
    "\u0002\u0002\u058f\u0592\u0003\u0002\u0002\u0002\u0590\u058e\u0003\u0002",
    "\u0002\u0002\u0590\u0591\u0003\u0002\u0002\u0002\u0591\u0593\u0003\u0002",
    "\u0002\u0002\u0592\u0590\u0003\u0002\u0002\u0002\u0593\u0594\u0007\u0004",
    "\u0002\u0002\u0594\u0596\u0003\u0002\u0002\u0002\u0595\u058a\u0003\u0002",
    "\u0002\u0002\u0595\u0596\u0003\u0002\u0002\u0002\u0596\u0597\u0003\u0002",
    "\u0002\u0002\u0597\u0599\u0007\b\u0002\u0002\u0598\u0588\u0003\u0002",
    "\u0002\u0002\u0598\u0599\u0003\u0002\u0002\u0002\u0599\u05af\u0003\u0002",
    "\u0002\u0002\u059a\u05ac\u0007\u00e4\u0002\u0002\u059b\u059c\u0007\u0007",
    "\u0002\u0002\u059c\u05a8\u0005\u00b6\\\u0002\u059d\u059e\u0007\u0003",
    "\u0002\u0002\u059e\u05a3\u0005\u00b6\\\u0002\u059f\u05a0\u0007\u0011",
    "\u0002\u0002\u05a0\u05a2\u0005\u00b6\\\u0002\u05a1\u059f\u0003\u0002",
    "\u0002\u0002\u05a2\u05a5\u0003\u0002\u0002\u0002\u05a3\u05a1\u0003\u0002",
    "\u0002\u0002\u05a3\u05a4\u0003\u0002\u0002\u0002\u05a4\u05a6\u0003\u0002",
    "\u0002\u0002\u05a5\u05a3\u0003\u0002\u0002\u0002\u05a6\u05a7\u0007\u0004",
    "\u0002\u0002\u05a7\u05a9\u0003\u0002\u0002\u0002\u05a8\u059d\u0003\u0002",
    "\u0002\u0002\u05a8\u05a9\u0003\u0002\u0002\u0002\u05a9\u05aa\u0003\u0002",
    "\u0002\u0002\u05aa\u05ab\u0007\b\u0002\u0002\u05ab\u05ad\u0003\u0002",
    "\u0002\u0002\u05ac\u059b\u0003\u0002\u0002\u0002\u05ac\u05ad\u0003\u0002",
    "\u0002\u0002\u05ad\u05af\u0003\u0002\u0002\u0002\u05ae\u0586\u0003\u0002",
    "\u0002\u0002\u05ae\u0587\u0003\u0002\u0002\u0002\u05ae\u059a\u0003\u0002",
    "\u0002\u0002\u05af\u0085\u0003\u0002\u0002\u0002\u05b0\u05b1\u0007\u00eb",
    "\u0002\u0002\u05b1\u0087\u0003\u0002\u0002\u0002\u05b2\u05b3\u0007\u00eb",
    "\u0002\u0002\u05b3\u0089\u0003\u0002\u0002\u0002\u05b4\u05b5\t\u001a",
    "\u0002\u0002\u05b5\u05ba\u0005\u008cG\u0002\u05b6\u05b7\u0007\u0013",
    "\u0002\u0002\u05b7\u05b9\u0005\u008cG\u0002\u05b8\u05b6\u0003\u0002",
    "\u0002\u0002\u05b9\u05bc\u0003\u0002\u0002\u0002\u05ba\u05b8\u0003\u0002",
    "\u0002\u0002\u05ba\u05bb\u0003\u0002\u0002\u0002\u05bb\u008b\u0003\u0002",
    "\u0002\u0002\u05bc\u05ba\u0003\u0002\u0002\u0002\u05bd\u05c0\u0005\u00b6",
    "\\\u0002\u05be\u05bf\u0007%\u0002\u0002\u05bf\u05c1\u0005\u00b4[\u0002",
    "\u05c0\u05be\u0003\u0002\u0002\u0002\u05c0\u05c1\u0003\u0002\u0002\u0002",
    "\u05c1\u008d\u0003\u0002\u0002\u0002\u05c2\u05c7\u0005\u0090I\u0002",
    "\u05c3\u05c4\u0007\u00ed\u0002\u0002\u05c4\u05c6\u0005\u0090I\u0002",
    "\u05c5\u05c3\u0003\u0002\u0002\u0002\u05c6\u05c9\u0003\u0002\u0002\u0002",
    "\u05c7\u05c5\u0003\u0002\u0002\u0002\u05c7\u05c8\u0003\u0002\u0002\u0002",
    "\u05c8\u008f\u0003\u0002\u0002\u0002\u05c9\u05c7\u0003\u0002\u0002\u0002",
    "\u05ca\u05cb\u0007\u00eb\u0002\u0002\u05cb\u05cd\u0007\u0017\u0002\u0002",
    "\u05cc\u05ca\u0003\u0002\u0002\u0002\u05cc\u05cd\u0003\u0002\u0002\u0002",
    "\u05cd\u05d2\u0003\u0002\u0002\u0002\u05ce\u05cf\u0007\u00af\u0002\u0002",
    "\u05cf\u05d0\u0005\b\u0005\u0002\u05d0\u05d1\u0007\u001a\u0002\u0002",
    "\u05d1\u05d3\u0003\u0002\u0002\u0002\u05d2\u05ce\u0003\u0002\u0002\u0002",
    "\u05d2\u05d3\u0003\u0002\u0002\u0002\u05d3\u05d4\u0003\u0002\u0002\u0002",
    "\u05d4\u05d6\u0005\b\u0005\u0002\u05d5\u05d7\u0005\u00be`\u0002\u05d6",
    "\u05d5\u0003\u0002\u0002\u0002\u05d6\u05d7\u0003\u0002\u0002\u0002\u05d7",
    "\u05d9\u0003\u0002\u0002\u0002\u05d8\u05da\u0005\u00c0a\u0002\u05d9",
    "\u05d8\u0003\u0002\u0002\u0002\u05d9\u05da\u0003\u0002\u0002\u0002\u05da",
    "\u0091\u0003\u0002\u0002\u0002\u05db\u05e0\u0005\u0094K\u0002\u05dc",
    "\u05dd\u0007\u00ed\u0002\u0002\u05dd\u05df\u0005\u0094K\u0002\u05de",
    "\u05dc\u0003\u0002\u0002\u0002\u05df\u05e2\u0003\u0002\u0002\u0002\u05e0",
    "\u05de\u0003\u0002\u0002\u0002\u05e0\u05e1\u0003\u0002\u0002\u0002\u05e1",
    "\u0093\u0003\u0002\u0002\u0002\u05e2\u05e0\u0003\u0002\u0002\u0002\u05e3",
    "\u05e4\u0007\u00eb\u0002\u0002\u05e4\u05e6\u0007\u0017\u0002\u0002\u05e5",
    "\u05e3\u0003\u0002\u0002\u0002\u05e5\u05e6\u0003\u0002\u0002\u0002\u05e6",
    "\u05e7\u0003\u0002\u0002\u0002\u05e7\u05e9\u0005\u009aN\u0002\u05e8",
    "\u05ea\u0005\u00be`\u0002\u05e9\u05e8\u0003\u0002\u0002\u0002\u05e9",
    "\u05ea\u0003\u0002\u0002\u0002\u05ea\u05ec\u0003\u0002\u0002\u0002\u05eb",
    "\u05ed\u0005\u00c0a\u0002\u05ec\u05eb\u0003\u0002\u0002\u0002\u05ec",
    "\u05ed\u0003\u0002\u0002\u0002\u05ed\u0095\u0003\u0002\u0002\u0002\u05ee",
    "\u05f1\t\u001a\u0002\u0002\u05ef\u05f0\u0007\u009d\u0002\u0002\u05f0",
    "\u05f2\u0005\u0098M\u0002\u05f1\u05ef\u0003\u0002\u0002\u0002\u05f1",
    "\u05f2\u0003\u0002\u0002\u0002\u05f2\u05f3\u0003\u0002\u0002\u0002\u05f3",
    "\u05f4\u0007v\u0002\u0002\u05f4\u05f5\u0007\u00eb\u0002\u0002\u05f5",
    "\u0097\u0003\u0002\u0002\u0002\u05f6\u05fb\u0005\u008cG\u0002\u05f7",
    "\u05f8\u0007\u0013\u0002\u0002\u05f8\u05fa\u0005\u008cG\u0002\u05f9",
    "\u05f7\u0003\u0002\u0002\u0002\u05fa\u05fd\u0003\u0002\u0002\u0002\u05fb",
    "\u05f9\u0003\u0002\u0002\u0002\u05fb\u05fc\u0003\u0002\u0002\u0002\u05fc",
    "\u0099\u0003\u0002\u0002\u0002\u05fd\u05fb\u0003\u0002\u0002\u0002\u05fe",
    "\u05ff\u0007\u00af\u0002\u0002\u05ff\u0600\u0005\b\u0005\u0002\u0600",
    "\u0601\u0007\u001a\u0002\u0002\u0601\u0603\u0003\u0002\u0002\u0002\u0602",
    "\u05fe\u0003\u0002\u0002\u0002\u0602\u0603\u0003\u0002\u0002\u0002\u0603",
    "\u0604\u0003\u0002\u0002\u0002\u0604\u0606\u0005\u009eP\u0002\u0605",
    "\u0607\u0005\u00c2b\u0002\u0606\u0605\u0003\u0002\u0002\u0002\u0606",
    "\u0607\u0003\u0002\u0002\u0002\u0607\u0608\u0003\u0002\u0002\u0002\u0608",
    "\u060c\u0005\u009cO\u0002\u0609\u060b\u0005\u009cO\u0002\u060a\u0609",
    "\u0003\u0002\u0002\u0002\u060b\u060e\u0003\u0002\u0002\u0002\u060c\u060a",
    "\u0003\u0002\u0002\u0002\u060c\u060d\u0003\u0002\u0002\u0002\u060d\u009b",
    "\u0003\u0002\u0002\u0002\u060e\u060c\u0003\u0002\u0002\u0002\u060f\u0611",
    "\t\u001b\u0002\u0002\u0610\u060f\u0003\u0002\u0002\u0002\u0610\u0611",
    "\u0003\u0002\u0002\u0002\u0611\u0612\u0003\u0002\u0002\u0002\u0612\u0617",
    "\u0005\u009eP\u0002\u0613\u0614\u0007\u0005\u0002\u0002\u0614\u0615",
    "\u0005\b\u0005\u0002\u0615\u0616\u0007\u0006\u0002\u0002\u0616\u0618",
    "\u0003\u0002\u0002\u0002\u0617\u0613\u0003\u0002\u0002\u0002\u0617\u0618",
    "\u0003\u0002\u0002\u0002\u0618\u009d\u0003\u0002\u0002\u0002\u0619\u061a",
    "\t\u001c\u0002\u0002\u061a\u009f\u0003\u0002\u0002\u0002\u061b\u061c",
    "\u0007\u0005\u0002\u0002\u061c\u061d\u0005\b\u0005\u0002\u061d\u061e",
    "\u0007\u0006\u0002\u0002\u061e\u062b\u0003\u0002\u0002\u0002\u061f\u0620",
    "\u0007\u0007\u0002\u0002\u0620\u0625\u0005\u00d2j\u0002\u0621\u0622",
    "\u0007\u0013\u0002\u0002\u0622\u0624\u0005\u00d2j\u0002\u0623\u0621",
    "\u0003\u0002\u0002\u0002\u0624\u0627\u0003\u0002\u0002\u0002\u0625\u0623",
    "\u0003\u0002\u0002\u0002\u0625\u0626\u0003\u0002\u0002\u0002\u0626\u0628",
    "\u0003\u0002\u0002\u0002\u0627\u0625\u0003\u0002\u0002\u0002\u0628\u0629",
    "\u0007\b\u0002\u0002\u0629\u062b\u0003\u0002\u0002\u0002\u062a\u061b",
    "\u0003\u0002\u0002\u0002\u062a\u061f\u0003\u0002\u0002\u0002\u062b\u00a1",
    "\u0003\u0002\u0002\u0002\u062c\u062f\u0005|?\u0002\u062d\u0630\u0005",
    "\u00ba^\u0002\u062e\u0630\u0005\u00a4S\u0002\u062f\u062d\u0003\u0002",
    "\u0002\u0002\u062f\u062e\u0003\u0002\u0002\u0002\u0630\u00a3\u0003\u0002",
    "\u0002\u0002\u0631\u0633\u0007i\u0002\u0002\u0632\u0634\t\u001d\u0002",
    "\u0002\u0633\u0632\u0003\u0002\u0002\u0002\u0633\u0634\u0003\u0002\u0002",
    "\u0002\u0634\u00a5\u0003\u0002\u0002\u0002\u0635\u0636\t\u001e\u0002",
    "\u0002\u0636\u00a7\u0003\u0002\u0002\u0002\u0637\u0638\t\u001f\u0002",
    "\u0002\u0638\u00a9\u0003\u0002\u0002\u0002\u0639\u063a\u0007\u009d\u0002",
    "\u0002\u063a\u063f\u0005\u00ba^\u0002\u063b\u063c\u0007\u0013\u0002",
    "\u0002\u063c\u063e\u0005\u00ba^\u0002\u063d\u063b\u0003\u0002\u0002",
    "\u0002\u063e\u0641\u0003\u0002\u0002\u0002\u063f\u063d\u0003\u0002\u0002",
    "\u0002\u063f\u0640\u0003\u0002\u0002\u0002\u0640\u00ab\u0003\u0002\u0002",
    "\u0002\u0641\u063f\u0003\u0002\u0002\u0002\u0642\u0643\t \u0002\u0002",
    "\u0643\u00ad\u0003\u0002\u0002\u0002\u0644\u0645\u0007<\u0002\u0002",
    "\u0645\u0646\u0005\u0006\u0004\u0002\u0646\u00af\u0003\u0002\u0002\u0002",
    "\u0647\u0648\t!\u0002\u0002\u0648\u00b1\u0003\u0002\u0002\u0002\u0649",
    "\u064a\t\"\u0002\u0002\u064a\u00b3\u0003\u0002\u0002\u0002\u064b\u064c",
    "\u0007\u00eb\u0002\u0002\u064c\u00b5\u0003\u0002\u0002\u0002\u064d\u064e",
    "\u0007\u00eb\u0002\u0002\u064e\u00b7\u0003\u0002\u0002\u0002\u064f\u0650",
    "\u0007\u00eb\u0002\u0002\u0650\u00b9\u0003\u0002\u0002\u0002\u0651\u0654",
    "\u0007\u00eb\u0002\u0002\u0652\u0653\u0007\u0016\u0002\u0002\u0653\u0655",
    "\u0007\u00eb\u0002\u0002\u0654\u0652\u0003\u0002\u0002\u0002\u0654\u0655",
    "\u0003\u0002\u0002\u0002\u0655\u00bb\u0003\u0002\u0002\u0002\u0656\u0657",
    "\u0007\u0007\u0002\u0002\u0657\u065c\u0005\u00d2j\u0002\u0658\u0659",
    "\u0007\u0013\u0002\u0002\u0659\u065b\u0005\u00d2j\u0002\u065a\u0658",
    "\u0003\u0002\u0002\u0002\u065b\u065e\u0003\u0002\u0002\u0002\u065c\u065a",
    "\u0003\u0002\u0002\u0002\u065c\u065d\u0003\u0002\u0002\u0002\u065d\u065f",
    "\u0003\u0002\u0002\u0002\u065e\u065c\u0003\u0002\u0002\u0002\u065f\u0660",
    "\u0007\b\u0002\u0002\u0660\u0663\u0003\u0002\u0002\u0002\u0661\u0663",
    "\u0005\u00ccg\u0002\u0662\u0656\u0003\u0002\u0002\u0002\u0662\u0661",
    "\u0003\u0002\u0002\u0002\u0663\u00bd\u0003\u0002\u0002\u0002\u0664\u0665",
    "\u0007=\u0002\u0002\u0665\u0666\u0005\u00d2j\u0002\u0666\u00bf\u0003",
    "\u0002\u0002\u0002\u0667\u0668\u0007@\u0002\u0002\u0668\u0669\u0005",
    "\u00d2j\u0002\u0669\u00c1\u0003\u0002\u0002\u0002\u066a\u066b\t#\u0002",
    "\u0002\u066b\u00c3\u0003\u0002\u0002\u0002\u066c\u066f\u0005\u0006\u0004",
    "\u0002\u066d\u066f\u0007i\u0002\u0002\u066e\u066c\u0003\u0002\u0002",
    "\u0002\u066e\u066d\u0003\u0002\u0002\u0002\u066f\u00c5\u0003\u0002\u0002",
    "\u0002\u0670\u0673\u0005\b\u0005\u0002\u0671\u0673\u0007i\u0002\u0002",
    "\u0672\u0670\u0003\u0002\u0002\u0002\u0672\u0671\u0003\u0002\u0002\u0002",
    "\u0673\u00c7\u0003\u0002\u0002\u0002\u0674\u067a\u0007^\u0002\u0002",
    "\u0675\u067a\u0007\u00e0\u0002\u0002\u0676\u067a\u0007]\u0002\u0002",
    "\u0677\u067a\u0007_\u0002\u0002\u0678\u067a\u0005\u00caf\u0002\u0679",
    "\u0674\u0003\u0002\u0002\u0002\u0679\u0675\u0003\u0002\u0002\u0002\u0679",
    "\u0676\u0003\u0002\u0002\u0002\u0679\u0677\u0003\u0002\u0002\u0002\u0679",
    "\u0678\u0003\u0002\u0002\u0002\u067a\u00c9\u0003\u0002\u0002\u0002\u067b",
    "\u067c\u0007d\u0002\u0002\u067c\u067d\u0007_\u0002\u0002\u067d\u00cb",
    "\u0003\u0002\u0002\u0002\u067e\u067f\u0007\u00eb\u0002\u0002\u067f\u00cd",
    "\u0003\u0002\u0002\u0002\u0680\u0681\u0007\u00eb\u0002\u0002\u0681\u00cf",
    "\u0003\u0002\u0002\u0002\u0682\u0683\u0007\u00eb\u0002\u0002\u0683\u00d1",
    "\u0003\u0002\u0002\u0002\u0684\u0685\t$\u0002\u0002\u0685\u00d3\u0003",
    "\u0002\u0002\u0002\u0686\u0687\t%\u0002\u0002\u0687\u00d5\u0003\u0002",
    "\u0002\u0002\u0688\u0689\t&\u0002\u0002\u0689\u00d7\u0003\u0002\u0002",
    "\u0002\u00bd\u00dd\u00eb\u00fe\u011b\u011d\u0131\u0146\u0148\u0153\u0161",
    "\u016a\u0172\u0179\u017b\u0186\u018f\u019d\u01ac\u01b7\u01ba\u01bf\u01e0",
    "\u01e9\u01ec\u01f6\u01fb\u01ff\u0205\u0209\u0213\u0217\u021b\u0224\u0227",
    "\u0231\u0235\u023f\u0244\u0248\u024e\u0252\u0256\u025b\u0260\u0270\u0274",
    "\u027f\u028a\u028e\u0292\u02a2\u02a6\u02b1\u02bc\u02c0\u02c4\u02d0\u02db",
    "\u02e7\u02f2\u0310\u0314\u032b\u0330\u0338\u034d\u0351\u0355\u035b\u0360",
    "\u0368\u037d\u0381\u0385\u038b\u0394\u039f\u03aa\u03b2\u03b6\u03b9\u03bc",
    "\u03bf\u03ce\u03d1\u03d4\u03de\u03e2\u03e5\u03e8\u03eb\u03f3\u03f6\u03f9",
    "\u03fc\u0400\u0418\u041f\u0421\u042b\u042e\u0431\u043c\u043e\u0443\u0453",
    "\u045b\u045e\u0461\u046c\u046e\u0473\u047f\u048f\u049a\u049e\u04a5\u04b4",
    "\u04bc\u04c5\u04c8\u04cd\u04d0\u04d5\u04d8\u04db\u04e7\u04f1\u04f6\u04fb",
    "\u050f\u0518\u051e\u0527\u052c\u0530\u0537\u053c\u0540\u0543\u0546\u0549",
    "\u0550\u0559\u055e\u0565\u056f\u0574\u057d\u0582\u0584\u0590\u0595\u0598",
    "\u05a3\u05a8\u05ac\u05ae\u05ba\u05c0\u05c7\u05cc\u05d2\u05d6\u05d9\u05e0",
    "\u05e5\u05e9\u05ec\u05f1\u05fb\u0602\u0606\u060c\u0610\u0617\u0625\u062a",
    "\u062f\u0633\u063f\u0654\u065c\u0662\u066e\u0672\u0679"].join("");


var atn = new antlr4.atn.ATNDeserializer().deserialize(serializedATN);

var decisionsToDFA = atn.decisionToState.map( function(ds, index) { return new antlr4.dfa.DFA(ds, index); });

var sharedContextCache = new antlr4.PredictionContextCache();

var literalNames = [ null, "'('", "')'", "'['", "']'", "'{'", "'}'", "'='", 
                     "'<'", "'>'", "'>='", "'<>'", "'<='", "'+'", "'-'", 
                     "'*'", "'/'", "','", "'->'", "':='", "'#'", "':'", 
                     "'eval'", "'if'", "'then'", "'else'", "'using'", "'with'", 
                     "'current_date'", "'on'", "'drop'", "'keep'", "'calc'", 
                     "'attrcalc'", "'rename'", "'as'", "'and'", "'or'", 
                     "'xor'", "'not'", "'between'", "'in'", "'not_in'", 
                     "'null'", "'isnull'", "'ex'", "'union'", "'diff'", 
                     "'symdiff'", "'intersect'", "'keys'", "'intyear'", 
                     "'intmonth'", "'intday'", "'check'", "'exists_in'", 
                     "'to'", "'return'", "'imbalance'", "'errorcode'", "'all'", 
                     "'aggr'", "'errorlevel'", "'order'", "'by'", "'rank'", 
                     "'asc'", "'desc'", "'min'", "'max'", "'first'", "'last'", 
                     "'indexof'", "'abs'", "'key'", "'ln'", "'log'", "'trunc'", 
                     "'round'", "'power'", "'mod'", "'length'", "'||'", 
                     "'trim'", "'upper'", "'lower'", "'substr'", "'sum'", 
                     "'avg'", "'median'", "'count'", "'identifier'", "'measure'", 
                     "'attribute'", "'filter'", "'merge'", "'exp'", "'componentRole'", 
                     "'viral'", "'match_characters'", "'type'", "'nvl'", 
                     "'hierarchy'", "'_'", "'invalid'", "'valuedomain'", 
                     "'variable'", "'data'", "'structure'", "'dataset'", 
                     "'operator'", "'define'", "'<-'", "'datapoint'", "'hierarchical'", 
                     "'ruleset'", "'rule'", "'end'", "'alterDataset'", "'ltrim'", 
                     "'rtrim'", "'instr'", "'replace'", "'ceil'", "'floor'", 
                     "'sqrt'", "'any'", "'setdiff'", "'stddev_pop'", "'stddev_samp'", 
                     "'var_pop'", "'var_samp'", "'group'", "'except'", "'having'", 
                     "'first_value'", "'last_value'", "'lag'", "'lead'", 
                     "'ratio_to_report'", "'over'", "'preceding'", "'following'", 
                     "'unbounded'", "'partition'", "'rows'", "'range'", 
                     "'current'", "'valid'", "'fill_time_series'", "'flow_to_stock'", 
                     "'stock_to_flow'", "'timeshift'", "'measures'", "'no_measures'", 
                     "'condition'", "'boolean'", "'date'", "'time_period'", 
                     "'number'", "'string'", "'time'", "'integer'", "'float'", 
                     "'list'", "'record'", "'restrict'", "'yyyy'", "'mm'", 
                     "'dd'", "'maxLength'", "'regexp'", "'is'", "'when'", 
                     "'from'", "'aggregates'", "'points'", "'point'", "'total'", 
                     "'partial'", "'always'", "'inner_join'", "'left_join'", 
                     "'cross_join'", "'full_join'", "'maps_from'", "'maps_to'", 
                     "'map_to'", "'map_from'", "'returns'", "'pivot'", "'customPivot'", 
                     "'unpivot'", "'sub'", "'apply'", "'conditioned'", "'period_indicator'", 
                     "'single'", "'duration'", "'time_agg'", "'unit'", "'Value'", 
                     "'valuedomains'", "'variables'", "'input'", "'output'", 
                     "'cast'", "'rule_priority'", "'dataset_priority'", 
                     "'default'", "'check_datapoint'", "'check_hierarchy'", 
                     "'computed'", "'non_null'", "'non_zero'", "'partial_null'", 
                     "'partial_zero'", "'always_null'", "'always_zero'", 
                     "'components'", "'all_measures'", "'scalar'", "'component'", 
                     "'datapoint_on_valuedomains'", "'datapoint_on_variables'", 
                     "'hierarchical_on_valuedomains'", "'hierarchical_on_variables'", 
                     "'set'", "'language'", null, null, null, null, null, 
                     null, "';'" ];

var symbolicNames = [ null, "LPAREN", "RPAREN", "QLPAREN", "QRPAREN", "GLPAREN", 
                      "GRPAREN", "EQ", "LT", "MT", "ME", "NEQ", "LE", "PLUS", 
                      "MINUS", "MUL", "DIV", "COMMA", "POINTER", "ASSIGN", 
                      "MEMBERSHIP", "COLON", "EVAL", "IF", "THEN", "ELSE", 
                      "USING", "WITH", "CURRENT_DATE", "ON", "DROP", "KEEP", 
                      "CALC", "ATTRCALC", "RENAME", "AS", "AND", "OR", "XOR", 
                      "NOT", "BETWEEN", "IN", "NOT_IN", "NULL_CONSTANT", 
                      "ISNULL", "EX", "UNION", "DIFF", "SYMDIFF", "INTERSECT", 
                      "KEYS", "INTYEAR", "INTMONTH", "INTDAY", "CHECK", 
                      "EXISTS_IN", "TO", "RETURN", "IMBALANCE", "ERRORCODE", 
                      "ALL", "AGGREGATE", "ERRORLEVEL", "ORDER", "BY", "RANK", 
                      "ASC", "DESC", "MIN", "MAX", "FIRST", "LAST", "INDEXOF", 
                      "ABS", "KEY", "LN", "LOG", "TRUNC", "ROUND", "POWER", 
                      "MOD", "LEN", "CONCAT", "TRIM", "UCASE", "LCASE", 
                      "SUBSTR", "SUM", "AVG", "MEDIAN", "COUNT", "DIMENSION", 
                      "MEASURE", "ATTRIBUTE", "FILTER", "MERGE", "EXP", 
                      "ROLE", "VIRAL", "CHARSET_MATCH", "TYPE", "NVL", "HIERARCHY", 
                      "OPTIONAL", "INVALID", "VALUE_DOMAIN", "VARIABLE", 
                      "DATA", "STRUCTURE", "DATASET", "OPERATOR", "DEFINE", 
                      "PUT_SYMBOL", "DATAPOINT", "HIERARCHICAL", "RULESET", 
                      "RULE", "END", "ALTER_DATASET", "LTRIM", "RTRIM", 
                      "INSTR", "REPLACE", "CEIL", "FLOOR", "SQRT", "ANY", 
                      "SETDIFF", "STDDEV_POP", "STDDEV_SAMP", "VAR_POP", 
                      "VAR_SAMP", "GROUP", "EXCEPT", "HAVING", "FIRST_VALUE", 
                      "LAST_VALUE", "LAG", "LEAD", "RATIO_TO_REPORT", "OVER", 
                      "PRECEDING", "FOLLOWING", "UNBOUNDED", "PARTITION", 
                      "ROWS", "RANGE", "CURRENT", "VALID", "FILL_TIME_SERIES", 
                      "FLOW_TO_STOCK", "STOCK_TO_FLOW", "TIMESHIFT", "MEASURES", 
                      "NO_MEASURES", "CONDITION", "BOOLEAN", "DATE", "TIME_PERIOD", 
                      "NUMBER", "STRING", "TIME", "INTEGER", "FLOAT", "LIST", 
                      "RECORD", "RESTRICT", "YYYY", "MM", "DD", "MAX_LENGTH", 
                      "REGEXP", "IS", "WHEN", "FROM", "AGGREGATES", "POINTS", 
                      "POINT", "TOTAL", "PARTIAL", "ALWAYS", "INNER_JOIN", 
                      "LEFT_JOIN", "CROSS_JOIN", "FULL_JOIN", "MAPS_FROM", 
                      "MAPS_TO", "MAP_TO", "MAP_FROM", "RETURNS", "PIVOT", 
                      "CUSTOMPIVOT", "UNPIVOT", "SUBSPACE", "APPLY", "CONDITIONED", 
                      "PERIOD_INDICATOR", "SINGLE", "DURATION", "TIME_AGG", 
                      "UNIT", "VALUE", "VALUEDOMAINS", "VARIABLES", "INPUT", 
                      "OUTPUT", "CAST", "RULE_PRIORITY", "DATASET_PRIORITY", 
                      "DEFAULT", "CHECK_DATAPOINT", "CHECK_HIERARCHY", "COMPUTED", 
                      "NON_NULL", "NON_ZERO", "PARTIAL_NULL", "PARTIAL_ZERO", 
                      "ALWAYS_NULL", "ALWAYS_ZERO", "COMPONENTS", "ALL_MEASURES", 
                      "SCALAR", "COMPONENT", "DATAPOINT_ON_VD", "DATAPOINT_ON_VAR", 
                      "HIERARCHICAL_ON_VD", "HIERARCHICAL_ON_VAR", "SET", 
                      "LANGUAGE", "INTEGER_CONSTANT", "NUMBER_CONSTANT", 
                      "BOOLEAN_CONSTANT", "STRING_CONSTANT", "IDENTIFIER", 
                      "WS", "EOL", "ML_COMMENT", "SL_COMMENT" ];

var ruleNames =  [ "start", "statement", "expr", "exprComponent", "functionsComponents", 
                   "functions", "datasetClause", "renameClause", "aggrClause", 
                   "filterClause", "calcClause", "keepOrDropClause", "pivotOrUnpivotClause", 
                   "subspaceClause", "joinOperators", "defOperators", "genericOperators", 
                   "genericOperatorsComponent", "parameterComponent", "parameter", 
                   "stringOperators", "stringOperatorsComponent", "numericOperators", 
                   "numericOperatorsComponent", "comparisonOperators", "comparisonOperatorsComponent", 
                   "timeOperators", "timeOperatorsComponent", "setOperators", 
                   "hierarchyOperators", "validationOperators", "conditionalOperators", 
                   "conditionalOperatorsComponent", "aggrOperators", "aggrOperatorsGrouping", 
                   "anFunction", "anFunctionComponent", "renameClauseItem", 
                   "aggregateClause", "aggrFunctionClause", "calcClauseItem", 
                   "subspaceClauseItem", "joinClauseWithoutUsing", "joinClause", 
                   "joinClauseItem", "joinBody", "joinApplyClause", "partitionByClause", 
                   "orderByClause", "orderByItem", "windowingClause", "signedInteger", 
                   "limitClauseItem", "groupingClause", "havingClause", 
                   "parameterItem", "outputParameterType", "outputParameterTypeComponent", 
                   "inputParameterType", "rulesetType", "scalarType", "componentType", 
                   "datasetType", "scalarSetType", "dpRuleset", "hrRuleset", 
                   "valueDomainName", "rulesetID", "rulesetSignature", "signature", 
                   "ruleClauseDatapoint", "ruleItemDatapoint", "ruleClauseHierarchical", 
                   "ruleItemHierarchical", "hierRuleSignature", "valueDomainSignature", 
                   "codeItemRelation", "codeItemRelationClause", "valueDomainValue", 
                   "scalarTypeConstraint", "compConstraint", "multModifier", 
                   "validationOutput", "validationMode", "conditionClause", 
                   "inputMode", "imbalanceExpr", "inputModeHierarchy", "outputModeHierarchy", 
                   "alias", "varID", "simpleComponentId", "componentID", 
                   "inexpr", "erCode", "erLevel", "comparisonOperand", "optionalExpr", 
                   "optionalExprComponent", "componentRole", "viralAttribute", 
                   "valueDomainID", "operatorID", "routineName", "constant", 
                   "basicScalarType", "retainType" ];

function VtlParser (input) {
	antlr4.Parser.call(this, input);
    this._interp = new antlr4.atn.ParserATNSimulator(this, atn, decisionsToDFA, sharedContextCache);
    this.ruleNames = ruleNames;
    this.literalNames = literalNames;
    this.symbolicNames = symbolicNames;
    return this;
}

VtlParser.prototype = Object.create(antlr4.Parser.prototype);
VtlParser.prototype.constructor = VtlParser;

Object.defineProperty(VtlParser.prototype, "atn", {
	get : function() {
		return atn;
	}
});

VtlParser.EOF = antlr4.Token.EOF;
VtlParser.LPAREN = 1;
VtlParser.RPAREN = 2;
VtlParser.QLPAREN = 3;
VtlParser.QRPAREN = 4;
VtlParser.GLPAREN = 5;
VtlParser.GRPAREN = 6;
VtlParser.EQ = 7;
VtlParser.LT = 8;
VtlParser.MT = 9;
VtlParser.ME = 10;
VtlParser.NEQ = 11;
VtlParser.LE = 12;
VtlParser.PLUS = 13;
VtlParser.MINUS = 14;
VtlParser.MUL = 15;
VtlParser.DIV = 16;
VtlParser.COMMA = 17;
VtlParser.POINTER = 18;
VtlParser.ASSIGN = 19;
VtlParser.MEMBERSHIP = 20;
VtlParser.COLON = 21;
VtlParser.EVAL = 22;
VtlParser.IF = 23;
VtlParser.THEN = 24;
VtlParser.ELSE = 25;
VtlParser.USING = 26;
VtlParser.WITH = 27;
VtlParser.CURRENT_DATE = 28;
VtlParser.ON = 29;
VtlParser.DROP = 30;
VtlParser.KEEP = 31;
VtlParser.CALC = 32;
VtlParser.ATTRCALC = 33;
VtlParser.RENAME = 34;
VtlParser.AS = 35;
VtlParser.AND = 36;
VtlParser.OR = 37;
VtlParser.XOR = 38;
VtlParser.NOT = 39;
VtlParser.BETWEEN = 40;
VtlParser.IN = 41;
VtlParser.NOT_IN = 42;
VtlParser.NULL_CONSTANT = 43;
VtlParser.ISNULL = 44;
VtlParser.EX = 45;
VtlParser.UNION = 46;
VtlParser.DIFF = 47;
VtlParser.SYMDIFF = 48;
VtlParser.INTERSECT = 49;
VtlParser.KEYS = 50;
VtlParser.INTYEAR = 51;
VtlParser.INTMONTH = 52;
VtlParser.INTDAY = 53;
VtlParser.CHECK = 54;
VtlParser.EXISTS_IN = 55;
VtlParser.TO = 56;
VtlParser.RETURN = 57;
VtlParser.IMBALANCE = 58;
VtlParser.ERRORCODE = 59;
VtlParser.ALL = 60;
VtlParser.AGGREGATE = 61;
VtlParser.ERRORLEVEL = 62;
VtlParser.ORDER = 63;
VtlParser.BY = 64;
VtlParser.RANK = 65;
VtlParser.ASC = 66;
VtlParser.DESC = 67;
VtlParser.MIN = 68;
VtlParser.MAX = 69;
VtlParser.FIRST = 70;
VtlParser.LAST = 71;
VtlParser.INDEXOF = 72;
VtlParser.ABS = 73;
VtlParser.KEY = 74;
VtlParser.LN = 75;
VtlParser.LOG = 76;
VtlParser.TRUNC = 77;
VtlParser.ROUND = 78;
VtlParser.POWER = 79;
VtlParser.MOD = 80;
VtlParser.LEN = 81;
VtlParser.CONCAT = 82;
VtlParser.TRIM = 83;
VtlParser.UCASE = 84;
VtlParser.LCASE = 85;
VtlParser.SUBSTR = 86;
VtlParser.SUM = 87;
VtlParser.AVG = 88;
VtlParser.MEDIAN = 89;
VtlParser.COUNT = 90;
VtlParser.DIMENSION = 91;
VtlParser.MEASURE = 92;
VtlParser.ATTRIBUTE = 93;
VtlParser.FILTER = 94;
VtlParser.MERGE = 95;
VtlParser.EXP = 96;
VtlParser.ROLE = 97;
VtlParser.VIRAL = 98;
VtlParser.CHARSET_MATCH = 99;
VtlParser.TYPE = 100;
VtlParser.NVL = 101;
VtlParser.HIERARCHY = 102;
VtlParser.OPTIONAL = 103;
VtlParser.INVALID = 104;
VtlParser.VALUE_DOMAIN = 105;
VtlParser.VARIABLE = 106;
VtlParser.DATA = 107;
VtlParser.STRUCTURE = 108;
VtlParser.DATASET = 109;
VtlParser.OPERATOR = 110;
VtlParser.DEFINE = 111;
VtlParser.PUT_SYMBOL = 112;
VtlParser.DATAPOINT = 113;
VtlParser.HIERARCHICAL = 114;
VtlParser.RULESET = 115;
VtlParser.RULE = 116;
VtlParser.END = 117;
VtlParser.ALTER_DATASET = 118;
VtlParser.LTRIM = 119;
VtlParser.RTRIM = 120;
VtlParser.INSTR = 121;
VtlParser.REPLACE = 122;
VtlParser.CEIL = 123;
VtlParser.FLOOR = 124;
VtlParser.SQRT = 125;
VtlParser.ANY = 126;
VtlParser.SETDIFF = 127;
VtlParser.STDDEV_POP = 128;
VtlParser.STDDEV_SAMP = 129;
VtlParser.VAR_POP = 130;
VtlParser.VAR_SAMP = 131;
VtlParser.GROUP = 132;
VtlParser.EXCEPT = 133;
VtlParser.HAVING = 134;
VtlParser.FIRST_VALUE = 135;
VtlParser.LAST_VALUE = 136;
VtlParser.LAG = 137;
VtlParser.LEAD = 138;
VtlParser.RATIO_TO_REPORT = 139;
VtlParser.OVER = 140;
VtlParser.PRECEDING = 141;
VtlParser.FOLLOWING = 142;
VtlParser.UNBOUNDED = 143;
VtlParser.PARTITION = 144;
VtlParser.ROWS = 145;
VtlParser.RANGE = 146;
VtlParser.CURRENT = 147;
VtlParser.VALID = 148;
VtlParser.FILL_TIME_SERIES = 149;
VtlParser.FLOW_TO_STOCK = 150;
VtlParser.STOCK_TO_FLOW = 151;
VtlParser.TIMESHIFT = 152;
VtlParser.MEASURES = 153;
VtlParser.NO_MEASURES = 154;
VtlParser.CONDITION = 155;
VtlParser.BOOLEAN = 156;
VtlParser.DATE = 157;
VtlParser.TIME_PERIOD = 158;
VtlParser.NUMBER = 159;
VtlParser.STRING = 160;
VtlParser.TIME = 161;
VtlParser.INTEGER = 162;
VtlParser.FLOAT = 163;
VtlParser.LIST = 164;
VtlParser.RECORD = 165;
VtlParser.RESTRICT = 166;
VtlParser.YYYY = 167;
VtlParser.MM = 168;
VtlParser.DD = 169;
VtlParser.MAX_LENGTH = 170;
VtlParser.REGEXP = 171;
VtlParser.IS = 172;
VtlParser.WHEN = 173;
VtlParser.FROM = 174;
VtlParser.AGGREGATES = 175;
VtlParser.POINTS = 176;
VtlParser.POINT = 177;
VtlParser.TOTAL = 178;
VtlParser.PARTIAL = 179;
VtlParser.ALWAYS = 180;
VtlParser.INNER_JOIN = 181;
VtlParser.LEFT_JOIN = 182;
VtlParser.CROSS_JOIN = 183;
VtlParser.FULL_JOIN = 184;
VtlParser.MAPS_FROM = 185;
VtlParser.MAPS_TO = 186;
VtlParser.MAP_TO = 187;
VtlParser.MAP_FROM = 188;
VtlParser.RETURNS = 189;
VtlParser.PIVOT = 190;
VtlParser.CUSTOMPIVOT = 191;
VtlParser.UNPIVOT = 192;
VtlParser.SUBSPACE = 193;
VtlParser.APPLY = 194;
VtlParser.CONDITIONED = 195;
VtlParser.PERIOD_INDICATOR = 196;
VtlParser.SINGLE = 197;
VtlParser.DURATION = 198;
VtlParser.TIME_AGG = 199;
VtlParser.UNIT = 200;
VtlParser.VALUE = 201;
VtlParser.VALUEDOMAINS = 202;
VtlParser.VARIABLES = 203;
VtlParser.INPUT = 204;
VtlParser.OUTPUT = 205;
VtlParser.CAST = 206;
VtlParser.RULE_PRIORITY = 207;
VtlParser.DATASET_PRIORITY = 208;
VtlParser.DEFAULT = 209;
VtlParser.CHECK_DATAPOINT = 210;
VtlParser.CHECK_HIERARCHY = 211;
VtlParser.COMPUTED = 212;
VtlParser.NON_NULL = 213;
VtlParser.NON_ZERO = 214;
VtlParser.PARTIAL_NULL = 215;
VtlParser.PARTIAL_ZERO = 216;
VtlParser.ALWAYS_NULL = 217;
VtlParser.ALWAYS_ZERO = 218;
VtlParser.COMPONENTS = 219;
VtlParser.ALL_MEASURES = 220;
VtlParser.SCALAR = 221;
VtlParser.COMPONENT = 222;
VtlParser.DATAPOINT_ON_VD = 223;
VtlParser.DATAPOINT_ON_VAR = 224;
VtlParser.HIERARCHICAL_ON_VD = 225;
VtlParser.HIERARCHICAL_ON_VAR = 226;
VtlParser.SET = 227;
VtlParser.LANGUAGE = 228;
VtlParser.INTEGER_CONSTANT = 229;
VtlParser.NUMBER_CONSTANT = 230;
VtlParser.BOOLEAN_CONSTANT = 231;
VtlParser.STRING_CONSTANT = 232;
VtlParser.IDENTIFIER = 233;
VtlParser.WS = 234;
VtlParser.EOL = 235;
VtlParser.ML_COMMENT = 236;
VtlParser.SL_COMMENT = 237;

VtlParser.RULE_start = 0;
VtlParser.RULE_statement = 1;
VtlParser.RULE_expr = 2;
VtlParser.RULE_exprComponent = 3;
VtlParser.RULE_functionsComponents = 4;
VtlParser.RULE_functions = 5;
VtlParser.RULE_datasetClause = 6;
VtlParser.RULE_renameClause = 7;
VtlParser.RULE_aggrClause = 8;
VtlParser.RULE_filterClause = 9;
VtlParser.RULE_calcClause = 10;
VtlParser.RULE_keepOrDropClause = 11;
VtlParser.RULE_pivotOrUnpivotClause = 12;
VtlParser.RULE_subspaceClause = 13;
VtlParser.RULE_joinOperators = 14;
VtlParser.RULE_defOperators = 15;
VtlParser.RULE_genericOperators = 16;
VtlParser.RULE_genericOperatorsComponent = 17;
VtlParser.RULE_parameterComponent = 18;
VtlParser.RULE_parameter = 19;
VtlParser.RULE_stringOperators = 20;
VtlParser.RULE_stringOperatorsComponent = 21;
VtlParser.RULE_numericOperators = 22;
VtlParser.RULE_numericOperatorsComponent = 23;
VtlParser.RULE_comparisonOperators = 24;
VtlParser.RULE_comparisonOperatorsComponent = 25;
VtlParser.RULE_timeOperators = 26;
VtlParser.RULE_timeOperatorsComponent = 27;
VtlParser.RULE_setOperators = 28;
VtlParser.RULE_hierarchyOperators = 29;
VtlParser.RULE_validationOperators = 30;
VtlParser.RULE_conditionalOperators = 31;
VtlParser.RULE_conditionalOperatorsComponent = 32;
VtlParser.RULE_aggrOperators = 33;
VtlParser.RULE_aggrOperatorsGrouping = 34;
VtlParser.RULE_anFunction = 35;
VtlParser.RULE_anFunctionComponent = 36;
VtlParser.RULE_renameClauseItem = 37;
VtlParser.RULE_aggregateClause = 38;
VtlParser.RULE_aggrFunctionClause = 39;
VtlParser.RULE_calcClauseItem = 40;
VtlParser.RULE_subspaceClauseItem = 41;
VtlParser.RULE_joinClauseWithoutUsing = 42;
VtlParser.RULE_joinClause = 43;
VtlParser.RULE_joinClauseItem = 44;
VtlParser.RULE_joinBody = 45;
VtlParser.RULE_joinApplyClause = 46;
VtlParser.RULE_partitionByClause = 47;
VtlParser.RULE_orderByClause = 48;
VtlParser.RULE_orderByItem = 49;
VtlParser.RULE_windowingClause = 50;
VtlParser.RULE_signedInteger = 51;
VtlParser.RULE_limitClauseItem = 52;
VtlParser.RULE_groupingClause = 53;
VtlParser.RULE_havingClause = 54;
VtlParser.RULE_parameterItem = 55;
VtlParser.RULE_outputParameterType = 56;
VtlParser.RULE_outputParameterTypeComponent = 57;
VtlParser.RULE_inputParameterType = 58;
VtlParser.RULE_rulesetType = 59;
VtlParser.RULE_scalarType = 60;
VtlParser.RULE_componentType = 61;
VtlParser.RULE_datasetType = 62;
VtlParser.RULE_scalarSetType = 63;
VtlParser.RULE_dpRuleset = 64;
VtlParser.RULE_hrRuleset = 65;
VtlParser.RULE_valueDomainName = 66;
VtlParser.RULE_rulesetID = 67;
VtlParser.RULE_rulesetSignature = 68;
VtlParser.RULE_signature = 69;
VtlParser.RULE_ruleClauseDatapoint = 70;
VtlParser.RULE_ruleItemDatapoint = 71;
VtlParser.RULE_ruleClauseHierarchical = 72;
VtlParser.RULE_ruleItemHierarchical = 73;
VtlParser.RULE_hierRuleSignature = 74;
VtlParser.RULE_valueDomainSignature = 75;
VtlParser.RULE_codeItemRelation = 76;
VtlParser.RULE_codeItemRelationClause = 77;
VtlParser.RULE_valueDomainValue = 78;
VtlParser.RULE_scalarTypeConstraint = 79;
VtlParser.RULE_compConstraint = 80;
VtlParser.RULE_multModifier = 81;
VtlParser.RULE_validationOutput = 82;
VtlParser.RULE_validationMode = 83;
VtlParser.RULE_conditionClause = 84;
VtlParser.RULE_inputMode = 85;
VtlParser.RULE_imbalanceExpr = 86;
VtlParser.RULE_inputModeHierarchy = 87;
VtlParser.RULE_outputModeHierarchy = 88;
VtlParser.RULE_alias = 89;
VtlParser.RULE_varID = 90;
VtlParser.RULE_simpleComponentId = 91;
VtlParser.RULE_componentID = 92;
VtlParser.RULE_inexpr = 93;
VtlParser.RULE_erCode = 94;
VtlParser.RULE_erLevel = 95;
VtlParser.RULE_comparisonOperand = 96;
VtlParser.RULE_optionalExpr = 97;
VtlParser.RULE_optionalExprComponent = 98;
VtlParser.RULE_componentRole = 99;
VtlParser.RULE_viralAttribute = 100;
VtlParser.RULE_valueDomainID = 101;
VtlParser.RULE_operatorID = 102;
VtlParser.RULE_routineName = 103;
VtlParser.RULE_constant = 104;
VtlParser.RULE_basicScalarType = 105;
VtlParser.RULE_retainType = 106;


function StartContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = VtlParser.RULE_start;
    return this;
}

StartContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
StartContext.prototype.constructor = StartContext;

StartContext.prototype.EOF = function() {
    return this.getToken(VtlParser.EOF, 0);
};

StartContext.prototype.statement = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(StatementContext);
    } else {
        return this.getTypedRuleContext(StatementContext,i);
    }
};

StartContext.prototype.EOL = function(i) {
	if(i===undefined) {
		i = null;
	}
    if(i===null) {
        return this.getTokens(VtlParser.EOL);
    } else {
        return this.getToken(VtlParser.EOL, i);
    }
};





VtlParser.StartContext = StartContext;

VtlParser.prototype.start = function() {

    var localctx = new StartContext(this, this._ctx, this.state);
    this.enterRule(localctx, 0, VtlParser.RULE_start);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 219;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while(_la===VtlParser.DEFINE || _la===VtlParser.IDENTIFIER) {
            this.state = 214;
            this.statement();
            this.state = 215;
            this.match(VtlParser.EOL);
            this.state = 221;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
        }
        this.state = 222;
        this.match(VtlParser.EOF);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


function StatementContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = VtlParser.RULE_statement;
    return this;
}

StatementContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
StatementContext.prototype.constructor = StatementContext;


 
StatementContext.prototype.copyFrom = function(ctx) {
    antlr4.ParserRuleContext.prototype.copyFrom.call(this, ctx);
};


function DefineExpressionContext(parser, ctx) {
	StatementContext.call(this, parser);
    StatementContext.prototype.copyFrom.call(this, ctx);
    return this;
}

DefineExpressionContext.prototype = Object.create(StatementContext.prototype);
DefineExpressionContext.prototype.constructor = DefineExpressionContext;

VtlParser.DefineExpressionContext = DefineExpressionContext;

DefineExpressionContext.prototype.defOperators = function() {
    return this.getTypedRuleContext(DefOperatorsContext,0);
};

function TemporaryAssignmentContext(parser, ctx) {
	StatementContext.call(this, parser);
    StatementContext.prototype.copyFrom.call(this, ctx);
    return this;
}

TemporaryAssignmentContext.prototype = Object.create(StatementContext.prototype);
TemporaryAssignmentContext.prototype.constructor = TemporaryAssignmentContext;

VtlParser.TemporaryAssignmentContext = TemporaryAssignmentContext;

TemporaryAssignmentContext.prototype.varID = function() {
    return this.getTypedRuleContext(VarIDContext,0);
};

TemporaryAssignmentContext.prototype.ASSIGN = function() {
    return this.getToken(VtlParser.ASSIGN, 0);
};

TemporaryAssignmentContext.prototype.expr = function() {
    return this.getTypedRuleContext(ExprContext,0);
};

function PersistAssignmentContext(parser, ctx) {
	StatementContext.call(this, parser);
    StatementContext.prototype.copyFrom.call(this, ctx);
    return this;
}

PersistAssignmentContext.prototype = Object.create(StatementContext.prototype);
PersistAssignmentContext.prototype.constructor = PersistAssignmentContext;

VtlParser.PersistAssignmentContext = PersistAssignmentContext;

PersistAssignmentContext.prototype.varID = function() {
    return this.getTypedRuleContext(VarIDContext,0);
};

PersistAssignmentContext.prototype.PUT_SYMBOL = function() {
    return this.getToken(VtlParser.PUT_SYMBOL, 0);
};

PersistAssignmentContext.prototype.expr = function() {
    return this.getTypedRuleContext(ExprContext,0);
};


VtlParser.StatementContext = StatementContext;

VtlParser.prototype.statement = function() {

    var localctx = new StatementContext(this, this._ctx, this.state);
    this.enterRule(localctx, 2, VtlParser.RULE_statement);
    try {
        this.state = 233;
        this._errHandler.sync(this);
        var la_ = this._interp.adaptivePredict(this._input,1,this._ctx);
        switch(la_) {
        case 1:
            localctx = new TemporaryAssignmentContext(this, localctx);
            this.enterOuterAlt(localctx, 1);
            this.state = 224;
            this.varID();
            this.state = 225;
            this.match(VtlParser.ASSIGN);
            this.state = 226;
            this.expr(0);
            break;

        case 2:
            localctx = new PersistAssignmentContext(this, localctx);
            this.enterOuterAlt(localctx, 2);
            this.state = 228;
            this.varID();
            this.state = 229;
            this.match(VtlParser.PUT_SYMBOL);
            this.state = 230;
            this.expr(0);
            break;

        case 3:
            localctx = new DefineExpressionContext(this, localctx);
            this.enterOuterAlt(localctx, 3);
            this.state = 232;
            this.defOperators();
            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


function ExprContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = VtlParser.RULE_expr;
    return this;
}

ExprContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ExprContext.prototype.constructor = ExprContext;


 
ExprContext.prototype.copyFrom = function(ctx) {
    antlr4.ParserRuleContext.prototype.copyFrom.call(this, ctx);
};

function VarIdExprContext(parser, ctx) {
	ExprContext.call(this, parser);
    ExprContext.prototype.copyFrom.call(this, ctx);
    return this;
}

VarIdExprContext.prototype = Object.create(ExprContext.prototype);
VarIdExprContext.prototype.constructor = VarIdExprContext;

VtlParser.VarIdExprContext = VarIdExprContext;

VarIdExprContext.prototype.varID = function() {
    return this.getTypedRuleContext(VarIDContext,0);
};

function MembershipExprContext(parser, ctx) {
	ExprContext.call(this, parser);
    ExprContext.prototype.copyFrom.call(this, ctx);
    return this;
}

MembershipExprContext.prototype = Object.create(ExprContext.prototype);
MembershipExprContext.prototype.constructor = MembershipExprContext;

VtlParser.MembershipExprContext = MembershipExprContext;

MembershipExprContext.prototype.expr = function() {
    return this.getTypedRuleContext(ExprContext,0);
};

MembershipExprContext.prototype.MEMBERSHIP = function() {
    return this.getToken(VtlParser.MEMBERSHIP, 0);
};

MembershipExprContext.prototype.simpleComponentId = function() {
    return this.getTypedRuleContext(SimpleComponentIdContext,0);
};

function InNotInExprContext(parser, ctx) {
	ExprContext.call(this, parser);
    this.left = null; // ExprContext;
    this.op = null; // Token;
    this.right = null; // InexprContext;
    ExprContext.prototype.copyFrom.call(this, ctx);
    return this;
}

InNotInExprContext.prototype = Object.create(ExprContext.prototype);
InNotInExprContext.prototype.constructor = InNotInExprContext;

VtlParser.InNotInExprContext = InNotInExprContext;

InNotInExprContext.prototype.expr = function() {
    return this.getTypedRuleContext(ExprContext,0);
};

InNotInExprContext.prototype.inexpr = function() {
    return this.getTypedRuleContext(InexprContext,0);
};

InNotInExprContext.prototype.IN = function() {
    return this.getToken(VtlParser.IN, 0);
};

InNotInExprContext.prototype.NOT_IN = function() {
    return this.getToken(VtlParser.NOT_IN, 0);
};

function BooleanExprContext(parser, ctx) {
	ExprContext.call(this, parser);
    this.left = null; // ExprContext;
    this.op = null; // Token;
    this.right = null; // ExprContext;
    ExprContext.prototype.copyFrom.call(this, ctx);
    return this;
}

BooleanExprContext.prototype = Object.create(ExprContext.prototype);
BooleanExprContext.prototype.constructor = BooleanExprContext;

VtlParser.BooleanExprContext = BooleanExprContext;

BooleanExprContext.prototype.expr = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(ExprContext);
    } else {
        return this.getTypedRuleContext(ExprContext,i);
    }
};

BooleanExprContext.prototype.AND = function() {
    return this.getToken(VtlParser.AND, 0);
};

BooleanExprContext.prototype.OR = function() {
    return this.getToken(VtlParser.OR, 0);
};

BooleanExprContext.prototype.XOR = function() {
    return this.getToken(VtlParser.XOR, 0);
};

function ComparisonExprContext(parser, ctx) {
	ExprContext.call(this, parser);
    this.left = null; // ExprContext;
    this.op = null; // ComparisonOperandContext;
    this.right = null; // ExprContext;
    ExprContext.prototype.copyFrom.call(this, ctx);
    return this;
}

ComparisonExprContext.prototype = Object.create(ExprContext.prototype);
ComparisonExprContext.prototype.constructor = ComparisonExprContext;

VtlParser.ComparisonExprContext = ComparisonExprContext;

ComparisonExprContext.prototype.expr = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(ExprContext);
    } else {
        return this.getTypedRuleContext(ExprContext,i);
    }
};

ComparisonExprContext.prototype.comparisonOperand = function() {
    return this.getTypedRuleContext(ComparisonOperandContext,0);
};

function UnaryExprContext(parser, ctx) {
	ExprContext.call(this, parser);
    this.op = null; // Token;
    this.right = null; // ExprContext;
    ExprContext.prototype.copyFrom.call(this, ctx);
    return this;
}

UnaryExprContext.prototype = Object.create(ExprContext.prototype);
UnaryExprContext.prototype.constructor = UnaryExprContext;

VtlParser.UnaryExprContext = UnaryExprContext;

UnaryExprContext.prototype.expr = function() {
    return this.getTypedRuleContext(ExprContext,0);
};

UnaryExprContext.prototype.PLUS = function() {
    return this.getToken(VtlParser.PLUS, 0);
};

UnaryExprContext.prototype.MINUS = function() {
    return this.getToken(VtlParser.MINUS, 0);
};

UnaryExprContext.prototype.NOT = function() {
    return this.getToken(VtlParser.NOT, 0);
};

function FunctionsExpressionContext(parser, ctx) {
	ExprContext.call(this, parser);
    ExprContext.prototype.copyFrom.call(this, ctx);
    return this;
}

FunctionsExpressionContext.prototype = Object.create(ExprContext.prototype);
FunctionsExpressionContext.prototype.constructor = FunctionsExpressionContext;

VtlParser.FunctionsExpressionContext = FunctionsExpressionContext;

FunctionsExpressionContext.prototype.functions = function() {
    return this.getTypedRuleContext(FunctionsContext,0);
};

function IfExprContext(parser, ctx) {
	ExprContext.call(this, parser);
    this.conditionalExpr = null; // ExprContext;
    this.thenExpr = null; // ExprContext;
    this.elseExpr = null; // ExprContext;
    ExprContext.prototype.copyFrom.call(this, ctx);
    return this;
}

IfExprContext.prototype = Object.create(ExprContext.prototype);
IfExprContext.prototype.constructor = IfExprContext;

VtlParser.IfExprContext = IfExprContext;

IfExprContext.prototype.IF = function() {
    return this.getToken(VtlParser.IF, 0);
};

IfExprContext.prototype.THEN = function() {
    return this.getToken(VtlParser.THEN, 0);
};

IfExprContext.prototype.ELSE = function() {
    return this.getToken(VtlParser.ELSE, 0);
};

IfExprContext.prototype.expr = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(ExprContext);
    } else {
        return this.getTypedRuleContext(ExprContext,i);
    }
};

function ClauseExprContext(parser, ctx) {
	ExprContext.call(this, parser);
    this.dataset = null; // ExprContext;
    this.clause = null; // DatasetClauseContext;
    ExprContext.prototype.copyFrom.call(this, ctx);
    return this;
}

ClauseExprContext.prototype = Object.create(ExprContext.prototype);
ClauseExprContext.prototype.constructor = ClauseExprContext;

VtlParser.ClauseExprContext = ClauseExprContext;

ClauseExprContext.prototype.QLPAREN = function() {
    return this.getToken(VtlParser.QLPAREN, 0);
};

ClauseExprContext.prototype.QRPAREN = function() {
    return this.getToken(VtlParser.QRPAREN, 0);
};

ClauseExprContext.prototype.expr = function() {
    return this.getTypedRuleContext(ExprContext,0);
};

ClauseExprContext.prototype.datasetClause = function() {
    return this.getTypedRuleContext(DatasetClauseContext,0);
};

function ArithmeticExprContext(parser, ctx) {
	ExprContext.call(this, parser);
    this.left = null; // ExprContext;
    this.op = null; // Token;
    this.right = null; // ExprContext;
    ExprContext.prototype.copyFrom.call(this, ctx);
    return this;
}

ArithmeticExprContext.prototype = Object.create(ExprContext.prototype);
ArithmeticExprContext.prototype.constructor = ArithmeticExprContext;

VtlParser.ArithmeticExprContext = ArithmeticExprContext;

ArithmeticExprContext.prototype.expr = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(ExprContext);
    } else {
        return this.getTypedRuleContext(ExprContext,i);
    }
};

ArithmeticExprContext.prototype.MUL = function() {
    return this.getToken(VtlParser.MUL, 0);
};

ArithmeticExprContext.prototype.DIV = function() {
    return this.getToken(VtlParser.DIV, 0);
};

function ParenthesisExprContext(parser, ctx) {
	ExprContext.call(this, parser);
    ExprContext.prototype.copyFrom.call(this, ctx);
    return this;
}

ParenthesisExprContext.prototype = Object.create(ExprContext.prototype);
ParenthesisExprContext.prototype.constructor = ParenthesisExprContext;

VtlParser.ParenthesisExprContext = ParenthesisExprContext;

ParenthesisExprContext.prototype.LPAREN = function() {
    return this.getToken(VtlParser.LPAREN, 0);
};

ParenthesisExprContext.prototype.expr = function() {
    return this.getTypedRuleContext(ExprContext,0);
};

ParenthesisExprContext.prototype.RPAREN = function() {
    return this.getToken(VtlParser.RPAREN, 0);
};

function ConstantExprContext(parser, ctx) {
	ExprContext.call(this, parser);
    ExprContext.prototype.copyFrom.call(this, ctx);
    return this;
}

ConstantExprContext.prototype = Object.create(ExprContext.prototype);
ConstantExprContext.prototype.constructor = ConstantExprContext;

VtlParser.ConstantExprContext = ConstantExprContext;

ConstantExprContext.prototype.constant = function() {
    return this.getTypedRuleContext(ConstantContext,0);
};

function ArithmeticExprOrConcatContext(parser, ctx) {
	ExprContext.call(this, parser);
    this.left = null; // ExprContext;
    this.op = null; // Token;
    this.right = null; // ExprContext;
    ExprContext.prototype.copyFrom.call(this, ctx);
    return this;
}

ArithmeticExprOrConcatContext.prototype = Object.create(ExprContext.prototype);
ArithmeticExprOrConcatContext.prototype.constructor = ArithmeticExprOrConcatContext;

VtlParser.ArithmeticExprOrConcatContext = ArithmeticExprOrConcatContext;

ArithmeticExprOrConcatContext.prototype.expr = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(ExprContext);
    } else {
        return this.getTypedRuleContext(ExprContext,i);
    }
};

ArithmeticExprOrConcatContext.prototype.PLUS = function() {
    return this.getToken(VtlParser.PLUS, 0);
};

ArithmeticExprOrConcatContext.prototype.MINUS = function() {
    return this.getToken(VtlParser.MINUS, 0);
};

ArithmeticExprOrConcatContext.prototype.CONCAT = function() {
    return this.getToken(VtlParser.CONCAT, 0);
};


VtlParser.prototype.expr = function(_p) {
	if(_p===undefined) {
	    _p = 0;
	}
    var _parentctx = this._ctx;
    var _parentState = this.state;
    var localctx = new ExprContext(this, this._ctx, _parentState);
    var _prevctx = localctx;
    var _startState = 4;
    this.enterRecursionRule(localctx, 4, VtlParser.RULE_expr, _p);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 252;
        this._errHandler.sync(this);
        var la_ = this._interp.adaptivePredict(this._input,2,this._ctx);
        switch(la_) {
        case 1:
            localctx = new ParenthesisExprContext(this, localctx);
            this._ctx = localctx;
            _prevctx = localctx;

            this.state = 236;
            this.match(VtlParser.LPAREN);
            this.state = 237;
            this.expr(0);
            this.state = 238;
            this.match(VtlParser.RPAREN);
            break;

        case 2:
            localctx = new FunctionsExpressionContext(this, localctx);
            this._ctx = localctx;
            _prevctx = localctx;
            this.state = 240;
            this.functions();
            break;

        case 3:
            localctx = new UnaryExprContext(this, localctx);
            this._ctx = localctx;
            _prevctx = localctx;
            this.state = 241;
            localctx.op = this._input.LT(1);
            _la = this._input.LA(1);
            if(!(((((_la - 13)) & ~0x1f) == 0 && ((1 << (_la - 13)) & ((1 << (VtlParser.PLUS - 13)) | (1 << (VtlParser.MINUS - 13)) | (1 << (VtlParser.NOT - 13)))) !== 0))) {
                localctx.op = this._errHandler.recoverInline(this);
            }
            else {
            	this._errHandler.reportMatch(this);
                this.consume();
            }
            this.state = 242;
            localctx.right = this.expr(10);
            break;

        case 4:
            localctx = new IfExprContext(this, localctx);
            this._ctx = localctx;
            _prevctx = localctx;
            this.state = 243;
            this.match(VtlParser.IF);
            this.state = 244;
            localctx.conditionalExpr = this.expr(0);
            this.state = 245;
            this.match(VtlParser.THEN);
            this.state = 246;
            localctx.thenExpr = this.expr(0);
            this.state = 247;
            this.match(VtlParser.ELSE);
            this.state = 248;
            localctx.elseExpr = this.expr(3);
            break;

        case 5:
            localctx = new ConstantExprContext(this, localctx);
            this._ctx = localctx;
            _prevctx = localctx;
            this.state = 250;
            this.constant();
            break;

        case 6:
            localctx = new VarIdExprContext(this, localctx);
            this._ctx = localctx;
            _prevctx = localctx;
            this.state = 251;
            this.varID();
            break;

        }
        this._ctx.stop = this._input.LT(-1);
        this.state = 283;
        this._errHandler.sync(this);
        var _alt = this._interp.adaptivePredict(this._input,4,this._ctx)
        while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
            if(_alt===1) {
                if(this._parseListeners!==null) {
                    this.triggerExitRuleEvent();
                }
                _prevctx = localctx;
                this.state = 281;
                this._errHandler.sync(this);
                var la_ = this._interp.adaptivePredict(this._input,3,this._ctx);
                switch(la_) {
                case 1:
                    localctx = new ArithmeticExprContext(this, new ExprContext(this, _parentctx, _parentState));
                    localctx.left = _prevctx;
                    this.pushNewRecursionContext(localctx, _startState, VtlParser.RULE_expr);
                    this.state = 254;
                    if (!( this.precpred(this._ctx, 9))) {
                        throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 9)");
                    }
                    this.state = 255;
                    localctx.op = this._input.LT(1);
                    _la = this._input.LA(1);
                    if(!(_la===VtlParser.MUL || _la===VtlParser.DIV)) {
                        localctx.op = this._errHandler.recoverInline(this);
                    }
                    else {
                    	this._errHandler.reportMatch(this);
                        this.consume();
                    }
                    this.state = 256;
                    localctx.right = this.expr(10);
                    break;

                case 2:
                    localctx = new ArithmeticExprOrConcatContext(this, new ExprContext(this, _parentctx, _parentState));
                    localctx.left = _prevctx;
                    this.pushNewRecursionContext(localctx, _startState, VtlParser.RULE_expr);
                    this.state = 257;
                    if (!( this.precpred(this._ctx, 8))) {
                        throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 8)");
                    }
                    this.state = 258;
                    localctx.op = this._input.LT(1);
                    _la = this._input.LA(1);
                    if(!(_la===VtlParser.PLUS || _la===VtlParser.MINUS || _la===VtlParser.CONCAT)) {
                        localctx.op = this._errHandler.recoverInline(this);
                    }
                    else {
                    	this._errHandler.reportMatch(this);
                        this.consume();
                    }
                    this.state = 259;
                    localctx.right = this.expr(9);
                    break;

                case 3:
                    localctx = new ComparisonExprContext(this, new ExprContext(this, _parentctx, _parentState));
                    localctx.left = _prevctx;
                    this.pushNewRecursionContext(localctx, _startState, VtlParser.RULE_expr);
                    this.state = 260;
                    if (!( this.precpred(this._ctx, 7))) {
                        throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 7)");
                    }
                    this.state = 261;
                    localctx.op = this.comparisonOperand();
                    this.state = 262;
                    localctx.right = this.expr(8);
                    break;

                case 4:
                    localctx = new BooleanExprContext(this, new ExprContext(this, _parentctx, _parentState));
                    localctx.left = _prevctx;
                    this.pushNewRecursionContext(localctx, _startState, VtlParser.RULE_expr);
                    this.state = 264;
                    if (!( this.precpred(this._ctx, 5))) {
                        throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 5)");
                    }
                    this.state = 265;
                    localctx.op = this.match(VtlParser.AND);
                    this.state = 266;
                    localctx.right = this.expr(6);
                    break;

                case 5:
                    localctx = new BooleanExprContext(this, new ExprContext(this, _parentctx, _parentState));
                    localctx.left = _prevctx;
                    this.pushNewRecursionContext(localctx, _startState, VtlParser.RULE_expr);
                    this.state = 267;
                    if (!( this.precpred(this._ctx, 4))) {
                        throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 4)");
                    }
                    this.state = 268;
                    localctx.op = this._input.LT(1);
                    _la = this._input.LA(1);
                    if(!(_la===VtlParser.OR || _la===VtlParser.XOR)) {
                        localctx.op = this._errHandler.recoverInline(this);
                    }
                    else {
                    	this._errHandler.reportMatch(this);
                        this.consume();
                    }
                    this.state = 269;
                    localctx.right = this.expr(5);
                    break;

                case 6:
                    localctx = new ClauseExprContext(this, new ExprContext(this, _parentctx, _parentState));
                    localctx.dataset = _prevctx;
                    this.pushNewRecursionContext(localctx, _startState, VtlParser.RULE_expr);
                    this.state = 270;
                    if (!( this.precpred(this._ctx, 12))) {
                        throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 12)");
                    }
                    this.state = 271;
                    this.match(VtlParser.QLPAREN);
                    this.state = 272;
                    localctx.clause = this.datasetClause();
                    this.state = 273;
                    this.match(VtlParser.QRPAREN);
                    break;

                case 7:
                    localctx = new MembershipExprContext(this, new ExprContext(this, _parentctx, _parentState));
                    this.pushNewRecursionContext(localctx, _startState, VtlParser.RULE_expr);
                    this.state = 275;
                    if (!( this.precpred(this._ctx, 11))) {
                        throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 11)");
                    }
                    this.state = 276;
                    this.match(VtlParser.MEMBERSHIP);
                    this.state = 277;
                    this.simpleComponentId();
                    break;

                case 8:
                    localctx = new InNotInExprContext(this, new ExprContext(this, _parentctx, _parentState));
                    localctx.left = _prevctx;
                    this.pushNewRecursionContext(localctx, _startState, VtlParser.RULE_expr);
                    this.state = 278;
                    if (!( this.precpred(this._ctx, 6))) {
                        throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 6)");
                    }
                    this.state = 279;
                    localctx.op = this._input.LT(1);
                    _la = this._input.LA(1);
                    if(!(_la===VtlParser.IN || _la===VtlParser.NOT_IN)) {
                        localctx.op = this._errHandler.recoverInline(this);
                    }
                    else {
                    	this._errHandler.reportMatch(this);
                        this.consume();
                    }
                    this.state = 280;
                    localctx.right = this.inexpr();
                    break;

                } 
            }
            this.state = 285;
            this._errHandler.sync(this);
            _alt = this._interp.adaptivePredict(this._input,4,this._ctx);
        }

    } catch( error) {
        if(error instanceof antlr4.error.RecognitionException) {
	        localctx.exception = error;
	        this._errHandler.reportError(this, error);
	        this._errHandler.recover(this, error);
	    } else {
	    	throw error;
	    }
    } finally {
        this.unrollRecursionContexts(_parentctx)
    }
    return localctx;
};


function ExprComponentContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = VtlParser.RULE_exprComponent;
    return this;
}

ExprComponentContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ExprComponentContext.prototype.constructor = ExprComponentContext;


 
ExprComponentContext.prototype.copyFrom = function(ctx) {
    antlr4.ParserRuleContext.prototype.copyFrom.call(this, ctx);
};

function ArithmeticExprCompContext(parser, ctx) {
	ExprComponentContext.call(this, parser);
    this.left = null; // ExprComponentContext;
    this.op = null; // Token;
    this.right = null; // ExprComponentContext;
    ExprComponentContext.prototype.copyFrom.call(this, ctx);
    return this;
}

ArithmeticExprCompContext.prototype = Object.create(ExprComponentContext.prototype);
ArithmeticExprCompContext.prototype.constructor = ArithmeticExprCompContext;

VtlParser.ArithmeticExprCompContext = ArithmeticExprCompContext;

ArithmeticExprCompContext.prototype.exprComponent = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(ExprComponentContext);
    } else {
        return this.getTypedRuleContext(ExprComponentContext,i);
    }
};

ArithmeticExprCompContext.prototype.MUL = function() {
    return this.getToken(VtlParser.MUL, 0);
};

ArithmeticExprCompContext.prototype.DIV = function() {
    return this.getToken(VtlParser.DIV, 0);
};

function IfExprCompContext(parser, ctx) {
	ExprComponentContext.call(this, parser);
    this.conditionalExpr = null; // ExprComponentContext;
    this.thenExpr = null; // ExprComponentContext;
    this.elseExpr = null; // ExprComponentContext;
    ExprComponentContext.prototype.copyFrom.call(this, ctx);
    return this;
}

IfExprCompContext.prototype = Object.create(ExprComponentContext.prototype);
IfExprCompContext.prototype.constructor = IfExprCompContext;

VtlParser.IfExprCompContext = IfExprCompContext;

IfExprCompContext.prototype.IF = function() {
    return this.getToken(VtlParser.IF, 0);
};

IfExprCompContext.prototype.THEN = function() {
    return this.getToken(VtlParser.THEN, 0);
};

IfExprCompContext.prototype.ELSE = function() {
    return this.getToken(VtlParser.ELSE, 0);
};

IfExprCompContext.prototype.exprComponent = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(ExprComponentContext);
    } else {
        return this.getTypedRuleContext(ExprComponentContext,i);
    }
};

function ComparisonExprCompContext(parser, ctx) {
	ExprComponentContext.call(this, parser);
    this.left = null; // ExprComponentContext;
    this.right = null; // ExprComponentContext;
    ExprComponentContext.prototype.copyFrom.call(this, ctx);
    return this;
}

ComparisonExprCompContext.prototype = Object.create(ExprComponentContext.prototype);
ComparisonExprCompContext.prototype.constructor = ComparisonExprCompContext;

VtlParser.ComparisonExprCompContext = ComparisonExprCompContext;

ComparisonExprCompContext.prototype.comparisonOperand = function() {
    return this.getTypedRuleContext(ComparisonOperandContext,0);
};

ComparisonExprCompContext.prototype.exprComponent = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(ExprComponentContext);
    } else {
        return this.getTypedRuleContext(ExprComponentContext,i);
    }
};

function FunctionsExpressionCompContext(parser, ctx) {
	ExprComponentContext.call(this, parser);
    ExprComponentContext.prototype.copyFrom.call(this, ctx);
    return this;
}

FunctionsExpressionCompContext.prototype = Object.create(ExprComponentContext.prototype);
FunctionsExpressionCompContext.prototype.constructor = FunctionsExpressionCompContext;

VtlParser.FunctionsExpressionCompContext = FunctionsExpressionCompContext;

FunctionsExpressionCompContext.prototype.functionsComponents = function() {
    return this.getTypedRuleContext(FunctionsComponentsContext,0);
};

function CompIdContext(parser, ctx) {
	ExprComponentContext.call(this, parser);
    ExprComponentContext.prototype.copyFrom.call(this, ctx);
    return this;
}

CompIdContext.prototype = Object.create(ExprComponentContext.prototype);
CompIdContext.prototype.constructor = CompIdContext;

VtlParser.CompIdContext = CompIdContext;

CompIdContext.prototype.componentID = function() {
    return this.getTypedRuleContext(ComponentIDContext,0);
};

function ConstantExprCompContext(parser, ctx) {
	ExprComponentContext.call(this, parser);
    ExprComponentContext.prototype.copyFrom.call(this, ctx);
    return this;
}

ConstantExprCompContext.prototype = Object.create(ExprComponentContext.prototype);
ConstantExprCompContext.prototype.constructor = ConstantExprCompContext;

VtlParser.ConstantExprCompContext = ConstantExprCompContext;

ConstantExprCompContext.prototype.constant = function() {
    return this.getTypedRuleContext(ConstantContext,0);
};

function ArithmeticExprOrConcatCompContext(parser, ctx) {
	ExprComponentContext.call(this, parser);
    this.left = null; // ExprComponentContext;
    this.op = null; // Token;
    this.right = null; // ExprComponentContext;
    ExprComponentContext.prototype.copyFrom.call(this, ctx);
    return this;
}

ArithmeticExprOrConcatCompContext.prototype = Object.create(ExprComponentContext.prototype);
ArithmeticExprOrConcatCompContext.prototype.constructor = ArithmeticExprOrConcatCompContext;

VtlParser.ArithmeticExprOrConcatCompContext = ArithmeticExprOrConcatCompContext;

ArithmeticExprOrConcatCompContext.prototype.exprComponent = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(ExprComponentContext);
    } else {
        return this.getTypedRuleContext(ExprComponentContext,i);
    }
};

ArithmeticExprOrConcatCompContext.prototype.PLUS = function() {
    return this.getToken(VtlParser.PLUS, 0);
};

ArithmeticExprOrConcatCompContext.prototype.MINUS = function() {
    return this.getToken(VtlParser.MINUS, 0);
};

ArithmeticExprOrConcatCompContext.prototype.CONCAT = function() {
    return this.getToken(VtlParser.CONCAT, 0);
};

function ParenthesisExprCompContext(parser, ctx) {
	ExprComponentContext.call(this, parser);
    ExprComponentContext.prototype.copyFrom.call(this, ctx);
    return this;
}

ParenthesisExprCompContext.prototype = Object.create(ExprComponentContext.prototype);
ParenthesisExprCompContext.prototype.constructor = ParenthesisExprCompContext;

VtlParser.ParenthesisExprCompContext = ParenthesisExprCompContext;

ParenthesisExprCompContext.prototype.LPAREN = function() {
    return this.getToken(VtlParser.LPAREN, 0);
};

ParenthesisExprCompContext.prototype.exprComponent = function() {
    return this.getTypedRuleContext(ExprComponentContext,0);
};

ParenthesisExprCompContext.prototype.RPAREN = function() {
    return this.getToken(VtlParser.RPAREN, 0);
};

function InNotInExprCompContext(parser, ctx) {
	ExprComponentContext.call(this, parser);
    this.left = null; // ExprComponentContext;
    this.op = null; // Token;
    this.right = null; // InexprContext;
    ExprComponentContext.prototype.copyFrom.call(this, ctx);
    return this;
}

InNotInExprCompContext.prototype = Object.create(ExprComponentContext.prototype);
InNotInExprCompContext.prototype.constructor = InNotInExprCompContext;

VtlParser.InNotInExprCompContext = InNotInExprCompContext;

InNotInExprCompContext.prototype.exprComponent = function() {
    return this.getTypedRuleContext(ExprComponentContext,0);
};

InNotInExprCompContext.prototype.inexpr = function() {
    return this.getTypedRuleContext(InexprContext,0);
};

InNotInExprCompContext.prototype.IN = function() {
    return this.getToken(VtlParser.IN, 0);
};

InNotInExprCompContext.prototype.NOT_IN = function() {
    return this.getToken(VtlParser.NOT_IN, 0);
};

function UnaryExprCompContext(parser, ctx) {
	ExprComponentContext.call(this, parser);
    this.op = null; // Token;
    this.right = null; // ExprComponentContext;
    ExprComponentContext.prototype.copyFrom.call(this, ctx);
    return this;
}

UnaryExprCompContext.prototype = Object.create(ExprComponentContext.prototype);
UnaryExprCompContext.prototype.constructor = UnaryExprCompContext;

VtlParser.UnaryExprCompContext = UnaryExprCompContext;

UnaryExprCompContext.prototype.exprComponent = function() {
    return this.getTypedRuleContext(ExprComponentContext,0);
};

UnaryExprCompContext.prototype.PLUS = function() {
    return this.getToken(VtlParser.PLUS, 0);
};

UnaryExprCompContext.prototype.MINUS = function() {
    return this.getToken(VtlParser.MINUS, 0);
};

UnaryExprCompContext.prototype.NOT = function() {
    return this.getToken(VtlParser.NOT, 0);
};

function BooleanExprCompContext(parser, ctx) {
	ExprComponentContext.call(this, parser);
    this.left = null; // ExprComponentContext;
    this.op = null; // Token;
    this.right = null; // ExprComponentContext;
    ExprComponentContext.prototype.copyFrom.call(this, ctx);
    return this;
}

BooleanExprCompContext.prototype = Object.create(ExprComponentContext.prototype);
BooleanExprCompContext.prototype.constructor = BooleanExprCompContext;

VtlParser.BooleanExprCompContext = BooleanExprCompContext;

BooleanExprCompContext.prototype.exprComponent = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(ExprComponentContext);
    } else {
        return this.getTypedRuleContext(ExprComponentContext,i);
    }
};

BooleanExprCompContext.prototype.AND = function() {
    return this.getToken(VtlParser.AND, 0);
};

BooleanExprCompContext.prototype.OR = function() {
    return this.getToken(VtlParser.OR, 0);
};

BooleanExprCompContext.prototype.XOR = function() {
    return this.getToken(VtlParser.XOR, 0);
};


VtlParser.prototype.exprComponent = function(_p) {
	if(_p===undefined) {
	    _p = 0;
	}
    var _parentctx = this._ctx;
    var _parentState = this.state;
    var localctx = new ExprComponentContext(this, this._ctx, _parentState);
    var _prevctx = localctx;
    var _startState = 6;
    this.enterRecursionRule(localctx, 6, VtlParser.RULE_exprComponent, _p);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 303;
        this._errHandler.sync(this);
        var la_ = this._interp.adaptivePredict(this._input,5,this._ctx);
        switch(la_) {
        case 1:
            localctx = new ParenthesisExprCompContext(this, localctx);
            this._ctx = localctx;
            _prevctx = localctx;

            this.state = 287;
            this.match(VtlParser.LPAREN);
            this.state = 288;
            this.exprComponent(0);
            this.state = 289;
            this.match(VtlParser.RPAREN);
            break;

        case 2:
            localctx = new FunctionsExpressionCompContext(this, localctx);
            this._ctx = localctx;
            _prevctx = localctx;
            this.state = 291;
            this.functionsComponents();
            break;

        case 3:
            localctx = new UnaryExprCompContext(this, localctx);
            this._ctx = localctx;
            _prevctx = localctx;
            this.state = 292;
            localctx.op = this._input.LT(1);
            _la = this._input.LA(1);
            if(!(((((_la - 13)) & ~0x1f) == 0 && ((1 << (_la - 13)) & ((1 << (VtlParser.PLUS - 13)) | (1 << (VtlParser.MINUS - 13)) | (1 << (VtlParser.NOT - 13)))) !== 0))) {
                localctx.op = this._errHandler.recoverInline(this);
            }
            else {
            	this._errHandler.reportMatch(this);
                this.consume();
            }
            this.state = 293;
            localctx.right = this.exprComponent(10);
            break;

        case 4:
            localctx = new IfExprCompContext(this, localctx);
            this._ctx = localctx;
            _prevctx = localctx;
            this.state = 294;
            this.match(VtlParser.IF);
            this.state = 295;
            localctx.conditionalExpr = this.exprComponent(0);
            this.state = 296;
            this.match(VtlParser.THEN);
            this.state = 297;
            localctx.thenExpr = this.exprComponent(0);
            this.state = 298;
            this.match(VtlParser.ELSE);
            this.state = 299;
            localctx.elseExpr = this.exprComponent(3);
            break;

        case 5:
            localctx = new ConstantExprCompContext(this, localctx);
            this._ctx = localctx;
            _prevctx = localctx;
            this.state = 301;
            this.constant();
            break;

        case 6:
            localctx = new CompIdContext(this, localctx);
            this._ctx = localctx;
            _prevctx = localctx;
            this.state = 302;
            this.componentID();
            break;

        }
        this._ctx.stop = this._input.LT(-1);
        this.state = 326;
        this._errHandler.sync(this);
        var _alt = this._interp.adaptivePredict(this._input,7,this._ctx)
        while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
            if(_alt===1) {
                if(this._parseListeners!==null) {
                    this.triggerExitRuleEvent();
                }
                _prevctx = localctx;
                this.state = 324;
                this._errHandler.sync(this);
                var la_ = this._interp.adaptivePredict(this._input,6,this._ctx);
                switch(la_) {
                case 1:
                    localctx = new ArithmeticExprCompContext(this, new ExprComponentContext(this, _parentctx, _parentState));
                    localctx.left = _prevctx;
                    this.pushNewRecursionContext(localctx, _startState, VtlParser.RULE_exprComponent);
                    this.state = 305;
                    if (!( this.precpred(this._ctx, 9))) {
                        throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 9)");
                    }
                    this.state = 306;
                    localctx.op = this._input.LT(1);
                    _la = this._input.LA(1);
                    if(!(_la===VtlParser.MUL || _la===VtlParser.DIV)) {
                        localctx.op = this._errHandler.recoverInline(this);
                    }
                    else {
                    	this._errHandler.reportMatch(this);
                        this.consume();
                    }
                    this.state = 307;
                    localctx.right = this.exprComponent(10);
                    break;

                case 2:
                    localctx = new ArithmeticExprOrConcatCompContext(this, new ExprComponentContext(this, _parentctx, _parentState));
                    localctx.left = _prevctx;
                    this.pushNewRecursionContext(localctx, _startState, VtlParser.RULE_exprComponent);
                    this.state = 308;
                    if (!( this.precpred(this._ctx, 8))) {
                        throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 8)");
                    }
                    this.state = 309;
                    localctx.op = this._input.LT(1);
                    _la = this._input.LA(1);
                    if(!(_la===VtlParser.PLUS || _la===VtlParser.MINUS || _la===VtlParser.CONCAT)) {
                        localctx.op = this._errHandler.recoverInline(this);
                    }
                    else {
                    	this._errHandler.reportMatch(this);
                        this.consume();
                    }
                    this.state = 310;
                    localctx.right = this.exprComponent(9);
                    break;

                case 3:
                    localctx = new ComparisonExprCompContext(this, new ExprComponentContext(this, _parentctx, _parentState));
                    localctx.left = _prevctx;
                    this.pushNewRecursionContext(localctx, _startState, VtlParser.RULE_exprComponent);
                    this.state = 311;
                    if (!( this.precpred(this._ctx, 7))) {
                        throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 7)");
                    }
                    this.state = 312;
                    this.comparisonOperand();
                    this.state = 313;
                    localctx.right = this.exprComponent(8);
                    break;

                case 4:
                    localctx = new BooleanExprCompContext(this, new ExprComponentContext(this, _parentctx, _parentState));
                    localctx.left = _prevctx;
                    this.pushNewRecursionContext(localctx, _startState, VtlParser.RULE_exprComponent);
                    this.state = 315;
                    if (!( this.precpred(this._ctx, 5))) {
                        throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 5)");
                    }
                    this.state = 316;
                    localctx.op = this.match(VtlParser.AND);
                    this.state = 317;
                    localctx.right = this.exprComponent(6);
                    break;

                case 5:
                    localctx = new BooleanExprCompContext(this, new ExprComponentContext(this, _parentctx, _parentState));
                    localctx.left = _prevctx;
                    this.pushNewRecursionContext(localctx, _startState, VtlParser.RULE_exprComponent);
                    this.state = 318;
                    if (!( this.precpred(this._ctx, 4))) {
                        throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 4)");
                    }
                    this.state = 319;
                    localctx.op = this._input.LT(1);
                    _la = this._input.LA(1);
                    if(!(_la===VtlParser.OR || _la===VtlParser.XOR)) {
                        localctx.op = this._errHandler.recoverInline(this);
                    }
                    else {
                    	this._errHandler.reportMatch(this);
                        this.consume();
                    }
                    this.state = 320;
                    localctx.right = this.exprComponent(5);
                    break;

                case 6:
                    localctx = new InNotInExprCompContext(this, new ExprComponentContext(this, _parentctx, _parentState));
                    localctx.left = _prevctx;
                    this.pushNewRecursionContext(localctx, _startState, VtlParser.RULE_exprComponent);
                    this.state = 321;
                    if (!( this.precpred(this._ctx, 6))) {
                        throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 6)");
                    }
                    this.state = 322;
                    localctx.op = this._input.LT(1);
                    _la = this._input.LA(1);
                    if(!(_la===VtlParser.IN || _la===VtlParser.NOT_IN)) {
                        localctx.op = this._errHandler.recoverInline(this);
                    }
                    else {
                    	this._errHandler.reportMatch(this);
                        this.consume();
                    }
                    this.state = 323;
                    localctx.right = this.inexpr();
                    break;

                } 
            }
            this.state = 328;
            this._errHandler.sync(this);
            _alt = this._interp.adaptivePredict(this._input,7,this._ctx);
        }

    } catch( error) {
        if(error instanceof antlr4.error.RecognitionException) {
	        localctx.exception = error;
	        this._errHandler.reportError(this, error);
	        this._errHandler.recover(this, error);
	    } else {
	    	throw error;
	    }
    } finally {
        this.unrollRecursionContexts(_parentctx)
    }
    return localctx;
};


function FunctionsComponentsContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = VtlParser.RULE_functionsComponents;
    return this;
}

FunctionsComponentsContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
FunctionsComponentsContext.prototype.constructor = FunctionsComponentsContext;


 
FunctionsComponentsContext.prototype.copyFrom = function(ctx) {
    antlr4.ParserRuleContext.prototype.copyFrom.call(this, ctx);
};


function NumericFunctionsComponentsContext(parser, ctx) {
	FunctionsComponentsContext.call(this, parser);
    FunctionsComponentsContext.prototype.copyFrom.call(this, ctx);
    return this;
}

NumericFunctionsComponentsContext.prototype = Object.create(FunctionsComponentsContext.prototype);
NumericFunctionsComponentsContext.prototype.constructor = NumericFunctionsComponentsContext;

VtlParser.NumericFunctionsComponentsContext = NumericFunctionsComponentsContext;

NumericFunctionsComponentsContext.prototype.numericOperatorsComponent = function() {
    return this.getTypedRuleContext(NumericOperatorsComponentContext,0);
};

function StringFunctionsComponentsContext(parser, ctx) {
	FunctionsComponentsContext.call(this, parser);
    FunctionsComponentsContext.prototype.copyFrom.call(this, ctx);
    return this;
}

StringFunctionsComponentsContext.prototype = Object.create(FunctionsComponentsContext.prototype);
StringFunctionsComponentsContext.prototype.constructor = StringFunctionsComponentsContext;

VtlParser.StringFunctionsComponentsContext = StringFunctionsComponentsContext;

StringFunctionsComponentsContext.prototype.stringOperatorsComponent = function() {
    return this.getTypedRuleContext(StringOperatorsComponentContext,0);
};

function ComparisonFunctionsComponentsContext(parser, ctx) {
	FunctionsComponentsContext.call(this, parser);
    FunctionsComponentsContext.prototype.copyFrom.call(this, ctx);
    return this;
}

ComparisonFunctionsComponentsContext.prototype = Object.create(FunctionsComponentsContext.prototype);
ComparisonFunctionsComponentsContext.prototype.constructor = ComparisonFunctionsComponentsContext;

VtlParser.ComparisonFunctionsComponentsContext = ComparisonFunctionsComponentsContext;

ComparisonFunctionsComponentsContext.prototype.comparisonOperatorsComponent = function() {
    return this.getTypedRuleContext(ComparisonOperatorsComponentContext,0);
};

function TimeFunctionsComponentsContext(parser, ctx) {
	FunctionsComponentsContext.call(this, parser);
    FunctionsComponentsContext.prototype.copyFrom.call(this, ctx);
    return this;
}

TimeFunctionsComponentsContext.prototype = Object.create(FunctionsComponentsContext.prototype);
TimeFunctionsComponentsContext.prototype.constructor = TimeFunctionsComponentsContext;

VtlParser.TimeFunctionsComponentsContext = TimeFunctionsComponentsContext;

TimeFunctionsComponentsContext.prototype.timeOperatorsComponent = function() {
    return this.getTypedRuleContext(TimeOperatorsComponentContext,0);
};

function GenericFunctionsComponentsContext(parser, ctx) {
	FunctionsComponentsContext.call(this, parser);
    FunctionsComponentsContext.prototype.copyFrom.call(this, ctx);
    return this;
}

GenericFunctionsComponentsContext.prototype = Object.create(FunctionsComponentsContext.prototype);
GenericFunctionsComponentsContext.prototype.constructor = GenericFunctionsComponentsContext;

VtlParser.GenericFunctionsComponentsContext = GenericFunctionsComponentsContext;

GenericFunctionsComponentsContext.prototype.genericOperatorsComponent = function() {
    return this.getTypedRuleContext(GenericOperatorsComponentContext,0);
};

function AnalyticFunctionsComponentsContext(parser, ctx) {
	FunctionsComponentsContext.call(this, parser);
    FunctionsComponentsContext.prototype.copyFrom.call(this, ctx);
    return this;
}

AnalyticFunctionsComponentsContext.prototype = Object.create(FunctionsComponentsContext.prototype);
AnalyticFunctionsComponentsContext.prototype.constructor = AnalyticFunctionsComponentsContext;

VtlParser.AnalyticFunctionsComponentsContext = AnalyticFunctionsComponentsContext;

AnalyticFunctionsComponentsContext.prototype.anFunctionComponent = function() {
    return this.getTypedRuleContext(AnFunctionComponentContext,0);
};

function ConditionalFunctionsComponentsContext(parser, ctx) {
	FunctionsComponentsContext.call(this, parser);
    FunctionsComponentsContext.prototype.copyFrom.call(this, ctx);
    return this;
}

ConditionalFunctionsComponentsContext.prototype = Object.create(FunctionsComponentsContext.prototype);
ConditionalFunctionsComponentsContext.prototype.constructor = ConditionalFunctionsComponentsContext;

VtlParser.ConditionalFunctionsComponentsContext = ConditionalFunctionsComponentsContext;

ConditionalFunctionsComponentsContext.prototype.conditionalOperatorsComponent = function() {
    return this.getTypedRuleContext(ConditionalOperatorsComponentContext,0);
};

function AggregateFunctionsComponentsContext(parser, ctx) {
	FunctionsComponentsContext.call(this, parser);
    FunctionsComponentsContext.prototype.copyFrom.call(this, ctx);
    return this;
}

AggregateFunctionsComponentsContext.prototype = Object.create(FunctionsComponentsContext.prototype);
AggregateFunctionsComponentsContext.prototype.constructor = AggregateFunctionsComponentsContext;

VtlParser.AggregateFunctionsComponentsContext = AggregateFunctionsComponentsContext;

AggregateFunctionsComponentsContext.prototype.aggrOperators = function() {
    return this.getTypedRuleContext(AggrOperatorsContext,0);
};


VtlParser.FunctionsComponentsContext = FunctionsComponentsContext;

VtlParser.prototype.functionsComponents = function() {

    var localctx = new FunctionsComponentsContext(this, this._ctx, this.state);
    this.enterRule(localctx, 8, VtlParser.RULE_functionsComponents);
    try {
        this.state = 337;
        this._errHandler.sync(this);
        var la_ = this._interp.adaptivePredict(this._input,8,this._ctx);
        switch(la_) {
        case 1:
            localctx = new GenericFunctionsComponentsContext(this, localctx);
            this.enterOuterAlt(localctx, 1);
            this.state = 329;
            this.genericOperatorsComponent();
            break;

        case 2:
            localctx = new StringFunctionsComponentsContext(this, localctx);
            this.enterOuterAlt(localctx, 2);
            this.state = 330;
            this.stringOperatorsComponent();
            break;

        case 3:
            localctx = new NumericFunctionsComponentsContext(this, localctx);
            this.enterOuterAlt(localctx, 3);
            this.state = 331;
            this.numericOperatorsComponent();
            break;

        case 4:
            localctx = new ComparisonFunctionsComponentsContext(this, localctx);
            this.enterOuterAlt(localctx, 4);
            this.state = 332;
            this.comparisonOperatorsComponent();
            break;

        case 5:
            localctx = new TimeFunctionsComponentsContext(this, localctx);
            this.enterOuterAlt(localctx, 5);
            this.state = 333;
            this.timeOperatorsComponent();
            break;

        case 6:
            localctx = new ConditionalFunctionsComponentsContext(this, localctx);
            this.enterOuterAlt(localctx, 6);
            this.state = 334;
            this.conditionalOperatorsComponent();
            break;

        case 7:
            localctx = new AggregateFunctionsComponentsContext(this, localctx);
            this.enterOuterAlt(localctx, 7);
            this.state = 335;
            this.aggrOperators();
            break;

        case 8:
            localctx = new AnalyticFunctionsComponentsContext(this, localctx);
            this.enterOuterAlt(localctx, 8);
            this.state = 336;
            this.anFunctionComponent();
            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


function FunctionsContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = VtlParser.RULE_functions;
    return this;
}

FunctionsContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
FunctionsContext.prototype.constructor = FunctionsContext;


 
FunctionsContext.prototype.copyFrom = function(ctx) {
    antlr4.ParserRuleContext.prototype.copyFrom.call(this, ctx);
};


function HierarchyFunctionsContext(parser, ctx) {
	FunctionsContext.call(this, parser);
    FunctionsContext.prototype.copyFrom.call(this, ctx);
    return this;
}

HierarchyFunctionsContext.prototype = Object.create(FunctionsContext.prototype);
HierarchyFunctionsContext.prototype.constructor = HierarchyFunctionsContext;

VtlParser.HierarchyFunctionsContext = HierarchyFunctionsContext;

HierarchyFunctionsContext.prototype.hierarchyOperators = function() {
    return this.getTypedRuleContext(HierarchyOperatorsContext,0);
};

function StringFunctionsContext(parser, ctx) {
	FunctionsContext.call(this, parser);
    FunctionsContext.prototype.copyFrom.call(this, ctx);
    return this;
}

StringFunctionsContext.prototype = Object.create(FunctionsContext.prototype);
StringFunctionsContext.prototype.constructor = StringFunctionsContext;

VtlParser.StringFunctionsContext = StringFunctionsContext;

StringFunctionsContext.prototype.stringOperators = function() {
    return this.getTypedRuleContext(StringOperatorsContext,0);
};

function ValidationFunctionsContext(parser, ctx) {
	FunctionsContext.call(this, parser);
    FunctionsContext.prototype.copyFrom.call(this, ctx);
    return this;
}

ValidationFunctionsContext.prototype = Object.create(FunctionsContext.prototype);
ValidationFunctionsContext.prototype.constructor = ValidationFunctionsContext;

VtlParser.ValidationFunctionsContext = ValidationFunctionsContext;

ValidationFunctionsContext.prototype.validationOperators = function() {
    return this.getTypedRuleContext(ValidationOperatorsContext,0);
};

function GenericFunctionsContext(parser, ctx) {
	FunctionsContext.call(this, parser);
    FunctionsContext.prototype.copyFrom.call(this, ctx);
    return this;
}

GenericFunctionsContext.prototype = Object.create(FunctionsContext.prototype);
GenericFunctionsContext.prototype.constructor = GenericFunctionsContext;

VtlParser.GenericFunctionsContext = GenericFunctionsContext;

GenericFunctionsContext.prototype.genericOperators = function() {
    return this.getTypedRuleContext(GenericOperatorsContext,0);
};

function ConditionalFunctionsContext(parser, ctx) {
	FunctionsContext.call(this, parser);
    FunctionsContext.prototype.copyFrom.call(this, ctx);
    return this;
}

ConditionalFunctionsContext.prototype = Object.create(FunctionsContext.prototype);
ConditionalFunctionsContext.prototype.constructor = ConditionalFunctionsContext;

VtlParser.ConditionalFunctionsContext = ConditionalFunctionsContext;

ConditionalFunctionsContext.prototype.conditionalOperators = function() {
    return this.getTypedRuleContext(ConditionalOperatorsContext,0);
};

function AggregateFunctionsContext(parser, ctx) {
	FunctionsContext.call(this, parser);
    FunctionsContext.prototype.copyFrom.call(this, ctx);
    return this;
}

AggregateFunctionsContext.prototype = Object.create(FunctionsContext.prototype);
AggregateFunctionsContext.prototype.constructor = AggregateFunctionsContext;

VtlParser.AggregateFunctionsContext = AggregateFunctionsContext;

AggregateFunctionsContext.prototype.aggrOperatorsGrouping = function() {
    return this.getTypedRuleContext(AggrOperatorsGroupingContext,0);
};

function JoinFunctionsContext(parser, ctx) {
	FunctionsContext.call(this, parser);
    FunctionsContext.prototype.copyFrom.call(this, ctx);
    return this;
}

JoinFunctionsContext.prototype = Object.create(FunctionsContext.prototype);
JoinFunctionsContext.prototype.constructor = JoinFunctionsContext;

VtlParser.JoinFunctionsContext = JoinFunctionsContext;

JoinFunctionsContext.prototype.joinOperators = function() {
    return this.getTypedRuleContext(JoinOperatorsContext,0);
};

function ComparisonFunctionsContext(parser, ctx) {
	FunctionsContext.call(this, parser);
    FunctionsContext.prototype.copyFrom.call(this, ctx);
    return this;
}

ComparisonFunctionsContext.prototype = Object.create(FunctionsContext.prototype);
ComparisonFunctionsContext.prototype.constructor = ComparisonFunctionsContext;

VtlParser.ComparisonFunctionsContext = ComparisonFunctionsContext;

ComparisonFunctionsContext.prototype.comparisonOperators = function() {
    return this.getTypedRuleContext(ComparisonOperatorsContext,0);
};

function NumericFunctionsContext(parser, ctx) {
	FunctionsContext.call(this, parser);
    FunctionsContext.prototype.copyFrom.call(this, ctx);
    return this;
}

NumericFunctionsContext.prototype = Object.create(FunctionsContext.prototype);
NumericFunctionsContext.prototype.constructor = NumericFunctionsContext;

VtlParser.NumericFunctionsContext = NumericFunctionsContext;

NumericFunctionsContext.prototype.numericOperators = function() {
    return this.getTypedRuleContext(NumericOperatorsContext,0);
};

function TimeFunctionsContext(parser, ctx) {
	FunctionsContext.call(this, parser);
    FunctionsContext.prototype.copyFrom.call(this, ctx);
    return this;
}

TimeFunctionsContext.prototype = Object.create(FunctionsContext.prototype);
TimeFunctionsContext.prototype.constructor = TimeFunctionsContext;

VtlParser.TimeFunctionsContext = TimeFunctionsContext;

TimeFunctionsContext.prototype.timeOperators = function() {
    return this.getTypedRuleContext(TimeOperatorsContext,0);
};

function SetFunctionsContext(parser, ctx) {
	FunctionsContext.call(this, parser);
    FunctionsContext.prototype.copyFrom.call(this, ctx);
    return this;
}

SetFunctionsContext.prototype = Object.create(FunctionsContext.prototype);
SetFunctionsContext.prototype.constructor = SetFunctionsContext;

VtlParser.SetFunctionsContext = SetFunctionsContext;

SetFunctionsContext.prototype.setOperators = function() {
    return this.getTypedRuleContext(SetOperatorsContext,0);
};

function AnalyticFunctionsContext(parser, ctx) {
	FunctionsContext.call(this, parser);
    FunctionsContext.prototype.copyFrom.call(this, ctx);
    return this;
}

AnalyticFunctionsContext.prototype = Object.create(FunctionsContext.prototype);
AnalyticFunctionsContext.prototype.constructor = AnalyticFunctionsContext;

VtlParser.AnalyticFunctionsContext = AnalyticFunctionsContext;

AnalyticFunctionsContext.prototype.anFunction = function() {
    return this.getTypedRuleContext(AnFunctionContext,0);
};


VtlParser.FunctionsContext = FunctionsContext;

VtlParser.prototype.functions = function() {

    var localctx = new FunctionsContext(this, this._ctx, this.state);
    this.enterRule(localctx, 10, VtlParser.RULE_functions);
    try {
        this.state = 351;
        this._errHandler.sync(this);
        var la_ = this._interp.adaptivePredict(this._input,9,this._ctx);
        switch(la_) {
        case 1:
            localctx = new JoinFunctionsContext(this, localctx);
            this.enterOuterAlt(localctx, 1);
            this.state = 339;
            this.joinOperators();
            break;

        case 2:
            localctx = new GenericFunctionsContext(this, localctx);
            this.enterOuterAlt(localctx, 2);
            this.state = 340;
            this.genericOperators();
            break;

        case 3:
            localctx = new StringFunctionsContext(this, localctx);
            this.enterOuterAlt(localctx, 3);
            this.state = 341;
            this.stringOperators();
            break;

        case 4:
            localctx = new NumericFunctionsContext(this, localctx);
            this.enterOuterAlt(localctx, 4);
            this.state = 342;
            this.numericOperators();
            break;

        case 5:
            localctx = new ComparisonFunctionsContext(this, localctx);
            this.enterOuterAlt(localctx, 5);
            this.state = 343;
            this.comparisonOperators();
            break;

        case 6:
            localctx = new TimeFunctionsContext(this, localctx);
            this.enterOuterAlt(localctx, 6);
            this.state = 344;
            this.timeOperators();
            break;

        case 7:
            localctx = new SetFunctionsContext(this, localctx);
            this.enterOuterAlt(localctx, 7);
            this.state = 345;
            this.setOperators();
            break;

        case 8:
            localctx = new HierarchyFunctionsContext(this, localctx);
            this.enterOuterAlt(localctx, 8);
            this.state = 346;
            this.hierarchyOperators();
            break;

        case 9:
            localctx = new ValidationFunctionsContext(this, localctx);
            this.enterOuterAlt(localctx, 9);
            this.state = 347;
            this.validationOperators();
            break;

        case 10:
            localctx = new ConditionalFunctionsContext(this, localctx);
            this.enterOuterAlt(localctx, 10);
            this.state = 348;
            this.conditionalOperators();
            break;

        case 11:
            localctx = new AggregateFunctionsContext(this, localctx);
            this.enterOuterAlt(localctx, 11);
            this.state = 349;
            this.aggrOperatorsGrouping();
            break;

        case 12:
            localctx = new AnalyticFunctionsContext(this, localctx);
            this.enterOuterAlt(localctx, 12);
            this.state = 350;
            this.anFunction();
            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


function DatasetClauseContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = VtlParser.RULE_datasetClause;
    return this;
}

DatasetClauseContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
DatasetClauseContext.prototype.constructor = DatasetClauseContext;

DatasetClauseContext.prototype.renameClause = function() {
    return this.getTypedRuleContext(RenameClauseContext,0);
};

DatasetClauseContext.prototype.aggrClause = function() {
    return this.getTypedRuleContext(AggrClauseContext,0);
};

DatasetClauseContext.prototype.filterClause = function() {
    return this.getTypedRuleContext(FilterClauseContext,0);
};

DatasetClauseContext.prototype.calcClause = function() {
    return this.getTypedRuleContext(CalcClauseContext,0);
};

DatasetClauseContext.prototype.keepOrDropClause = function() {
    return this.getTypedRuleContext(KeepOrDropClauseContext,0);
};

DatasetClauseContext.prototype.pivotOrUnpivotClause = function() {
    return this.getTypedRuleContext(PivotOrUnpivotClauseContext,0);
};

DatasetClauseContext.prototype.subspaceClause = function() {
    return this.getTypedRuleContext(SubspaceClauseContext,0);
};




VtlParser.DatasetClauseContext = DatasetClauseContext;

VtlParser.prototype.datasetClause = function() {

    var localctx = new DatasetClauseContext(this, this._ctx, this.state);
    this.enterRule(localctx, 12, VtlParser.RULE_datasetClause);
    try {
        this.state = 360;
        this._errHandler.sync(this);
        switch(this._input.LA(1)) {
        case VtlParser.RENAME:
            this.enterOuterAlt(localctx, 1);
            this.state = 353;
            this.renameClause();
            break;
        case VtlParser.AGGREGATE:
            this.enterOuterAlt(localctx, 2);
            this.state = 354;
            this.aggrClause();
            break;
        case VtlParser.FILTER:
            this.enterOuterAlt(localctx, 3);
            this.state = 355;
            this.filterClause();
            break;
        case VtlParser.CALC:
            this.enterOuterAlt(localctx, 4);
            this.state = 356;
            this.calcClause();
            break;
        case VtlParser.DROP:
        case VtlParser.KEEP:
            this.enterOuterAlt(localctx, 5);
            this.state = 357;
            this.keepOrDropClause();
            break;
        case VtlParser.PIVOT:
        case VtlParser.UNPIVOT:
            this.enterOuterAlt(localctx, 6);
            this.state = 358;
            this.pivotOrUnpivotClause();
            break;
        case VtlParser.SUBSPACE:
            this.enterOuterAlt(localctx, 7);
            this.state = 359;
            this.subspaceClause();
            break;
        default:
            throw new antlr4.error.NoViableAltException(this);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


function RenameClauseContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = VtlParser.RULE_renameClause;
    return this;
}

RenameClauseContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
RenameClauseContext.prototype.constructor = RenameClauseContext;

RenameClauseContext.prototype.RENAME = function() {
    return this.getToken(VtlParser.RENAME, 0);
};

RenameClauseContext.prototype.renameClauseItem = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(RenameClauseItemContext);
    } else {
        return this.getTypedRuleContext(RenameClauseItemContext,i);
    }
};

RenameClauseContext.prototype.COMMA = function(i) {
	if(i===undefined) {
		i = null;
	}
    if(i===null) {
        return this.getTokens(VtlParser.COMMA);
    } else {
        return this.getToken(VtlParser.COMMA, i);
    }
};





VtlParser.RenameClauseContext = RenameClauseContext;

VtlParser.prototype.renameClause = function() {

    var localctx = new RenameClauseContext(this, this._ctx, this.state);
    this.enterRule(localctx, 14, VtlParser.RULE_renameClause);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 362;
        this.match(VtlParser.RENAME);
        this.state = 363;
        this.renameClauseItem();
        this.state = 368;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while(_la===VtlParser.COMMA) {
            this.state = 364;
            this.match(VtlParser.COMMA);
            this.state = 365;
            this.renameClauseItem();
            this.state = 370;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


function AggrClauseContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = VtlParser.RULE_aggrClause;
    return this;
}

AggrClauseContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
AggrClauseContext.prototype.constructor = AggrClauseContext;

AggrClauseContext.prototype.AGGREGATE = function() {
    return this.getToken(VtlParser.AGGREGATE, 0);
};

AggrClauseContext.prototype.aggregateClause = function() {
    return this.getTypedRuleContext(AggregateClauseContext,0);
};

AggrClauseContext.prototype.groupingClause = function() {
    return this.getTypedRuleContext(GroupingClauseContext,0);
};

AggrClauseContext.prototype.havingClause = function() {
    return this.getTypedRuleContext(HavingClauseContext,0);
};




VtlParser.AggrClauseContext = AggrClauseContext;

VtlParser.prototype.aggrClause = function() {

    var localctx = new AggrClauseContext(this, this._ctx, this.state);
    this.enterRule(localctx, 16, VtlParser.RULE_aggrClause);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 371;
        this.match(VtlParser.AGGREGATE);
        this.state = 372;
        this.aggregateClause();
        this.state = 377;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if(_la===VtlParser.GROUP) {
            this.state = 373;
            this.groupingClause();
            this.state = 375;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if(_la===VtlParser.HAVING) {
                this.state = 374;
                this.havingClause();
            }

        }

    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


function FilterClauseContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = VtlParser.RULE_filterClause;
    return this;
}

FilterClauseContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
FilterClauseContext.prototype.constructor = FilterClauseContext;

FilterClauseContext.prototype.FILTER = function() {
    return this.getToken(VtlParser.FILTER, 0);
};

FilterClauseContext.prototype.exprComponent = function() {
    return this.getTypedRuleContext(ExprComponentContext,0);
};




VtlParser.FilterClauseContext = FilterClauseContext;

VtlParser.prototype.filterClause = function() {

    var localctx = new FilterClauseContext(this, this._ctx, this.state);
    this.enterRule(localctx, 18, VtlParser.RULE_filterClause);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 379;
        this.match(VtlParser.FILTER);
        this.state = 380;
        this.exprComponent(0);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


function CalcClauseContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = VtlParser.RULE_calcClause;
    return this;
}

CalcClauseContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
CalcClauseContext.prototype.constructor = CalcClauseContext;

CalcClauseContext.prototype.CALC = function() {
    return this.getToken(VtlParser.CALC, 0);
};

CalcClauseContext.prototype.calcClauseItem = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(CalcClauseItemContext);
    } else {
        return this.getTypedRuleContext(CalcClauseItemContext,i);
    }
};

CalcClauseContext.prototype.COMMA = function(i) {
	if(i===undefined) {
		i = null;
	}
    if(i===null) {
        return this.getTokens(VtlParser.COMMA);
    } else {
        return this.getToken(VtlParser.COMMA, i);
    }
};





VtlParser.CalcClauseContext = CalcClauseContext;

VtlParser.prototype.calcClause = function() {

    var localctx = new CalcClauseContext(this, this._ctx, this.state);
    this.enterRule(localctx, 20, VtlParser.RULE_calcClause);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 382;
        this.match(VtlParser.CALC);
        this.state = 383;
        this.calcClauseItem();
        this.state = 388;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while(_la===VtlParser.COMMA) {
            this.state = 384;
            this.match(VtlParser.COMMA);
            this.state = 385;
            this.calcClauseItem();
            this.state = 390;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


function KeepOrDropClauseContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = VtlParser.RULE_keepOrDropClause;
    this.op = null; // Token
    return this;
}

KeepOrDropClauseContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
KeepOrDropClauseContext.prototype.constructor = KeepOrDropClauseContext;

KeepOrDropClauseContext.prototype.componentID = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(ComponentIDContext);
    } else {
        return this.getTypedRuleContext(ComponentIDContext,i);
    }
};

KeepOrDropClauseContext.prototype.KEEP = function() {
    return this.getToken(VtlParser.KEEP, 0);
};

KeepOrDropClauseContext.prototype.DROP = function() {
    return this.getToken(VtlParser.DROP, 0);
};

KeepOrDropClauseContext.prototype.COMMA = function(i) {
	if(i===undefined) {
		i = null;
	}
    if(i===null) {
        return this.getTokens(VtlParser.COMMA);
    } else {
        return this.getToken(VtlParser.COMMA, i);
    }
};





VtlParser.KeepOrDropClauseContext = KeepOrDropClauseContext;

VtlParser.prototype.keepOrDropClause = function() {

    var localctx = new KeepOrDropClauseContext(this, this._ctx, this.state);
    this.enterRule(localctx, 22, VtlParser.RULE_keepOrDropClause);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 391;
        localctx.op = this._input.LT(1);
        _la = this._input.LA(1);
        if(!(_la===VtlParser.DROP || _la===VtlParser.KEEP)) {
            localctx.op = this._errHandler.recoverInline(this);
        }
        else {
        	this._errHandler.reportMatch(this);
            this.consume();
        }
        this.state = 392;
        this.componentID();
        this.state = 397;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while(_la===VtlParser.COMMA) {
            this.state = 393;
            this.match(VtlParser.COMMA);
            this.state = 394;
            this.componentID();
            this.state = 399;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


function PivotOrUnpivotClauseContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = VtlParser.RULE_pivotOrUnpivotClause;
    this.op = null; // Token
    this.id_ = null; // ComponentIDContext
    this.mea = null; // ComponentIDContext
    return this;
}

PivotOrUnpivotClauseContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
PivotOrUnpivotClauseContext.prototype.constructor = PivotOrUnpivotClauseContext;

PivotOrUnpivotClauseContext.prototype.COMMA = function() {
    return this.getToken(VtlParser.COMMA, 0);
};

PivotOrUnpivotClauseContext.prototype.componentID = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(ComponentIDContext);
    } else {
        return this.getTypedRuleContext(ComponentIDContext,i);
    }
};

PivotOrUnpivotClauseContext.prototype.PIVOT = function() {
    return this.getToken(VtlParser.PIVOT, 0);
};

PivotOrUnpivotClauseContext.prototype.UNPIVOT = function() {
    return this.getToken(VtlParser.UNPIVOT, 0);
};




VtlParser.PivotOrUnpivotClauseContext = PivotOrUnpivotClauseContext;

VtlParser.prototype.pivotOrUnpivotClause = function() {

    var localctx = new PivotOrUnpivotClauseContext(this, this._ctx, this.state);
    this.enterRule(localctx, 24, VtlParser.RULE_pivotOrUnpivotClause);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 400;
        localctx.op = this._input.LT(1);
        _la = this._input.LA(1);
        if(!(_la===VtlParser.PIVOT || _la===VtlParser.UNPIVOT)) {
            localctx.op = this._errHandler.recoverInline(this);
        }
        else {
        	this._errHandler.reportMatch(this);
            this.consume();
        }
        this.state = 401;
        localctx.id_ = this.componentID();
        this.state = 402;
        this.match(VtlParser.COMMA);
        this.state = 403;
        localctx.mea = this.componentID();
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


function SubspaceClauseContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = VtlParser.RULE_subspaceClause;
    return this;
}

SubspaceClauseContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
SubspaceClauseContext.prototype.constructor = SubspaceClauseContext;

SubspaceClauseContext.prototype.SUBSPACE = function() {
    return this.getToken(VtlParser.SUBSPACE, 0);
};

SubspaceClauseContext.prototype.subspaceClauseItem = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(SubspaceClauseItemContext);
    } else {
        return this.getTypedRuleContext(SubspaceClauseItemContext,i);
    }
};

SubspaceClauseContext.prototype.COMMA = function(i) {
	if(i===undefined) {
		i = null;
	}
    if(i===null) {
        return this.getTokens(VtlParser.COMMA);
    } else {
        return this.getToken(VtlParser.COMMA, i);
    }
};





VtlParser.SubspaceClauseContext = SubspaceClauseContext;

VtlParser.prototype.subspaceClause = function() {

    var localctx = new SubspaceClauseContext(this, this._ctx, this.state);
    this.enterRule(localctx, 26, VtlParser.RULE_subspaceClause);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 405;
        this.match(VtlParser.SUBSPACE);
        this.state = 406;
        this.subspaceClauseItem();
        this.state = 411;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while(_la===VtlParser.COMMA) {
            this.state = 407;
            this.match(VtlParser.COMMA);
            this.state = 408;
            this.subspaceClauseItem();
            this.state = 413;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


function JoinOperatorsContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = VtlParser.RULE_joinOperators;
    return this;
}

JoinOperatorsContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
JoinOperatorsContext.prototype.constructor = JoinOperatorsContext;


 
JoinOperatorsContext.prototype.copyFrom = function(ctx) {
    antlr4.ParserRuleContext.prototype.copyFrom.call(this, ctx);
};


function JoinExprContext(parser, ctx) {
	JoinOperatorsContext.call(this, parser);
    this.joinKeyword = null; // Token;
    JoinOperatorsContext.prototype.copyFrom.call(this, ctx);
    return this;
}

JoinExprContext.prototype = Object.create(JoinOperatorsContext.prototype);
JoinExprContext.prototype.constructor = JoinExprContext;

VtlParser.JoinExprContext = JoinExprContext;

JoinExprContext.prototype.LPAREN = function() {
    return this.getToken(VtlParser.LPAREN, 0);
};

JoinExprContext.prototype.joinClause = function() {
    return this.getTypedRuleContext(JoinClauseContext,0);
};

JoinExprContext.prototype.joinBody = function() {
    return this.getTypedRuleContext(JoinBodyContext,0);
};

JoinExprContext.prototype.RPAREN = function() {
    return this.getToken(VtlParser.RPAREN, 0);
};

JoinExprContext.prototype.INNER_JOIN = function() {
    return this.getToken(VtlParser.INNER_JOIN, 0);
};

JoinExprContext.prototype.LEFT_JOIN = function() {
    return this.getToken(VtlParser.LEFT_JOIN, 0);
};

JoinExprContext.prototype.joinClauseWithoutUsing = function() {
    return this.getTypedRuleContext(JoinClauseWithoutUsingContext,0);
};

JoinExprContext.prototype.FULL_JOIN = function() {
    return this.getToken(VtlParser.FULL_JOIN, 0);
};

JoinExprContext.prototype.CROSS_JOIN = function() {
    return this.getToken(VtlParser.CROSS_JOIN, 0);
};


VtlParser.JoinOperatorsContext = JoinOperatorsContext;

VtlParser.prototype.joinOperators = function() {

    var localctx = new JoinOperatorsContext(this, this._ctx, this.state);
    this.enterRule(localctx, 28, VtlParser.RULE_joinOperators);
    var _la = 0; // Token type
    try {
        this.state = 426;
        this._errHandler.sync(this);
        switch(this._input.LA(1)) {
        case VtlParser.INNER_JOIN:
        case VtlParser.LEFT_JOIN:
            localctx = new JoinExprContext(this, localctx);
            this.enterOuterAlt(localctx, 1);
            this.state = 414;
            localctx.joinKeyword = this._input.LT(1);
            _la = this._input.LA(1);
            if(!(_la===VtlParser.INNER_JOIN || _la===VtlParser.LEFT_JOIN)) {
                localctx.joinKeyword = this._errHandler.recoverInline(this);
            }
            else {
            	this._errHandler.reportMatch(this);
                this.consume();
            }
            this.state = 415;
            this.match(VtlParser.LPAREN);
            this.state = 416;
            this.joinClause();
            this.state = 417;
            this.joinBody();
            this.state = 418;
            this.match(VtlParser.RPAREN);
            break;
        case VtlParser.CROSS_JOIN:
        case VtlParser.FULL_JOIN:
            localctx = new JoinExprContext(this, localctx);
            this.enterOuterAlt(localctx, 2);
            this.state = 420;
            localctx.joinKeyword = this._input.LT(1);
            _la = this._input.LA(1);
            if(!(_la===VtlParser.CROSS_JOIN || _la===VtlParser.FULL_JOIN)) {
                localctx.joinKeyword = this._errHandler.recoverInline(this);
            }
            else {
            	this._errHandler.reportMatch(this);
                this.consume();
            }
            this.state = 421;
            this.match(VtlParser.LPAREN);
            this.state = 422;
            this.joinClauseWithoutUsing();
            this.state = 423;
            this.joinBody();
            this.state = 424;
            this.match(VtlParser.RPAREN);
            break;
        default:
            throw new antlr4.error.NoViableAltException(this);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


function DefOperatorsContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = VtlParser.RULE_defOperators;
    return this;
}

DefOperatorsContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
DefOperatorsContext.prototype.constructor = DefOperatorsContext;


 
DefOperatorsContext.prototype.copyFrom = function(ctx) {
    antlr4.ParserRuleContext.prototype.copyFrom.call(this, ctx);
};


function DefOperatorContext(parser, ctx) {
	DefOperatorsContext.call(this, parser);
    DefOperatorsContext.prototype.copyFrom.call(this, ctx);
    return this;
}

DefOperatorContext.prototype = Object.create(DefOperatorsContext.prototype);
DefOperatorContext.prototype.constructor = DefOperatorContext;

VtlParser.DefOperatorContext = DefOperatorContext;

DefOperatorContext.prototype.DEFINE = function() {
    return this.getToken(VtlParser.DEFINE, 0);
};

DefOperatorContext.prototype.OPERATOR = function(i) {
	if(i===undefined) {
		i = null;
	}
    if(i===null) {
        return this.getTokens(VtlParser.OPERATOR);
    } else {
        return this.getToken(VtlParser.OPERATOR, i);
    }
};


DefOperatorContext.prototype.operatorID = function() {
    return this.getTypedRuleContext(OperatorIDContext,0);
};

DefOperatorContext.prototype.LPAREN = function() {
    return this.getToken(VtlParser.LPAREN, 0);
};

DefOperatorContext.prototype.RPAREN = function() {
    return this.getToken(VtlParser.RPAREN, 0);
};

DefOperatorContext.prototype.IS = function() {
    return this.getToken(VtlParser.IS, 0);
};

DefOperatorContext.prototype.END = function() {
    return this.getToken(VtlParser.END, 0);
};

DefOperatorContext.prototype.expr = function() {
    return this.getTypedRuleContext(ExprContext,0);
};

DefOperatorContext.prototype.parameterItem = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(ParameterItemContext);
    } else {
        return this.getTypedRuleContext(ParameterItemContext,i);
    }
};

DefOperatorContext.prototype.RETURNS = function() {
    return this.getToken(VtlParser.RETURNS, 0);
};

DefOperatorContext.prototype.outputParameterType = function() {
    return this.getTypedRuleContext(OutputParameterTypeContext,0);
};

DefOperatorContext.prototype.COMMA = function(i) {
	if(i===undefined) {
		i = null;
	}
    if(i===null) {
        return this.getTokens(VtlParser.COMMA);
    } else {
        return this.getToken(VtlParser.COMMA, i);
    }
};


function DefHierarchicalContext(parser, ctx) {
	DefOperatorsContext.call(this, parser);
    DefOperatorsContext.prototype.copyFrom.call(this, ctx);
    return this;
}

DefHierarchicalContext.prototype = Object.create(DefOperatorsContext.prototype);
DefHierarchicalContext.prototype.constructor = DefHierarchicalContext;

VtlParser.DefHierarchicalContext = DefHierarchicalContext;

DefHierarchicalContext.prototype.DEFINE = function() {
    return this.getToken(VtlParser.DEFINE, 0);
};

DefHierarchicalContext.prototype.HIERARCHICAL = function(i) {
	if(i===undefined) {
		i = null;
	}
    if(i===null) {
        return this.getTokens(VtlParser.HIERARCHICAL);
    } else {
        return this.getToken(VtlParser.HIERARCHICAL, i);
    }
};


DefHierarchicalContext.prototype.RULESET = function(i) {
	if(i===undefined) {
		i = null;
	}
    if(i===null) {
        return this.getTokens(VtlParser.RULESET);
    } else {
        return this.getToken(VtlParser.RULESET, i);
    }
};


DefHierarchicalContext.prototype.rulesetID = function() {
    return this.getTypedRuleContext(RulesetIDContext,0);
};

DefHierarchicalContext.prototype.LPAREN = function() {
    return this.getToken(VtlParser.LPAREN, 0);
};

DefHierarchicalContext.prototype.hierRuleSignature = function() {
    return this.getTypedRuleContext(HierRuleSignatureContext,0);
};

DefHierarchicalContext.prototype.RPAREN = function() {
    return this.getToken(VtlParser.RPAREN, 0);
};

DefHierarchicalContext.prototype.IS = function() {
    return this.getToken(VtlParser.IS, 0);
};

DefHierarchicalContext.prototype.ruleClauseHierarchical = function() {
    return this.getTypedRuleContext(RuleClauseHierarchicalContext,0);
};

DefHierarchicalContext.prototype.END = function() {
    return this.getToken(VtlParser.END, 0);
};

function DefDatapointRulesetContext(parser, ctx) {
	DefOperatorsContext.call(this, parser);
    DefOperatorsContext.prototype.copyFrom.call(this, ctx);
    return this;
}

DefDatapointRulesetContext.prototype = Object.create(DefOperatorsContext.prototype);
DefDatapointRulesetContext.prototype.constructor = DefDatapointRulesetContext;

VtlParser.DefDatapointRulesetContext = DefDatapointRulesetContext;

DefDatapointRulesetContext.prototype.DEFINE = function() {
    return this.getToken(VtlParser.DEFINE, 0);
};

DefDatapointRulesetContext.prototype.DATAPOINT = function(i) {
	if(i===undefined) {
		i = null;
	}
    if(i===null) {
        return this.getTokens(VtlParser.DATAPOINT);
    } else {
        return this.getToken(VtlParser.DATAPOINT, i);
    }
};


DefDatapointRulesetContext.prototype.RULESET = function(i) {
	if(i===undefined) {
		i = null;
	}
    if(i===null) {
        return this.getTokens(VtlParser.RULESET);
    } else {
        return this.getToken(VtlParser.RULESET, i);
    }
};


DefDatapointRulesetContext.prototype.rulesetID = function() {
    return this.getTypedRuleContext(RulesetIDContext,0);
};

DefDatapointRulesetContext.prototype.LPAREN = function() {
    return this.getToken(VtlParser.LPAREN, 0);
};

DefDatapointRulesetContext.prototype.rulesetSignature = function() {
    return this.getTypedRuleContext(RulesetSignatureContext,0);
};

DefDatapointRulesetContext.prototype.RPAREN = function() {
    return this.getToken(VtlParser.RPAREN, 0);
};

DefDatapointRulesetContext.prototype.IS = function() {
    return this.getToken(VtlParser.IS, 0);
};

DefDatapointRulesetContext.prototype.ruleClauseDatapoint = function() {
    return this.getTypedRuleContext(RuleClauseDatapointContext,0);
};

DefDatapointRulesetContext.prototype.END = function() {
    return this.getToken(VtlParser.END, 0);
};


VtlParser.DefOperatorsContext = DefOperatorsContext;

VtlParser.prototype.defOperators = function() {

    var localctx = new DefOperatorsContext(this, this._ctx, this.state);
    this.enterRule(localctx, 30, VtlParser.RULE_defOperators);
    var _la = 0; // Token type
    try {
        this.state = 478;
        this._errHandler.sync(this);
        var la_ = this._interp.adaptivePredict(this._input,21,this._ctx);
        switch(la_) {
        case 1:
            localctx = new DefOperatorContext(this, localctx);
            this.enterOuterAlt(localctx, 1);
            this.state = 428;
            this.match(VtlParser.DEFINE);
            this.state = 429;
            this.match(VtlParser.OPERATOR);
            this.state = 430;
            this.operatorID();
            this.state = 431;
            this.match(VtlParser.LPAREN);
            this.state = 440;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if(_la===VtlParser.IDENTIFIER) {
                this.state = 432;
                this.parameterItem();
                this.state = 437;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
                while(_la===VtlParser.COMMA) {
                    this.state = 433;
                    this.match(VtlParser.COMMA);
                    this.state = 434;
                    this.parameterItem();
                    this.state = 439;
                    this._errHandler.sync(this);
                    _la = this._input.LA(1);
                }
            }

            this.state = 442;
            this.match(VtlParser.RPAREN);
            this.state = 445;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if(_la===VtlParser.RETURNS) {
                this.state = 443;
                this.match(VtlParser.RETURNS);
                this.state = 444;
                this.outputParameterType();
            }

            this.state = 447;
            this.match(VtlParser.IS);

            this.state = 448;
            this.expr(0);
            this.state = 449;
            this.match(VtlParser.END);
            this.state = 450;
            this.match(VtlParser.OPERATOR);
            break;

        case 2:
            localctx = new DefDatapointRulesetContext(this, localctx);
            this.enterOuterAlt(localctx, 2);
            this.state = 452;
            this.match(VtlParser.DEFINE);
            this.state = 453;
            this.match(VtlParser.DATAPOINT);
            this.state = 454;
            this.match(VtlParser.RULESET);
            this.state = 455;
            this.rulesetID();
            this.state = 456;
            this.match(VtlParser.LPAREN);
            this.state = 457;
            this.rulesetSignature();
            this.state = 458;
            this.match(VtlParser.RPAREN);
            this.state = 459;
            this.match(VtlParser.IS);
            this.state = 460;
            this.ruleClauseDatapoint();
            this.state = 461;
            this.match(VtlParser.END);
            this.state = 462;
            this.match(VtlParser.DATAPOINT);
            this.state = 463;
            this.match(VtlParser.RULESET);
            break;

        case 3:
            localctx = new DefHierarchicalContext(this, localctx);
            this.enterOuterAlt(localctx, 3);
            this.state = 465;
            this.match(VtlParser.DEFINE);
            this.state = 466;
            this.match(VtlParser.HIERARCHICAL);
            this.state = 467;
            this.match(VtlParser.RULESET);
            this.state = 468;
            this.rulesetID();
            this.state = 469;
            this.match(VtlParser.LPAREN);
            this.state = 470;
            this.hierRuleSignature();
            this.state = 471;
            this.match(VtlParser.RPAREN);
            this.state = 472;
            this.match(VtlParser.IS);
            this.state = 473;
            this.ruleClauseHierarchical();
            this.state = 474;
            this.match(VtlParser.END);
            this.state = 475;
            this.match(VtlParser.HIERARCHICAL);
            this.state = 476;
            this.match(VtlParser.RULESET);
            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


function GenericOperatorsContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = VtlParser.RULE_genericOperators;
    return this;
}

GenericOperatorsContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
GenericOperatorsContext.prototype.constructor = GenericOperatorsContext;


 
GenericOperatorsContext.prototype.copyFrom = function(ctx) {
    antlr4.ParserRuleContext.prototype.copyFrom.call(this, ctx);
};


function EvalAtomContext(parser, ctx) {
	GenericOperatorsContext.call(this, parser);
    GenericOperatorsContext.prototype.copyFrom.call(this, ctx);
    return this;
}

EvalAtomContext.prototype = Object.create(GenericOperatorsContext.prototype);
EvalAtomContext.prototype.constructor = EvalAtomContext;

VtlParser.EvalAtomContext = EvalAtomContext;

EvalAtomContext.prototype.EVAL = function() {
    return this.getToken(VtlParser.EVAL, 0);
};

EvalAtomContext.prototype.LPAREN = function(i) {
	if(i===undefined) {
		i = null;
	}
    if(i===null) {
        return this.getTokens(VtlParser.LPAREN);
    } else {
        return this.getToken(VtlParser.LPAREN, i);
    }
};


EvalAtomContext.prototype.routineName = function() {
    return this.getTypedRuleContext(RoutineNameContext,0);
};

EvalAtomContext.prototype.RPAREN = function(i) {
	if(i===undefined) {
		i = null;
	}
    if(i===null) {
        return this.getTokens(VtlParser.RPAREN);
    } else {
        return this.getToken(VtlParser.RPAREN, i);
    }
};


EvalAtomContext.prototype.varID = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(VarIDContext);
    } else {
        return this.getTypedRuleContext(VarIDContext,i);
    }
};

EvalAtomContext.prototype.constant = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(ConstantContext);
    } else {
        return this.getTypedRuleContext(ConstantContext,i);
    }
};

EvalAtomContext.prototype.COMMA = function(i) {
	if(i===undefined) {
		i = null;
	}
    if(i===null) {
        return this.getTokens(VtlParser.COMMA);
    } else {
        return this.getToken(VtlParser.COMMA, i);
    }
};


EvalAtomContext.prototype.LANGUAGE = function() {
    return this.getToken(VtlParser.LANGUAGE, 0);
};

EvalAtomContext.prototype.STRING_CONSTANT = function() {
    return this.getToken(VtlParser.STRING_CONSTANT, 0);
};

EvalAtomContext.prototype.RETURNS = function() {
    return this.getToken(VtlParser.RETURNS, 0);
};

EvalAtomContext.prototype.datasetType = function() {
    return this.getTypedRuleContext(DatasetTypeContext,0);
};

function CastExprDatasetContext(parser, ctx) {
	GenericOperatorsContext.call(this, parser);
    GenericOperatorsContext.prototype.copyFrom.call(this, ctx);
    return this;
}

CastExprDatasetContext.prototype = Object.create(GenericOperatorsContext.prototype);
CastExprDatasetContext.prototype.constructor = CastExprDatasetContext;

VtlParser.CastExprDatasetContext = CastExprDatasetContext;

CastExprDatasetContext.prototype.CAST = function() {
    return this.getToken(VtlParser.CAST, 0);
};

CastExprDatasetContext.prototype.LPAREN = function() {
    return this.getToken(VtlParser.LPAREN, 0);
};

CastExprDatasetContext.prototype.expr = function() {
    return this.getTypedRuleContext(ExprContext,0);
};

CastExprDatasetContext.prototype.COMMA = function(i) {
	if(i===undefined) {
		i = null;
	}
    if(i===null) {
        return this.getTokens(VtlParser.COMMA);
    } else {
        return this.getToken(VtlParser.COMMA, i);
    }
};


CastExprDatasetContext.prototype.RPAREN = function() {
    return this.getToken(VtlParser.RPAREN, 0);
};

CastExprDatasetContext.prototype.basicScalarType = function() {
    return this.getTypedRuleContext(BasicScalarTypeContext,0);
};

CastExprDatasetContext.prototype.valueDomainName = function() {
    return this.getTypedRuleContext(ValueDomainNameContext,0);
};

CastExprDatasetContext.prototype.STRING_CONSTANT = function() {
    return this.getToken(VtlParser.STRING_CONSTANT, 0);
};

function CallDatasetContext(parser, ctx) {
	GenericOperatorsContext.call(this, parser);
    GenericOperatorsContext.prototype.copyFrom.call(this, ctx);
    return this;
}

CallDatasetContext.prototype = Object.create(GenericOperatorsContext.prototype);
CallDatasetContext.prototype.constructor = CallDatasetContext;

VtlParser.CallDatasetContext = CallDatasetContext;

CallDatasetContext.prototype.operatorID = function() {
    return this.getTypedRuleContext(OperatorIDContext,0);
};

CallDatasetContext.prototype.LPAREN = function() {
    return this.getToken(VtlParser.LPAREN, 0);
};

CallDatasetContext.prototype.RPAREN = function() {
    return this.getToken(VtlParser.RPAREN, 0);
};

CallDatasetContext.prototype.parameter = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(ParameterContext);
    } else {
        return this.getTypedRuleContext(ParameterContext,i);
    }
};

CallDatasetContext.prototype.COMMA = function(i) {
	if(i===undefined) {
		i = null;
	}
    if(i===null) {
        return this.getTokens(VtlParser.COMMA);
    } else {
        return this.getToken(VtlParser.COMMA, i);
    }
};



VtlParser.GenericOperatorsContext = GenericOperatorsContext;

VtlParser.prototype.genericOperators = function() {

    var localctx = new GenericOperatorsContext(this, this._ctx, this.state);
    this.enterRule(localctx, 32, VtlParser.RULE_genericOperators);
    var _la = 0; // Token type
    try {
        this.state = 537;
        this._errHandler.sync(this);
        switch(this._input.LA(1)) {
        case VtlParser.IDENTIFIER:
            localctx = new CallDatasetContext(this, localctx);
            this.enterOuterAlt(localctx, 1);
            this.state = 480;
            this.operatorID();
            this.state = 481;
            this.match(VtlParser.LPAREN);
            this.state = 490;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if(_la===VtlParser.NULL_CONSTANT || _la===VtlParser.OPTIONAL || ((((_la - 229)) & ~0x1f) == 0 && ((1 << (_la - 229)) & ((1 << (VtlParser.INTEGER_CONSTANT - 229)) | (1 << (VtlParser.NUMBER_CONSTANT - 229)) | (1 << (VtlParser.BOOLEAN_CONSTANT - 229)) | (1 << (VtlParser.STRING_CONSTANT - 229)) | (1 << (VtlParser.IDENTIFIER - 229)))) !== 0)) {
                this.state = 482;
                this.parameter();
                this.state = 487;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
                while(_la===VtlParser.COMMA) {
                    this.state = 483;
                    this.match(VtlParser.COMMA);
                    this.state = 484;
                    this.parameter();
                    this.state = 489;
                    this._errHandler.sync(this);
                    _la = this._input.LA(1);
                }
            }

            this.state = 492;
            this.match(VtlParser.RPAREN);
            break;
        case VtlParser.EVAL:
            localctx = new EvalAtomContext(this, localctx);
            this.enterOuterAlt(localctx, 2);
            this.state = 494;
            this.match(VtlParser.EVAL);
            this.state = 495;
            this.match(VtlParser.LPAREN);
            this.state = 496;
            this.routineName();
            this.state = 497;
            this.match(VtlParser.LPAREN);
            this.state = 500;
            this._errHandler.sync(this);
            switch (this._input.LA(1)) {
            case VtlParser.IDENTIFIER:
            	this.state = 498;
            	this.varID();
            	break;
            case VtlParser.NULL_CONSTANT:
            case VtlParser.INTEGER_CONSTANT:
            case VtlParser.NUMBER_CONSTANT:
            case VtlParser.BOOLEAN_CONSTANT:
            case VtlParser.STRING_CONSTANT:
            	this.state = 499;
            	this.constant();
            	break;
            case VtlParser.RPAREN:
            case VtlParser.COMMA:
            	break;
            default:
            	break;
            }
            this.state = 509;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            while(_la===VtlParser.COMMA) {
                this.state = 502;
                this.match(VtlParser.COMMA);
                this.state = 505;
                this._errHandler.sync(this);
                switch(this._input.LA(1)) {
                case VtlParser.IDENTIFIER:
                    this.state = 503;
                    this.varID();
                    break;
                case VtlParser.NULL_CONSTANT:
                case VtlParser.INTEGER_CONSTANT:
                case VtlParser.NUMBER_CONSTANT:
                case VtlParser.BOOLEAN_CONSTANT:
                case VtlParser.STRING_CONSTANT:
                    this.state = 504;
                    this.constant();
                    break;
                default:
                    throw new antlr4.error.NoViableAltException(this);
                }
                this.state = 511;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
            }
            this.state = 512;
            this.match(VtlParser.RPAREN);
            this.state = 515;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if(_la===VtlParser.LANGUAGE) {
                this.state = 513;
                this.match(VtlParser.LANGUAGE);
                this.state = 514;
                this.match(VtlParser.STRING_CONSTANT);
            }

            this.state = 519;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if(_la===VtlParser.RETURNS) {
                this.state = 517;
                this.match(VtlParser.RETURNS);
                this.state = 518;
                this.datasetType();
            }

            this.state = 521;
            this.match(VtlParser.RPAREN);
            break;
        case VtlParser.CAST:
            localctx = new CastExprDatasetContext(this, localctx);
            this.enterOuterAlt(localctx, 3);
            this.state = 523;
            this.match(VtlParser.CAST);
            this.state = 524;
            this.match(VtlParser.LPAREN);
            this.state = 525;
            this.expr(0);
            this.state = 526;
            this.match(VtlParser.COMMA);
            this.state = 529;
            this._errHandler.sync(this);
            switch(this._input.LA(1)) {
            case VtlParser.BOOLEAN:
            case VtlParser.DATE:
            case VtlParser.TIME_PERIOD:
            case VtlParser.NUMBER:
            case VtlParser.STRING:
            case VtlParser.TIME:
            case VtlParser.INTEGER:
            case VtlParser.DURATION:
            case VtlParser.SCALAR:
                this.state = 527;
                this.basicScalarType();
                break;
            case VtlParser.IDENTIFIER:
                this.state = 528;
                this.valueDomainName();
                break;
            default:
                throw new antlr4.error.NoViableAltException(this);
            }
            this.state = 533;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if(_la===VtlParser.COMMA) {
                this.state = 531;
                this.match(VtlParser.COMMA);
                this.state = 532;
                this.match(VtlParser.STRING_CONSTANT);
            }

            this.state = 535;
            this.match(VtlParser.RPAREN);
            break;
        default:
            throw new antlr4.error.NoViableAltException(this);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


function GenericOperatorsComponentContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = VtlParser.RULE_genericOperatorsComponent;
    return this;
}

GenericOperatorsComponentContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
GenericOperatorsComponentContext.prototype.constructor = GenericOperatorsComponentContext;


 
GenericOperatorsComponentContext.prototype.copyFrom = function(ctx) {
    antlr4.ParserRuleContext.prototype.copyFrom.call(this, ctx);
};


function EvalAtomComponentContext(parser, ctx) {
	GenericOperatorsComponentContext.call(this, parser);
    GenericOperatorsComponentContext.prototype.copyFrom.call(this, ctx);
    return this;
}

EvalAtomComponentContext.prototype = Object.create(GenericOperatorsComponentContext.prototype);
EvalAtomComponentContext.prototype.constructor = EvalAtomComponentContext;

VtlParser.EvalAtomComponentContext = EvalAtomComponentContext;

EvalAtomComponentContext.prototype.EVAL = function() {
    return this.getToken(VtlParser.EVAL, 0);
};

EvalAtomComponentContext.prototype.LPAREN = function(i) {
	if(i===undefined) {
		i = null;
	}
    if(i===null) {
        return this.getTokens(VtlParser.LPAREN);
    } else {
        return this.getToken(VtlParser.LPAREN, i);
    }
};


EvalAtomComponentContext.prototype.routineName = function() {
    return this.getTypedRuleContext(RoutineNameContext,0);
};

EvalAtomComponentContext.prototype.RPAREN = function(i) {
	if(i===undefined) {
		i = null;
	}
    if(i===null) {
        return this.getTokens(VtlParser.RPAREN);
    } else {
        return this.getToken(VtlParser.RPAREN, i);
    }
};


EvalAtomComponentContext.prototype.componentID = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(ComponentIDContext);
    } else {
        return this.getTypedRuleContext(ComponentIDContext,i);
    }
};

EvalAtomComponentContext.prototype.constant = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(ConstantContext);
    } else {
        return this.getTypedRuleContext(ConstantContext,i);
    }
};

EvalAtomComponentContext.prototype.COMMA = function(i) {
	if(i===undefined) {
		i = null;
	}
    if(i===null) {
        return this.getTokens(VtlParser.COMMA);
    } else {
        return this.getToken(VtlParser.COMMA, i);
    }
};


EvalAtomComponentContext.prototype.LANGUAGE = function() {
    return this.getToken(VtlParser.LANGUAGE, 0);
};

EvalAtomComponentContext.prototype.STRING_CONSTANT = function() {
    return this.getToken(VtlParser.STRING_CONSTANT, 0);
};

EvalAtomComponentContext.prototype.RETURNS = function() {
    return this.getToken(VtlParser.RETURNS, 0);
};

EvalAtomComponentContext.prototype.outputParameterTypeComponent = function() {
    return this.getTypedRuleContext(OutputParameterTypeComponentContext,0);
};

function CastExprComponentContext(parser, ctx) {
	GenericOperatorsComponentContext.call(this, parser);
    GenericOperatorsComponentContext.prototype.copyFrom.call(this, ctx);
    return this;
}

CastExprComponentContext.prototype = Object.create(GenericOperatorsComponentContext.prototype);
CastExprComponentContext.prototype.constructor = CastExprComponentContext;

VtlParser.CastExprComponentContext = CastExprComponentContext;

CastExprComponentContext.prototype.CAST = function() {
    return this.getToken(VtlParser.CAST, 0);
};

CastExprComponentContext.prototype.LPAREN = function() {
    return this.getToken(VtlParser.LPAREN, 0);
};

CastExprComponentContext.prototype.exprComponent = function() {
    return this.getTypedRuleContext(ExprComponentContext,0);
};

CastExprComponentContext.prototype.COMMA = function(i) {
	if(i===undefined) {
		i = null;
	}
    if(i===null) {
        return this.getTokens(VtlParser.COMMA);
    } else {
        return this.getToken(VtlParser.COMMA, i);
    }
};


CastExprComponentContext.prototype.RPAREN = function() {
    return this.getToken(VtlParser.RPAREN, 0);
};

CastExprComponentContext.prototype.basicScalarType = function() {
    return this.getTypedRuleContext(BasicScalarTypeContext,0);
};

CastExprComponentContext.prototype.valueDomainName = function() {
    return this.getTypedRuleContext(ValueDomainNameContext,0);
};

CastExprComponentContext.prototype.STRING_CONSTANT = function() {
    return this.getToken(VtlParser.STRING_CONSTANT, 0);
};

function CallComponentContext(parser, ctx) {
	GenericOperatorsComponentContext.call(this, parser);
    GenericOperatorsComponentContext.prototype.copyFrom.call(this, ctx);
    return this;
}

CallComponentContext.prototype = Object.create(GenericOperatorsComponentContext.prototype);
CallComponentContext.prototype.constructor = CallComponentContext;

VtlParser.CallComponentContext = CallComponentContext;

CallComponentContext.prototype.operatorID = function() {
    return this.getTypedRuleContext(OperatorIDContext,0);
};

CallComponentContext.prototype.LPAREN = function() {
    return this.getToken(VtlParser.LPAREN, 0);
};

CallComponentContext.prototype.RPAREN = function() {
    return this.getToken(VtlParser.RPAREN, 0);
};

CallComponentContext.prototype.parameterComponent = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(ParameterComponentContext);
    } else {
        return this.getTypedRuleContext(ParameterComponentContext,i);
    }
};

CallComponentContext.prototype.COMMA = function(i) {
	if(i===undefined) {
		i = null;
	}
    if(i===null) {
        return this.getTokens(VtlParser.COMMA);
    } else {
        return this.getToken(VtlParser.COMMA, i);
    }
};



VtlParser.GenericOperatorsComponentContext = GenericOperatorsComponentContext;

VtlParser.prototype.genericOperatorsComponent = function() {

    var localctx = new GenericOperatorsComponentContext(this, this._ctx, this.state);
    this.enterRule(localctx, 34, VtlParser.RULE_genericOperatorsComponent);
    var _la = 0; // Token type
    try {
        this.state = 596;
        this._errHandler.sync(this);
        switch(this._input.LA(1)) {
        case VtlParser.IDENTIFIER:
            localctx = new CallComponentContext(this, localctx);
            this.enterOuterAlt(localctx, 1);
            this.state = 539;
            this.operatorID();
            this.state = 540;
            this.match(VtlParser.LPAREN);
            this.state = 549;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if(_la===VtlParser.NULL_CONSTANT || _la===VtlParser.OPTIONAL || ((((_la - 229)) & ~0x1f) == 0 && ((1 << (_la - 229)) & ((1 << (VtlParser.INTEGER_CONSTANT - 229)) | (1 << (VtlParser.NUMBER_CONSTANT - 229)) | (1 << (VtlParser.BOOLEAN_CONSTANT - 229)) | (1 << (VtlParser.STRING_CONSTANT - 229)) | (1 << (VtlParser.IDENTIFIER - 229)))) !== 0)) {
                this.state = 541;
                this.parameterComponent();
                this.state = 546;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
                while(_la===VtlParser.COMMA) {
                    this.state = 542;
                    this.match(VtlParser.COMMA);
                    this.state = 543;
                    this.parameterComponent();
                    this.state = 548;
                    this._errHandler.sync(this);
                    _la = this._input.LA(1);
                }
            }

            this.state = 551;
            this.match(VtlParser.RPAREN);
            break;
        case VtlParser.CAST:
            localctx = new CastExprComponentContext(this, localctx);
            this.enterOuterAlt(localctx, 2);
            this.state = 553;
            this.match(VtlParser.CAST);
            this.state = 554;
            this.match(VtlParser.LPAREN);
            this.state = 555;
            this.exprComponent(0);
            this.state = 556;
            this.match(VtlParser.COMMA);
            this.state = 559;
            this._errHandler.sync(this);
            switch(this._input.LA(1)) {
            case VtlParser.BOOLEAN:
            case VtlParser.DATE:
            case VtlParser.TIME_PERIOD:
            case VtlParser.NUMBER:
            case VtlParser.STRING:
            case VtlParser.TIME:
            case VtlParser.INTEGER:
            case VtlParser.DURATION:
            case VtlParser.SCALAR:
                this.state = 557;
                this.basicScalarType();
                break;
            case VtlParser.IDENTIFIER:
                this.state = 558;
                this.valueDomainName();
                break;
            default:
                throw new antlr4.error.NoViableAltException(this);
            }
            this.state = 563;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if(_la===VtlParser.COMMA) {
                this.state = 561;
                this.match(VtlParser.COMMA);
                this.state = 562;
                this.match(VtlParser.STRING_CONSTANT);
            }

            this.state = 565;
            this.match(VtlParser.RPAREN);
            break;
        case VtlParser.EVAL:
            localctx = new EvalAtomComponentContext(this, localctx);
            this.enterOuterAlt(localctx, 3);
            this.state = 567;
            this.match(VtlParser.EVAL);
            this.state = 568;
            this.match(VtlParser.LPAREN);
            this.state = 569;
            this.routineName();
            this.state = 570;
            this.match(VtlParser.LPAREN);
            this.state = 573;
            this._errHandler.sync(this);
            switch (this._input.LA(1)) {
            case VtlParser.IDENTIFIER:
            	this.state = 571;
            	this.componentID();
            	break;
            case VtlParser.NULL_CONSTANT:
            case VtlParser.INTEGER_CONSTANT:
            case VtlParser.NUMBER_CONSTANT:
            case VtlParser.BOOLEAN_CONSTANT:
            case VtlParser.STRING_CONSTANT:
            	this.state = 572;
            	this.constant();
            	break;
            case VtlParser.RPAREN:
            case VtlParser.COMMA:
            	break;
            default:
            	break;
            }
            this.state = 582;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            while(_la===VtlParser.COMMA) {
                this.state = 575;
                this.match(VtlParser.COMMA);
                this.state = 578;
                this._errHandler.sync(this);
                switch(this._input.LA(1)) {
                case VtlParser.IDENTIFIER:
                    this.state = 576;
                    this.componentID();
                    break;
                case VtlParser.NULL_CONSTANT:
                case VtlParser.INTEGER_CONSTANT:
                case VtlParser.NUMBER_CONSTANT:
                case VtlParser.BOOLEAN_CONSTANT:
                case VtlParser.STRING_CONSTANT:
                    this.state = 577;
                    this.constant();
                    break;
                default:
                    throw new antlr4.error.NoViableAltException(this);
                }
                this.state = 584;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
            }
            this.state = 585;
            this.match(VtlParser.RPAREN);
            this.state = 588;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if(_la===VtlParser.LANGUAGE) {
                this.state = 586;
                this.match(VtlParser.LANGUAGE);
                this.state = 587;
                this.match(VtlParser.STRING_CONSTANT);
            }

            this.state = 592;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if(_la===VtlParser.RETURNS) {
                this.state = 590;
                this.match(VtlParser.RETURNS);
                this.state = 591;
                this.outputParameterTypeComponent();
            }

            this.state = 594;
            this.match(VtlParser.RPAREN);
            break;
        default:
            throw new antlr4.error.NoViableAltException(this);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


function ParameterComponentContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = VtlParser.RULE_parameterComponent;
    return this;
}

ParameterComponentContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ParameterComponentContext.prototype.constructor = ParameterComponentContext;

ParameterComponentContext.prototype.componentID = function() {
    return this.getTypedRuleContext(ComponentIDContext,0);
};

ParameterComponentContext.prototype.constant = function() {
    return this.getTypedRuleContext(ConstantContext,0);
};

ParameterComponentContext.prototype.OPTIONAL = function() {
    return this.getToken(VtlParser.OPTIONAL, 0);
};




VtlParser.ParameterComponentContext = ParameterComponentContext;

VtlParser.prototype.parameterComponent = function() {

    var localctx = new ParameterComponentContext(this, this._ctx, this.state);
    this.enterRule(localctx, 36, VtlParser.RULE_parameterComponent);
    try {
        this.state = 601;
        this._errHandler.sync(this);
        switch(this._input.LA(1)) {
        case VtlParser.IDENTIFIER:
            this.enterOuterAlt(localctx, 1);
            this.state = 598;
            this.componentID();
            break;
        case VtlParser.NULL_CONSTANT:
        case VtlParser.INTEGER_CONSTANT:
        case VtlParser.NUMBER_CONSTANT:
        case VtlParser.BOOLEAN_CONSTANT:
        case VtlParser.STRING_CONSTANT:
            this.enterOuterAlt(localctx, 2);
            this.state = 599;
            this.constant();
            break;
        case VtlParser.OPTIONAL:
            this.enterOuterAlt(localctx, 3);
            this.state = 600;
            this.match(VtlParser.OPTIONAL);
            break;
        default:
            throw new antlr4.error.NoViableAltException(this);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


function ParameterContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = VtlParser.RULE_parameter;
    return this;
}

ParameterContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ParameterContext.prototype.constructor = ParameterContext;

ParameterContext.prototype.varID = function() {
    return this.getTypedRuleContext(VarIDContext,0);
};

ParameterContext.prototype.constant = function() {
    return this.getTypedRuleContext(ConstantContext,0);
};

ParameterContext.prototype.OPTIONAL = function() {
    return this.getToken(VtlParser.OPTIONAL, 0);
};




VtlParser.ParameterContext = ParameterContext;

VtlParser.prototype.parameter = function() {

    var localctx = new ParameterContext(this, this._ctx, this.state);
    this.enterRule(localctx, 38, VtlParser.RULE_parameter);
    try {
        this.state = 606;
        this._errHandler.sync(this);
        switch(this._input.LA(1)) {
        case VtlParser.IDENTIFIER:
            this.enterOuterAlt(localctx, 1);
            this.state = 603;
            this.varID();
            break;
        case VtlParser.NULL_CONSTANT:
        case VtlParser.INTEGER_CONSTANT:
        case VtlParser.NUMBER_CONSTANT:
        case VtlParser.BOOLEAN_CONSTANT:
        case VtlParser.STRING_CONSTANT:
            this.enterOuterAlt(localctx, 2);
            this.state = 604;
            this.constant();
            break;
        case VtlParser.OPTIONAL:
            this.enterOuterAlt(localctx, 3);
            this.state = 605;
            this.match(VtlParser.OPTIONAL);
            break;
        default:
            throw new antlr4.error.NoViableAltException(this);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


function StringOperatorsContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = VtlParser.RULE_stringOperators;
    return this;
}

StringOperatorsContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
StringOperatorsContext.prototype.constructor = StringOperatorsContext;


 
StringOperatorsContext.prototype.copyFrom = function(ctx) {
    antlr4.ParserRuleContext.prototype.copyFrom.call(this, ctx);
};


function InstrAtomContext(parser, ctx) {
	StringOperatorsContext.call(this, parser);
    this.pattern = null; // ExprContext;
    this.startParameter = null; // OptionalExprContext;
    this.occurrenceParameter = null; // OptionalExprContext;
    StringOperatorsContext.prototype.copyFrom.call(this, ctx);
    return this;
}

InstrAtomContext.prototype = Object.create(StringOperatorsContext.prototype);
InstrAtomContext.prototype.constructor = InstrAtomContext;

VtlParser.InstrAtomContext = InstrAtomContext;

InstrAtomContext.prototype.INSTR = function() {
    return this.getToken(VtlParser.INSTR, 0);
};

InstrAtomContext.prototype.LPAREN = function() {
    return this.getToken(VtlParser.LPAREN, 0);
};

InstrAtomContext.prototype.expr = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(ExprContext);
    } else {
        return this.getTypedRuleContext(ExprContext,i);
    }
};

InstrAtomContext.prototype.COMMA = function(i) {
	if(i===undefined) {
		i = null;
	}
    if(i===null) {
        return this.getTokens(VtlParser.COMMA);
    } else {
        return this.getToken(VtlParser.COMMA, i);
    }
};


InstrAtomContext.prototype.RPAREN = function() {
    return this.getToken(VtlParser.RPAREN, 0);
};

InstrAtomContext.prototype.optionalExpr = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(OptionalExprContext);
    } else {
        return this.getTypedRuleContext(OptionalExprContext,i);
    }
};

function UnaryStringFunctionContext(parser, ctx) {
	StringOperatorsContext.call(this, parser);
    this.op = null; // Token;
    StringOperatorsContext.prototype.copyFrom.call(this, ctx);
    return this;
}

UnaryStringFunctionContext.prototype = Object.create(StringOperatorsContext.prototype);
UnaryStringFunctionContext.prototype.constructor = UnaryStringFunctionContext;

VtlParser.UnaryStringFunctionContext = UnaryStringFunctionContext;

UnaryStringFunctionContext.prototype.LPAREN = function() {
    return this.getToken(VtlParser.LPAREN, 0);
};

UnaryStringFunctionContext.prototype.expr = function() {
    return this.getTypedRuleContext(ExprContext,0);
};

UnaryStringFunctionContext.prototype.RPAREN = function() {
    return this.getToken(VtlParser.RPAREN, 0);
};

UnaryStringFunctionContext.prototype.TRIM = function() {
    return this.getToken(VtlParser.TRIM, 0);
};

UnaryStringFunctionContext.prototype.LTRIM = function() {
    return this.getToken(VtlParser.LTRIM, 0);
};

UnaryStringFunctionContext.prototype.RTRIM = function() {
    return this.getToken(VtlParser.RTRIM, 0);
};

UnaryStringFunctionContext.prototype.UCASE = function() {
    return this.getToken(VtlParser.UCASE, 0);
};

UnaryStringFunctionContext.prototype.LCASE = function() {
    return this.getToken(VtlParser.LCASE, 0);
};

UnaryStringFunctionContext.prototype.LEN = function() {
    return this.getToken(VtlParser.LEN, 0);
};

function SubstrAtomContext(parser, ctx) {
	StringOperatorsContext.call(this, parser);
    this.startParameter = null; // OptionalExprContext;
    this.endParameter = null; // OptionalExprContext;
    StringOperatorsContext.prototype.copyFrom.call(this, ctx);
    return this;
}

SubstrAtomContext.prototype = Object.create(StringOperatorsContext.prototype);
SubstrAtomContext.prototype.constructor = SubstrAtomContext;

VtlParser.SubstrAtomContext = SubstrAtomContext;

SubstrAtomContext.prototype.SUBSTR = function() {
    return this.getToken(VtlParser.SUBSTR, 0);
};

SubstrAtomContext.prototype.LPAREN = function() {
    return this.getToken(VtlParser.LPAREN, 0);
};

SubstrAtomContext.prototype.expr = function() {
    return this.getTypedRuleContext(ExprContext,0);
};

SubstrAtomContext.prototype.RPAREN = function() {
    return this.getToken(VtlParser.RPAREN, 0);
};

SubstrAtomContext.prototype.COMMA = function(i) {
	if(i===undefined) {
		i = null;
	}
    if(i===null) {
        return this.getTokens(VtlParser.COMMA);
    } else {
        return this.getToken(VtlParser.COMMA, i);
    }
};


SubstrAtomContext.prototype.optionalExpr = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(OptionalExprContext);
    } else {
        return this.getTypedRuleContext(OptionalExprContext,i);
    }
};

function ReplaceAtomContext(parser, ctx) {
	StringOperatorsContext.call(this, parser);
    this.param = null; // ExprContext;
    StringOperatorsContext.prototype.copyFrom.call(this, ctx);
    return this;
}

ReplaceAtomContext.prototype = Object.create(StringOperatorsContext.prototype);
ReplaceAtomContext.prototype.constructor = ReplaceAtomContext;

VtlParser.ReplaceAtomContext = ReplaceAtomContext;

ReplaceAtomContext.prototype.REPLACE = function() {
    return this.getToken(VtlParser.REPLACE, 0);
};

ReplaceAtomContext.prototype.LPAREN = function() {
    return this.getToken(VtlParser.LPAREN, 0);
};

ReplaceAtomContext.prototype.expr = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(ExprContext);
    } else {
        return this.getTypedRuleContext(ExprContext,i);
    }
};

ReplaceAtomContext.prototype.COMMA = function(i) {
	if(i===undefined) {
		i = null;
	}
    if(i===null) {
        return this.getTokens(VtlParser.COMMA);
    } else {
        return this.getToken(VtlParser.COMMA, i);
    }
};


ReplaceAtomContext.prototype.RPAREN = function() {
    return this.getToken(VtlParser.RPAREN, 0);
};

ReplaceAtomContext.prototype.optionalExpr = function() {
    return this.getTypedRuleContext(OptionalExprContext,0);
};


VtlParser.StringOperatorsContext = StringOperatorsContext;

VtlParser.prototype.stringOperators = function() {

    var localctx = new StringOperatorsContext(this, this._ctx, this.state);
    this.enterRule(localctx, 40, VtlParser.RULE_stringOperators);
    var _la = 0; // Token type
    try {
        this.state = 656;
        this._errHandler.sync(this);
        switch(this._input.LA(1)) {
        case VtlParser.LEN:
        case VtlParser.TRIM:
        case VtlParser.UCASE:
        case VtlParser.LCASE:
        case VtlParser.LTRIM:
        case VtlParser.RTRIM:
            localctx = new UnaryStringFunctionContext(this, localctx);
            this.enterOuterAlt(localctx, 1);
            this.state = 608;
            localctx.op = this._input.LT(1);
            _la = this._input.LA(1);
            if(!(((((_la - 81)) & ~0x1f) == 0 && ((1 << (_la - 81)) & ((1 << (VtlParser.LEN - 81)) | (1 << (VtlParser.TRIM - 81)) | (1 << (VtlParser.UCASE - 81)) | (1 << (VtlParser.LCASE - 81)))) !== 0) || _la===VtlParser.LTRIM || _la===VtlParser.RTRIM)) {
                localctx.op = this._errHandler.recoverInline(this);
            }
            else {
            	this._errHandler.reportMatch(this);
                this.consume();
            }
            this.state = 609;
            this.match(VtlParser.LPAREN);
            this.state = 610;
            this.expr(0);
            this.state = 611;
            this.match(VtlParser.RPAREN);
            break;
        case VtlParser.SUBSTR:
            localctx = new SubstrAtomContext(this, localctx);
            this.enterOuterAlt(localctx, 2);
            this.state = 613;
            this.match(VtlParser.SUBSTR);
            this.state = 614;
            this.match(VtlParser.LPAREN);
            this.state = 615;
            this.expr(0);
            this.state = 626;
            this._errHandler.sync(this);
            var la_ = this._interp.adaptivePredict(this._input,45,this._ctx);
            switch(la_) {
            case 1:
                this.state = 622;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
                if(_la===VtlParser.COMMA) {
                    this.state = 616;
                    this.match(VtlParser.COMMA);
                    this.state = 617;
                    localctx.startParameter = this.optionalExpr();

                    this.state = 619;
                    this.match(VtlParser.COMMA);
                    this.state = 620;
                    localctx.endParameter = this.optionalExpr();
                }

                break;

            case 2:
                this.state = 624;
                this.match(VtlParser.COMMA);
                this.state = 625;
                localctx.startParameter = this.optionalExpr();
                break;

            }
            this.state = 628;
            this.match(VtlParser.RPAREN);
            break;
        case VtlParser.REPLACE:
            localctx = new ReplaceAtomContext(this, localctx);
            this.enterOuterAlt(localctx, 3);
            this.state = 630;
            this.match(VtlParser.REPLACE);
            this.state = 631;
            this.match(VtlParser.LPAREN);
            this.state = 632;
            this.expr(0);
            this.state = 633;
            this.match(VtlParser.COMMA);
            this.state = 634;
            localctx.param = this.expr(0);
            this.state = 637;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if(_la===VtlParser.COMMA) {
                this.state = 635;
                this.match(VtlParser.COMMA);
                this.state = 636;
                this.optionalExpr();
            }

            this.state = 639;
            this.match(VtlParser.RPAREN);
            break;
        case VtlParser.INSTR:
            localctx = new InstrAtomContext(this, localctx);
            this.enterOuterAlt(localctx, 4);
            this.state = 641;
            this.match(VtlParser.INSTR);
            this.state = 642;
            this.match(VtlParser.LPAREN);
            this.state = 643;
            this.expr(0);
            this.state = 644;
            this.match(VtlParser.COMMA);
            this.state = 645;
            localctx.pattern = this.expr(0);
            this.state = 648;
            this._errHandler.sync(this);
            var la_ = this._interp.adaptivePredict(this._input,47,this._ctx);
            if(la_===1) {
                this.state = 646;
                this.match(VtlParser.COMMA);
                this.state = 647;
                localctx.startParameter = this.optionalExpr();

            }
            this.state = 652;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if(_la===VtlParser.COMMA) {
                this.state = 650;
                this.match(VtlParser.COMMA);
                this.state = 651;
                localctx.occurrenceParameter = this.optionalExpr();
            }

            this.state = 654;
            this.match(VtlParser.RPAREN);
            break;
        default:
            throw new antlr4.error.NoViableAltException(this);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


function StringOperatorsComponentContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = VtlParser.RULE_stringOperatorsComponent;
    return this;
}

StringOperatorsComponentContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
StringOperatorsComponentContext.prototype.constructor = StringOperatorsComponentContext;


 
StringOperatorsComponentContext.prototype.copyFrom = function(ctx) {
    antlr4.ParserRuleContext.prototype.copyFrom.call(this, ctx);
};


function ReplaceAtomComponentContext(parser, ctx) {
	StringOperatorsComponentContext.call(this, parser);
    this.param = null; // ExprComponentContext;
    StringOperatorsComponentContext.prototype.copyFrom.call(this, ctx);
    return this;
}

ReplaceAtomComponentContext.prototype = Object.create(StringOperatorsComponentContext.prototype);
ReplaceAtomComponentContext.prototype.constructor = ReplaceAtomComponentContext;

VtlParser.ReplaceAtomComponentContext = ReplaceAtomComponentContext;

ReplaceAtomComponentContext.prototype.REPLACE = function() {
    return this.getToken(VtlParser.REPLACE, 0);
};

ReplaceAtomComponentContext.prototype.LPAREN = function() {
    return this.getToken(VtlParser.LPAREN, 0);
};

ReplaceAtomComponentContext.prototype.exprComponent = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(ExprComponentContext);
    } else {
        return this.getTypedRuleContext(ExprComponentContext,i);
    }
};

ReplaceAtomComponentContext.prototype.COMMA = function(i) {
	if(i===undefined) {
		i = null;
	}
    if(i===null) {
        return this.getTokens(VtlParser.COMMA);
    } else {
        return this.getToken(VtlParser.COMMA, i);
    }
};


ReplaceAtomComponentContext.prototype.RPAREN = function() {
    return this.getToken(VtlParser.RPAREN, 0);
};

ReplaceAtomComponentContext.prototype.optionalExprComponent = function() {
    return this.getTypedRuleContext(OptionalExprComponentContext,0);
};

function UnaryStringFunctionComponentContext(parser, ctx) {
	StringOperatorsComponentContext.call(this, parser);
    this.op = null; // Token;
    StringOperatorsComponentContext.prototype.copyFrom.call(this, ctx);
    return this;
}

UnaryStringFunctionComponentContext.prototype = Object.create(StringOperatorsComponentContext.prototype);
UnaryStringFunctionComponentContext.prototype.constructor = UnaryStringFunctionComponentContext;

VtlParser.UnaryStringFunctionComponentContext = UnaryStringFunctionComponentContext;

UnaryStringFunctionComponentContext.prototype.LPAREN = function() {
    return this.getToken(VtlParser.LPAREN, 0);
};

UnaryStringFunctionComponentContext.prototype.exprComponent = function() {
    return this.getTypedRuleContext(ExprComponentContext,0);
};

UnaryStringFunctionComponentContext.prototype.RPAREN = function() {
    return this.getToken(VtlParser.RPAREN, 0);
};

UnaryStringFunctionComponentContext.prototype.TRIM = function() {
    return this.getToken(VtlParser.TRIM, 0);
};

UnaryStringFunctionComponentContext.prototype.LTRIM = function() {
    return this.getToken(VtlParser.LTRIM, 0);
};

UnaryStringFunctionComponentContext.prototype.RTRIM = function() {
    return this.getToken(VtlParser.RTRIM, 0);
};

UnaryStringFunctionComponentContext.prototype.UCASE = function() {
    return this.getToken(VtlParser.UCASE, 0);
};

UnaryStringFunctionComponentContext.prototype.LCASE = function() {
    return this.getToken(VtlParser.LCASE, 0);
};

UnaryStringFunctionComponentContext.prototype.LEN = function() {
    return this.getToken(VtlParser.LEN, 0);
};

function SubstrAtomComponentContext(parser, ctx) {
	StringOperatorsComponentContext.call(this, parser);
    this.startParameter = null; // OptionalExprComponentContext;
    this.endParameter = null; // OptionalExprComponentContext;
    StringOperatorsComponentContext.prototype.copyFrom.call(this, ctx);
    return this;
}

SubstrAtomComponentContext.prototype = Object.create(StringOperatorsComponentContext.prototype);
SubstrAtomComponentContext.prototype.constructor = SubstrAtomComponentContext;

VtlParser.SubstrAtomComponentContext = SubstrAtomComponentContext;

SubstrAtomComponentContext.prototype.SUBSTR = function() {
    return this.getToken(VtlParser.SUBSTR, 0);
};

SubstrAtomComponentContext.prototype.LPAREN = function() {
    return this.getToken(VtlParser.LPAREN, 0);
};

SubstrAtomComponentContext.prototype.exprComponent = function() {
    return this.getTypedRuleContext(ExprComponentContext,0);
};

SubstrAtomComponentContext.prototype.RPAREN = function() {
    return this.getToken(VtlParser.RPAREN, 0);
};

SubstrAtomComponentContext.prototype.COMMA = function(i) {
	if(i===undefined) {
		i = null;
	}
    if(i===null) {
        return this.getTokens(VtlParser.COMMA);
    } else {
        return this.getToken(VtlParser.COMMA, i);
    }
};


SubstrAtomComponentContext.prototype.optionalExprComponent = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(OptionalExprComponentContext);
    } else {
        return this.getTypedRuleContext(OptionalExprComponentContext,i);
    }
};

function InstrAtomComponentContext(parser, ctx) {
	StringOperatorsComponentContext.call(this, parser);
    this.pattern = null; // ExprComponentContext;
    this.startParameter = null; // OptionalExprComponentContext;
    this.occurrenceParameter = null; // OptionalExprComponentContext;
    StringOperatorsComponentContext.prototype.copyFrom.call(this, ctx);
    return this;
}

InstrAtomComponentContext.prototype = Object.create(StringOperatorsComponentContext.prototype);
InstrAtomComponentContext.prototype.constructor = InstrAtomComponentContext;

VtlParser.InstrAtomComponentContext = InstrAtomComponentContext;

InstrAtomComponentContext.prototype.INSTR = function() {
    return this.getToken(VtlParser.INSTR, 0);
};

InstrAtomComponentContext.prototype.LPAREN = function() {
    return this.getToken(VtlParser.LPAREN, 0);
};

InstrAtomComponentContext.prototype.exprComponent = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(ExprComponentContext);
    } else {
        return this.getTypedRuleContext(ExprComponentContext,i);
    }
};

InstrAtomComponentContext.prototype.COMMA = function(i) {
	if(i===undefined) {
		i = null;
	}
    if(i===null) {
        return this.getTokens(VtlParser.COMMA);
    } else {
        return this.getToken(VtlParser.COMMA, i);
    }
};


InstrAtomComponentContext.prototype.RPAREN = function() {
    return this.getToken(VtlParser.RPAREN, 0);
};

InstrAtomComponentContext.prototype.optionalExprComponent = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(OptionalExprComponentContext);
    } else {
        return this.getTypedRuleContext(OptionalExprComponentContext,i);
    }
};


VtlParser.StringOperatorsComponentContext = StringOperatorsComponentContext;

VtlParser.prototype.stringOperatorsComponent = function() {

    var localctx = new StringOperatorsComponentContext(this, this._ctx, this.state);
    this.enterRule(localctx, 42, VtlParser.RULE_stringOperatorsComponent);
    var _la = 0; // Token type
    try {
        this.state = 706;
        this._errHandler.sync(this);
        switch(this._input.LA(1)) {
        case VtlParser.LEN:
        case VtlParser.TRIM:
        case VtlParser.UCASE:
        case VtlParser.LCASE:
        case VtlParser.LTRIM:
        case VtlParser.RTRIM:
            localctx = new UnaryStringFunctionComponentContext(this, localctx);
            this.enterOuterAlt(localctx, 1);
            this.state = 658;
            localctx.op = this._input.LT(1);
            _la = this._input.LA(1);
            if(!(((((_la - 81)) & ~0x1f) == 0 && ((1 << (_la - 81)) & ((1 << (VtlParser.LEN - 81)) | (1 << (VtlParser.TRIM - 81)) | (1 << (VtlParser.UCASE - 81)) | (1 << (VtlParser.LCASE - 81)))) !== 0) || _la===VtlParser.LTRIM || _la===VtlParser.RTRIM)) {
                localctx.op = this._errHandler.recoverInline(this);
            }
            else {
            	this._errHandler.reportMatch(this);
                this.consume();
            }
            this.state = 659;
            this.match(VtlParser.LPAREN);
            this.state = 660;
            this.exprComponent(0);
            this.state = 661;
            this.match(VtlParser.RPAREN);
            break;
        case VtlParser.SUBSTR:
            localctx = new SubstrAtomComponentContext(this, localctx);
            this.enterOuterAlt(localctx, 2);
            this.state = 663;
            this.match(VtlParser.SUBSTR);
            this.state = 664;
            this.match(VtlParser.LPAREN);
            this.state = 665;
            this.exprComponent(0);
            this.state = 676;
            this._errHandler.sync(this);
            var la_ = this._interp.adaptivePredict(this._input,51,this._ctx);
            switch(la_) {
            case 1:
                this.state = 672;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
                if(_la===VtlParser.COMMA) {
                    this.state = 666;
                    this.match(VtlParser.COMMA);
                    this.state = 667;
                    localctx.startParameter = this.optionalExprComponent();

                    this.state = 669;
                    this.match(VtlParser.COMMA);
                    this.state = 670;
                    localctx.endParameter = this.optionalExprComponent();
                }

                break;

            case 2:
                this.state = 674;
                this.match(VtlParser.COMMA);
                this.state = 675;
                localctx.startParameter = this.optionalExprComponent();
                break;

            }
            this.state = 678;
            this.match(VtlParser.RPAREN);
            break;
        case VtlParser.REPLACE:
            localctx = new ReplaceAtomComponentContext(this, localctx);
            this.enterOuterAlt(localctx, 3);
            this.state = 680;
            this.match(VtlParser.REPLACE);
            this.state = 681;
            this.match(VtlParser.LPAREN);
            this.state = 682;
            this.exprComponent(0);
            this.state = 683;
            this.match(VtlParser.COMMA);
            this.state = 684;
            localctx.param = this.exprComponent(0);
            this.state = 687;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if(_la===VtlParser.COMMA) {
                this.state = 685;
                this.match(VtlParser.COMMA);
                this.state = 686;
                this.optionalExprComponent();
            }

            this.state = 689;
            this.match(VtlParser.RPAREN);
            break;
        case VtlParser.INSTR:
            localctx = new InstrAtomComponentContext(this, localctx);
            this.enterOuterAlt(localctx, 4);
            this.state = 691;
            this.match(VtlParser.INSTR);
            this.state = 692;
            this.match(VtlParser.LPAREN);
            this.state = 693;
            this.exprComponent(0);
            this.state = 694;
            this.match(VtlParser.COMMA);
            this.state = 695;
            localctx.pattern = this.exprComponent(0);
            this.state = 698;
            this._errHandler.sync(this);
            var la_ = this._interp.adaptivePredict(this._input,53,this._ctx);
            if(la_===1) {
                this.state = 696;
                this.match(VtlParser.COMMA);
                this.state = 697;
                localctx.startParameter = this.optionalExprComponent();

            }
            this.state = 702;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if(_la===VtlParser.COMMA) {
                this.state = 700;
                this.match(VtlParser.COMMA);
                this.state = 701;
                localctx.occurrenceParameter = this.optionalExprComponent();
            }

            this.state = 704;
            this.match(VtlParser.RPAREN);
            break;
        default:
            throw new antlr4.error.NoViableAltException(this);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


function NumericOperatorsContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = VtlParser.RULE_numericOperators;
    return this;
}

NumericOperatorsContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
NumericOperatorsContext.prototype.constructor = NumericOperatorsContext;


 
NumericOperatorsContext.prototype.copyFrom = function(ctx) {
    antlr4.ParserRuleContext.prototype.copyFrom.call(this, ctx);
};


function UnaryNumericContext(parser, ctx) {
	NumericOperatorsContext.call(this, parser);
    this.op = null; // Token;
    NumericOperatorsContext.prototype.copyFrom.call(this, ctx);
    return this;
}

UnaryNumericContext.prototype = Object.create(NumericOperatorsContext.prototype);
UnaryNumericContext.prototype.constructor = UnaryNumericContext;

VtlParser.UnaryNumericContext = UnaryNumericContext;

UnaryNumericContext.prototype.LPAREN = function() {
    return this.getToken(VtlParser.LPAREN, 0);
};

UnaryNumericContext.prototype.expr = function() {
    return this.getTypedRuleContext(ExprContext,0);
};

UnaryNumericContext.prototype.RPAREN = function() {
    return this.getToken(VtlParser.RPAREN, 0);
};

UnaryNumericContext.prototype.CEIL = function() {
    return this.getToken(VtlParser.CEIL, 0);
};

UnaryNumericContext.prototype.FLOOR = function() {
    return this.getToken(VtlParser.FLOOR, 0);
};

UnaryNumericContext.prototype.ABS = function() {
    return this.getToken(VtlParser.ABS, 0);
};

UnaryNumericContext.prototype.EXP = function() {
    return this.getToken(VtlParser.EXP, 0);
};

UnaryNumericContext.prototype.LN = function() {
    return this.getToken(VtlParser.LN, 0);
};

UnaryNumericContext.prototype.SQRT = function() {
    return this.getToken(VtlParser.SQRT, 0);
};

function UnaryWithOptionalNumericContext(parser, ctx) {
	NumericOperatorsContext.call(this, parser);
    this.op = null; // Token;
    NumericOperatorsContext.prototype.copyFrom.call(this, ctx);
    return this;
}

UnaryWithOptionalNumericContext.prototype = Object.create(NumericOperatorsContext.prototype);
UnaryWithOptionalNumericContext.prototype.constructor = UnaryWithOptionalNumericContext;

VtlParser.UnaryWithOptionalNumericContext = UnaryWithOptionalNumericContext;

UnaryWithOptionalNumericContext.prototype.LPAREN = function() {
    return this.getToken(VtlParser.LPAREN, 0);
};

UnaryWithOptionalNumericContext.prototype.expr = function() {
    return this.getTypedRuleContext(ExprContext,0);
};

UnaryWithOptionalNumericContext.prototype.RPAREN = function() {
    return this.getToken(VtlParser.RPAREN, 0);
};

UnaryWithOptionalNumericContext.prototype.ROUND = function() {
    return this.getToken(VtlParser.ROUND, 0);
};

UnaryWithOptionalNumericContext.prototype.TRUNC = function() {
    return this.getToken(VtlParser.TRUNC, 0);
};

UnaryWithOptionalNumericContext.prototype.COMMA = function() {
    return this.getToken(VtlParser.COMMA, 0);
};

UnaryWithOptionalNumericContext.prototype.optionalExpr = function() {
    return this.getTypedRuleContext(OptionalExprContext,0);
};

function BinaryNumericContext(parser, ctx) {
	NumericOperatorsContext.call(this, parser);
    this.op = null; // Token;
    this.left = null; // ExprContext;
    this.right = null; // ExprContext;
    NumericOperatorsContext.prototype.copyFrom.call(this, ctx);
    return this;
}

BinaryNumericContext.prototype = Object.create(NumericOperatorsContext.prototype);
BinaryNumericContext.prototype.constructor = BinaryNumericContext;

VtlParser.BinaryNumericContext = BinaryNumericContext;

BinaryNumericContext.prototype.LPAREN = function() {
    return this.getToken(VtlParser.LPAREN, 0);
};

BinaryNumericContext.prototype.COMMA = function() {
    return this.getToken(VtlParser.COMMA, 0);
};

BinaryNumericContext.prototype.RPAREN = function() {
    return this.getToken(VtlParser.RPAREN, 0);
};

BinaryNumericContext.prototype.expr = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(ExprContext);
    } else {
        return this.getTypedRuleContext(ExprContext,i);
    }
};

BinaryNumericContext.prototype.MOD = function() {
    return this.getToken(VtlParser.MOD, 0);
};

BinaryNumericContext.prototype.POWER = function() {
    return this.getToken(VtlParser.POWER, 0);
};

BinaryNumericContext.prototype.LOG = function() {
    return this.getToken(VtlParser.LOG, 0);
};


VtlParser.NumericOperatorsContext = NumericOperatorsContext;

VtlParser.prototype.numericOperators = function() {

    var localctx = new NumericOperatorsContext(this, this._ctx, this.state);
    this.enterRule(localctx, 44, VtlParser.RULE_numericOperators);
    var _la = 0; // Token type
    try {
        this.state = 729;
        this._errHandler.sync(this);
        switch(this._input.LA(1)) {
        case VtlParser.ABS:
        case VtlParser.LN:
        case VtlParser.EXP:
        case VtlParser.CEIL:
        case VtlParser.FLOOR:
        case VtlParser.SQRT:
            localctx = new UnaryNumericContext(this, localctx);
            this.enterOuterAlt(localctx, 1);
            this.state = 708;
            localctx.op = this._input.LT(1);
            _la = this._input.LA(1);
            if(!(((((_la - 73)) & ~0x1f) == 0 && ((1 << (_la - 73)) & ((1 << (VtlParser.ABS - 73)) | (1 << (VtlParser.LN - 73)) | (1 << (VtlParser.EXP - 73)))) !== 0) || ((((_la - 123)) & ~0x1f) == 0 && ((1 << (_la - 123)) & ((1 << (VtlParser.CEIL - 123)) | (1 << (VtlParser.FLOOR - 123)) | (1 << (VtlParser.SQRT - 123)))) !== 0))) {
                localctx.op = this._errHandler.recoverInline(this);
            }
            else {
            	this._errHandler.reportMatch(this);
                this.consume();
            }
            this.state = 709;
            this.match(VtlParser.LPAREN);
            this.state = 710;
            this.expr(0);
            this.state = 711;
            this.match(VtlParser.RPAREN);
            break;
        case VtlParser.TRUNC:
        case VtlParser.ROUND:
            localctx = new UnaryWithOptionalNumericContext(this, localctx);
            this.enterOuterAlt(localctx, 2);
            this.state = 713;
            localctx.op = this._input.LT(1);
            _la = this._input.LA(1);
            if(!(_la===VtlParser.TRUNC || _la===VtlParser.ROUND)) {
                localctx.op = this._errHandler.recoverInline(this);
            }
            else {
            	this._errHandler.reportMatch(this);
                this.consume();
            }
            this.state = 714;
            this.match(VtlParser.LPAREN);
            this.state = 715;
            this.expr(0);
            this.state = 718;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if(_la===VtlParser.COMMA) {
                this.state = 716;
                this.match(VtlParser.COMMA);
                this.state = 717;
                this.optionalExpr();
            }

            this.state = 720;
            this.match(VtlParser.RPAREN);
            break;
        case VtlParser.LOG:
        case VtlParser.POWER:
        case VtlParser.MOD:
            localctx = new BinaryNumericContext(this, localctx);
            this.enterOuterAlt(localctx, 3);
            this.state = 722;
            localctx.op = this._input.LT(1);
            _la = this._input.LA(1);
            if(!(((((_la - 76)) & ~0x1f) == 0 && ((1 << (_la - 76)) & ((1 << (VtlParser.LOG - 76)) | (1 << (VtlParser.POWER - 76)) | (1 << (VtlParser.MOD - 76)))) !== 0))) {
                localctx.op = this._errHandler.recoverInline(this);
            }
            else {
            	this._errHandler.reportMatch(this);
                this.consume();
            }
            this.state = 723;
            this.match(VtlParser.LPAREN);
            this.state = 724;
            localctx.left = this.expr(0);
            this.state = 725;
            this.match(VtlParser.COMMA);
            this.state = 726;
            localctx.right = this.expr(0);
            this.state = 727;
            this.match(VtlParser.RPAREN);
            break;
        default:
            throw new antlr4.error.NoViableAltException(this);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


function NumericOperatorsComponentContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = VtlParser.RULE_numericOperatorsComponent;
    return this;
}

NumericOperatorsComponentContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
NumericOperatorsComponentContext.prototype.constructor = NumericOperatorsComponentContext;


 
NumericOperatorsComponentContext.prototype.copyFrom = function(ctx) {
    antlr4.ParserRuleContext.prototype.copyFrom.call(this, ctx);
};


function UnaryNumericComponentContext(parser, ctx) {
	NumericOperatorsComponentContext.call(this, parser);
    this.op = null; // Token;
    NumericOperatorsComponentContext.prototype.copyFrom.call(this, ctx);
    return this;
}

UnaryNumericComponentContext.prototype = Object.create(NumericOperatorsComponentContext.prototype);
UnaryNumericComponentContext.prototype.constructor = UnaryNumericComponentContext;

VtlParser.UnaryNumericComponentContext = UnaryNumericComponentContext;

UnaryNumericComponentContext.prototype.LPAREN = function() {
    return this.getToken(VtlParser.LPAREN, 0);
};

UnaryNumericComponentContext.prototype.exprComponent = function() {
    return this.getTypedRuleContext(ExprComponentContext,0);
};

UnaryNumericComponentContext.prototype.RPAREN = function() {
    return this.getToken(VtlParser.RPAREN, 0);
};

UnaryNumericComponentContext.prototype.CEIL = function() {
    return this.getToken(VtlParser.CEIL, 0);
};

UnaryNumericComponentContext.prototype.FLOOR = function() {
    return this.getToken(VtlParser.FLOOR, 0);
};

UnaryNumericComponentContext.prototype.ABS = function() {
    return this.getToken(VtlParser.ABS, 0);
};

UnaryNumericComponentContext.prototype.EXP = function() {
    return this.getToken(VtlParser.EXP, 0);
};

UnaryNumericComponentContext.prototype.LN = function() {
    return this.getToken(VtlParser.LN, 0);
};

UnaryNumericComponentContext.prototype.SQRT = function() {
    return this.getToken(VtlParser.SQRT, 0);
};

function BinaryNumericComponentContext(parser, ctx) {
	NumericOperatorsComponentContext.call(this, parser);
    this.op = null; // Token;
    this.left = null; // ExprComponentContext;
    this.right = null; // ExprComponentContext;
    NumericOperatorsComponentContext.prototype.copyFrom.call(this, ctx);
    return this;
}

BinaryNumericComponentContext.prototype = Object.create(NumericOperatorsComponentContext.prototype);
BinaryNumericComponentContext.prototype.constructor = BinaryNumericComponentContext;

VtlParser.BinaryNumericComponentContext = BinaryNumericComponentContext;

BinaryNumericComponentContext.prototype.LPAREN = function() {
    return this.getToken(VtlParser.LPAREN, 0);
};

BinaryNumericComponentContext.prototype.COMMA = function() {
    return this.getToken(VtlParser.COMMA, 0);
};

BinaryNumericComponentContext.prototype.RPAREN = function() {
    return this.getToken(VtlParser.RPAREN, 0);
};

BinaryNumericComponentContext.prototype.exprComponent = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(ExprComponentContext);
    } else {
        return this.getTypedRuleContext(ExprComponentContext,i);
    }
};

BinaryNumericComponentContext.prototype.MOD = function() {
    return this.getToken(VtlParser.MOD, 0);
};

BinaryNumericComponentContext.prototype.POWER = function() {
    return this.getToken(VtlParser.POWER, 0);
};

BinaryNumericComponentContext.prototype.LOG = function() {
    return this.getToken(VtlParser.LOG, 0);
};

function UnaryWithOptionalNumericComponentContext(parser, ctx) {
	NumericOperatorsComponentContext.call(this, parser);
    this.op = null; // Token;
    NumericOperatorsComponentContext.prototype.copyFrom.call(this, ctx);
    return this;
}

UnaryWithOptionalNumericComponentContext.prototype = Object.create(NumericOperatorsComponentContext.prototype);
UnaryWithOptionalNumericComponentContext.prototype.constructor = UnaryWithOptionalNumericComponentContext;

VtlParser.UnaryWithOptionalNumericComponentContext = UnaryWithOptionalNumericComponentContext;

UnaryWithOptionalNumericComponentContext.prototype.LPAREN = function() {
    return this.getToken(VtlParser.LPAREN, 0);
};

UnaryWithOptionalNumericComponentContext.prototype.exprComponent = function() {
    return this.getTypedRuleContext(ExprComponentContext,0);
};

UnaryWithOptionalNumericComponentContext.prototype.RPAREN = function() {
    return this.getToken(VtlParser.RPAREN, 0);
};

UnaryWithOptionalNumericComponentContext.prototype.ROUND = function() {
    return this.getToken(VtlParser.ROUND, 0);
};

UnaryWithOptionalNumericComponentContext.prototype.TRUNC = function() {
    return this.getToken(VtlParser.TRUNC, 0);
};

UnaryWithOptionalNumericComponentContext.prototype.COMMA = function() {
    return this.getToken(VtlParser.COMMA, 0);
};

UnaryWithOptionalNumericComponentContext.prototype.optionalExprComponent = function() {
    return this.getTypedRuleContext(OptionalExprComponentContext,0);
};


VtlParser.NumericOperatorsComponentContext = NumericOperatorsComponentContext;

VtlParser.prototype.numericOperatorsComponent = function() {

    var localctx = new NumericOperatorsComponentContext(this, this._ctx, this.state);
    this.enterRule(localctx, 46, VtlParser.RULE_numericOperatorsComponent);
    var _la = 0; // Token type
    try {
        this.state = 752;
        this._errHandler.sync(this);
        switch(this._input.LA(1)) {
        case VtlParser.ABS:
        case VtlParser.LN:
        case VtlParser.EXP:
        case VtlParser.CEIL:
        case VtlParser.FLOOR:
        case VtlParser.SQRT:
            localctx = new UnaryNumericComponentContext(this, localctx);
            this.enterOuterAlt(localctx, 1);
            this.state = 731;
            localctx.op = this._input.LT(1);
            _la = this._input.LA(1);
            if(!(((((_la - 73)) & ~0x1f) == 0 && ((1 << (_la - 73)) & ((1 << (VtlParser.ABS - 73)) | (1 << (VtlParser.LN - 73)) | (1 << (VtlParser.EXP - 73)))) !== 0) || ((((_la - 123)) & ~0x1f) == 0 && ((1 << (_la - 123)) & ((1 << (VtlParser.CEIL - 123)) | (1 << (VtlParser.FLOOR - 123)) | (1 << (VtlParser.SQRT - 123)))) !== 0))) {
                localctx.op = this._errHandler.recoverInline(this);
            }
            else {
            	this._errHandler.reportMatch(this);
                this.consume();
            }
            this.state = 732;
            this.match(VtlParser.LPAREN);
            this.state = 733;
            this.exprComponent(0);
            this.state = 734;
            this.match(VtlParser.RPAREN);
            break;
        case VtlParser.TRUNC:
        case VtlParser.ROUND:
            localctx = new UnaryWithOptionalNumericComponentContext(this, localctx);
            this.enterOuterAlt(localctx, 2);
            this.state = 736;
            localctx.op = this._input.LT(1);
            _la = this._input.LA(1);
            if(!(_la===VtlParser.TRUNC || _la===VtlParser.ROUND)) {
                localctx.op = this._errHandler.recoverInline(this);
            }
            else {
            	this._errHandler.reportMatch(this);
                this.consume();
            }
            this.state = 737;
            this.match(VtlParser.LPAREN);
            this.state = 738;
            this.exprComponent(0);
            this.state = 741;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if(_la===VtlParser.COMMA) {
                this.state = 739;
                this.match(VtlParser.COMMA);
                this.state = 740;
                this.optionalExprComponent();
            }

            this.state = 743;
            this.match(VtlParser.RPAREN);
            break;
        case VtlParser.LOG:
        case VtlParser.POWER:
        case VtlParser.MOD:
            localctx = new BinaryNumericComponentContext(this, localctx);
            this.enterOuterAlt(localctx, 3);
            this.state = 745;
            localctx.op = this._input.LT(1);
            _la = this._input.LA(1);
            if(!(((((_la - 76)) & ~0x1f) == 0 && ((1 << (_la - 76)) & ((1 << (VtlParser.LOG - 76)) | (1 << (VtlParser.POWER - 76)) | (1 << (VtlParser.MOD - 76)))) !== 0))) {
                localctx.op = this._errHandler.recoverInline(this);
            }
            else {
            	this._errHandler.reportMatch(this);
                this.consume();
            }
            this.state = 746;
            this.match(VtlParser.LPAREN);
            this.state = 747;
            localctx.left = this.exprComponent(0);
            this.state = 748;
            this.match(VtlParser.COMMA);
            this.state = 749;
            localctx.right = this.exprComponent(0);
            this.state = 750;
            this.match(VtlParser.RPAREN);
            break;
        default:
            throw new antlr4.error.NoViableAltException(this);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


function ComparisonOperatorsContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = VtlParser.RULE_comparisonOperators;
    return this;
}

ComparisonOperatorsContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ComparisonOperatorsContext.prototype.constructor = ComparisonOperatorsContext;


 
ComparisonOperatorsContext.prototype.copyFrom = function(ctx) {
    antlr4.ParserRuleContext.prototype.copyFrom.call(this, ctx);
};


function BetweenAtomContext(parser, ctx) {
	ComparisonOperatorsContext.call(this, parser);
    this.op = null; // ExprContext;
    this.from_ = null; // ExprContext;
    this.to_ = null; // ExprContext;
    ComparisonOperatorsContext.prototype.copyFrom.call(this, ctx);
    return this;
}

BetweenAtomContext.prototype = Object.create(ComparisonOperatorsContext.prototype);
BetweenAtomContext.prototype.constructor = BetweenAtomContext;

VtlParser.BetweenAtomContext = BetweenAtomContext;

BetweenAtomContext.prototype.BETWEEN = function() {
    return this.getToken(VtlParser.BETWEEN, 0);
};

BetweenAtomContext.prototype.LPAREN = function() {
    return this.getToken(VtlParser.LPAREN, 0);
};

BetweenAtomContext.prototype.COMMA = function(i) {
	if(i===undefined) {
		i = null;
	}
    if(i===null) {
        return this.getTokens(VtlParser.COMMA);
    } else {
        return this.getToken(VtlParser.COMMA, i);
    }
};


BetweenAtomContext.prototype.RPAREN = function() {
    return this.getToken(VtlParser.RPAREN, 0);
};

BetweenAtomContext.prototype.expr = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(ExprContext);
    } else {
        return this.getTypedRuleContext(ExprContext,i);
    }
};

function CharsetMatchAtomContext(parser, ctx) {
	ComparisonOperatorsContext.call(this, parser);
    this.op = null; // ExprContext;
    this.pattern = null; // ExprContext;
    ComparisonOperatorsContext.prototype.copyFrom.call(this, ctx);
    return this;
}

CharsetMatchAtomContext.prototype = Object.create(ComparisonOperatorsContext.prototype);
CharsetMatchAtomContext.prototype.constructor = CharsetMatchAtomContext;

VtlParser.CharsetMatchAtomContext = CharsetMatchAtomContext;

CharsetMatchAtomContext.prototype.CHARSET_MATCH = function() {
    return this.getToken(VtlParser.CHARSET_MATCH, 0);
};

CharsetMatchAtomContext.prototype.LPAREN = function() {
    return this.getToken(VtlParser.LPAREN, 0);
};

CharsetMatchAtomContext.prototype.COMMA = function() {
    return this.getToken(VtlParser.COMMA, 0);
};

CharsetMatchAtomContext.prototype.RPAREN = function() {
    return this.getToken(VtlParser.RPAREN, 0);
};

CharsetMatchAtomContext.prototype.expr = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(ExprContext);
    } else {
        return this.getTypedRuleContext(ExprContext,i);
    }
};

function IsNullAtomContext(parser, ctx) {
	ComparisonOperatorsContext.call(this, parser);
    ComparisonOperatorsContext.prototype.copyFrom.call(this, ctx);
    return this;
}

IsNullAtomContext.prototype = Object.create(ComparisonOperatorsContext.prototype);
IsNullAtomContext.prototype.constructor = IsNullAtomContext;

VtlParser.IsNullAtomContext = IsNullAtomContext;

IsNullAtomContext.prototype.ISNULL = function() {
    return this.getToken(VtlParser.ISNULL, 0);
};

IsNullAtomContext.prototype.LPAREN = function() {
    return this.getToken(VtlParser.LPAREN, 0);
};

IsNullAtomContext.prototype.expr = function() {
    return this.getTypedRuleContext(ExprContext,0);
};

IsNullAtomContext.prototype.RPAREN = function() {
    return this.getToken(VtlParser.RPAREN, 0);
};

function ExistInAtomContext(parser, ctx) {
	ComparisonOperatorsContext.call(this, parser);
    this.left = null; // ExprContext;
    this.right = null; // ExprContext;
    ComparisonOperatorsContext.prototype.copyFrom.call(this, ctx);
    return this;
}

ExistInAtomContext.prototype = Object.create(ComparisonOperatorsContext.prototype);
ExistInAtomContext.prototype.constructor = ExistInAtomContext;

VtlParser.ExistInAtomContext = ExistInAtomContext;

ExistInAtomContext.prototype.EXISTS_IN = function() {
    return this.getToken(VtlParser.EXISTS_IN, 0);
};

ExistInAtomContext.prototype.LPAREN = function() {
    return this.getToken(VtlParser.LPAREN, 0);
};

ExistInAtomContext.prototype.COMMA = function(i) {
	if(i===undefined) {
		i = null;
	}
    if(i===null) {
        return this.getTokens(VtlParser.COMMA);
    } else {
        return this.getToken(VtlParser.COMMA, i);
    }
};


ExistInAtomContext.prototype.RPAREN = function() {
    return this.getToken(VtlParser.RPAREN, 0);
};

ExistInAtomContext.prototype.expr = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(ExprContext);
    } else {
        return this.getTypedRuleContext(ExprContext,i);
    }
};

ExistInAtomContext.prototype.retainType = function() {
    return this.getTypedRuleContext(RetainTypeContext,0);
};


VtlParser.ComparisonOperatorsContext = ComparisonOperatorsContext;

VtlParser.prototype.comparisonOperators = function() {

    var localctx = new ComparisonOperatorsContext(this, this._ctx, this.state);
    this.enterRule(localctx, 48, VtlParser.RULE_comparisonOperators);
    var _la = 0; // Token type
    try {
        this.state = 786;
        this._errHandler.sync(this);
        switch(this._input.LA(1)) {
        case VtlParser.BETWEEN:
            localctx = new BetweenAtomContext(this, localctx);
            this.enterOuterAlt(localctx, 1);
            this.state = 754;
            this.match(VtlParser.BETWEEN);
            this.state = 755;
            this.match(VtlParser.LPAREN);
            this.state = 756;
            localctx.op = this.expr(0);
            this.state = 757;
            this.match(VtlParser.COMMA);
            this.state = 758;
            localctx.from_ = this.expr(0);
            this.state = 759;
            this.match(VtlParser.COMMA);
            this.state = 760;
            localctx.to_ = this.expr(0);
            this.state = 761;
            this.match(VtlParser.RPAREN);
            break;
        case VtlParser.CHARSET_MATCH:
            localctx = new CharsetMatchAtomContext(this, localctx);
            this.enterOuterAlt(localctx, 2);
            this.state = 763;
            this.match(VtlParser.CHARSET_MATCH);
            this.state = 764;
            this.match(VtlParser.LPAREN);
            this.state = 765;
            localctx.op = this.expr(0);
            this.state = 766;
            this.match(VtlParser.COMMA);
            this.state = 767;
            localctx.pattern = this.expr(0);
            this.state = 768;
            this.match(VtlParser.RPAREN);
            break;
        case VtlParser.ISNULL:
            localctx = new IsNullAtomContext(this, localctx);
            this.enterOuterAlt(localctx, 3);
            this.state = 770;
            this.match(VtlParser.ISNULL);
            this.state = 771;
            this.match(VtlParser.LPAREN);
            this.state = 772;
            this.expr(0);
            this.state = 773;
            this.match(VtlParser.RPAREN);
            break;
        case VtlParser.EXISTS_IN:
            localctx = new ExistInAtomContext(this, localctx);
            this.enterOuterAlt(localctx, 4);
            this.state = 775;
            this.match(VtlParser.EXISTS_IN);
            this.state = 776;
            this.match(VtlParser.LPAREN);
            this.state = 777;
            localctx.left = this.expr(0);
            this.state = 778;
            this.match(VtlParser.COMMA);
            this.state = 779;
            localctx.right = this.expr(0);
            this.state = 782;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if(_la===VtlParser.COMMA) {
                this.state = 780;
                this.match(VtlParser.COMMA);
                this.state = 781;
                this.retainType();
            }

            this.state = 784;
            this.match(VtlParser.RPAREN);
            break;
        default:
            throw new antlr4.error.NoViableAltException(this);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


function ComparisonOperatorsComponentContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = VtlParser.RULE_comparisonOperatorsComponent;
    return this;
}

ComparisonOperatorsComponentContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ComparisonOperatorsComponentContext.prototype.constructor = ComparisonOperatorsComponentContext;


 
ComparisonOperatorsComponentContext.prototype.copyFrom = function(ctx) {
    antlr4.ParserRuleContext.prototype.copyFrom.call(this, ctx);
};


function IsNullAtomComponentContext(parser, ctx) {
	ComparisonOperatorsComponentContext.call(this, parser);
    ComparisonOperatorsComponentContext.prototype.copyFrom.call(this, ctx);
    return this;
}

IsNullAtomComponentContext.prototype = Object.create(ComparisonOperatorsComponentContext.prototype);
IsNullAtomComponentContext.prototype.constructor = IsNullAtomComponentContext;

VtlParser.IsNullAtomComponentContext = IsNullAtomComponentContext;

IsNullAtomComponentContext.prototype.ISNULL = function() {
    return this.getToken(VtlParser.ISNULL, 0);
};

IsNullAtomComponentContext.prototype.LPAREN = function() {
    return this.getToken(VtlParser.LPAREN, 0);
};

IsNullAtomComponentContext.prototype.exprComponent = function() {
    return this.getTypedRuleContext(ExprComponentContext,0);
};

IsNullAtomComponentContext.prototype.RPAREN = function() {
    return this.getToken(VtlParser.RPAREN, 0);
};

function CharsetMatchAtomComponentContext(parser, ctx) {
	ComparisonOperatorsComponentContext.call(this, parser);
    this.op = null; // ExprComponentContext;
    this.pattern = null; // ExprComponentContext;
    ComparisonOperatorsComponentContext.prototype.copyFrom.call(this, ctx);
    return this;
}

CharsetMatchAtomComponentContext.prototype = Object.create(ComparisonOperatorsComponentContext.prototype);
CharsetMatchAtomComponentContext.prototype.constructor = CharsetMatchAtomComponentContext;

VtlParser.CharsetMatchAtomComponentContext = CharsetMatchAtomComponentContext;

CharsetMatchAtomComponentContext.prototype.CHARSET_MATCH = function() {
    return this.getToken(VtlParser.CHARSET_MATCH, 0);
};

CharsetMatchAtomComponentContext.prototype.LPAREN = function() {
    return this.getToken(VtlParser.LPAREN, 0);
};

CharsetMatchAtomComponentContext.prototype.COMMA = function() {
    return this.getToken(VtlParser.COMMA, 0);
};

CharsetMatchAtomComponentContext.prototype.RPAREN = function() {
    return this.getToken(VtlParser.RPAREN, 0);
};

CharsetMatchAtomComponentContext.prototype.exprComponent = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(ExprComponentContext);
    } else {
        return this.getTypedRuleContext(ExprComponentContext,i);
    }
};

function BetweenAtomComponentContext(parser, ctx) {
	ComparisonOperatorsComponentContext.call(this, parser);
    this.op = null; // ExprComponentContext;
    this.from_ = null; // ExprComponentContext;
    this.to_ = null; // ExprComponentContext;
    ComparisonOperatorsComponentContext.prototype.copyFrom.call(this, ctx);
    return this;
}

BetweenAtomComponentContext.prototype = Object.create(ComparisonOperatorsComponentContext.prototype);
BetweenAtomComponentContext.prototype.constructor = BetweenAtomComponentContext;

VtlParser.BetweenAtomComponentContext = BetweenAtomComponentContext;

BetweenAtomComponentContext.prototype.BETWEEN = function() {
    return this.getToken(VtlParser.BETWEEN, 0);
};

BetweenAtomComponentContext.prototype.LPAREN = function() {
    return this.getToken(VtlParser.LPAREN, 0);
};

BetweenAtomComponentContext.prototype.COMMA = function(i) {
	if(i===undefined) {
		i = null;
	}
    if(i===null) {
        return this.getTokens(VtlParser.COMMA);
    } else {
        return this.getToken(VtlParser.COMMA, i);
    }
};


BetweenAtomComponentContext.prototype.RPAREN = function() {
    return this.getToken(VtlParser.RPAREN, 0);
};

BetweenAtomComponentContext.prototype.exprComponent = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(ExprComponentContext);
    } else {
        return this.getTypedRuleContext(ExprComponentContext,i);
    }
};


VtlParser.ComparisonOperatorsComponentContext = ComparisonOperatorsComponentContext;

VtlParser.prototype.comparisonOperatorsComponent = function() {

    var localctx = new ComparisonOperatorsComponentContext(this, this._ctx, this.state);
    this.enterRule(localctx, 50, VtlParser.RULE_comparisonOperatorsComponent);
    try {
        this.state = 809;
        this._errHandler.sync(this);
        switch(this._input.LA(1)) {
        case VtlParser.BETWEEN:
            localctx = new BetweenAtomComponentContext(this, localctx);
            this.enterOuterAlt(localctx, 1);
            this.state = 788;
            this.match(VtlParser.BETWEEN);
            this.state = 789;
            this.match(VtlParser.LPAREN);
            this.state = 790;
            localctx.op = this.exprComponent(0);
            this.state = 791;
            this.match(VtlParser.COMMA);
            this.state = 792;
            localctx.from_ = this.exprComponent(0);
            this.state = 793;
            this.match(VtlParser.COMMA);
            this.state = 794;
            localctx.to_ = this.exprComponent(0);
            this.state = 795;
            this.match(VtlParser.RPAREN);
            break;
        case VtlParser.CHARSET_MATCH:
            localctx = new CharsetMatchAtomComponentContext(this, localctx);
            this.enterOuterAlt(localctx, 2);
            this.state = 797;
            this.match(VtlParser.CHARSET_MATCH);
            this.state = 798;
            this.match(VtlParser.LPAREN);
            this.state = 799;
            localctx.op = this.exprComponent(0);
            this.state = 800;
            this.match(VtlParser.COMMA);
            this.state = 801;
            localctx.pattern = this.exprComponent(0);
            this.state = 802;
            this.match(VtlParser.RPAREN);
            break;
        case VtlParser.ISNULL:
            localctx = new IsNullAtomComponentContext(this, localctx);
            this.enterOuterAlt(localctx, 3);
            this.state = 804;
            this.match(VtlParser.ISNULL);
            this.state = 805;
            this.match(VtlParser.LPAREN);
            this.state = 806;
            this.exprComponent(0);
            this.state = 807;
            this.match(VtlParser.RPAREN);
            break;
        default:
            throw new antlr4.error.NoViableAltException(this);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


function TimeOperatorsContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = VtlParser.RULE_timeOperators;
    return this;
}

TimeOperatorsContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
TimeOperatorsContext.prototype.constructor = TimeOperatorsContext;


 
TimeOperatorsContext.prototype.copyFrom = function(ctx) {
    antlr4.ParserRuleContext.prototype.copyFrom.call(this, ctx);
};


function FlowAtomContext(parser, ctx) {
	TimeOperatorsContext.call(this, parser);
    this.op = null; // Token;
    TimeOperatorsContext.prototype.copyFrom.call(this, ctx);
    return this;
}

FlowAtomContext.prototype = Object.create(TimeOperatorsContext.prototype);
FlowAtomContext.prototype.constructor = FlowAtomContext;

VtlParser.FlowAtomContext = FlowAtomContext;

FlowAtomContext.prototype.LPAREN = function() {
    return this.getToken(VtlParser.LPAREN, 0);
};

FlowAtomContext.prototype.expr = function() {
    return this.getTypedRuleContext(ExprContext,0);
};

FlowAtomContext.prototype.RPAREN = function() {
    return this.getToken(VtlParser.RPAREN, 0);
};

FlowAtomContext.prototype.FLOW_TO_STOCK = function() {
    return this.getToken(VtlParser.FLOW_TO_STOCK, 0);
};

FlowAtomContext.prototype.STOCK_TO_FLOW = function() {
    return this.getToken(VtlParser.STOCK_TO_FLOW, 0);
};

function TimeShiftAtomContext(parser, ctx) {
	TimeOperatorsContext.call(this, parser);
    TimeOperatorsContext.prototype.copyFrom.call(this, ctx);
    return this;
}

TimeShiftAtomContext.prototype = Object.create(TimeOperatorsContext.prototype);
TimeShiftAtomContext.prototype.constructor = TimeShiftAtomContext;

VtlParser.TimeShiftAtomContext = TimeShiftAtomContext;

TimeShiftAtomContext.prototype.TIMESHIFT = function() {
    return this.getToken(VtlParser.TIMESHIFT, 0);
};

TimeShiftAtomContext.prototype.LPAREN = function() {
    return this.getToken(VtlParser.LPAREN, 0);
};

TimeShiftAtomContext.prototype.expr = function() {
    return this.getTypedRuleContext(ExprContext,0);
};

TimeShiftAtomContext.prototype.COMMA = function() {
    return this.getToken(VtlParser.COMMA, 0);
};

TimeShiftAtomContext.prototype.signedInteger = function() {
    return this.getTypedRuleContext(SignedIntegerContext,0);
};

TimeShiftAtomContext.prototype.RPAREN = function() {
    return this.getToken(VtlParser.RPAREN, 0);
};

function TimeAggAtomContext(parser, ctx) {
	TimeOperatorsContext.call(this, parser);
    this.periodIndTo = null; // Token;
    this.periodIndFrom = null; // Token;
    this.op = null; // OptionalExprContext;
    TimeOperatorsContext.prototype.copyFrom.call(this, ctx);
    return this;
}

TimeAggAtomContext.prototype = Object.create(TimeOperatorsContext.prototype);
TimeAggAtomContext.prototype.constructor = TimeAggAtomContext;

VtlParser.TimeAggAtomContext = TimeAggAtomContext;

TimeAggAtomContext.prototype.TIME_AGG = function() {
    return this.getToken(VtlParser.TIME_AGG, 0);
};

TimeAggAtomContext.prototype.LPAREN = function() {
    return this.getToken(VtlParser.LPAREN, 0);
};

TimeAggAtomContext.prototype.RPAREN = function() {
    return this.getToken(VtlParser.RPAREN, 0);
};

TimeAggAtomContext.prototype.STRING_CONSTANT = function(i) {
	if(i===undefined) {
		i = null;
	}
    if(i===null) {
        return this.getTokens(VtlParser.STRING_CONSTANT);
    } else {
        return this.getToken(VtlParser.STRING_CONSTANT, i);
    }
};


TimeAggAtomContext.prototype.COMMA = function(i) {
	if(i===undefined) {
		i = null;
	}
    if(i===null) {
        return this.getTokens(VtlParser.COMMA);
    } else {
        return this.getToken(VtlParser.COMMA, i);
    }
};


TimeAggAtomContext.prototype.optionalExpr = function() {
    return this.getTypedRuleContext(OptionalExprContext,0);
};

TimeAggAtomContext.prototype.FIRST = function() {
    return this.getToken(VtlParser.FIRST, 0);
};

TimeAggAtomContext.prototype.LAST = function() {
    return this.getToken(VtlParser.LAST, 0);
};

TimeAggAtomContext.prototype.OPTIONAL = function() {
    return this.getToken(VtlParser.OPTIONAL, 0);
};

function CurrentDateAtomContext(parser, ctx) {
	TimeOperatorsContext.call(this, parser);
    TimeOperatorsContext.prototype.copyFrom.call(this, ctx);
    return this;
}

CurrentDateAtomContext.prototype = Object.create(TimeOperatorsContext.prototype);
CurrentDateAtomContext.prototype.constructor = CurrentDateAtomContext;

VtlParser.CurrentDateAtomContext = CurrentDateAtomContext;

CurrentDateAtomContext.prototype.CURRENT_DATE = function() {
    return this.getToken(VtlParser.CURRENT_DATE, 0);
};

CurrentDateAtomContext.prototype.LPAREN = function() {
    return this.getToken(VtlParser.LPAREN, 0);
};

CurrentDateAtomContext.prototype.RPAREN = function() {
    return this.getToken(VtlParser.RPAREN, 0);
};

function PeriodAtomContext(parser, ctx) {
	TimeOperatorsContext.call(this, parser);
    TimeOperatorsContext.prototype.copyFrom.call(this, ctx);
    return this;
}

PeriodAtomContext.prototype = Object.create(TimeOperatorsContext.prototype);
PeriodAtomContext.prototype.constructor = PeriodAtomContext;

VtlParser.PeriodAtomContext = PeriodAtomContext;

PeriodAtomContext.prototype.PERIOD_INDICATOR = function() {
    return this.getToken(VtlParser.PERIOD_INDICATOR, 0);
};

PeriodAtomContext.prototype.LPAREN = function() {
    return this.getToken(VtlParser.LPAREN, 0);
};

PeriodAtomContext.prototype.RPAREN = function() {
    return this.getToken(VtlParser.RPAREN, 0);
};

PeriodAtomContext.prototype.expr = function() {
    return this.getTypedRuleContext(ExprContext,0);
};

function FillTimeAtomContext(parser, ctx) {
	TimeOperatorsContext.call(this, parser);
    this.op = null; // Token;
    TimeOperatorsContext.prototype.copyFrom.call(this, ctx);
    return this;
}

FillTimeAtomContext.prototype = Object.create(TimeOperatorsContext.prototype);
FillTimeAtomContext.prototype.constructor = FillTimeAtomContext;

VtlParser.FillTimeAtomContext = FillTimeAtomContext;

FillTimeAtomContext.prototype.FILL_TIME_SERIES = function() {
    return this.getToken(VtlParser.FILL_TIME_SERIES, 0);
};

FillTimeAtomContext.prototype.LPAREN = function() {
    return this.getToken(VtlParser.LPAREN, 0);
};

FillTimeAtomContext.prototype.expr = function() {
    return this.getTypedRuleContext(ExprContext,0);
};

FillTimeAtomContext.prototype.RPAREN = function() {
    return this.getToken(VtlParser.RPAREN, 0);
};

FillTimeAtomContext.prototype.COMMA = function() {
    return this.getToken(VtlParser.COMMA, 0);
};

FillTimeAtomContext.prototype.SINGLE = function() {
    return this.getToken(VtlParser.SINGLE, 0);
};

FillTimeAtomContext.prototype.ALL = function() {
    return this.getToken(VtlParser.ALL, 0);
};


VtlParser.TimeOperatorsContext = TimeOperatorsContext;

VtlParser.prototype.timeOperators = function() {

    var localctx = new TimeOperatorsContext(this, this._ctx, this.state);
    this.enterRule(localctx, 52, VtlParser.RULE_timeOperators);
    var _la = 0; // Token type
    try {
        this.state = 857;
        this._errHandler.sync(this);
        switch(this._input.LA(1)) {
        case VtlParser.PERIOD_INDICATOR:
            localctx = new PeriodAtomContext(this, localctx);
            this.enterOuterAlt(localctx, 1);
            this.state = 811;
            this.match(VtlParser.PERIOD_INDICATOR);
            this.state = 812;
            this.match(VtlParser.LPAREN);
            this.state = 814;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << VtlParser.LPAREN) | (1 << VtlParser.PLUS) | (1 << VtlParser.MINUS) | (1 << VtlParser.EVAL) | (1 << VtlParser.IF) | (1 << VtlParser.CURRENT_DATE))) !== 0) || ((((_la - 39)) & ~0x1f) == 0 && ((1 << (_la - 39)) & ((1 << (VtlParser.NOT - 39)) | (1 << (VtlParser.BETWEEN - 39)) | (1 << (VtlParser.NULL_CONSTANT - 39)) | (1 << (VtlParser.ISNULL - 39)) | (1 << (VtlParser.UNION - 39)) | (1 << (VtlParser.SYMDIFF - 39)) | (1 << (VtlParser.INTERSECT - 39)) | (1 << (VtlParser.CHECK - 39)) | (1 << (VtlParser.EXISTS_IN - 39)) | (1 << (VtlParser.MIN - 39)) | (1 << (VtlParser.MAX - 39)))) !== 0) || ((((_la - 73)) & ~0x1f) == 0 && ((1 << (_la - 73)) & ((1 << (VtlParser.ABS - 73)) | (1 << (VtlParser.LN - 73)) | (1 << (VtlParser.LOG - 73)) | (1 << (VtlParser.TRUNC - 73)) | (1 << (VtlParser.ROUND - 73)) | (1 << (VtlParser.POWER - 73)) | (1 << (VtlParser.MOD - 73)) | (1 << (VtlParser.LEN - 73)) | (1 << (VtlParser.TRIM - 73)) | (1 << (VtlParser.UCASE - 73)) | (1 << (VtlParser.LCASE - 73)) | (1 << (VtlParser.SUBSTR - 73)) | (1 << (VtlParser.SUM - 73)) | (1 << (VtlParser.AVG - 73)) | (1 << (VtlParser.MEDIAN - 73)) | (1 << (VtlParser.COUNT - 73)) | (1 << (VtlParser.EXP - 73)) | (1 << (VtlParser.CHARSET_MATCH - 73)) | (1 << (VtlParser.NVL - 73)) | (1 << (VtlParser.HIERARCHY - 73)))) !== 0) || ((((_la - 119)) & ~0x1f) == 0 && ((1 << (_la - 119)) & ((1 << (VtlParser.LTRIM - 119)) | (1 << (VtlParser.RTRIM - 119)) | (1 << (VtlParser.INSTR - 119)) | (1 << (VtlParser.REPLACE - 119)) | (1 << (VtlParser.CEIL - 119)) | (1 << (VtlParser.FLOOR - 119)) | (1 << (VtlParser.SQRT - 119)) | (1 << (VtlParser.SETDIFF - 119)) | (1 << (VtlParser.STDDEV_POP - 119)) | (1 << (VtlParser.STDDEV_SAMP - 119)) | (1 << (VtlParser.VAR_POP - 119)) | (1 << (VtlParser.VAR_SAMP - 119)) | (1 << (VtlParser.FIRST_VALUE - 119)) | (1 << (VtlParser.LAST_VALUE - 119)) | (1 << (VtlParser.LAG - 119)) | (1 << (VtlParser.LEAD - 119)) | (1 << (VtlParser.RATIO_TO_REPORT - 119)) | (1 << (VtlParser.FILL_TIME_SERIES - 119)) | (1 << (VtlParser.FLOW_TO_STOCK - 119)))) !== 0) || ((((_la - 151)) & ~0x1f) == 0 && ((1 << (_la - 151)) & ((1 << (VtlParser.STOCK_TO_FLOW - 151)) | (1 << (VtlParser.TIMESHIFT - 151)) | (1 << (VtlParser.INNER_JOIN - 151)) | (1 << (VtlParser.LEFT_JOIN - 151)))) !== 0) || ((((_la - 183)) & ~0x1f) == 0 && ((1 << (_la - 183)) & ((1 << (VtlParser.CROSS_JOIN - 183)) | (1 << (VtlParser.FULL_JOIN - 183)) | (1 << (VtlParser.PERIOD_INDICATOR - 183)) | (1 << (VtlParser.TIME_AGG - 183)) | (1 << (VtlParser.CAST - 183)) | (1 << (VtlParser.CHECK_DATAPOINT - 183)) | (1 << (VtlParser.CHECK_HIERARCHY - 183)))) !== 0) || ((((_la - 229)) & ~0x1f) == 0 && ((1 << (_la - 229)) & ((1 << (VtlParser.INTEGER_CONSTANT - 229)) | (1 << (VtlParser.NUMBER_CONSTANT - 229)) | (1 << (VtlParser.BOOLEAN_CONSTANT - 229)) | (1 << (VtlParser.STRING_CONSTANT - 229)) | (1 << (VtlParser.IDENTIFIER - 229)))) !== 0)) {
                this.state = 813;
                this.expr(0);
            }

            this.state = 816;
            this.match(VtlParser.RPAREN);
            break;
        case VtlParser.FILL_TIME_SERIES:
            localctx = new FillTimeAtomContext(this, localctx);
            this.enterOuterAlt(localctx, 2);
            this.state = 817;
            this.match(VtlParser.FILL_TIME_SERIES);
            this.state = 818;
            this.match(VtlParser.LPAREN);
            this.state = 819;
            this.expr(0);
            this.state = 822;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if(_la===VtlParser.COMMA) {
                this.state = 820;
                this.match(VtlParser.COMMA);
                this.state = 821;
                localctx.op = this._input.LT(1);
                _la = this._input.LA(1);
                if(!(_la===VtlParser.ALL || _la===VtlParser.SINGLE)) {
                    localctx.op = this._errHandler.recoverInline(this);
                }
                else {
                	this._errHandler.reportMatch(this);
                    this.consume();
                }
            }

            this.state = 824;
            this.match(VtlParser.RPAREN);
            break;
        case VtlParser.FLOW_TO_STOCK:
        case VtlParser.STOCK_TO_FLOW:
            localctx = new FlowAtomContext(this, localctx);
            this.enterOuterAlt(localctx, 3);
            this.state = 826;
            localctx.op = this._input.LT(1);
            _la = this._input.LA(1);
            if(!(_la===VtlParser.FLOW_TO_STOCK || _la===VtlParser.STOCK_TO_FLOW)) {
                localctx.op = this._errHandler.recoverInline(this);
            }
            else {
            	this._errHandler.reportMatch(this);
                this.consume();
            }
            this.state = 827;
            this.match(VtlParser.LPAREN);
            this.state = 828;
            this.expr(0);
            this.state = 829;
            this.match(VtlParser.RPAREN);
            break;
        case VtlParser.TIMESHIFT:
            localctx = new TimeShiftAtomContext(this, localctx);
            this.enterOuterAlt(localctx, 4);
            this.state = 831;
            this.match(VtlParser.TIMESHIFT);
            this.state = 832;
            this.match(VtlParser.LPAREN);
            this.state = 833;
            this.expr(0);
            this.state = 834;
            this.match(VtlParser.COMMA);
            this.state = 835;
            this.signedInteger();
            this.state = 836;
            this.match(VtlParser.RPAREN);
            break;
        case VtlParser.TIME_AGG:
            localctx = new TimeAggAtomContext(this, localctx);
            this.enterOuterAlt(localctx, 5);
            this.state = 838;
            this.match(VtlParser.TIME_AGG);
            this.state = 839;
            this.match(VtlParser.LPAREN);
            this.state = 840;
            localctx.periodIndTo = this.match(VtlParser.STRING_CONSTANT);
            this.state = 843;
            this._errHandler.sync(this);
            var la_ = this._interp.adaptivePredict(this._input,65,this._ctx);
            if(la_===1) {
                this.state = 841;
                this.match(VtlParser.COMMA);
                this.state = 842;
                localctx.periodIndFrom = this._input.LT(1);
                _la = this._input.LA(1);
                if(!(_la===VtlParser.OPTIONAL || _la===VtlParser.STRING_CONSTANT)) {
                    localctx.periodIndFrom = this._errHandler.recoverInline(this);
                }
                else {
                	this._errHandler.reportMatch(this);
                    this.consume();
                }

            }
            this.state = 847;
            this._errHandler.sync(this);
            var la_ = this._interp.adaptivePredict(this._input,66,this._ctx);
            if(la_===1) {
                this.state = 845;
                this.match(VtlParser.COMMA);
                this.state = 846;
                localctx.op = this.optionalExpr();

            }
            this.state = 851;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if(_la===VtlParser.COMMA) {
                this.state = 849;
                this.match(VtlParser.COMMA);
                this.state = 850;
                _la = this._input.LA(1);
                if(!(_la===VtlParser.FIRST || _la===VtlParser.LAST)) {
                this._errHandler.recoverInline(this);
                }
                else {
                	this._errHandler.reportMatch(this);
                    this.consume();
                }
            }

            this.state = 853;
            this.match(VtlParser.RPAREN);
            break;
        case VtlParser.CURRENT_DATE:
            localctx = new CurrentDateAtomContext(this, localctx);
            this.enterOuterAlt(localctx, 6);
            this.state = 854;
            this.match(VtlParser.CURRENT_DATE);
            this.state = 855;
            this.match(VtlParser.LPAREN);
            this.state = 856;
            this.match(VtlParser.RPAREN);
            break;
        default:
            throw new antlr4.error.NoViableAltException(this);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


function TimeOperatorsComponentContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = VtlParser.RULE_timeOperatorsComponent;
    return this;
}

TimeOperatorsComponentContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
TimeOperatorsComponentContext.prototype.constructor = TimeOperatorsComponentContext;


 
TimeOperatorsComponentContext.prototype.copyFrom = function(ctx) {
    antlr4.ParserRuleContext.prototype.copyFrom.call(this, ctx);
};


function PeriodAtomComponentContext(parser, ctx) {
	TimeOperatorsComponentContext.call(this, parser);
    TimeOperatorsComponentContext.prototype.copyFrom.call(this, ctx);
    return this;
}

PeriodAtomComponentContext.prototype = Object.create(TimeOperatorsComponentContext.prototype);
PeriodAtomComponentContext.prototype.constructor = PeriodAtomComponentContext;

VtlParser.PeriodAtomComponentContext = PeriodAtomComponentContext;

PeriodAtomComponentContext.prototype.PERIOD_INDICATOR = function() {
    return this.getToken(VtlParser.PERIOD_INDICATOR, 0);
};

PeriodAtomComponentContext.prototype.LPAREN = function() {
    return this.getToken(VtlParser.LPAREN, 0);
};

PeriodAtomComponentContext.prototype.RPAREN = function() {
    return this.getToken(VtlParser.RPAREN, 0);
};

PeriodAtomComponentContext.prototype.exprComponent = function() {
    return this.getTypedRuleContext(ExprComponentContext,0);
};

function TimeShiftAtomComponentContext(parser, ctx) {
	TimeOperatorsComponentContext.call(this, parser);
    TimeOperatorsComponentContext.prototype.copyFrom.call(this, ctx);
    return this;
}

TimeShiftAtomComponentContext.prototype = Object.create(TimeOperatorsComponentContext.prototype);
TimeShiftAtomComponentContext.prototype.constructor = TimeShiftAtomComponentContext;

VtlParser.TimeShiftAtomComponentContext = TimeShiftAtomComponentContext;

TimeShiftAtomComponentContext.prototype.TIMESHIFT = function() {
    return this.getToken(VtlParser.TIMESHIFT, 0);
};

TimeShiftAtomComponentContext.prototype.LPAREN = function() {
    return this.getToken(VtlParser.LPAREN, 0);
};

TimeShiftAtomComponentContext.prototype.exprComponent = function() {
    return this.getTypedRuleContext(ExprComponentContext,0);
};

TimeShiftAtomComponentContext.prototype.COMMA = function() {
    return this.getToken(VtlParser.COMMA, 0);
};

TimeShiftAtomComponentContext.prototype.signedInteger = function() {
    return this.getTypedRuleContext(SignedIntegerContext,0);
};

TimeShiftAtomComponentContext.prototype.RPAREN = function() {
    return this.getToken(VtlParser.RPAREN, 0);
};

function TimeAggAtomComponentContext(parser, ctx) {
	TimeOperatorsComponentContext.call(this, parser);
    this.periodIndTo = null; // Token;
    this.periodIndFrom = null; // Token;
    this.op = null; // OptionalExprComponentContext;
    TimeOperatorsComponentContext.prototype.copyFrom.call(this, ctx);
    return this;
}

TimeAggAtomComponentContext.prototype = Object.create(TimeOperatorsComponentContext.prototype);
TimeAggAtomComponentContext.prototype.constructor = TimeAggAtomComponentContext;

VtlParser.TimeAggAtomComponentContext = TimeAggAtomComponentContext;

TimeAggAtomComponentContext.prototype.TIME_AGG = function() {
    return this.getToken(VtlParser.TIME_AGG, 0);
};

TimeAggAtomComponentContext.prototype.LPAREN = function() {
    return this.getToken(VtlParser.LPAREN, 0);
};

TimeAggAtomComponentContext.prototype.RPAREN = function() {
    return this.getToken(VtlParser.RPAREN, 0);
};

TimeAggAtomComponentContext.prototype.STRING_CONSTANT = function(i) {
	if(i===undefined) {
		i = null;
	}
    if(i===null) {
        return this.getTokens(VtlParser.STRING_CONSTANT);
    } else {
        return this.getToken(VtlParser.STRING_CONSTANT, i);
    }
};


TimeAggAtomComponentContext.prototype.COMMA = function(i) {
	if(i===undefined) {
		i = null;
	}
    if(i===null) {
        return this.getTokens(VtlParser.COMMA);
    } else {
        return this.getToken(VtlParser.COMMA, i);
    }
};


TimeAggAtomComponentContext.prototype.optionalExprComponent = function() {
    return this.getTypedRuleContext(OptionalExprComponentContext,0);
};

TimeAggAtomComponentContext.prototype.FIRST = function() {
    return this.getToken(VtlParser.FIRST, 0);
};

TimeAggAtomComponentContext.prototype.LAST = function() {
    return this.getToken(VtlParser.LAST, 0);
};

TimeAggAtomComponentContext.prototype.OPTIONAL = function() {
    return this.getToken(VtlParser.OPTIONAL, 0);
};

function CurrentDateAtomComponentContext(parser, ctx) {
	TimeOperatorsComponentContext.call(this, parser);
    TimeOperatorsComponentContext.prototype.copyFrom.call(this, ctx);
    return this;
}

CurrentDateAtomComponentContext.prototype = Object.create(TimeOperatorsComponentContext.prototype);
CurrentDateAtomComponentContext.prototype.constructor = CurrentDateAtomComponentContext;

VtlParser.CurrentDateAtomComponentContext = CurrentDateAtomComponentContext;

CurrentDateAtomComponentContext.prototype.CURRENT_DATE = function() {
    return this.getToken(VtlParser.CURRENT_DATE, 0);
};

CurrentDateAtomComponentContext.prototype.LPAREN = function() {
    return this.getToken(VtlParser.LPAREN, 0);
};

CurrentDateAtomComponentContext.prototype.RPAREN = function() {
    return this.getToken(VtlParser.RPAREN, 0);
};

function FlowAtomComponentContext(parser, ctx) {
	TimeOperatorsComponentContext.call(this, parser);
    this.op = null; // Token;
    TimeOperatorsComponentContext.prototype.copyFrom.call(this, ctx);
    return this;
}

FlowAtomComponentContext.prototype = Object.create(TimeOperatorsComponentContext.prototype);
FlowAtomComponentContext.prototype.constructor = FlowAtomComponentContext;

VtlParser.FlowAtomComponentContext = FlowAtomComponentContext;

FlowAtomComponentContext.prototype.LPAREN = function() {
    return this.getToken(VtlParser.LPAREN, 0);
};

FlowAtomComponentContext.prototype.exprComponent = function() {
    return this.getTypedRuleContext(ExprComponentContext,0);
};

FlowAtomComponentContext.prototype.RPAREN = function() {
    return this.getToken(VtlParser.RPAREN, 0);
};

FlowAtomComponentContext.prototype.FLOW_TO_STOCK = function() {
    return this.getToken(VtlParser.FLOW_TO_STOCK, 0);
};

FlowAtomComponentContext.prototype.STOCK_TO_FLOW = function() {
    return this.getToken(VtlParser.STOCK_TO_FLOW, 0);
};

function FillTimeAtomComponentContext(parser, ctx) {
	TimeOperatorsComponentContext.call(this, parser);
    TimeOperatorsComponentContext.prototype.copyFrom.call(this, ctx);
    return this;
}

FillTimeAtomComponentContext.prototype = Object.create(TimeOperatorsComponentContext.prototype);
FillTimeAtomComponentContext.prototype.constructor = FillTimeAtomComponentContext;

VtlParser.FillTimeAtomComponentContext = FillTimeAtomComponentContext;

FillTimeAtomComponentContext.prototype.FILL_TIME_SERIES = function() {
    return this.getToken(VtlParser.FILL_TIME_SERIES, 0);
};

FillTimeAtomComponentContext.prototype.LPAREN = function() {
    return this.getToken(VtlParser.LPAREN, 0);
};

FillTimeAtomComponentContext.prototype.exprComponent = function() {
    return this.getTypedRuleContext(ExprComponentContext,0);
};

FillTimeAtomComponentContext.prototype.RPAREN = function() {
    return this.getToken(VtlParser.RPAREN, 0);
};

FillTimeAtomComponentContext.prototype.COMMA = function() {
    return this.getToken(VtlParser.COMMA, 0);
};

FillTimeAtomComponentContext.prototype.SINGLE = function() {
    return this.getToken(VtlParser.SINGLE, 0);
};

FillTimeAtomComponentContext.prototype.ALL = function() {
    return this.getToken(VtlParser.ALL, 0);
};


VtlParser.TimeOperatorsComponentContext = TimeOperatorsComponentContext;

VtlParser.prototype.timeOperatorsComponent = function() {

    var localctx = new TimeOperatorsComponentContext(this, this._ctx, this.state);
    this.enterRule(localctx, 54, VtlParser.RULE_timeOperatorsComponent);
    var _la = 0; // Token type
    try {
        this.state = 905;
        this._errHandler.sync(this);
        switch(this._input.LA(1)) {
        case VtlParser.PERIOD_INDICATOR:
            localctx = new PeriodAtomComponentContext(this, localctx);
            this.enterOuterAlt(localctx, 1);
            this.state = 859;
            this.match(VtlParser.PERIOD_INDICATOR);
            this.state = 860;
            this.match(VtlParser.LPAREN);
            this.state = 862;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << VtlParser.LPAREN) | (1 << VtlParser.PLUS) | (1 << VtlParser.MINUS) | (1 << VtlParser.EVAL) | (1 << VtlParser.IF) | (1 << VtlParser.CURRENT_DATE))) !== 0) || ((((_la - 39)) & ~0x1f) == 0 && ((1 << (_la - 39)) & ((1 << (VtlParser.NOT - 39)) | (1 << (VtlParser.BETWEEN - 39)) | (1 << (VtlParser.NULL_CONSTANT - 39)) | (1 << (VtlParser.ISNULL - 39)) | (1 << (VtlParser.RANK - 39)) | (1 << (VtlParser.MIN - 39)) | (1 << (VtlParser.MAX - 39)))) !== 0) || ((((_la - 73)) & ~0x1f) == 0 && ((1 << (_la - 73)) & ((1 << (VtlParser.ABS - 73)) | (1 << (VtlParser.LN - 73)) | (1 << (VtlParser.LOG - 73)) | (1 << (VtlParser.TRUNC - 73)) | (1 << (VtlParser.ROUND - 73)) | (1 << (VtlParser.POWER - 73)) | (1 << (VtlParser.MOD - 73)) | (1 << (VtlParser.LEN - 73)) | (1 << (VtlParser.TRIM - 73)) | (1 << (VtlParser.UCASE - 73)) | (1 << (VtlParser.LCASE - 73)) | (1 << (VtlParser.SUBSTR - 73)) | (1 << (VtlParser.SUM - 73)) | (1 << (VtlParser.AVG - 73)) | (1 << (VtlParser.MEDIAN - 73)) | (1 << (VtlParser.COUNT - 73)) | (1 << (VtlParser.EXP - 73)) | (1 << (VtlParser.CHARSET_MATCH - 73)) | (1 << (VtlParser.NVL - 73)))) !== 0) || ((((_la - 119)) & ~0x1f) == 0 && ((1 << (_la - 119)) & ((1 << (VtlParser.LTRIM - 119)) | (1 << (VtlParser.RTRIM - 119)) | (1 << (VtlParser.INSTR - 119)) | (1 << (VtlParser.REPLACE - 119)) | (1 << (VtlParser.CEIL - 119)) | (1 << (VtlParser.FLOOR - 119)) | (1 << (VtlParser.SQRT - 119)) | (1 << (VtlParser.STDDEV_POP - 119)) | (1 << (VtlParser.STDDEV_SAMP - 119)) | (1 << (VtlParser.VAR_POP - 119)) | (1 << (VtlParser.VAR_SAMP - 119)) | (1 << (VtlParser.FIRST_VALUE - 119)) | (1 << (VtlParser.LAST_VALUE - 119)) | (1 << (VtlParser.LAG - 119)) | (1 << (VtlParser.LEAD - 119)) | (1 << (VtlParser.RATIO_TO_REPORT - 119)) | (1 << (VtlParser.FILL_TIME_SERIES - 119)) | (1 << (VtlParser.FLOW_TO_STOCK - 119)))) !== 0) || _la===VtlParser.STOCK_TO_FLOW || _la===VtlParser.TIMESHIFT || ((((_la - 196)) & ~0x1f) == 0 && ((1 << (_la - 196)) & ((1 << (VtlParser.PERIOD_INDICATOR - 196)) | (1 << (VtlParser.TIME_AGG - 196)) | (1 << (VtlParser.CAST - 196)))) !== 0) || ((((_la - 229)) & ~0x1f) == 0 && ((1 << (_la - 229)) & ((1 << (VtlParser.INTEGER_CONSTANT - 229)) | (1 << (VtlParser.NUMBER_CONSTANT - 229)) | (1 << (VtlParser.BOOLEAN_CONSTANT - 229)) | (1 << (VtlParser.STRING_CONSTANT - 229)) | (1 << (VtlParser.IDENTIFIER - 229)))) !== 0)) {
                this.state = 861;
                this.exprComponent(0);
            }

            this.state = 864;
            this.match(VtlParser.RPAREN);
            break;
        case VtlParser.FILL_TIME_SERIES:
            localctx = new FillTimeAtomComponentContext(this, localctx);
            this.enterOuterAlt(localctx, 2);
            this.state = 865;
            this.match(VtlParser.FILL_TIME_SERIES);
            this.state = 866;
            this.match(VtlParser.LPAREN);
            this.state = 867;
            this.exprComponent(0);
            this.state = 870;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if(_la===VtlParser.COMMA) {
                this.state = 868;
                this.match(VtlParser.COMMA);
                this.state = 869;
                _la = this._input.LA(1);
                if(!(_la===VtlParser.ALL || _la===VtlParser.SINGLE)) {
                this._errHandler.recoverInline(this);
                }
                else {
                	this._errHandler.reportMatch(this);
                    this.consume();
                }
            }

            this.state = 872;
            this.match(VtlParser.RPAREN);
            break;
        case VtlParser.FLOW_TO_STOCK:
        case VtlParser.STOCK_TO_FLOW:
            localctx = new FlowAtomComponentContext(this, localctx);
            this.enterOuterAlt(localctx, 3);
            this.state = 874;
            localctx.op = this._input.LT(1);
            _la = this._input.LA(1);
            if(!(_la===VtlParser.FLOW_TO_STOCK || _la===VtlParser.STOCK_TO_FLOW)) {
                localctx.op = this._errHandler.recoverInline(this);
            }
            else {
            	this._errHandler.reportMatch(this);
                this.consume();
            }
            this.state = 875;
            this.match(VtlParser.LPAREN);
            this.state = 876;
            this.exprComponent(0);
            this.state = 877;
            this.match(VtlParser.RPAREN);
            break;
        case VtlParser.TIMESHIFT:
            localctx = new TimeShiftAtomComponentContext(this, localctx);
            this.enterOuterAlt(localctx, 4);
            this.state = 879;
            this.match(VtlParser.TIMESHIFT);
            this.state = 880;
            this.match(VtlParser.LPAREN);
            this.state = 881;
            this.exprComponent(0);
            this.state = 882;
            this.match(VtlParser.COMMA);
            this.state = 883;
            this.signedInteger();
            this.state = 884;
            this.match(VtlParser.RPAREN);
            break;
        case VtlParser.TIME_AGG:
            localctx = new TimeAggAtomComponentContext(this, localctx);
            this.enterOuterAlt(localctx, 5);
            this.state = 886;
            this.match(VtlParser.TIME_AGG);
            this.state = 887;
            this.match(VtlParser.LPAREN);
            this.state = 888;
            localctx.periodIndTo = this.match(VtlParser.STRING_CONSTANT);
            this.state = 891;
            this._errHandler.sync(this);
            var la_ = this._interp.adaptivePredict(this._input,71,this._ctx);
            if(la_===1) {
                this.state = 889;
                this.match(VtlParser.COMMA);
                this.state = 890;
                localctx.periodIndFrom = this._input.LT(1);
                _la = this._input.LA(1);
                if(!(_la===VtlParser.OPTIONAL || _la===VtlParser.STRING_CONSTANT)) {
                    localctx.periodIndFrom = this._errHandler.recoverInline(this);
                }
                else {
                	this._errHandler.reportMatch(this);
                    this.consume();
                }

            }
            this.state = 895;
            this._errHandler.sync(this);
            var la_ = this._interp.adaptivePredict(this._input,72,this._ctx);
            if(la_===1) {
                this.state = 893;
                this.match(VtlParser.COMMA);
                this.state = 894;
                localctx.op = this.optionalExprComponent();

            }
            this.state = 899;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if(_la===VtlParser.COMMA) {
                this.state = 897;
                this.match(VtlParser.COMMA);
                this.state = 898;
                _la = this._input.LA(1);
                if(!(_la===VtlParser.FIRST || _la===VtlParser.LAST)) {
                this._errHandler.recoverInline(this);
                }
                else {
                	this._errHandler.reportMatch(this);
                    this.consume();
                }
            }

            this.state = 901;
            this.match(VtlParser.RPAREN);
            break;
        case VtlParser.CURRENT_DATE:
            localctx = new CurrentDateAtomComponentContext(this, localctx);
            this.enterOuterAlt(localctx, 6);
            this.state = 902;
            this.match(VtlParser.CURRENT_DATE);
            this.state = 903;
            this.match(VtlParser.LPAREN);
            this.state = 904;
            this.match(VtlParser.RPAREN);
            break;
        default:
            throw new antlr4.error.NoViableAltException(this);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


function SetOperatorsContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = VtlParser.RULE_setOperators;
    return this;
}

SetOperatorsContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
SetOperatorsContext.prototype.constructor = SetOperatorsContext;


 
SetOperatorsContext.prototype.copyFrom = function(ctx) {
    antlr4.ParserRuleContext.prototype.copyFrom.call(this, ctx);
};


function SetOrSYmDiffAtomContext(parser, ctx) {
	SetOperatorsContext.call(this, parser);
    this.op = null; // Token;
    this.left = null; // ExprContext;
    this.right = null; // ExprContext;
    SetOperatorsContext.prototype.copyFrom.call(this, ctx);
    return this;
}

SetOrSYmDiffAtomContext.prototype = Object.create(SetOperatorsContext.prototype);
SetOrSYmDiffAtomContext.prototype.constructor = SetOrSYmDiffAtomContext;

VtlParser.SetOrSYmDiffAtomContext = SetOrSYmDiffAtomContext;

SetOrSYmDiffAtomContext.prototype.LPAREN = function() {
    return this.getToken(VtlParser.LPAREN, 0);
};

SetOrSYmDiffAtomContext.prototype.COMMA = function() {
    return this.getToken(VtlParser.COMMA, 0);
};

SetOrSYmDiffAtomContext.prototype.RPAREN = function() {
    return this.getToken(VtlParser.RPAREN, 0);
};

SetOrSYmDiffAtomContext.prototype.expr = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(ExprContext);
    } else {
        return this.getTypedRuleContext(ExprContext,i);
    }
};

SetOrSYmDiffAtomContext.prototype.SETDIFF = function() {
    return this.getToken(VtlParser.SETDIFF, 0);
};

SetOrSYmDiffAtomContext.prototype.SYMDIFF = function() {
    return this.getToken(VtlParser.SYMDIFF, 0);
};

function IntersectAtomContext(parser, ctx) {
	SetOperatorsContext.call(this, parser);
    this.left = null; // ExprContext;
    SetOperatorsContext.prototype.copyFrom.call(this, ctx);
    return this;
}

IntersectAtomContext.prototype = Object.create(SetOperatorsContext.prototype);
IntersectAtomContext.prototype.constructor = IntersectAtomContext;

VtlParser.IntersectAtomContext = IntersectAtomContext;

IntersectAtomContext.prototype.INTERSECT = function() {
    return this.getToken(VtlParser.INTERSECT, 0);
};

IntersectAtomContext.prototype.LPAREN = function() {
    return this.getToken(VtlParser.LPAREN, 0);
};

IntersectAtomContext.prototype.RPAREN = function() {
    return this.getToken(VtlParser.RPAREN, 0);
};

IntersectAtomContext.prototype.expr = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(ExprContext);
    } else {
        return this.getTypedRuleContext(ExprContext,i);
    }
};

IntersectAtomContext.prototype.COMMA = function(i) {
	if(i===undefined) {
		i = null;
	}
    if(i===null) {
        return this.getTokens(VtlParser.COMMA);
    } else {
        return this.getToken(VtlParser.COMMA, i);
    }
};


function UnionAtomContext(parser, ctx) {
	SetOperatorsContext.call(this, parser);
    this.left = null; // ExprContext;
    SetOperatorsContext.prototype.copyFrom.call(this, ctx);
    return this;
}

UnionAtomContext.prototype = Object.create(SetOperatorsContext.prototype);
UnionAtomContext.prototype.constructor = UnionAtomContext;

VtlParser.UnionAtomContext = UnionAtomContext;

UnionAtomContext.prototype.UNION = function() {
    return this.getToken(VtlParser.UNION, 0);
};

UnionAtomContext.prototype.LPAREN = function() {
    return this.getToken(VtlParser.LPAREN, 0);
};

UnionAtomContext.prototype.RPAREN = function() {
    return this.getToken(VtlParser.RPAREN, 0);
};

UnionAtomContext.prototype.expr = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(ExprContext);
    } else {
        return this.getTypedRuleContext(ExprContext,i);
    }
};

UnionAtomContext.prototype.COMMA = function(i) {
	if(i===undefined) {
		i = null;
	}
    if(i===null) {
        return this.getTokens(VtlParser.COMMA);
    } else {
        return this.getToken(VtlParser.COMMA, i);
    }
};



VtlParser.SetOperatorsContext = SetOperatorsContext;

VtlParser.prototype.setOperators = function() {

    var localctx = new SetOperatorsContext(this, this._ctx, this.state);
    this.enterRule(localctx, 56, VtlParser.RULE_setOperators);
    var _la = 0; // Token type
    try {
        this.state = 936;
        this._errHandler.sync(this);
        switch(this._input.LA(1)) {
        case VtlParser.UNION:
            localctx = new UnionAtomContext(this, localctx);
            this.enterOuterAlt(localctx, 1);
            this.state = 907;
            this.match(VtlParser.UNION);
            this.state = 908;
            this.match(VtlParser.LPAREN);
            this.state = 909;
            localctx.left = this.expr(0);
            this.state = 912; 
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            do {
                this.state = 910;
                this.match(VtlParser.COMMA);
                this.state = 911;
                this.expr(0);
                this.state = 914; 
                this._errHandler.sync(this);
                _la = this._input.LA(1);
            } while(_la===VtlParser.COMMA);
            this.state = 916;
            this.match(VtlParser.RPAREN);
            break;
        case VtlParser.INTERSECT:
            localctx = new IntersectAtomContext(this, localctx);
            this.enterOuterAlt(localctx, 2);
            this.state = 918;
            this.match(VtlParser.INTERSECT);
            this.state = 919;
            this.match(VtlParser.LPAREN);
            this.state = 920;
            localctx.left = this.expr(0);
            this.state = 923; 
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            do {
                this.state = 921;
                this.match(VtlParser.COMMA);
                this.state = 922;
                this.expr(0);
                this.state = 925; 
                this._errHandler.sync(this);
                _la = this._input.LA(1);
            } while(_la===VtlParser.COMMA);
            this.state = 927;
            this.match(VtlParser.RPAREN);
            break;
        case VtlParser.SYMDIFF:
        case VtlParser.SETDIFF:
            localctx = new SetOrSYmDiffAtomContext(this, localctx);
            this.enterOuterAlt(localctx, 3);
            this.state = 929;
            localctx.op = this._input.LT(1);
            _la = this._input.LA(1);
            if(!(_la===VtlParser.SYMDIFF || _la===VtlParser.SETDIFF)) {
                localctx.op = this._errHandler.recoverInline(this);
            }
            else {
            	this._errHandler.reportMatch(this);
                this.consume();
            }
            this.state = 930;
            this.match(VtlParser.LPAREN);
            this.state = 931;
            localctx.left = this.expr(0);
            this.state = 932;
            this.match(VtlParser.COMMA);
            this.state = 933;
            localctx.right = this.expr(0);
            this.state = 934;
            this.match(VtlParser.RPAREN);
            break;
        default:
            throw new antlr4.error.NoViableAltException(this);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


function HierarchyOperatorsContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = VtlParser.RULE_hierarchyOperators;
    this.op = null; // ExprContext
    this.hrName = null; // Token
    this.ruleComponent = null; // ComponentIDContext
    return this;
}

HierarchyOperatorsContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
HierarchyOperatorsContext.prototype.constructor = HierarchyOperatorsContext;

HierarchyOperatorsContext.prototype.HIERARCHY = function() {
    return this.getToken(VtlParser.HIERARCHY, 0);
};

HierarchyOperatorsContext.prototype.LPAREN = function() {
    return this.getToken(VtlParser.LPAREN, 0);
};

HierarchyOperatorsContext.prototype.COMMA = function() {
    return this.getToken(VtlParser.COMMA, 0);
};

HierarchyOperatorsContext.prototype.RPAREN = function() {
    return this.getToken(VtlParser.RPAREN, 0);
};

HierarchyOperatorsContext.prototype.expr = function() {
    return this.getTypedRuleContext(ExprContext,0);
};

HierarchyOperatorsContext.prototype.IDENTIFIER = function() {
    return this.getToken(VtlParser.IDENTIFIER, 0);
};

HierarchyOperatorsContext.prototype.conditionClause = function() {
    return this.getTypedRuleContext(ConditionClauseContext,0);
};

HierarchyOperatorsContext.prototype.RULE = function() {
    return this.getToken(VtlParser.RULE, 0);
};

HierarchyOperatorsContext.prototype.validationMode = function() {
    return this.getTypedRuleContext(ValidationModeContext,0);
};

HierarchyOperatorsContext.prototype.inputModeHierarchy = function() {
    return this.getTypedRuleContext(InputModeHierarchyContext,0);
};

HierarchyOperatorsContext.prototype.outputModeHierarchy = function() {
    return this.getTypedRuleContext(OutputModeHierarchyContext,0);
};

HierarchyOperatorsContext.prototype.componentID = function() {
    return this.getTypedRuleContext(ComponentIDContext,0);
};




VtlParser.HierarchyOperatorsContext = HierarchyOperatorsContext;

VtlParser.prototype.hierarchyOperators = function() {

    var localctx = new HierarchyOperatorsContext(this, this._ctx, this.state);
    this.enterRule(localctx, 58, VtlParser.RULE_hierarchyOperators);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 938;
        this.match(VtlParser.HIERARCHY);
        this.state = 939;
        this.match(VtlParser.LPAREN);
        this.state = 940;
        localctx.op = this.expr(0);
        this.state = 941;
        this.match(VtlParser.COMMA);
        this.state = 942;
        localctx.hrName = this.match(VtlParser.IDENTIFIER);
        this.state = 944;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if(_la===VtlParser.CONDITION) {
            this.state = 943;
            this.conditionClause();
        }

        this.state = 948;
        this._errHandler.sync(this);
        var la_ = this._interp.adaptivePredict(this._input,79,this._ctx);
        if(la_===1) {
            this.state = 946;
            this.match(VtlParser.RULE);
            this.state = 947;
            localctx.ruleComponent = this.componentID();

        }
        this.state = 951;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if(((((_la - 213)) & ~0x1f) == 0 && ((1 << (_la - 213)) & ((1 << (VtlParser.NON_NULL - 213)) | (1 << (VtlParser.NON_ZERO - 213)) | (1 << (VtlParser.PARTIAL_NULL - 213)) | (1 << (VtlParser.PARTIAL_ZERO - 213)) | (1 << (VtlParser.ALWAYS_NULL - 213)) | (1 << (VtlParser.ALWAYS_ZERO - 213)))) !== 0)) {
            this.state = 950;
            this.validationMode();
        }

        this.state = 954;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if(_la===VtlParser.DATASET || _la===VtlParser.RULE || _la===VtlParser.RULE_PRIORITY) {
            this.state = 953;
            this.inputModeHierarchy();
        }

        this.state = 957;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if(_la===VtlParser.ALL || _la===VtlParser.COMPUTED) {
            this.state = 956;
            this.outputModeHierarchy();
        }

        this.state = 959;
        this.match(VtlParser.RPAREN);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


function ValidationOperatorsContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = VtlParser.RULE_validationOperators;
    return this;
}

ValidationOperatorsContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ValidationOperatorsContext.prototype.constructor = ValidationOperatorsContext;


 
ValidationOperatorsContext.prototype.copyFrom = function(ctx) {
    antlr4.ParserRuleContext.prototype.copyFrom.call(this, ctx);
};


function ValidateHRrulesetContext(parser, ctx) {
	ValidationOperatorsContext.call(this, parser);
    this.op = null; // ExprContext;
    this.hrName = null; // Token;
    ValidationOperatorsContext.prototype.copyFrom.call(this, ctx);
    return this;
}

ValidateHRrulesetContext.prototype = Object.create(ValidationOperatorsContext.prototype);
ValidateHRrulesetContext.prototype.constructor = ValidateHRrulesetContext;

VtlParser.ValidateHRrulesetContext = ValidateHRrulesetContext;

ValidateHRrulesetContext.prototype.CHECK_HIERARCHY = function() {
    return this.getToken(VtlParser.CHECK_HIERARCHY, 0);
};

ValidateHRrulesetContext.prototype.LPAREN = function() {
    return this.getToken(VtlParser.LPAREN, 0);
};

ValidateHRrulesetContext.prototype.COMMA = function() {
    return this.getToken(VtlParser.COMMA, 0);
};

ValidateHRrulesetContext.prototype.RPAREN = function() {
    return this.getToken(VtlParser.RPAREN, 0);
};

ValidateHRrulesetContext.prototype.expr = function() {
    return this.getTypedRuleContext(ExprContext,0);
};

ValidateHRrulesetContext.prototype.IDENTIFIER = function() {
    return this.getToken(VtlParser.IDENTIFIER, 0);
};

ValidateHRrulesetContext.prototype.conditionClause = function() {
    return this.getTypedRuleContext(ConditionClauseContext,0);
};

ValidateHRrulesetContext.prototype.RULE = function() {
    return this.getToken(VtlParser.RULE, 0);
};

ValidateHRrulesetContext.prototype.componentID = function() {
    return this.getTypedRuleContext(ComponentIDContext,0);
};

ValidateHRrulesetContext.prototype.validationMode = function() {
    return this.getTypedRuleContext(ValidationModeContext,0);
};

ValidateHRrulesetContext.prototype.inputMode = function() {
    return this.getTypedRuleContext(InputModeContext,0);
};

ValidateHRrulesetContext.prototype.validationOutput = function() {
    return this.getTypedRuleContext(ValidationOutputContext,0);
};

function ValidateDPrulesetContext(parser, ctx) {
	ValidationOperatorsContext.call(this, parser);
    this.op = null; // ExprContext;
    this.dpName = null; // Token;
    ValidationOperatorsContext.prototype.copyFrom.call(this, ctx);
    return this;
}

ValidateDPrulesetContext.prototype = Object.create(ValidationOperatorsContext.prototype);
ValidateDPrulesetContext.prototype.constructor = ValidateDPrulesetContext;

VtlParser.ValidateDPrulesetContext = ValidateDPrulesetContext;

ValidateDPrulesetContext.prototype.CHECK_DATAPOINT = function() {
    return this.getToken(VtlParser.CHECK_DATAPOINT, 0);
};

ValidateDPrulesetContext.prototype.LPAREN = function() {
    return this.getToken(VtlParser.LPAREN, 0);
};

ValidateDPrulesetContext.prototype.COMMA = function(i) {
	if(i===undefined) {
		i = null;
	}
    if(i===null) {
        return this.getTokens(VtlParser.COMMA);
    } else {
        return this.getToken(VtlParser.COMMA, i);
    }
};


ValidateDPrulesetContext.prototype.RPAREN = function() {
    return this.getToken(VtlParser.RPAREN, 0);
};

ValidateDPrulesetContext.prototype.expr = function() {
    return this.getTypedRuleContext(ExprContext,0);
};

ValidateDPrulesetContext.prototype.IDENTIFIER = function() {
    return this.getToken(VtlParser.IDENTIFIER, 0);
};

ValidateDPrulesetContext.prototype.COMPONENTS = function() {
    return this.getToken(VtlParser.COMPONENTS, 0);
};

ValidateDPrulesetContext.prototype.componentID = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(ComponentIDContext);
    } else {
        return this.getTypedRuleContext(ComponentIDContext,i);
    }
};

ValidateDPrulesetContext.prototype.validationOutput = function() {
    return this.getTypedRuleContext(ValidationOutputContext,0);
};

function ValidationSimpleContext(parser, ctx) {
	ValidationOperatorsContext.call(this, parser);
    this.op = null; // ExprContext;
    this.codeErr = null; // ErCodeContext;
    this.levelCode = null; // ErLevelContext;
    this.output = null; // Token;
    ValidationOperatorsContext.prototype.copyFrom.call(this, ctx);
    return this;
}

ValidationSimpleContext.prototype = Object.create(ValidationOperatorsContext.prototype);
ValidationSimpleContext.prototype.constructor = ValidationSimpleContext;

VtlParser.ValidationSimpleContext = ValidationSimpleContext;

ValidationSimpleContext.prototype.CHECK = function() {
    return this.getToken(VtlParser.CHECK, 0);
};

ValidationSimpleContext.prototype.LPAREN = function() {
    return this.getToken(VtlParser.LPAREN, 0);
};

ValidationSimpleContext.prototype.RPAREN = function() {
    return this.getToken(VtlParser.RPAREN, 0);
};

ValidationSimpleContext.prototype.expr = function() {
    return this.getTypedRuleContext(ExprContext,0);
};

ValidationSimpleContext.prototype.imbalanceExpr = function() {
    return this.getTypedRuleContext(ImbalanceExprContext,0);
};

ValidationSimpleContext.prototype.erCode = function() {
    return this.getTypedRuleContext(ErCodeContext,0);
};

ValidationSimpleContext.prototype.erLevel = function() {
    return this.getTypedRuleContext(ErLevelContext,0);
};

ValidationSimpleContext.prototype.INVALID = function() {
    return this.getToken(VtlParser.INVALID, 0);
};

ValidationSimpleContext.prototype.ALL = function() {
    return this.getToken(VtlParser.ALL, 0);
};


VtlParser.ValidationOperatorsContext = ValidationOperatorsContext;

VtlParser.prototype.validationOperators = function() {

    var localctx = new ValidationOperatorsContext(this, this._ctx, this.state);
    this.enterRule(localctx, 60, VtlParser.RULE_validationOperators);
    var _la = 0; // Token type
    try {
        this.state = 1022;
        this._errHandler.sync(this);
        switch(this._input.LA(1)) {
        case VtlParser.CHECK_DATAPOINT:
            localctx = new ValidateDPrulesetContext(this, localctx);
            this.enterOuterAlt(localctx, 1);
            this.state = 961;
            this.match(VtlParser.CHECK_DATAPOINT);
            this.state = 962;
            this.match(VtlParser.LPAREN);
            this.state = 963;
            localctx.op = this.expr(0);
            this.state = 964;
            this.match(VtlParser.COMMA);
            this.state = 965;
            localctx.dpName = this.match(VtlParser.IDENTIFIER);
            this.state = 975;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if(_la===VtlParser.COMPONENTS) {
                this.state = 966;
                this.match(VtlParser.COMPONENTS);
                this.state = 967;
                this.componentID();
                this.state = 972;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
                while(_la===VtlParser.COMMA) {
                    this.state = 968;
                    this.match(VtlParser.COMMA);
                    this.state = 969;
                    this.componentID();
                    this.state = 974;
                    this._errHandler.sync(this);
                    _la = this._input.LA(1);
                }
            }

            this.state = 978;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if(_la===VtlParser.ALL || _la===VtlParser.INVALID || _la===VtlParser.ALL_MEASURES) {
                this.state = 977;
                this.validationOutput();
            }

            this.state = 980;
            this.match(VtlParser.RPAREN);
            break;
        case VtlParser.CHECK_HIERARCHY:
            localctx = new ValidateHRrulesetContext(this, localctx);
            this.enterOuterAlt(localctx, 2);
            this.state = 982;
            this.match(VtlParser.CHECK_HIERARCHY);
            this.state = 983;
            this.match(VtlParser.LPAREN);
            this.state = 984;
            localctx.op = this.expr(0);
            this.state = 985;
            this.match(VtlParser.COMMA);
            this.state = 986;
            localctx.hrName = this.match(VtlParser.IDENTIFIER);
            this.state = 988;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if(_la===VtlParser.CONDITION) {
                this.state = 987;
                this.conditionClause();
            }

            this.state = 992;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if(_la===VtlParser.RULE) {
                this.state = 990;
                this.match(VtlParser.RULE);
                this.state = 991;
                this.componentID();
            }

            this.state = 995;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if(((((_la - 213)) & ~0x1f) == 0 && ((1 << (_la - 213)) & ((1 << (VtlParser.NON_NULL - 213)) | (1 << (VtlParser.NON_ZERO - 213)) | (1 << (VtlParser.PARTIAL_NULL - 213)) | (1 << (VtlParser.PARTIAL_ZERO - 213)) | (1 << (VtlParser.ALWAYS_NULL - 213)) | (1 << (VtlParser.ALWAYS_ZERO - 213)))) !== 0)) {
                this.state = 994;
                this.validationMode();
            }

            this.state = 998;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if(_la===VtlParser.DATASET || _la===VtlParser.DATASET_PRIORITY) {
                this.state = 997;
                this.inputMode();
            }

            this.state = 1001;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if(_la===VtlParser.ALL || _la===VtlParser.INVALID || _la===VtlParser.ALL_MEASURES) {
                this.state = 1000;
                this.validationOutput();
            }

            this.state = 1003;
            this.match(VtlParser.RPAREN);
            break;
        case VtlParser.CHECK:
            localctx = new ValidationSimpleContext(this, localctx);
            this.enterOuterAlt(localctx, 3);
            this.state = 1005;
            this.match(VtlParser.CHECK);
            this.state = 1006;
            this.match(VtlParser.LPAREN);
            this.state = 1007;
            localctx.op = this.expr(0);
            this.state = 1009;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if(_la===VtlParser.ERRORCODE) {
                this.state = 1008;
                localctx.codeErr = this.erCode();
            }

            this.state = 1012;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if(_la===VtlParser.ERRORLEVEL) {
                this.state = 1011;
                localctx.levelCode = this.erLevel();
            }

            this.state = 1015;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if(_la===VtlParser.IMBALANCE) {
                this.state = 1014;
                this.imbalanceExpr();
            }

            this.state = 1018;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if(_la===VtlParser.ALL || _la===VtlParser.INVALID) {
                this.state = 1017;
                localctx.output = this._input.LT(1);
                _la = this._input.LA(1);
                if(!(_la===VtlParser.ALL || _la===VtlParser.INVALID)) {
                    localctx.output = this._errHandler.recoverInline(this);
                }
                else {
                	this._errHandler.reportMatch(this);
                    this.consume();
                }
            }

            this.state = 1020;
            this.match(VtlParser.RPAREN);
            break;
        default:
            throw new antlr4.error.NoViableAltException(this);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


function ConditionalOperatorsContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = VtlParser.RULE_conditionalOperators;
    return this;
}

ConditionalOperatorsContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ConditionalOperatorsContext.prototype.constructor = ConditionalOperatorsContext;


 
ConditionalOperatorsContext.prototype.copyFrom = function(ctx) {
    antlr4.ParserRuleContext.prototype.copyFrom.call(this, ctx);
};


function NvlAtomContext(parser, ctx) {
	ConditionalOperatorsContext.call(this, parser);
    this.left = null; // ExprContext;
    this.right = null; // ExprContext;
    ConditionalOperatorsContext.prototype.copyFrom.call(this, ctx);
    return this;
}

NvlAtomContext.prototype = Object.create(ConditionalOperatorsContext.prototype);
NvlAtomContext.prototype.constructor = NvlAtomContext;

VtlParser.NvlAtomContext = NvlAtomContext;

NvlAtomContext.prototype.NVL = function() {
    return this.getToken(VtlParser.NVL, 0);
};

NvlAtomContext.prototype.LPAREN = function() {
    return this.getToken(VtlParser.LPAREN, 0);
};

NvlAtomContext.prototype.COMMA = function() {
    return this.getToken(VtlParser.COMMA, 0);
};

NvlAtomContext.prototype.RPAREN = function() {
    return this.getToken(VtlParser.RPAREN, 0);
};

NvlAtomContext.prototype.expr = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(ExprContext);
    } else {
        return this.getTypedRuleContext(ExprContext,i);
    }
};


VtlParser.ConditionalOperatorsContext = ConditionalOperatorsContext;

VtlParser.prototype.conditionalOperators = function() {

    var localctx = new ConditionalOperatorsContext(this, this._ctx, this.state);
    this.enterRule(localctx, 62, VtlParser.RULE_conditionalOperators);
    try {
        localctx = new NvlAtomContext(this, localctx);
        this.enterOuterAlt(localctx, 1);
        this.state = 1024;
        this.match(VtlParser.NVL);
        this.state = 1025;
        this.match(VtlParser.LPAREN);
        this.state = 1026;
        localctx.left = this.expr(0);
        this.state = 1027;
        this.match(VtlParser.COMMA);
        this.state = 1028;
        localctx.right = this.expr(0);
        this.state = 1029;
        this.match(VtlParser.RPAREN);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


function ConditionalOperatorsComponentContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = VtlParser.RULE_conditionalOperatorsComponent;
    return this;
}

ConditionalOperatorsComponentContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ConditionalOperatorsComponentContext.prototype.constructor = ConditionalOperatorsComponentContext;


 
ConditionalOperatorsComponentContext.prototype.copyFrom = function(ctx) {
    antlr4.ParserRuleContext.prototype.copyFrom.call(this, ctx);
};


function NvlAtomComponentContext(parser, ctx) {
	ConditionalOperatorsComponentContext.call(this, parser);
    this.left = null; // ExprComponentContext;
    this.right = null; // ExprComponentContext;
    ConditionalOperatorsComponentContext.prototype.copyFrom.call(this, ctx);
    return this;
}

NvlAtomComponentContext.prototype = Object.create(ConditionalOperatorsComponentContext.prototype);
NvlAtomComponentContext.prototype.constructor = NvlAtomComponentContext;

VtlParser.NvlAtomComponentContext = NvlAtomComponentContext;

NvlAtomComponentContext.prototype.NVL = function() {
    return this.getToken(VtlParser.NVL, 0);
};

NvlAtomComponentContext.prototype.LPAREN = function() {
    return this.getToken(VtlParser.LPAREN, 0);
};

NvlAtomComponentContext.prototype.COMMA = function() {
    return this.getToken(VtlParser.COMMA, 0);
};

NvlAtomComponentContext.prototype.RPAREN = function() {
    return this.getToken(VtlParser.RPAREN, 0);
};

NvlAtomComponentContext.prototype.exprComponent = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(ExprComponentContext);
    } else {
        return this.getTypedRuleContext(ExprComponentContext,i);
    }
};


VtlParser.ConditionalOperatorsComponentContext = ConditionalOperatorsComponentContext;

VtlParser.prototype.conditionalOperatorsComponent = function() {

    var localctx = new ConditionalOperatorsComponentContext(this, this._ctx, this.state);
    this.enterRule(localctx, 64, VtlParser.RULE_conditionalOperatorsComponent);
    try {
        localctx = new NvlAtomComponentContext(this, localctx);
        this.enterOuterAlt(localctx, 1);
        this.state = 1031;
        this.match(VtlParser.NVL);
        this.state = 1032;
        this.match(VtlParser.LPAREN);
        this.state = 1033;
        localctx.left = this.exprComponent(0);
        this.state = 1034;
        this.match(VtlParser.COMMA);
        this.state = 1035;
        localctx.right = this.exprComponent(0);
        this.state = 1036;
        this.match(VtlParser.RPAREN);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


function AggrOperatorsContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = VtlParser.RULE_aggrOperators;
    return this;
}

AggrOperatorsContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
AggrOperatorsContext.prototype.constructor = AggrOperatorsContext;


 
AggrOperatorsContext.prototype.copyFrom = function(ctx) {
    antlr4.ParserRuleContext.prototype.copyFrom.call(this, ctx);
};


function AggrCompContext(parser, ctx) {
	AggrOperatorsContext.call(this, parser);
    this.op = null; // Token;
    AggrOperatorsContext.prototype.copyFrom.call(this, ctx);
    return this;
}

AggrCompContext.prototype = Object.create(AggrOperatorsContext.prototype);
AggrCompContext.prototype.constructor = AggrCompContext;

VtlParser.AggrCompContext = AggrCompContext;

AggrCompContext.prototype.LPAREN = function() {
    return this.getToken(VtlParser.LPAREN, 0);
};

AggrCompContext.prototype.exprComponent = function() {
    return this.getTypedRuleContext(ExprComponentContext,0);
};

AggrCompContext.prototype.RPAREN = function() {
    return this.getToken(VtlParser.RPAREN, 0);
};

AggrCompContext.prototype.SUM = function() {
    return this.getToken(VtlParser.SUM, 0);
};

AggrCompContext.prototype.AVG = function() {
    return this.getToken(VtlParser.AVG, 0);
};

AggrCompContext.prototype.COUNT = function() {
    return this.getToken(VtlParser.COUNT, 0);
};

AggrCompContext.prototype.MEDIAN = function() {
    return this.getToken(VtlParser.MEDIAN, 0);
};

AggrCompContext.prototype.MIN = function() {
    return this.getToken(VtlParser.MIN, 0);
};

AggrCompContext.prototype.MAX = function() {
    return this.getToken(VtlParser.MAX, 0);
};

AggrCompContext.prototype.STDDEV_POP = function() {
    return this.getToken(VtlParser.STDDEV_POP, 0);
};

AggrCompContext.prototype.STDDEV_SAMP = function() {
    return this.getToken(VtlParser.STDDEV_SAMP, 0);
};

AggrCompContext.prototype.VAR_POP = function() {
    return this.getToken(VtlParser.VAR_POP, 0);
};

AggrCompContext.prototype.VAR_SAMP = function() {
    return this.getToken(VtlParser.VAR_SAMP, 0);
};

function CountAggrCompContext(parser, ctx) {
	AggrOperatorsContext.call(this, parser);
    AggrOperatorsContext.prototype.copyFrom.call(this, ctx);
    return this;
}

CountAggrCompContext.prototype = Object.create(AggrOperatorsContext.prototype);
CountAggrCompContext.prototype.constructor = CountAggrCompContext;

VtlParser.CountAggrCompContext = CountAggrCompContext;

CountAggrCompContext.prototype.COUNT = function() {
    return this.getToken(VtlParser.COUNT, 0);
};

CountAggrCompContext.prototype.LPAREN = function() {
    return this.getToken(VtlParser.LPAREN, 0);
};

CountAggrCompContext.prototype.RPAREN = function() {
    return this.getToken(VtlParser.RPAREN, 0);
};


VtlParser.AggrOperatorsContext = AggrOperatorsContext;

VtlParser.prototype.aggrOperators = function() {

    var localctx = new AggrOperatorsContext(this, this._ctx, this.state);
    this.enterRule(localctx, 66, VtlParser.RULE_aggrOperators);
    var _la = 0; // Token type
    try {
        this.state = 1046;
        this._errHandler.sync(this);
        var la_ = this._interp.adaptivePredict(this._input,96,this._ctx);
        switch(la_) {
        case 1:
            localctx = new AggrCompContext(this, localctx);
            this.enterOuterAlt(localctx, 1);
            this.state = 1038;
            localctx.op = this._input.LT(1);
            _la = this._input.LA(1);
            if(!(((((_la - 68)) & ~0x1f) == 0 && ((1 << (_la - 68)) & ((1 << (VtlParser.MIN - 68)) | (1 << (VtlParser.MAX - 68)) | (1 << (VtlParser.SUM - 68)) | (1 << (VtlParser.AVG - 68)) | (1 << (VtlParser.MEDIAN - 68)) | (1 << (VtlParser.COUNT - 68)))) !== 0) || ((((_la - 128)) & ~0x1f) == 0 && ((1 << (_la - 128)) & ((1 << (VtlParser.STDDEV_POP - 128)) | (1 << (VtlParser.STDDEV_SAMP - 128)) | (1 << (VtlParser.VAR_POP - 128)) | (1 << (VtlParser.VAR_SAMP - 128)))) !== 0))) {
                localctx.op = this._errHandler.recoverInline(this);
            }
            else {
            	this._errHandler.reportMatch(this);
                this.consume();
            }
            this.state = 1039;
            this.match(VtlParser.LPAREN);
            this.state = 1040;
            this.exprComponent(0);
            this.state = 1041;
            this.match(VtlParser.RPAREN);
            break;

        case 2:
            localctx = new CountAggrCompContext(this, localctx);
            this.enterOuterAlt(localctx, 2);
            this.state = 1043;
            this.match(VtlParser.COUNT);
            this.state = 1044;
            this.match(VtlParser.LPAREN);
            this.state = 1045;
            this.match(VtlParser.RPAREN);
            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


function AggrOperatorsGroupingContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = VtlParser.RULE_aggrOperatorsGrouping;
    return this;
}

AggrOperatorsGroupingContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
AggrOperatorsGroupingContext.prototype.constructor = AggrOperatorsGroupingContext;


 
AggrOperatorsGroupingContext.prototype.copyFrom = function(ctx) {
    antlr4.ParserRuleContext.prototype.copyFrom.call(this, ctx);
};


function AggrDatasetContext(parser, ctx) {
	AggrOperatorsGroupingContext.call(this, parser);
    this.op = null; // Token;
    AggrOperatorsGroupingContext.prototype.copyFrom.call(this, ctx);
    return this;
}

AggrDatasetContext.prototype = Object.create(AggrOperatorsGroupingContext.prototype);
AggrDatasetContext.prototype.constructor = AggrDatasetContext;

VtlParser.AggrDatasetContext = AggrDatasetContext;

AggrDatasetContext.prototype.LPAREN = function() {
    return this.getToken(VtlParser.LPAREN, 0);
};

AggrDatasetContext.prototype.expr = function() {
    return this.getTypedRuleContext(ExprContext,0);
};

AggrDatasetContext.prototype.RPAREN = function() {
    return this.getToken(VtlParser.RPAREN, 0);
};

AggrDatasetContext.prototype.SUM = function() {
    return this.getToken(VtlParser.SUM, 0);
};

AggrDatasetContext.prototype.AVG = function() {
    return this.getToken(VtlParser.AVG, 0);
};

AggrDatasetContext.prototype.COUNT = function() {
    return this.getToken(VtlParser.COUNT, 0);
};

AggrDatasetContext.prototype.MEDIAN = function() {
    return this.getToken(VtlParser.MEDIAN, 0);
};

AggrDatasetContext.prototype.MIN = function() {
    return this.getToken(VtlParser.MIN, 0);
};

AggrDatasetContext.prototype.MAX = function() {
    return this.getToken(VtlParser.MAX, 0);
};

AggrDatasetContext.prototype.STDDEV_POP = function() {
    return this.getToken(VtlParser.STDDEV_POP, 0);
};

AggrDatasetContext.prototype.STDDEV_SAMP = function() {
    return this.getToken(VtlParser.STDDEV_SAMP, 0);
};

AggrDatasetContext.prototype.VAR_POP = function() {
    return this.getToken(VtlParser.VAR_POP, 0);
};

AggrDatasetContext.prototype.VAR_SAMP = function() {
    return this.getToken(VtlParser.VAR_SAMP, 0);
};

AggrDatasetContext.prototype.groupingClause = function() {
    return this.getTypedRuleContext(GroupingClauseContext,0);
};

AggrDatasetContext.prototype.havingClause = function() {
    return this.getTypedRuleContext(HavingClauseContext,0);
};


VtlParser.AggrOperatorsGroupingContext = AggrOperatorsGroupingContext;

VtlParser.prototype.aggrOperatorsGrouping = function() {

    var localctx = new AggrOperatorsGroupingContext(this, this._ctx, this.state);
    this.enterRule(localctx, 68, VtlParser.RULE_aggrOperatorsGrouping);
    var _la = 0; // Token type
    try {
        localctx = new AggrDatasetContext(this, localctx);
        this.enterOuterAlt(localctx, 1);
        this.state = 1048;
        localctx.op = this._input.LT(1);
        _la = this._input.LA(1);
        if(!(((((_la - 68)) & ~0x1f) == 0 && ((1 << (_la - 68)) & ((1 << (VtlParser.MIN - 68)) | (1 << (VtlParser.MAX - 68)) | (1 << (VtlParser.SUM - 68)) | (1 << (VtlParser.AVG - 68)) | (1 << (VtlParser.MEDIAN - 68)) | (1 << (VtlParser.COUNT - 68)))) !== 0) || ((((_la - 128)) & ~0x1f) == 0 && ((1 << (_la - 128)) & ((1 << (VtlParser.STDDEV_POP - 128)) | (1 << (VtlParser.STDDEV_SAMP - 128)) | (1 << (VtlParser.VAR_POP - 128)) | (1 << (VtlParser.VAR_SAMP - 128)))) !== 0))) {
            localctx.op = this._errHandler.recoverInline(this);
        }
        else {
        	this._errHandler.reportMatch(this);
            this.consume();
        }
        this.state = 1049;
        this.match(VtlParser.LPAREN);
        this.state = 1050;
        this.expr(0);
        this.state = 1055;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if(_la===VtlParser.GROUP) {
            this.state = 1051;
            this.groupingClause();
            this.state = 1053;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if(_la===VtlParser.HAVING) {
                this.state = 1052;
                this.havingClause();
            }

        }

        this.state = 1057;
        this.match(VtlParser.RPAREN);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


function AnFunctionContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = VtlParser.RULE_anFunction;
    return this;
}

AnFunctionContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
AnFunctionContext.prototype.constructor = AnFunctionContext;


 
AnFunctionContext.prototype.copyFrom = function(ctx) {
    antlr4.ParserRuleContext.prototype.copyFrom.call(this, ctx);
};


function LagOrLeadAnContext(parser, ctx) {
	AnFunctionContext.call(this, parser);
    this.op = null; // Token;
    this.offet = null; // SignedIntegerContext;
    this.defaultValue = null; // ConstantContext;
    this.partition = null; // PartitionByClauseContext;
    this.orderBy = null; // OrderByClauseContext;
    AnFunctionContext.prototype.copyFrom.call(this, ctx);
    return this;
}

LagOrLeadAnContext.prototype = Object.create(AnFunctionContext.prototype);
LagOrLeadAnContext.prototype.constructor = LagOrLeadAnContext;

VtlParser.LagOrLeadAnContext = LagOrLeadAnContext;

LagOrLeadAnContext.prototype.LPAREN = function(i) {
	if(i===undefined) {
		i = null;
	}
    if(i===null) {
        return this.getTokens(VtlParser.LPAREN);
    } else {
        return this.getToken(VtlParser.LPAREN, i);
    }
};


LagOrLeadAnContext.prototype.expr = function() {
    return this.getTypedRuleContext(ExprContext,0);
};

LagOrLeadAnContext.prototype.OVER = function() {
    return this.getToken(VtlParser.OVER, 0);
};

LagOrLeadAnContext.prototype.RPAREN = function(i) {
	if(i===undefined) {
		i = null;
	}
    if(i===null) {
        return this.getTokens(VtlParser.RPAREN);
    } else {
        return this.getToken(VtlParser.RPAREN, i);
    }
};


LagOrLeadAnContext.prototype.LAG = function() {
    return this.getToken(VtlParser.LAG, 0);
};

LagOrLeadAnContext.prototype.LEAD = function() {
    return this.getToken(VtlParser.LEAD, 0);
};

LagOrLeadAnContext.prototype.COMMA = function() {
    return this.getToken(VtlParser.COMMA, 0);
};

LagOrLeadAnContext.prototype.orderByClause = function() {
    return this.getTypedRuleContext(OrderByClauseContext,0);
};

LagOrLeadAnContext.prototype.signedInteger = function() {
    return this.getTypedRuleContext(SignedIntegerContext,0);
};

LagOrLeadAnContext.prototype.partitionByClause = function() {
    return this.getTypedRuleContext(PartitionByClauseContext,0);
};

LagOrLeadAnContext.prototype.constant = function() {
    return this.getTypedRuleContext(ConstantContext,0);
};

function RatioToReportAnContext(parser, ctx) {
	AnFunctionContext.call(this, parser);
    this.op = null; // Token;
    this.partition = null; // PartitionByClauseContext;
    AnFunctionContext.prototype.copyFrom.call(this, ctx);
    return this;
}

RatioToReportAnContext.prototype = Object.create(AnFunctionContext.prototype);
RatioToReportAnContext.prototype.constructor = RatioToReportAnContext;

VtlParser.RatioToReportAnContext = RatioToReportAnContext;

RatioToReportAnContext.prototype.LPAREN = function(i) {
	if(i===undefined) {
		i = null;
	}
    if(i===null) {
        return this.getTokens(VtlParser.LPAREN);
    } else {
        return this.getToken(VtlParser.LPAREN, i);
    }
};


RatioToReportAnContext.prototype.expr = function() {
    return this.getTypedRuleContext(ExprContext,0);
};

RatioToReportAnContext.prototype.OVER = function() {
    return this.getToken(VtlParser.OVER, 0);
};

RatioToReportAnContext.prototype.RPAREN = function(i) {
	if(i===undefined) {
		i = null;
	}
    if(i===null) {
        return this.getTokens(VtlParser.RPAREN);
    } else {
        return this.getToken(VtlParser.RPAREN, i);
    }
};


RatioToReportAnContext.prototype.RATIO_TO_REPORT = function() {
    return this.getToken(VtlParser.RATIO_TO_REPORT, 0);
};

RatioToReportAnContext.prototype.partitionByClause = function() {
    return this.getTypedRuleContext(PartitionByClauseContext,0);
};

function AnSimpleFunctionContext(parser, ctx) {
	AnFunctionContext.call(this, parser);
    this.op = null; // Token;
    this.partition = null; // PartitionByClauseContext;
    this.orderBy = null; // OrderByClauseContext;
    this.windowing = null; // WindowingClauseContext;
    AnFunctionContext.prototype.copyFrom.call(this, ctx);
    return this;
}

AnSimpleFunctionContext.prototype = Object.create(AnFunctionContext.prototype);
AnSimpleFunctionContext.prototype.constructor = AnSimpleFunctionContext;

VtlParser.AnSimpleFunctionContext = AnSimpleFunctionContext;

AnSimpleFunctionContext.prototype.LPAREN = function(i) {
	if(i===undefined) {
		i = null;
	}
    if(i===null) {
        return this.getTokens(VtlParser.LPAREN);
    } else {
        return this.getToken(VtlParser.LPAREN, i);
    }
};


AnSimpleFunctionContext.prototype.expr = function() {
    return this.getTypedRuleContext(ExprContext,0);
};

AnSimpleFunctionContext.prototype.OVER = function() {
    return this.getToken(VtlParser.OVER, 0);
};

AnSimpleFunctionContext.prototype.RPAREN = function(i) {
	if(i===undefined) {
		i = null;
	}
    if(i===null) {
        return this.getTokens(VtlParser.RPAREN);
    } else {
        return this.getToken(VtlParser.RPAREN, i);
    }
};


AnSimpleFunctionContext.prototype.SUM = function() {
    return this.getToken(VtlParser.SUM, 0);
};

AnSimpleFunctionContext.prototype.AVG = function() {
    return this.getToken(VtlParser.AVG, 0);
};

AnSimpleFunctionContext.prototype.COUNT = function() {
    return this.getToken(VtlParser.COUNT, 0);
};

AnSimpleFunctionContext.prototype.MEDIAN = function() {
    return this.getToken(VtlParser.MEDIAN, 0);
};

AnSimpleFunctionContext.prototype.MIN = function() {
    return this.getToken(VtlParser.MIN, 0);
};

AnSimpleFunctionContext.prototype.MAX = function() {
    return this.getToken(VtlParser.MAX, 0);
};

AnSimpleFunctionContext.prototype.STDDEV_POP = function() {
    return this.getToken(VtlParser.STDDEV_POP, 0);
};

AnSimpleFunctionContext.prototype.STDDEV_SAMP = function() {
    return this.getToken(VtlParser.STDDEV_SAMP, 0);
};

AnSimpleFunctionContext.prototype.VAR_POP = function() {
    return this.getToken(VtlParser.VAR_POP, 0);
};

AnSimpleFunctionContext.prototype.VAR_SAMP = function() {
    return this.getToken(VtlParser.VAR_SAMP, 0);
};

AnSimpleFunctionContext.prototype.FIRST_VALUE = function() {
    return this.getToken(VtlParser.FIRST_VALUE, 0);
};

AnSimpleFunctionContext.prototype.LAST_VALUE = function() {
    return this.getToken(VtlParser.LAST_VALUE, 0);
};

AnSimpleFunctionContext.prototype.partitionByClause = function() {
    return this.getTypedRuleContext(PartitionByClauseContext,0);
};

AnSimpleFunctionContext.prototype.orderByClause = function() {
    return this.getTypedRuleContext(OrderByClauseContext,0);
};

AnSimpleFunctionContext.prototype.windowingClause = function() {
    return this.getTypedRuleContext(WindowingClauseContext,0);
};


VtlParser.AnFunctionContext = AnFunctionContext;

VtlParser.prototype.anFunction = function() {

    var localctx = new AnFunctionContext(this, this._ctx, this.state);
    this.enterRule(localctx, 70, VtlParser.RULE_anFunction);
    var _la = 0; // Token type
    try {
        this.state = 1105;
        this._errHandler.sync(this);
        switch(this._input.LA(1)) {
        case VtlParser.MIN:
        case VtlParser.MAX:
        case VtlParser.SUM:
        case VtlParser.AVG:
        case VtlParser.MEDIAN:
        case VtlParser.COUNT:
        case VtlParser.STDDEV_POP:
        case VtlParser.STDDEV_SAMP:
        case VtlParser.VAR_POP:
        case VtlParser.VAR_SAMP:
        case VtlParser.FIRST_VALUE:
        case VtlParser.LAST_VALUE:
            localctx = new AnSimpleFunctionContext(this, localctx);
            this.enterOuterAlt(localctx, 1);
            this.state = 1059;
            localctx.op = this._input.LT(1);
            _la = this._input.LA(1);
            if(!(((((_la - 68)) & ~0x1f) == 0 && ((1 << (_la - 68)) & ((1 << (VtlParser.MIN - 68)) | (1 << (VtlParser.MAX - 68)) | (1 << (VtlParser.SUM - 68)) | (1 << (VtlParser.AVG - 68)) | (1 << (VtlParser.MEDIAN - 68)) | (1 << (VtlParser.COUNT - 68)))) !== 0) || ((((_la - 128)) & ~0x1f) == 0 && ((1 << (_la - 128)) & ((1 << (VtlParser.STDDEV_POP - 128)) | (1 << (VtlParser.STDDEV_SAMP - 128)) | (1 << (VtlParser.VAR_POP - 128)) | (1 << (VtlParser.VAR_SAMP - 128)) | (1 << (VtlParser.FIRST_VALUE - 128)) | (1 << (VtlParser.LAST_VALUE - 128)))) !== 0))) {
                localctx.op = this._errHandler.recoverInline(this);
            }
            else {
            	this._errHandler.reportMatch(this);
                this.consume();
            }
            this.state = 1060;
            this.match(VtlParser.LPAREN);
            this.state = 1061;
            this.expr(0);
            this.state = 1062;
            this.match(VtlParser.OVER);
            this.state = 1063;
            this.match(VtlParser.LPAREN);

            this.state = 1065;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if(_la===VtlParser.PARTITION) {
                this.state = 1064;
                localctx.partition = this.partitionByClause();
            }

            this.state = 1068;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if(_la===VtlParser.ORDER) {
                this.state = 1067;
                localctx.orderBy = this.orderByClause();
            }

            this.state = 1071;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if(_la===VtlParser.DATA || _la===VtlParser.RANGE) {
                this.state = 1070;
                localctx.windowing = this.windowingClause();
            }

            this.state = 1073;
            this.match(VtlParser.RPAREN);
            this.state = 1074;
            this.match(VtlParser.RPAREN);
            break;
        case VtlParser.LAG:
        case VtlParser.LEAD:
            localctx = new LagOrLeadAnContext(this, localctx);
            this.enterOuterAlt(localctx, 2);
            this.state = 1076;
            localctx.op = this._input.LT(1);
            _la = this._input.LA(1);
            if(!(_la===VtlParser.LAG || _la===VtlParser.LEAD)) {
                localctx.op = this._errHandler.recoverInline(this);
            }
            else {
            	this._errHandler.reportMatch(this);
                this.consume();
            }
            this.state = 1077;
            this.match(VtlParser.LPAREN);
            this.state = 1078;
            this.expr(0);
            this.state = 1084;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if(_la===VtlParser.COMMA) {
                this.state = 1079;
                this.match(VtlParser.COMMA);
                this.state = 1080;
                localctx.offet = this.signedInteger();
                this.state = 1082;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
                if(_la===VtlParser.NULL_CONSTANT || ((((_la - 229)) & ~0x1f) == 0 && ((1 << (_la - 229)) & ((1 << (VtlParser.INTEGER_CONSTANT - 229)) | (1 << (VtlParser.NUMBER_CONSTANT - 229)) | (1 << (VtlParser.BOOLEAN_CONSTANT - 229)) | (1 << (VtlParser.STRING_CONSTANT - 229)))) !== 0)) {
                    this.state = 1081;
                    localctx.defaultValue = this.constant();
                }

            }

            this.state = 1086;
            this.match(VtlParser.OVER);
            this.state = 1087;
            this.match(VtlParser.LPAREN);

            this.state = 1089;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if(_la===VtlParser.PARTITION) {
                this.state = 1088;
                localctx.partition = this.partitionByClause();
            }

            this.state = 1091;
            localctx.orderBy = this.orderByClause();
            this.state = 1093;
            this.match(VtlParser.RPAREN);
            this.state = 1094;
            this.match(VtlParser.RPAREN);
            break;
        case VtlParser.RATIO_TO_REPORT:
            localctx = new RatioToReportAnContext(this, localctx);
            this.enterOuterAlt(localctx, 3);
            this.state = 1096;
            localctx.op = this.match(VtlParser.RATIO_TO_REPORT);
            this.state = 1097;
            this.match(VtlParser.LPAREN);
            this.state = 1098;
            this.expr(0);
            this.state = 1099;
            this.match(VtlParser.OVER);
            this.state = 1100;
            this.match(VtlParser.LPAREN);

            this.state = 1101;
            localctx.partition = this.partitionByClause();
            this.state = 1102;
            this.match(VtlParser.RPAREN);
            this.state = 1103;
            this.match(VtlParser.RPAREN);
            break;
        default:
            throw new antlr4.error.NoViableAltException(this);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


function AnFunctionComponentContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = VtlParser.RULE_anFunctionComponent;
    return this;
}

AnFunctionComponentContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
AnFunctionComponentContext.prototype.constructor = AnFunctionComponentContext;


 
AnFunctionComponentContext.prototype.copyFrom = function(ctx) {
    antlr4.ParserRuleContext.prototype.copyFrom.call(this, ctx);
};


function AnSimpleFunctionComponentContext(parser, ctx) {
	AnFunctionComponentContext.call(this, parser);
    this.op = null; // Token;
    this.partition = null; // PartitionByClauseContext;
    this.orderBy = null; // OrderByClauseContext;
    this.windowing = null; // WindowingClauseContext;
    AnFunctionComponentContext.prototype.copyFrom.call(this, ctx);
    return this;
}

AnSimpleFunctionComponentContext.prototype = Object.create(AnFunctionComponentContext.prototype);
AnSimpleFunctionComponentContext.prototype.constructor = AnSimpleFunctionComponentContext;

VtlParser.AnSimpleFunctionComponentContext = AnSimpleFunctionComponentContext;

AnSimpleFunctionComponentContext.prototype.LPAREN = function(i) {
	if(i===undefined) {
		i = null;
	}
    if(i===null) {
        return this.getTokens(VtlParser.LPAREN);
    } else {
        return this.getToken(VtlParser.LPAREN, i);
    }
};


AnSimpleFunctionComponentContext.prototype.exprComponent = function() {
    return this.getTypedRuleContext(ExprComponentContext,0);
};

AnSimpleFunctionComponentContext.prototype.OVER = function() {
    return this.getToken(VtlParser.OVER, 0);
};

AnSimpleFunctionComponentContext.prototype.RPAREN = function(i) {
	if(i===undefined) {
		i = null;
	}
    if(i===null) {
        return this.getTokens(VtlParser.RPAREN);
    } else {
        return this.getToken(VtlParser.RPAREN, i);
    }
};


AnSimpleFunctionComponentContext.prototype.SUM = function() {
    return this.getToken(VtlParser.SUM, 0);
};

AnSimpleFunctionComponentContext.prototype.AVG = function() {
    return this.getToken(VtlParser.AVG, 0);
};

AnSimpleFunctionComponentContext.prototype.COUNT = function() {
    return this.getToken(VtlParser.COUNT, 0);
};

AnSimpleFunctionComponentContext.prototype.MEDIAN = function() {
    return this.getToken(VtlParser.MEDIAN, 0);
};

AnSimpleFunctionComponentContext.prototype.MIN = function() {
    return this.getToken(VtlParser.MIN, 0);
};

AnSimpleFunctionComponentContext.prototype.MAX = function() {
    return this.getToken(VtlParser.MAX, 0);
};

AnSimpleFunctionComponentContext.prototype.STDDEV_POP = function() {
    return this.getToken(VtlParser.STDDEV_POP, 0);
};

AnSimpleFunctionComponentContext.prototype.STDDEV_SAMP = function() {
    return this.getToken(VtlParser.STDDEV_SAMP, 0);
};

AnSimpleFunctionComponentContext.prototype.VAR_POP = function() {
    return this.getToken(VtlParser.VAR_POP, 0);
};

AnSimpleFunctionComponentContext.prototype.VAR_SAMP = function() {
    return this.getToken(VtlParser.VAR_SAMP, 0);
};

AnSimpleFunctionComponentContext.prototype.FIRST_VALUE = function() {
    return this.getToken(VtlParser.FIRST_VALUE, 0);
};

AnSimpleFunctionComponentContext.prototype.LAST_VALUE = function() {
    return this.getToken(VtlParser.LAST_VALUE, 0);
};

AnSimpleFunctionComponentContext.prototype.partitionByClause = function() {
    return this.getTypedRuleContext(PartitionByClauseContext,0);
};

AnSimpleFunctionComponentContext.prototype.orderByClause = function() {
    return this.getTypedRuleContext(OrderByClauseContext,0);
};

AnSimpleFunctionComponentContext.prototype.windowingClause = function() {
    return this.getTypedRuleContext(WindowingClauseContext,0);
};

function LagOrLeadAnComponentContext(parser, ctx) {
	AnFunctionComponentContext.call(this, parser);
    this.op = null; // Token;
    this.offet = null; // SignedIntegerContext;
    this.defaultValue = null; // ConstantContext;
    this.partition = null; // PartitionByClauseContext;
    this.orderBy = null; // OrderByClauseContext;
    AnFunctionComponentContext.prototype.copyFrom.call(this, ctx);
    return this;
}

LagOrLeadAnComponentContext.prototype = Object.create(AnFunctionComponentContext.prototype);
LagOrLeadAnComponentContext.prototype.constructor = LagOrLeadAnComponentContext;

VtlParser.LagOrLeadAnComponentContext = LagOrLeadAnComponentContext;

LagOrLeadAnComponentContext.prototype.LPAREN = function(i) {
	if(i===undefined) {
		i = null;
	}
    if(i===null) {
        return this.getTokens(VtlParser.LPAREN);
    } else {
        return this.getToken(VtlParser.LPAREN, i);
    }
};


LagOrLeadAnComponentContext.prototype.exprComponent = function() {
    return this.getTypedRuleContext(ExprComponentContext,0);
};

LagOrLeadAnComponentContext.prototype.OVER = function() {
    return this.getToken(VtlParser.OVER, 0);
};

LagOrLeadAnComponentContext.prototype.RPAREN = function(i) {
	if(i===undefined) {
		i = null;
	}
    if(i===null) {
        return this.getTokens(VtlParser.RPAREN);
    } else {
        return this.getToken(VtlParser.RPAREN, i);
    }
};


LagOrLeadAnComponentContext.prototype.LAG = function() {
    return this.getToken(VtlParser.LAG, 0);
};

LagOrLeadAnComponentContext.prototype.LEAD = function() {
    return this.getToken(VtlParser.LEAD, 0);
};

LagOrLeadAnComponentContext.prototype.COMMA = function() {
    return this.getToken(VtlParser.COMMA, 0);
};

LagOrLeadAnComponentContext.prototype.orderByClause = function() {
    return this.getTypedRuleContext(OrderByClauseContext,0);
};

LagOrLeadAnComponentContext.prototype.signedInteger = function() {
    return this.getTypedRuleContext(SignedIntegerContext,0);
};

LagOrLeadAnComponentContext.prototype.partitionByClause = function() {
    return this.getTypedRuleContext(PartitionByClauseContext,0);
};

LagOrLeadAnComponentContext.prototype.constant = function() {
    return this.getTypedRuleContext(ConstantContext,0);
};

function RankAnComponentContext(parser, ctx) {
	AnFunctionComponentContext.call(this, parser);
    this.op = null; // Token;
    this.partition = null; // PartitionByClauseContext;
    this.orderBy = null; // OrderByClauseContext;
    AnFunctionComponentContext.prototype.copyFrom.call(this, ctx);
    return this;
}

RankAnComponentContext.prototype = Object.create(AnFunctionComponentContext.prototype);
RankAnComponentContext.prototype.constructor = RankAnComponentContext;

VtlParser.RankAnComponentContext = RankAnComponentContext;

RankAnComponentContext.prototype.LPAREN = function(i) {
	if(i===undefined) {
		i = null;
	}
    if(i===null) {
        return this.getTokens(VtlParser.LPAREN);
    } else {
        return this.getToken(VtlParser.LPAREN, i);
    }
};


RankAnComponentContext.prototype.OVER = function() {
    return this.getToken(VtlParser.OVER, 0);
};

RankAnComponentContext.prototype.RPAREN = function(i) {
	if(i===undefined) {
		i = null;
	}
    if(i===null) {
        return this.getTokens(VtlParser.RPAREN);
    } else {
        return this.getToken(VtlParser.RPAREN, i);
    }
};


RankAnComponentContext.prototype.RANK = function() {
    return this.getToken(VtlParser.RANK, 0);
};

RankAnComponentContext.prototype.orderByClause = function() {
    return this.getTypedRuleContext(OrderByClauseContext,0);
};

RankAnComponentContext.prototype.partitionByClause = function() {
    return this.getTypedRuleContext(PartitionByClauseContext,0);
};

function RatioToReportAnComponentContext(parser, ctx) {
	AnFunctionComponentContext.call(this, parser);
    this.op = null; // Token;
    this.partition = null; // PartitionByClauseContext;
    AnFunctionComponentContext.prototype.copyFrom.call(this, ctx);
    return this;
}

RatioToReportAnComponentContext.prototype = Object.create(AnFunctionComponentContext.prototype);
RatioToReportAnComponentContext.prototype.constructor = RatioToReportAnComponentContext;

VtlParser.RatioToReportAnComponentContext = RatioToReportAnComponentContext;

RatioToReportAnComponentContext.prototype.LPAREN = function(i) {
	if(i===undefined) {
		i = null;
	}
    if(i===null) {
        return this.getTokens(VtlParser.LPAREN);
    } else {
        return this.getToken(VtlParser.LPAREN, i);
    }
};


RatioToReportAnComponentContext.prototype.exprComponent = function() {
    return this.getTypedRuleContext(ExprComponentContext,0);
};

RatioToReportAnComponentContext.prototype.OVER = function() {
    return this.getToken(VtlParser.OVER, 0);
};

RatioToReportAnComponentContext.prototype.RPAREN = function(i) {
	if(i===undefined) {
		i = null;
	}
    if(i===null) {
        return this.getTokens(VtlParser.RPAREN);
    } else {
        return this.getToken(VtlParser.RPAREN, i);
    }
};


RatioToReportAnComponentContext.prototype.RATIO_TO_REPORT = function() {
    return this.getToken(VtlParser.RATIO_TO_REPORT, 0);
};

RatioToReportAnComponentContext.prototype.partitionByClause = function() {
    return this.getTypedRuleContext(PartitionByClauseContext,0);
};


VtlParser.AnFunctionComponentContext = AnFunctionComponentContext;

VtlParser.prototype.anFunctionComponent = function() {

    var localctx = new AnFunctionComponentContext(this, this._ctx, this.state);
    this.enterRule(localctx, 72, VtlParser.RULE_anFunctionComponent);
    var _la = 0; // Token type
    try {
        this.state = 1165;
        this._errHandler.sync(this);
        switch(this._input.LA(1)) {
        case VtlParser.MIN:
        case VtlParser.MAX:
        case VtlParser.SUM:
        case VtlParser.AVG:
        case VtlParser.MEDIAN:
        case VtlParser.COUNT:
        case VtlParser.STDDEV_POP:
        case VtlParser.STDDEV_SAMP:
        case VtlParser.VAR_POP:
        case VtlParser.VAR_SAMP:
        case VtlParser.FIRST_VALUE:
        case VtlParser.LAST_VALUE:
            localctx = new AnSimpleFunctionComponentContext(this, localctx);
            this.enterOuterAlt(localctx, 1);
            this.state = 1107;
            localctx.op = this._input.LT(1);
            _la = this._input.LA(1);
            if(!(((((_la - 68)) & ~0x1f) == 0 && ((1 << (_la - 68)) & ((1 << (VtlParser.MIN - 68)) | (1 << (VtlParser.MAX - 68)) | (1 << (VtlParser.SUM - 68)) | (1 << (VtlParser.AVG - 68)) | (1 << (VtlParser.MEDIAN - 68)) | (1 << (VtlParser.COUNT - 68)))) !== 0) || ((((_la - 128)) & ~0x1f) == 0 && ((1 << (_la - 128)) & ((1 << (VtlParser.STDDEV_POP - 128)) | (1 << (VtlParser.STDDEV_SAMP - 128)) | (1 << (VtlParser.VAR_POP - 128)) | (1 << (VtlParser.VAR_SAMP - 128)) | (1 << (VtlParser.FIRST_VALUE - 128)) | (1 << (VtlParser.LAST_VALUE - 128)))) !== 0))) {
                localctx.op = this._errHandler.recoverInline(this);
            }
            else {
            	this._errHandler.reportMatch(this);
                this.consume();
            }
            this.state = 1108;
            this.match(VtlParser.LPAREN);
            this.state = 1109;
            this.exprComponent(0);
            this.state = 1110;
            this.match(VtlParser.OVER);
            this.state = 1111;
            this.match(VtlParser.LPAREN);

            this.state = 1113;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if(_la===VtlParser.PARTITION) {
                this.state = 1112;
                localctx.partition = this.partitionByClause();
            }

            this.state = 1116;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if(_la===VtlParser.ORDER) {
                this.state = 1115;
                localctx.orderBy = this.orderByClause();
            }

            this.state = 1119;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if(_la===VtlParser.DATA || _la===VtlParser.RANGE) {
                this.state = 1118;
                localctx.windowing = this.windowingClause();
            }

            this.state = 1121;
            this.match(VtlParser.RPAREN);
            this.state = 1122;
            this.match(VtlParser.RPAREN);
            break;
        case VtlParser.LAG:
        case VtlParser.LEAD:
            localctx = new LagOrLeadAnComponentContext(this, localctx);
            this.enterOuterAlt(localctx, 2);
            this.state = 1124;
            localctx.op = this._input.LT(1);
            _la = this._input.LA(1);
            if(!(_la===VtlParser.LAG || _la===VtlParser.LEAD)) {
                localctx.op = this._errHandler.recoverInline(this);
            }
            else {
            	this._errHandler.reportMatch(this);
                this.consume();
            }
            this.state = 1125;
            this.match(VtlParser.LPAREN);
            this.state = 1126;
            this.exprComponent(0);
            this.state = 1132;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if(_la===VtlParser.COMMA) {
                this.state = 1127;
                this.match(VtlParser.COMMA);
                this.state = 1128;
                localctx.offet = this.signedInteger();
                this.state = 1130;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
                if(_la===VtlParser.NULL_CONSTANT || ((((_la - 229)) & ~0x1f) == 0 && ((1 << (_la - 229)) & ((1 << (VtlParser.INTEGER_CONSTANT - 229)) | (1 << (VtlParser.NUMBER_CONSTANT - 229)) | (1 << (VtlParser.BOOLEAN_CONSTANT - 229)) | (1 << (VtlParser.STRING_CONSTANT - 229)))) !== 0)) {
                    this.state = 1129;
                    localctx.defaultValue = this.constant();
                }

            }

            this.state = 1134;
            this.match(VtlParser.OVER);
            this.state = 1135;
            this.match(VtlParser.LPAREN);

            this.state = 1137;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if(_la===VtlParser.PARTITION) {
                this.state = 1136;
                localctx.partition = this.partitionByClause();
            }

            this.state = 1139;
            localctx.orderBy = this.orderByClause();
            this.state = 1141;
            this.match(VtlParser.RPAREN);
            this.state = 1142;
            this.match(VtlParser.RPAREN);
            break;
        case VtlParser.RANK:
            localctx = new RankAnComponentContext(this, localctx);
            this.enterOuterAlt(localctx, 3);
            this.state = 1144;
            localctx.op = this.match(VtlParser.RANK);
            this.state = 1145;
            this.match(VtlParser.LPAREN);
            this.state = 1146;
            this.match(VtlParser.OVER);
            this.state = 1147;
            this.match(VtlParser.LPAREN);

            this.state = 1149;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if(_la===VtlParser.PARTITION) {
                this.state = 1148;
                localctx.partition = this.partitionByClause();
            }

            this.state = 1151;
            localctx.orderBy = this.orderByClause();
            this.state = 1153;
            this.match(VtlParser.RPAREN);
            this.state = 1154;
            this.match(VtlParser.RPAREN);
            break;
        case VtlParser.RATIO_TO_REPORT:
            localctx = new RatioToReportAnComponentContext(this, localctx);
            this.enterOuterAlt(localctx, 4);
            this.state = 1156;
            localctx.op = this.match(VtlParser.RATIO_TO_REPORT);
            this.state = 1157;
            this.match(VtlParser.LPAREN);
            this.state = 1158;
            this.exprComponent(0);
            this.state = 1159;
            this.match(VtlParser.OVER);
            this.state = 1160;
            this.match(VtlParser.LPAREN);

            this.state = 1161;
            localctx.partition = this.partitionByClause();
            this.state = 1162;
            this.match(VtlParser.RPAREN);
            this.state = 1163;
            this.match(VtlParser.RPAREN);
            break;
        default:
            throw new antlr4.error.NoViableAltException(this);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


function RenameClauseItemContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = VtlParser.RULE_renameClauseItem;
    this.fromName = null; // ComponentIDContext
    this.toName = null; // ComponentIDContext
    return this;
}

RenameClauseItemContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
RenameClauseItemContext.prototype.constructor = RenameClauseItemContext;

RenameClauseItemContext.prototype.TO = function() {
    return this.getToken(VtlParser.TO, 0);
};

RenameClauseItemContext.prototype.componentID = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(ComponentIDContext);
    } else {
        return this.getTypedRuleContext(ComponentIDContext,i);
    }
};




VtlParser.RenameClauseItemContext = RenameClauseItemContext;

VtlParser.prototype.renameClauseItem = function() {

    var localctx = new RenameClauseItemContext(this, this._ctx, this.state);
    this.enterRule(localctx, 74, VtlParser.RULE_renameClauseItem);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1167;
        localctx.fromName = this.componentID();
        this.state = 1168;
        this.match(VtlParser.TO);
        this.state = 1169;
        localctx.toName = this.componentID();
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


function AggregateClauseContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = VtlParser.RULE_aggregateClause;
    return this;
}

AggregateClauseContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
AggregateClauseContext.prototype.constructor = AggregateClauseContext;

AggregateClauseContext.prototype.aggrFunctionClause = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(AggrFunctionClauseContext);
    } else {
        return this.getTypedRuleContext(AggrFunctionClauseContext,i);
    }
};

AggregateClauseContext.prototype.COMMA = function(i) {
	if(i===undefined) {
		i = null;
	}
    if(i===null) {
        return this.getTokens(VtlParser.COMMA);
    } else {
        return this.getToken(VtlParser.COMMA, i);
    }
};





VtlParser.AggregateClauseContext = AggregateClauseContext;

VtlParser.prototype.aggregateClause = function() {

    var localctx = new AggregateClauseContext(this, this._ctx, this.state);
    this.enterRule(localctx, 76, VtlParser.RULE_aggregateClause);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1171;
        this.aggrFunctionClause();
        this.state = 1176;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while(_la===VtlParser.COMMA) {
            this.state = 1172;
            this.match(VtlParser.COMMA);
            this.state = 1173;
            this.aggrFunctionClause();
            this.state = 1178;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


function AggrFunctionClauseContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = VtlParser.RULE_aggrFunctionClause;
    return this;
}

AggrFunctionClauseContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
AggrFunctionClauseContext.prototype.constructor = AggrFunctionClauseContext;

AggrFunctionClauseContext.prototype.componentID = function() {
    return this.getTypedRuleContext(ComponentIDContext,0);
};

AggrFunctionClauseContext.prototype.ASSIGN = function() {
    return this.getToken(VtlParser.ASSIGN, 0);
};

AggrFunctionClauseContext.prototype.aggrOperators = function() {
    return this.getTypedRuleContext(AggrOperatorsContext,0);
};

AggrFunctionClauseContext.prototype.componentRole = function() {
    return this.getTypedRuleContext(ComponentRoleContext,0);
};




VtlParser.AggrFunctionClauseContext = AggrFunctionClauseContext;

VtlParser.prototype.aggrFunctionClause = function() {

    var localctx = new AggrFunctionClauseContext(this, this._ctx, this.state);
    this.enterRule(localctx, 78, VtlParser.RULE_aggrFunctionClause);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1180;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if(((((_la - 91)) & ~0x1f) == 0 && ((1 << (_la - 91)) & ((1 << (VtlParser.DIMENSION - 91)) | (1 << (VtlParser.MEASURE - 91)) | (1 << (VtlParser.ATTRIBUTE - 91)) | (1 << (VtlParser.VIRAL - 91)))) !== 0) || _la===VtlParser.COMPONENT) {
            this.state = 1179;
            this.componentRole();
        }

        this.state = 1182;
        this.componentID();
        this.state = 1183;
        this.match(VtlParser.ASSIGN);
        this.state = 1184;
        this.aggrOperators();
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


function CalcClauseItemContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = VtlParser.RULE_calcClauseItem;
    return this;
}

CalcClauseItemContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
CalcClauseItemContext.prototype.constructor = CalcClauseItemContext;

CalcClauseItemContext.prototype.componentID = function() {
    return this.getTypedRuleContext(ComponentIDContext,0);
};

CalcClauseItemContext.prototype.ASSIGN = function() {
    return this.getToken(VtlParser.ASSIGN, 0);
};

CalcClauseItemContext.prototype.exprComponent = function() {
    return this.getTypedRuleContext(ExprComponentContext,0);
};

CalcClauseItemContext.prototype.componentRole = function() {
    return this.getTypedRuleContext(ComponentRoleContext,0);
};




VtlParser.CalcClauseItemContext = CalcClauseItemContext;

VtlParser.prototype.calcClauseItem = function() {

    var localctx = new CalcClauseItemContext(this, this._ctx, this.state);
    this.enterRule(localctx, 80, VtlParser.RULE_calcClauseItem);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1187;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if(((((_la - 91)) & ~0x1f) == 0 && ((1 << (_la - 91)) & ((1 << (VtlParser.DIMENSION - 91)) | (1 << (VtlParser.MEASURE - 91)) | (1 << (VtlParser.ATTRIBUTE - 91)) | (1 << (VtlParser.VIRAL - 91)))) !== 0) || _la===VtlParser.COMPONENT) {
            this.state = 1186;
            this.componentRole();
        }

        this.state = 1189;
        this.componentID();
        this.state = 1190;
        this.match(VtlParser.ASSIGN);
        this.state = 1191;
        this.exprComponent(0);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


function SubspaceClauseItemContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = VtlParser.RULE_subspaceClauseItem;
    return this;
}

SubspaceClauseItemContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
SubspaceClauseItemContext.prototype.constructor = SubspaceClauseItemContext;

SubspaceClauseItemContext.prototype.componentID = function() {
    return this.getTypedRuleContext(ComponentIDContext,0);
};

SubspaceClauseItemContext.prototype.EQ = function() {
    return this.getToken(VtlParser.EQ, 0);
};

SubspaceClauseItemContext.prototype.constant = function() {
    return this.getTypedRuleContext(ConstantContext,0);
};




VtlParser.SubspaceClauseItemContext = SubspaceClauseItemContext;

VtlParser.prototype.subspaceClauseItem = function() {

    var localctx = new SubspaceClauseItemContext(this, this._ctx, this.state);
    this.enterRule(localctx, 82, VtlParser.RULE_subspaceClauseItem);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1193;
        this.componentID();
        this.state = 1194;
        this.match(VtlParser.EQ);
        this.state = 1195;
        this.constant();
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


function JoinClauseWithoutUsingContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = VtlParser.RULE_joinClauseWithoutUsing;
    return this;
}

JoinClauseWithoutUsingContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
JoinClauseWithoutUsingContext.prototype.constructor = JoinClauseWithoutUsingContext;

JoinClauseWithoutUsingContext.prototype.joinClauseItem = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(JoinClauseItemContext);
    } else {
        return this.getTypedRuleContext(JoinClauseItemContext,i);
    }
};

JoinClauseWithoutUsingContext.prototype.COMMA = function(i) {
	if(i===undefined) {
		i = null;
	}
    if(i===null) {
        return this.getTokens(VtlParser.COMMA);
    } else {
        return this.getToken(VtlParser.COMMA, i);
    }
};





VtlParser.JoinClauseWithoutUsingContext = JoinClauseWithoutUsingContext;

VtlParser.prototype.joinClauseWithoutUsing = function() {

    var localctx = new JoinClauseWithoutUsingContext(this, this._ctx, this.state);
    this.enterRule(localctx, 84, VtlParser.RULE_joinClauseWithoutUsing);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1197;
        this.joinClauseItem();
        this.state = 1202;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while(_la===VtlParser.COMMA) {
            this.state = 1198;
            this.match(VtlParser.COMMA);
            this.state = 1199;
            this.joinClauseItem();
            this.state = 1204;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


function JoinClauseContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = VtlParser.RULE_joinClause;
    return this;
}

JoinClauseContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
JoinClauseContext.prototype.constructor = JoinClauseContext;

JoinClauseContext.prototype.joinClauseItem = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(JoinClauseItemContext);
    } else {
        return this.getTypedRuleContext(JoinClauseItemContext,i);
    }
};

JoinClauseContext.prototype.COMMA = function(i) {
	if(i===undefined) {
		i = null;
	}
    if(i===null) {
        return this.getTokens(VtlParser.COMMA);
    } else {
        return this.getToken(VtlParser.COMMA, i);
    }
};


JoinClauseContext.prototype.USING = function() {
    return this.getToken(VtlParser.USING, 0);
};

JoinClauseContext.prototype.componentID = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(ComponentIDContext);
    } else {
        return this.getTypedRuleContext(ComponentIDContext,i);
    }
};




VtlParser.JoinClauseContext = JoinClauseContext;

VtlParser.prototype.joinClause = function() {

    var localctx = new JoinClauseContext(this, this._ctx, this.state);
    this.enterRule(localctx, 86, VtlParser.RULE_joinClause);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1205;
        this.joinClauseItem();
        this.state = 1210;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while(_la===VtlParser.COMMA) {
            this.state = 1206;
            this.match(VtlParser.COMMA);
            this.state = 1207;
            this.joinClauseItem();
            this.state = 1212;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
        }
        this.state = 1222;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if(_la===VtlParser.USING) {
            this.state = 1213;
            this.match(VtlParser.USING);
            this.state = 1214;
            this.componentID();
            this.state = 1219;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            while(_la===VtlParser.COMMA) {
                this.state = 1215;
                this.match(VtlParser.COMMA);
                this.state = 1216;
                this.componentID();
                this.state = 1221;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
            }
        }

    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


function JoinClauseItemContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = VtlParser.RULE_joinClauseItem;
    return this;
}

JoinClauseItemContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
JoinClauseItemContext.prototype.constructor = JoinClauseItemContext;

JoinClauseItemContext.prototype.expr = function() {
    return this.getTypedRuleContext(ExprContext,0);
};

JoinClauseItemContext.prototype.AS = function() {
    return this.getToken(VtlParser.AS, 0);
};

JoinClauseItemContext.prototype.alias = function() {
    return this.getTypedRuleContext(AliasContext,0);
};




VtlParser.JoinClauseItemContext = JoinClauseItemContext;

VtlParser.prototype.joinClauseItem = function() {

    var localctx = new JoinClauseItemContext(this, this._ctx, this.state);
    this.enterRule(localctx, 88, VtlParser.RULE_joinClauseItem);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1224;
        this.expr(0);
        this.state = 1227;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if(_la===VtlParser.AS) {
            this.state = 1225;
            this.match(VtlParser.AS);
            this.state = 1226;
            this.alias();
        }

    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


function JoinBodyContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = VtlParser.RULE_joinBody;
    return this;
}

JoinBodyContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
JoinBodyContext.prototype.constructor = JoinBodyContext;

JoinBodyContext.prototype.filterClause = function() {
    return this.getTypedRuleContext(FilterClauseContext,0);
};

JoinBodyContext.prototype.calcClause = function() {
    return this.getTypedRuleContext(CalcClauseContext,0);
};

JoinBodyContext.prototype.joinApplyClause = function() {
    return this.getTypedRuleContext(JoinApplyClauseContext,0);
};

JoinBodyContext.prototype.aggrClause = function() {
    return this.getTypedRuleContext(AggrClauseContext,0);
};

JoinBodyContext.prototype.keepOrDropClause = function() {
    return this.getTypedRuleContext(KeepOrDropClauseContext,0);
};

JoinBodyContext.prototype.renameClause = function() {
    return this.getTypedRuleContext(RenameClauseContext,0);
};




VtlParser.JoinBodyContext = JoinBodyContext;

VtlParser.prototype.joinBody = function() {

    var localctx = new JoinBodyContext(this, this._ctx, this.state);
    this.enterRule(localctx, 90, VtlParser.RULE_joinBody);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1230;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if(_la===VtlParser.FILTER) {
            this.state = 1229;
            this.filterClause();
        }

        this.state = 1235;
        this._errHandler.sync(this);
        switch (this._input.LA(1)) {
        case VtlParser.CALC:
        	this.state = 1232;
        	this.calcClause();
        	break;
        case VtlParser.APPLY:
        	this.state = 1233;
        	this.joinApplyClause();
        	break;
        case VtlParser.AGGREGATE:
        	this.state = 1234;
        	this.aggrClause();
        	break;
        case VtlParser.RPAREN:
        case VtlParser.DROP:
        case VtlParser.KEEP:
        case VtlParser.RENAME:
        	break;
        default:
        	break;
        }
        this.state = 1238;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if(_la===VtlParser.DROP || _la===VtlParser.KEEP) {
            this.state = 1237;
            this.keepOrDropClause();
        }

        this.state = 1241;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if(_la===VtlParser.RENAME) {
            this.state = 1240;
            this.renameClause();
        }

    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


function JoinApplyClauseContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = VtlParser.RULE_joinApplyClause;
    return this;
}

JoinApplyClauseContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
JoinApplyClauseContext.prototype.constructor = JoinApplyClauseContext;

JoinApplyClauseContext.prototype.APPLY = function() {
    return this.getToken(VtlParser.APPLY, 0);
};

JoinApplyClauseContext.prototype.expr = function() {
    return this.getTypedRuleContext(ExprContext,0);
};




VtlParser.JoinApplyClauseContext = JoinApplyClauseContext;

VtlParser.prototype.joinApplyClause = function() {

    var localctx = new JoinApplyClauseContext(this, this._ctx, this.state);
    this.enterRule(localctx, 92, VtlParser.RULE_joinApplyClause);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1243;
        this.match(VtlParser.APPLY);
        this.state = 1244;
        this.expr(0);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


function PartitionByClauseContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = VtlParser.RULE_partitionByClause;
    return this;
}

PartitionByClauseContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
PartitionByClauseContext.prototype.constructor = PartitionByClauseContext;

PartitionByClauseContext.prototype.PARTITION = function() {
    return this.getToken(VtlParser.PARTITION, 0);
};

PartitionByClauseContext.prototype.BY = function() {
    return this.getToken(VtlParser.BY, 0);
};

PartitionByClauseContext.prototype.componentID = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(ComponentIDContext);
    } else {
        return this.getTypedRuleContext(ComponentIDContext,i);
    }
};

PartitionByClauseContext.prototype.COMMA = function(i) {
	if(i===undefined) {
		i = null;
	}
    if(i===null) {
        return this.getTokens(VtlParser.COMMA);
    } else {
        return this.getToken(VtlParser.COMMA, i);
    }
};





VtlParser.PartitionByClauseContext = PartitionByClauseContext;

VtlParser.prototype.partitionByClause = function() {

    var localctx = new PartitionByClauseContext(this, this._ctx, this.state);
    this.enterRule(localctx, 94, VtlParser.RULE_partitionByClause);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1246;
        this.match(VtlParser.PARTITION);
        this.state = 1247;
        this.match(VtlParser.BY);
        this.state = 1248;
        this.componentID();
        this.state = 1253;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while(_la===VtlParser.COMMA) {
            this.state = 1249;
            this.match(VtlParser.COMMA);
            this.state = 1250;
            this.componentID();
            this.state = 1255;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


function OrderByClauseContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = VtlParser.RULE_orderByClause;
    return this;
}

OrderByClauseContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
OrderByClauseContext.prototype.constructor = OrderByClauseContext;

OrderByClauseContext.prototype.ORDER = function() {
    return this.getToken(VtlParser.ORDER, 0);
};

OrderByClauseContext.prototype.BY = function() {
    return this.getToken(VtlParser.BY, 0);
};

OrderByClauseContext.prototype.orderByItem = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(OrderByItemContext);
    } else {
        return this.getTypedRuleContext(OrderByItemContext,i);
    }
};

OrderByClauseContext.prototype.COMMA = function(i) {
	if(i===undefined) {
		i = null;
	}
    if(i===null) {
        return this.getTokens(VtlParser.COMMA);
    } else {
        return this.getToken(VtlParser.COMMA, i);
    }
};





VtlParser.OrderByClauseContext = OrderByClauseContext;

VtlParser.prototype.orderByClause = function() {

    var localctx = new OrderByClauseContext(this, this._ctx, this.state);
    this.enterRule(localctx, 96, VtlParser.RULE_orderByClause);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1256;
        this.match(VtlParser.ORDER);
        this.state = 1257;
        this.match(VtlParser.BY);
        this.state = 1258;
        this.orderByItem();
        this.state = 1263;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while(_la===VtlParser.COMMA) {
            this.state = 1259;
            this.match(VtlParser.COMMA);
            this.state = 1260;
            this.orderByItem();
            this.state = 1265;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


function OrderByItemContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = VtlParser.RULE_orderByItem;
    return this;
}

OrderByItemContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
OrderByItemContext.prototype.constructor = OrderByItemContext;

OrderByItemContext.prototype.componentID = function() {
    return this.getTypedRuleContext(ComponentIDContext,0);
};

OrderByItemContext.prototype.ASC = function() {
    return this.getToken(VtlParser.ASC, 0);
};

OrderByItemContext.prototype.DESC = function() {
    return this.getToken(VtlParser.DESC, 0);
};




VtlParser.OrderByItemContext = OrderByItemContext;

VtlParser.prototype.orderByItem = function() {

    var localctx = new OrderByItemContext(this, this._ctx, this.state);
    this.enterRule(localctx, 98, VtlParser.RULE_orderByItem);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1266;
        this.componentID();
        this.state = 1268;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if(_la===VtlParser.ASC || _la===VtlParser.DESC) {
            this.state = 1267;
            _la = this._input.LA(1);
            if(!(_la===VtlParser.ASC || _la===VtlParser.DESC)) {
            this._errHandler.recoverInline(this);
            }
            else {
            	this._errHandler.reportMatch(this);
                this.consume();
            }
        }

    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


function WindowingClauseContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = VtlParser.RULE_windowingClause;
    this.from_ = null; // LimitClauseItemContext
    this.to_ = null; // LimitClauseItemContext
    return this;
}

WindowingClauseContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
WindowingClauseContext.prototype.constructor = WindowingClauseContext;

WindowingClauseContext.prototype.BETWEEN = function() {
    return this.getToken(VtlParser.BETWEEN, 0);
};

WindowingClauseContext.prototype.AND = function() {
    return this.getToken(VtlParser.AND, 0);
};

WindowingClauseContext.prototype.limitClauseItem = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(LimitClauseItemContext);
    } else {
        return this.getTypedRuleContext(LimitClauseItemContext,i);
    }
};

WindowingClauseContext.prototype.RANGE = function() {
    return this.getToken(VtlParser.RANGE, 0);
};

WindowingClauseContext.prototype.DATA = function() {
    return this.getToken(VtlParser.DATA, 0);
};

WindowingClauseContext.prototype.POINTS = function() {
    return this.getToken(VtlParser.POINTS, 0);
};




VtlParser.WindowingClauseContext = WindowingClauseContext;

VtlParser.prototype.windowingClause = function() {

    var localctx = new WindowingClauseContext(this, this._ctx, this.state);
    this.enterRule(localctx, 100, VtlParser.RULE_windowingClause);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1273;
        this._errHandler.sync(this);
        switch(this._input.LA(1)) {
        case VtlParser.DATA:
            this.state = 1270;
            this.match(VtlParser.DATA);
            this.state = 1271;
            this.match(VtlParser.POINTS);
            break;
        case VtlParser.RANGE:
            this.state = 1272;
            this.match(VtlParser.RANGE);
            break;
        default:
            throw new antlr4.error.NoViableAltException(this);
        }
        this.state = 1275;
        this.match(VtlParser.BETWEEN);
        this.state = 1276;
        localctx.from_ = this.limitClauseItem();
        this.state = 1277;
        this.match(VtlParser.AND);
        this.state = 1278;
        localctx.to_ = this.limitClauseItem();
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


function SignedIntegerContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = VtlParser.RULE_signedInteger;
    return this;
}

SignedIntegerContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
SignedIntegerContext.prototype.constructor = SignedIntegerContext;

SignedIntegerContext.prototype.INTEGER_CONSTANT = function() {
    return this.getToken(VtlParser.INTEGER_CONSTANT, 0);
};




VtlParser.SignedIntegerContext = SignedIntegerContext;

VtlParser.prototype.signedInteger = function() {

    var localctx = new SignedIntegerContext(this, this._ctx, this.state);
    this.enterRule(localctx, 102, VtlParser.RULE_signedInteger);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1280;
        this.match(VtlParser.INTEGER_CONSTANT);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


function LimitClauseItemContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = VtlParser.RULE_limitClauseItem;
    this.dir = null; // Token
    return this;
}

LimitClauseItemContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
LimitClauseItemContext.prototype.constructor = LimitClauseItemContext;

LimitClauseItemContext.prototype.INTEGER_CONSTANT = function() {
    return this.getToken(VtlParser.INTEGER_CONSTANT, 0);
};

LimitClauseItemContext.prototype.PRECEDING = function() {
    return this.getToken(VtlParser.PRECEDING, 0);
};

LimitClauseItemContext.prototype.FOLLOWING = function() {
    return this.getToken(VtlParser.FOLLOWING, 0);
};

LimitClauseItemContext.prototype.CURRENT = function() {
    return this.getToken(VtlParser.CURRENT, 0);
};

LimitClauseItemContext.prototype.DATA = function() {
    return this.getToken(VtlParser.DATA, 0);
};

LimitClauseItemContext.prototype.POINT = function() {
    return this.getToken(VtlParser.POINT, 0);
};

LimitClauseItemContext.prototype.UNBOUNDED = function() {
    return this.getToken(VtlParser.UNBOUNDED, 0);
};




VtlParser.LimitClauseItemContext = LimitClauseItemContext;

VtlParser.prototype.limitClauseItem = function() {

    var localctx = new LimitClauseItemContext(this, this._ctx, this.state);
    this.enterRule(localctx, 104, VtlParser.RULE_limitClauseItem);
    try {
        this.state = 1293;
        this._errHandler.sync(this);
        var la_ = this._interp.adaptivePredict(this._input,130,this._ctx);
        switch(la_) {
        case 1:
            this.enterOuterAlt(localctx, 1);
            this.state = 1282;
            this.match(VtlParser.INTEGER_CONSTANT);
            this.state = 1283;
            localctx.dir = this.match(VtlParser.PRECEDING);
            break;

        case 2:
            this.enterOuterAlt(localctx, 2);
            this.state = 1284;
            this.match(VtlParser.INTEGER_CONSTANT);
            this.state = 1285;
            localctx.dir = this.match(VtlParser.FOLLOWING);
            break;

        case 3:
            this.enterOuterAlt(localctx, 3);
            this.state = 1286;
            this.match(VtlParser.CURRENT);
            this.state = 1287;
            this.match(VtlParser.DATA);
            this.state = 1288;
            this.match(VtlParser.POINT);
            break;

        case 4:
            this.enterOuterAlt(localctx, 4);
            this.state = 1289;
            this.match(VtlParser.UNBOUNDED);
            this.state = 1290;
            localctx.dir = this.match(VtlParser.PRECEDING);
            break;

        case 5:
            this.enterOuterAlt(localctx, 5);
            this.state = 1291;
            this.match(VtlParser.UNBOUNDED);
            this.state = 1292;
            localctx.dir = this.match(VtlParser.FOLLOWING);
            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


function GroupingClauseContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = VtlParser.RULE_groupingClause;
    return this;
}

GroupingClauseContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
GroupingClauseContext.prototype.constructor = GroupingClauseContext;


 
GroupingClauseContext.prototype.copyFrom = function(ctx) {
    antlr4.ParserRuleContext.prototype.copyFrom.call(this, ctx);
};


function GroupAllContext(parser, ctx) {
	GroupingClauseContext.call(this, parser);
    GroupingClauseContext.prototype.copyFrom.call(this, ctx);
    return this;
}

GroupAllContext.prototype = Object.create(GroupingClauseContext.prototype);
GroupAllContext.prototype.constructor = GroupAllContext;

VtlParser.GroupAllContext = GroupAllContext;

GroupAllContext.prototype.GROUP = function() {
    return this.getToken(VtlParser.GROUP, 0);
};

GroupAllContext.prototype.ALL = function() {
    return this.getToken(VtlParser.ALL, 0);
};

GroupAllContext.prototype.exprComponent = function() {
    return this.getTypedRuleContext(ExprComponentContext,0);
};

function GroupByOrExceptContext(parser, ctx) {
	GroupingClauseContext.call(this, parser);
    this.op = null; // Token;
    GroupingClauseContext.prototype.copyFrom.call(this, ctx);
    return this;
}

GroupByOrExceptContext.prototype = Object.create(GroupingClauseContext.prototype);
GroupByOrExceptContext.prototype.constructor = GroupByOrExceptContext;

VtlParser.GroupByOrExceptContext = GroupByOrExceptContext;

GroupByOrExceptContext.prototype.GROUP = function() {
    return this.getToken(VtlParser.GROUP, 0);
};

GroupByOrExceptContext.prototype.componentID = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(ComponentIDContext);
    } else {
        return this.getTypedRuleContext(ComponentIDContext,i);
    }
};

GroupByOrExceptContext.prototype.BY = function() {
    return this.getToken(VtlParser.BY, 0);
};

GroupByOrExceptContext.prototype.EXCEPT = function() {
    return this.getToken(VtlParser.EXCEPT, 0);
};

GroupByOrExceptContext.prototype.COMMA = function(i) {
	if(i===undefined) {
		i = null;
	}
    if(i===null) {
        return this.getTokens(VtlParser.COMMA);
    } else {
        return this.getToken(VtlParser.COMMA, i);
    }
};



VtlParser.GroupingClauseContext = GroupingClauseContext;

VtlParser.prototype.groupingClause = function() {

    var localctx = new GroupingClauseContext(this, this._ctx, this.state);
    this.enterRule(localctx, 106, VtlParser.RULE_groupingClause);
    var _la = 0; // Token type
    try {
        this.state = 1308;
        this._errHandler.sync(this);
        var la_ = this._interp.adaptivePredict(this._input,132,this._ctx);
        switch(la_) {
        case 1:
            localctx = new GroupByOrExceptContext(this, localctx);
            this.enterOuterAlt(localctx, 1);
            this.state = 1295;
            this.match(VtlParser.GROUP);
            this.state = 1296;
            localctx.op = this._input.LT(1);
            _la = this._input.LA(1);
            if(!(_la===VtlParser.BY || _la===VtlParser.EXCEPT)) {
                localctx.op = this._errHandler.recoverInline(this);
            }
            else {
            	this._errHandler.reportMatch(this);
                this.consume();
            }
            this.state = 1297;
            this.componentID();
            this.state = 1302;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            while(_la===VtlParser.COMMA) {
                this.state = 1298;
                this.match(VtlParser.COMMA);
                this.state = 1299;
                this.componentID();
                this.state = 1304;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
            }
            break;

        case 2:
            localctx = new GroupAllContext(this, localctx);
            this.enterOuterAlt(localctx, 2);
            this.state = 1305;
            this.match(VtlParser.GROUP);
            this.state = 1306;
            this.match(VtlParser.ALL);
            this.state = 1307;
            this.exprComponent(0);
            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


function HavingClauseContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = VtlParser.RULE_havingClause;
    return this;
}

HavingClauseContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
HavingClauseContext.prototype.constructor = HavingClauseContext;

HavingClauseContext.prototype.HAVING = function() {
    return this.getToken(VtlParser.HAVING, 0);
};

HavingClauseContext.prototype.exprComponent = function() {
    return this.getTypedRuleContext(ExprComponentContext,0);
};




VtlParser.HavingClauseContext = HavingClauseContext;

VtlParser.prototype.havingClause = function() {

    var localctx = new HavingClauseContext(this, this._ctx, this.state);
    this.enterRule(localctx, 108, VtlParser.RULE_havingClause);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1310;
        this.match(VtlParser.HAVING);
        this.state = 1311;
        this.exprComponent(0);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


function ParameterItemContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = VtlParser.RULE_parameterItem;
    return this;
}

ParameterItemContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ParameterItemContext.prototype.constructor = ParameterItemContext;

ParameterItemContext.prototype.varID = function() {
    return this.getTypedRuleContext(VarIDContext,0);
};

ParameterItemContext.prototype.inputParameterType = function() {
    return this.getTypedRuleContext(InputParameterTypeContext,0);
};

ParameterItemContext.prototype.DEFAULT = function() {
    return this.getToken(VtlParser.DEFAULT, 0);
};

ParameterItemContext.prototype.constant = function() {
    return this.getTypedRuleContext(ConstantContext,0);
};




VtlParser.ParameterItemContext = ParameterItemContext;

VtlParser.prototype.parameterItem = function() {

    var localctx = new ParameterItemContext(this, this._ctx, this.state);
    this.enterRule(localctx, 110, VtlParser.RULE_parameterItem);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1313;
        this.varID();
        this.state = 1314;
        this.inputParameterType();
        this.state = 1317;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if(_la===VtlParser.DEFAULT) {
            this.state = 1315;
            this.match(VtlParser.DEFAULT);
            this.state = 1316;
            this.constant();
        }

    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


function OutputParameterTypeContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = VtlParser.RULE_outputParameterType;
    return this;
}

OutputParameterTypeContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
OutputParameterTypeContext.prototype.constructor = OutputParameterTypeContext;

OutputParameterTypeContext.prototype.scalarType = function() {
    return this.getTypedRuleContext(ScalarTypeContext,0);
};

OutputParameterTypeContext.prototype.datasetType = function() {
    return this.getTypedRuleContext(DatasetTypeContext,0);
};

OutputParameterTypeContext.prototype.componentType = function() {
    return this.getTypedRuleContext(ComponentTypeContext,0);
};




VtlParser.OutputParameterTypeContext = OutputParameterTypeContext;

VtlParser.prototype.outputParameterType = function() {

    var localctx = new OutputParameterTypeContext(this, this._ctx, this.state);
    this.enterRule(localctx, 112, VtlParser.RULE_outputParameterType);
    try {
        this.state = 1322;
        this._errHandler.sync(this);
        switch(this._input.LA(1)) {
        case VtlParser.BOOLEAN:
        case VtlParser.DATE:
        case VtlParser.TIME_PERIOD:
        case VtlParser.NUMBER:
        case VtlParser.STRING:
        case VtlParser.TIME:
        case VtlParser.INTEGER:
        case VtlParser.DURATION:
        case VtlParser.SCALAR:
        case VtlParser.IDENTIFIER:
            this.enterOuterAlt(localctx, 1);
            this.state = 1319;
            this.scalarType();
            break;
        case VtlParser.DATASET:
            this.enterOuterAlt(localctx, 2);
            this.state = 1320;
            this.datasetType();
            break;
        case VtlParser.DIMENSION:
        case VtlParser.MEASURE:
        case VtlParser.ATTRIBUTE:
        case VtlParser.VIRAL:
        case VtlParser.COMPONENT:
            this.enterOuterAlt(localctx, 3);
            this.state = 1321;
            this.componentType();
            break;
        default:
            throw new antlr4.error.NoViableAltException(this);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


function OutputParameterTypeComponentContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = VtlParser.RULE_outputParameterTypeComponent;
    return this;
}

OutputParameterTypeComponentContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
OutputParameterTypeComponentContext.prototype.constructor = OutputParameterTypeComponentContext;

OutputParameterTypeComponentContext.prototype.componentType = function() {
    return this.getTypedRuleContext(ComponentTypeContext,0);
};

OutputParameterTypeComponentContext.prototype.scalarType = function() {
    return this.getTypedRuleContext(ScalarTypeContext,0);
};




VtlParser.OutputParameterTypeComponentContext = OutputParameterTypeComponentContext;

VtlParser.prototype.outputParameterTypeComponent = function() {

    var localctx = new OutputParameterTypeComponentContext(this, this._ctx, this.state);
    this.enterRule(localctx, 114, VtlParser.RULE_outputParameterTypeComponent);
    try {
        this.state = 1326;
        this._errHandler.sync(this);
        switch(this._input.LA(1)) {
        case VtlParser.DIMENSION:
        case VtlParser.MEASURE:
        case VtlParser.ATTRIBUTE:
        case VtlParser.VIRAL:
        case VtlParser.COMPONENT:
            this.enterOuterAlt(localctx, 1);
            this.state = 1324;
            this.componentType();
            break;
        case VtlParser.BOOLEAN:
        case VtlParser.DATE:
        case VtlParser.TIME_PERIOD:
        case VtlParser.NUMBER:
        case VtlParser.STRING:
        case VtlParser.TIME:
        case VtlParser.INTEGER:
        case VtlParser.DURATION:
        case VtlParser.SCALAR:
        case VtlParser.IDENTIFIER:
            this.enterOuterAlt(localctx, 2);
            this.state = 1325;
            this.scalarType();
            break;
        default:
            throw new antlr4.error.NoViableAltException(this);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


function InputParameterTypeContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = VtlParser.RULE_inputParameterType;
    return this;
}

InputParameterTypeContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
InputParameterTypeContext.prototype.constructor = InputParameterTypeContext;

InputParameterTypeContext.prototype.scalarType = function() {
    return this.getTypedRuleContext(ScalarTypeContext,0);
};

InputParameterTypeContext.prototype.datasetType = function() {
    return this.getTypedRuleContext(DatasetTypeContext,0);
};

InputParameterTypeContext.prototype.scalarSetType = function() {
    return this.getTypedRuleContext(ScalarSetTypeContext,0);
};

InputParameterTypeContext.prototype.rulesetType = function() {
    return this.getTypedRuleContext(RulesetTypeContext,0);
};

InputParameterTypeContext.prototype.componentType = function() {
    return this.getTypedRuleContext(ComponentTypeContext,0);
};




VtlParser.InputParameterTypeContext = InputParameterTypeContext;

VtlParser.prototype.inputParameterType = function() {

    var localctx = new InputParameterTypeContext(this, this._ctx, this.state);
    this.enterRule(localctx, 116, VtlParser.RULE_inputParameterType);
    try {
        this.state = 1333;
        this._errHandler.sync(this);
        switch(this._input.LA(1)) {
        case VtlParser.BOOLEAN:
        case VtlParser.DATE:
        case VtlParser.TIME_PERIOD:
        case VtlParser.NUMBER:
        case VtlParser.STRING:
        case VtlParser.TIME:
        case VtlParser.INTEGER:
        case VtlParser.DURATION:
        case VtlParser.SCALAR:
        case VtlParser.IDENTIFIER:
            this.enterOuterAlt(localctx, 1);
            this.state = 1328;
            this.scalarType();
            break;
        case VtlParser.DATASET:
            this.enterOuterAlt(localctx, 2);
            this.state = 1329;
            this.datasetType();
            break;
        case VtlParser.SET:
            this.enterOuterAlt(localctx, 3);
            this.state = 1330;
            this.scalarSetType();
            break;
        case VtlParser.DATAPOINT:
        case VtlParser.HIERARCHICAL:
        case VtlParser.RULESET:
        case VtlParser.DATAPOINT_ON_VD:
        case VtlParser.DATAPOINT_ON_VAR:
        case VtlParser.HIERARCHICAL_ON_VD:
        case VtlParser.HIERARCHICAL_ON_VAR:
            this.enterOuterAlt(localctx, 4);
            this.state = 1331;
            this.rulesetType();
            break;
        case VtlParser.DIMENSION:
        case VtlParser.MEASURE:
        case VtlParser.ATTRIBUTE:
        case VtlParser.VIRAL:
        case VtlParser.COMPONENT:
            this.enterOuterAlt(localctx, 5);
            this.state = 1332;
            this.componentType();
            break;
        default:
            throw new antlr4.error.NoViableAltException(this);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


function RulesetTypeContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = VtlParser.RULE_rulesetType;
    return this;
}

RulesetTypeContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
RulesetTypeContext.prototype.constructor = RulesetTypeContext;

RulesetTypeContext.prototype.RULESET = function() {
    return this.getToken(VtlParser.RULESET, 0);
};

RulesetTypeContext.prototype.dpRuleset = function() {
    return this.getTypedRuleContext(DpRulesetContext,0);
};

RulesetTypeContext.prototype.hrRuleset = function() {
    return this.getTypedRuleContext(HrRulesetContext,0);
};




VtlParser.RulesetTypeContext = RulesetTypeContext;

VtlParser.prototype.rulesetType = function() {

    var localctx = new RulesetTypeContext(this, this._ctx, this.state);
    this.enterRule(localctx, 118, VtlParser.RULE_rulesetType);
    try {
        this.state = 1338;
        this._errHandler.sync(this);
        switch(this._input.LA(1)) {
        case VtlParser.RULESET:
            this.enterOuterAlt(localctx, 1);
            this.state = 1335;
            this.match(VtlParser.RULESET);
            break;
        case VtlParser.DATAPOINT:
        case VtlParser.DATAPOINT_ON_VD:
        case VtlParser.DATAPOINT_ON_VAR:
            this.enterOuterAlt(localctx, 2);
            this.state = 1336;
            this.dpRuleset();
            break;
        case VtlParser.HIERARCHICAL:
        case VtlParser.HIERARCHICAL_ON_VD:
        case VtlParser.HIERARCHICAL_ON_VAR:
            this.enterOuterAlt(localctx, 3);
            this.state = 1337;
            this.hrRuleset();
            break;
        default:
            throw new antlr4.error.NoViableAltException(this);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


function ScalarTypeContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = VtlParser.RULE_scalarType;
    return this;
}

ScalarTypeContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ScalarTypeContext.prototype.constructor = ScalarTypeContext;

ScalarTypeContext.prototype.basicScalarType = function() {
    return this.getTypedRuleContext(BasicScalarTypeContext,0);
};

ScalarTypeContext.prototype.valueDomainName = function() {
    return this.getTypedRuleContext(ValueDomainNameContext,0);
};

ScalarTypeContext.prototype.scalarTypeConstraint = function() {
    return this.getTypedRuleContext(ScalarTypeConstraintContext,0);
};

ScalarTypeContext.prototype.NULL_CONSTANT = function() {
    return this.getToken(VtlParser.NULL_CONSTANT, 0);
};

ScalarTypeContext.prototype.NOT = function() {
    return this.getToken(VtlParser.NOT, 0);
};




VtlParser.ScalarTypeContext = ScalarTypeContext;

VtlParser.prototype.scalarType = function() {

    var localctx = new ScalarTypeContext(this, this._ctx, this.state);
    this.enterRule(localctx, 120, VtlParser.RULE_scalarType);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1342;
        this._errHandler.sync(this);
        switch(this._input.LA(1)) {
        case VtlParser.BOOLEAN:
        case VtlParser.DATE:
        case VtlParser.TIME_PERIOD:
        case VtlParser.NUMBER:
        case VtlParser.STRING:
        case VtlParser.TIME:
        case VtlParser.INTEGER:
        case VtlParser.DURATION:
        case VtlParser.SCALAR:
            this.state = 1340;
            this.basicScalarType();
            break;
        case VtlParser.IDENTIFIER:
            this.state = 1341;
            this.valueDomainName();
            break;
        default:
            throw new antlr4.error.NoViableAltException(this);
        }
        this.state = 1345;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if(_la===VtlParser.QLPAREN || _la===VtlParser.GLPAREN) {
            this.state = 1344;
            this.scalarTypeConstraint();
        }

        this.state = 1351;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if(_la===VtlParser.NOT || _la===VtlParser.NULL_CONSTANT) {
            this.state = 1348;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if(_la===VtlParser.NOT) {
                this.state = 1347;
                this.match(VtlParser.NOT);
            }

            this.state = 1350;
            this.match(VtlParser.NULL_CONSTANT);
        }

    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


function ComponentTypeContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = VtlParser.RULE_componentType;
    return this;
}

ComponentTypeContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ComponentTypeContext.prototype.constructor = ComponentTypeContext;

ComponentTypeContext.prototype.componentRole = function() {
    return this.getTypedRuleContext(ComponentRoleContext,0);
};

ComponentTypeContext.prototype.LT = function() {
    return this.getToken(VtlParser.LT, 0);
};

ComponentTypeContext.prototype.scalarType = function() {
    return this.getTypedRuleContext(ScalarTypeContext,0);
};

ComponentTypeContext.prototype.MT = function() {
    return this.getToken(VtlParser.MT, 0);
};




VtlParser.ComponentTypeContext = ComponentTypeContext;

VtlParser.prototype.componentType = function() {

    var localctx = new ComponentTypeContext(this, this._ctx, this.state);
    this.enterRule(localctx, 122, VtlParser.RULE_componentType);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1353;
        this.componentRole();
        this.state = 1358;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if(_la===VtlParser.LT) {
            this.state = 1354;
            this.match(VtlParser.LT);
            this.state = 1355;
            this.scalarType();
            this.state = 1356;
            this.match(VtlParser.MT);
        }

    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


function DatasetTypeContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = VtlParser.RULE_datasetType;
    return this;
}

DatasetTypeContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
DatasetTypeContext.prototype.constructor = DatasetTypeContext;

DatasetTypeContext.prototype.DATASET = function() {
    return this.getToken(VtlParser.DATASET, 0);
};

DatasetTypeContext.prototype.GLPAREN = function() {
    return this.getToken(VtlParser.GLPAREN, 0);
};

DatasetTypeContext.prototype.compConstraint = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(CompConstraintContext);
    } else {
        return this.getTypedRuleContext(CompConstraintContext,i);
    }
};

DatasetTypeContext.prototype.GRPAREN = function() {
    return this.getToken(VtlParser.GRPAREN, 0);
};

DatasetTypeContext.prototype.COMMA = function(i) {
	if(i===undefined) {
		i = null;
	}
    if(i===null) {
        return this.getTokens(VtlParser.COMMA);
    } else {
        return this.getToken(VtlParser.COMMA, i);
    }
};





VtlParser.DatasetTypeContext = DatasetTypeContext;

VtlParser.prototype.datasetType = function() {

    var localctx = new DatasetTypeContext(this, this._ctx, this.state);
    this.enterRule(localctx, 124, VtlParser.RULE_datasetType);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1360;
        this.match(VtlParser.DATASET);
        this.state = 1372;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if(_la===VtlParser.GLPAREN) {
            this.state = 1361;
            this.match(VtlParser.GLPAREN);
            this.state = 1362;
            this.compConstraint();
            this.state = 1367;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            while(_la===VtlParser.COMMA) {
                this.state = 1363;
                this.match(VtlParser.COMMA);
                this.state = 1364;
                this.compConstraint();
                this.state = 1369;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
            }
            this.state = 1370;
            this.match(VtlParser.GRPAREN);
        }

    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


function ScalarSetTypeContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = VtlParser.RULE_scalarSetType;
    return this;
}

ScalarSetTypeContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ScalarSetTypeContext.prototype.constructor = ScalarSetTypeContext;

ScalarSetTypeContext.prototype.SET = function() {
    return this.getToken(VtlParser.SET, 0);
};

ScalarSetTypeContext.prototype.LT = function() {
    return this.getToken(VtlParser.LT, 0);
};

ScalarSetTypeContext.prototype.scalarType = function() {
    return this.getTypedRuleContext(ScalarTypeContext,0);
};

ScalarSetTypeContext.prototype.MT = function() {
    return this.getToken(VtlParser.MT, 0);
};




VtlParser.ScalarSetTypeContext = ScalarSetTypeContext;

VtlParser.prototype.scalarSetType = function() {

    var localctx = new ScalarSetTypeContext(this, this._ctx, this.state);
    this.enterRule(localctx, 126, VtlParser.RULE_scalarSetType);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1374;
        this.match(VtlParser.SET);
        this.state = 1379;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if(_la===VtlParser.LT) {
            this.state = 1375;
            this.match(VtlParser.LT);
            this.state = 1376;
            this.scalarType();
            this.state = 1377;
            this.match(VtlParser.MT);
        }

    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


function DpRulesetContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = VtlParser.RULE_dpRuleset;
    return this;
}

DpRulesetContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
DpRulesetContext.prototype.constructor = DpRulesetContext;


 
DpRulesetContext.prototype.copyFrom = function(ctx) {
    antlr4.ParserRuleContext.prototype.copyFrom.call(this, ctx);
};


function DataPointVdContext(parser, ctx) {
	DpRulesetContext.call(this, parser);
    DpRulesetContext.prototype.copyFrom.call(this, ctx);
    return this;
}

DataPointVdContext.prototype = Object.create(DpRulesetContext.prototype);
DataPointVdContext.prototype.constructor = DataPointVdContext;

VtlParser.DataPointVdContext = DataPointVdContext;

DataPointVdContext.prototype.DATAPOINT_ON_VD = function() {
    return this.getToken(VtlParser.DATAPOINT_ON_VD, 0);
};

DataPointVdContext.prototype.GLPAREN = function() {
    return this.getToken(VtlParser.GLPAREN, 0);
};

DataPointVdContext.prototype.valueDomainName = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(ValueDomainNameContext);
    } else {
        return this.getTypedRuleContext(ValueDomainNameContext,i);
    }
};

DataPointVdContext.prototype.GRPAREN = function() {
    return this.getToken(VtlParser.GRPAREN, 0);
};

DataPointVdContext.prototype.MUL = function(i) {
	if(i===undefined) {
		i = null;
	}
    if(i===null) {
        return this.getTokens(VtlParser.MUL);
    } else {
        return this.getToken(VtlParser.MUL, i);
    }
};


function DataPointVarContext(parser, ctx) {
	DpRulesetContext.call(this, parser);
    DpRulesetContext.prototype.copyFrom.call(this, ctx);
    return this;
}

DataPointVarContext.prototype = Object.create(DpRulesetContext.prototype);
DataPointVarContext.prototype.constructor = DataPointVarContext;

VtlParser.DataPointVarContext = DataPointVarContext;

DataPointVarContext.prototype.DATAPOINT_ON_VAR = function() {
    return this.getToken(VtlParser.DATAPOINT_ON_VAR, 0);
};

DataPointVarContext.prototype.GLPAREN = function() {
    return this.getToken(VtlParser.GLPAREN, 0);
};

DataPointVarContext.prototype.varID = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(VarIDContext);
    } else {
        return this.getTypedRuleContext(VarIDContext,i);
    }
};

DataPointVarContext.prototype.GRPAREN = function() {
    return this.getToken(VtlParser.GRPAREN, 0);
};

DataPointVarContext.prototype.MUL = function(i) {
	if(i===undefined) {
		i = null;
	}
    if(i===null) {
        return this.getTokens(VtlParser.MUL);
    } else {
        return this.getToken(VtlParser.MUL, i);
    }
};


function DataPointContext(parser, ctx) {
	DpRulesetContext.call(this, parser);
    DpRulesetContext.prototype.copyFrom.call(this, ctx);
    return this;
}

DataPointContext.prototype = Object.create(DpRulesetContext.prototype);
DataPointContext.prototype.constructor = DataPointContext;

VtlParser.DataPointContext = DataPointContext;

DataPointContext.prototype.DATAPOINT = function() {
    return this.getToken(VtlParser.DATAPOINT, 0);
};


VtlParser.DpRulesetContext = DpRulesetContext;

VtlParser.prototype.dpRuleset = function() {

    var localctx = new DpRulesetContext(this, this._ctx, this.state);
    this.enterRule(localctx, 128, VtlParser.RULE_dpRuleset);
    var _la = 0; // Token type
    try {
        this.state = 1410;
        this._errHandler.sync(this);
        switch(this._input.LA(1)) {
        case VtlParser.DATAPOINT:
            localctx = new DataPointContext(this, localctx);
            this.enterOuterAlt(localctx, 1);
            this.state = 1381;
            this.match(VtlParser.DATAPOINT);
            break;
        case VtlParser.DATAPOINT_ON_VD:
            localctx = new DataPointVdContext(this, localctx);
            this.enterOuterAlt(localctx, 2);
            this.state = 1382;
            this.match(VtlParser.DATAPOINT_ON_VD);
            this.state = 1394;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if(_la===VtlParser.GLPAREN) {
                this.state = 1383;
                this.match(VtlParser.GLPAREN);
                this.state = 1384;
                this.valueDomainName();
                this.state = 1389;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
                while(_la===VtlParser.MUL) {
                    this.state = 1385;
                    this.match(VtlParser.MUL);
                    this.state = 1386;
                    this.valueDomainName();
                    this.state = 1391;
                    this._errHandler.sync(this);
                    _la = this._input.LA(1);
                }
                this.state = 1392;
                this.match(VtlParser.GRPAREN);
            }

            break;
        case VtlParser.DATAPOINT_ON_VAR:
            localctx = new DataPointVarContext(this, localctx);
            this.enterOuterAlt(localctx, 3);
            this.state = 1396;
            this.match(VtlParser.DATAPOINT_ON_VAR);
            this.state = 1408;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if(_la===VtlParser.GLPAREN) {
                this.state = 1397;
                this.match(VtlParser.GLPAREN);
                this.state = 1398;
                this.varID();
                this.state = 1403;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
                while(_la===VtlParser.MUL) {
                    this.state = 1399;
                    this.match(VtlParser.MUL);
                    this.state = 1400;
                    this.varID();
                    this.state = 1405;
                    this._errHandler.sync(this);
                    _la = this._input.LA(1);
                }
                this.state = 1406;
                this.match(VtlParser.GRPAREN);
            }

            break;
        default:
            throw new antlr4.error.NoViableAltException(this);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


function HrRulesetContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = VtlParser.RULE_hrRuleset;
    return this;
}

HrRulesetContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
HrRulesetContext.prototype.constructor = HrRulesetContext;


 
HrRulesetContext.prototype.copyFrom = function(ctx) {
    antlr4.ParserRuleContext.prototype.copyFrom.call(this, ctx);
};


function HrRulesetVdTypeContext(parser, ctx) {
	HrRulesetContext.call(this, parser);
    this.vdName = null; // Token;
    HrRulesetContext.prototype.copyFrom.call(this, ctx);
    return this;
}

HrRulesetVdTypeContext.prototype = Object.create(HrRulesetContext.prototype);
HrRulesetVdTypeContext.prototype.constructor = HrRulesetVdTypeContext;

VtlParser.HrRulesetVdTypeContext = HrRulesetVdTypeContext;

HrRulesetVdTypeContext.prototype.HIERARCHICAL_ON_VD = function() {
    return this.getToken(VtlParser.HIERARCHICAL_ON_VD, 0);
};

HrRulesetVdTypeContext.prototype.GLPAREN = function() {
    return this.getToken(VtlParser.GLPAREN, 0);
};

HrRulesetVdTypeContext.prototype.GRPAREN = function() {
    return this.getToken(VtlParser.GRPAREN, 0);
};

HrRulesetVdTypeContext.prototype.IDENTIFIER = function() {
    return this.getToken(VtlParser.IDENTIFIER, 0);
};

HrRulesetVdTypeContext.prototype.LPAREN = function() {
    return this.getToken(VtlParser.LPAREN, 0);
};

HrRulesetVdTypeContext.prototype.valueDomainName = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(ValueDomainNameContext);
    } else {
        return this.getTypedRuleContext(ValueDomainNameContext,i);
    }
};

HrRulesetVdTypeContext.prototype.RPAREN = function() {
    return this.getToken(VtlParser.RPAREN, 0);
};

HrRulesetVdTypeContext.prototype.MUL = function(i) {
	if(i===undefined) {
		i = null;
	}
    if(i===null) {
        return this.getTokens(VtlParser.MUL);
    } else {
        return this.getToken(VtlParser.MUL, i);
    }
};


function HrRulesetVarTypeContext(parser, ctx) {
	HrRulesetContext.call(this, parser);
    this.varName = null; // VarIDContext;
    HrRulesetContext.prototype.copyFrom.call(this, ctx);
    return this;
}

HrRulesetVarTypeContext.prototype = Object.create(HrRulesetContext.prototype);
HrRulesetVarTypeContext.prototype.constructor = HrRulesetVarTypeContext;

VtlParser.HrRulesetVarTypeContext = HrRulesetVarTypeContext;

HrRulesetVarTypeContext.prototype.HIERARCHICAL_ON_VAR = function() {
    return this.getToken(VtlParser.HIERARCHICAL_ON_VAR, 0);
};

HrRulesetVarTypeContext.prototype.GLPAREN = function() {
    return this.getToken(VtlParser.GLPAREN, 0);
};

HrRulesetVarTypeContext.prototype.GRPAREN = function() {
    return this.getToken(VtlParser.GRPAREN, 0);
};

HrRulesetVarTypeContext.prototype.varID = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(VarIDContext);
    } else {
        return this.getTypedRuleContext(VarIDContext,i);
    }
};

HrRulesetVarTypeContext.prototype.LPAREN = function() {
    return this.getToken(VtlParser.LPAREN, 0);
};

HrRulesetVarTypeContext.prototype.RPAREN = function() {
    return this.getToken(VtlParser.RPAREN, 0);
};

HrRulesetVarTypeContext.prototype.MUL = function(i) {
	if(i===undefined) {
		i = null;
	}
    if(i===null) {
        return this.getTokens(VtlParser.MUL);
    } else {
        return this.getToken(VtlParser.MUL, i);
    }
};


function HrRulesetTypeContext(parser, ctx) {
	HrRulesetContext.call(this, parser);
    HrRulesetContext.prototype.copyFrom.call(this, ctx);
    return this;
}

HrRulesetTypeContext.prototype = Object.create(HrRulesetContext.prototype);
HrRulesetTypeContext.prototype.constructor = HrRulesetTypeContext;

VtlParser.HrRulesetTypeContext = HrRulesetTypeContext;

HrRulesetTypeContext.prototype.HIERARCHICAL = function() {
    return this.getToken(VtlParser.HIERARCHICAL, 0);
};


VtlParser.HrRulesetContext = HrRulesetContext;

VtlParser.prototype.hrRuleset = function() {

    var localctx = new HrRulesetContext(this, this._ctx, this.state);
    this.enterRule(localctx, 130, VtlParser.RULE_hrRuleset);
    var _la = 0; // Token type
    try {
        this.state = 1452;
        this._errHandler.sync(this);
        switch(this._input.LA(1)) {
        case VtlParser.HIERARCHICAL:
            localctx = new HrRulesetTypeContext(this, localctx);
            this.enterOuterAlt(localctx, 1);
            this.state = 1412;
            this.match(VtlParser.HIERARCHICAL);
            break;
        case VtlParser.HIERARCHICAL_ON_VD:
            localctx = new HrRulesetVdTypeContext(this, localctx);
            this.enterOuterAlt(localctx, 2);
            this.state = 1413;
            this.match(VtlParser.HIERARCHICAL_ON_VD);
            this.state = 1430;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if(_la===VtlParser.GLPAREN) {
                this.state = 1414;
                this.match(VtlParser.GLPAREN);
                this.state = 1415;
                localctx.vdName = this.match(VtlParser.IDENTIFIER);
                this.state = 1427;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
                if(_la===VtlParser.LPAREN) {
                    this.state = 1416;
                    this.match(VtlParser.LPAREN);
                    this.state = 1417;
                    this.valueDomainName();
                    this.state = 1422;
                    this._errHandler.sync(this);
                    _la = this._input.LA(1);
                    while(_la===VtlParser.MUL) {
                        this.state = 1418;
                        this.match(VtlParser.MUL);
                        this.state = 1419;
                        this.valueDomainName();
                        this.state = 1424;
                        this._errHandler.sync(this);
                        _la = this._input.LA(1);
                    }
                    this.state = 1425;
                    this.match(VtlParser.RPAREN);
                }

                this.state = 1429;
                this.match(VtlParser.GRPAREN);
            }

            break;
        case VtlParser.HIERARCHICAL_ON_VAR:
            localctx = new HrRulesetVarTypeContext(this, localctx);
            this.enterOuterAlt(localctx, 3);
            this.state = 1432;
            this.match(VtlParser.HIERARCHICAL_ON_VAR);
            this.state = 1450;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if(_la===VtlParser.GLPAREN) {
                this.state = 1433;
                this.match(VtlParser.GLPAREN);
                this.state = 1434;
                localctx.varName = this.varID();
                this.state = 1446;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
                if(_la===VtlParser.LPAREN) {
                    this.state = 1435;
                    this.match(VtlParser.LPAREN);
                    this.state = 1436;
                    this.varID();
                    this.state = 1441;
                    this._errHandler.sync(this);
                    _la = this._input.LA(1);
                    while(_la===VtlParser.MUL) {
                        this.state = 1437;
                        this.match(VtlParser.MUL);
                        this.state = 1438;
                        this.varID();
                        this.state = 1443;
                        this._errHandler.sync(this);
                        _la = this._input.LA(1);
                    }
                    this.state = 1444;
                    this.match(VtlParser.RPAREN);
                }

                this.state = 1448;
                this.match(VtlParser.GRPAREN);
            }

            break;
        default:
            throw new antlr4.error.NoViableAltException(this);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


function ValueDomainNameContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = VtlParser.RULE_valueDomainName;
    return this;
}

ValueDomainNameContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ValueDomainNameContext.prototype.constructor = ValueDomainNameContext;

ValueDomainNameContext.prototype.IDENTIFIER = function() {
    return this.getToken(VtlParser.IDENTIFIER, 0);
};




VtlParser.ValueDomainNameContext = ValueDomainNameContext;

VtlParser.prototype.valueDomainName = function() {

    var localctx = new ValueDomainNameContext(this, this._ctx, this.state);
    this.enterRule(localctx, 132, VtlParser.RULE_valueDomainName);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1454;
        this.match(VtlParser.IDENTIFIER);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


function RulesetIDContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = VtlParser.RULE_rulesetID;
    return this;
}

RulesetIDContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
RulesetIDContext.prototype.constructor = RulesetIDContext;

RulesetIDContext.prototype.IDENTIFIER = function() {
    return this.getToken(VtlParser.IDENTIFIER, 0);
};




VtlParser.RulesetIDContext = RulesetIDContext;

VtlParser.prototype.rulesetID = function() {

    var localctx = new RulesetIDContext(this, this._ctx, this.state);
    this.enterRule(localctx, 134, VtlParser.RULE_rulesetID);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1456;
        this.match(VtlParser.IDENTIFIER);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


function RulesetSignatureContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = VtlParser.RULE_rulesetSignature;
    return this;
}

RulesetSignatureContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
RulesetSignatureContext.prototype.constructor = RulesetSignatureContext;

RulesetSignatureContext.prototype.signature = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(SignatureContext);
    } else {
        return this.getTypedRuleContext(SignatureContext,i);
    }
};

RulesetSignatureContext.prototype.VALUE_DOMAIN = function() {
    return this.getToken(VtlParser.VALUE_DOMAIN, 0);
};

RulesetSignatureContext.prototype.VARIABLE = function() {
    return this.getToken(VtlParser.VARIABLE, 0);
};

RulesetSignatureContext.prototype.COMMA = function(i) {
	if(i===undefined) {
		i = null;
	}
    if(i===null) {
        return this.getTokens(VtlParser.COMMA);
    } else {
        return this.getToken(VtlParser.COMMA, i);
    }
};





VtlParser.RulesetSignatureContext = RulesetSignatureContext;

VtlParser.prototype.rulesetSignature = function() {

    var localctx = new RulesetSignatureContext(this, this._ctx, this.state);
    this.enterRule(localctx, 136, VtlParser.RULE_rulesetSignature);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1458;
        _la = this._input.LA(1);
        if(!(_la===VtlParser.VALUE_DOMAIN || _la===VtlParser.VARIABLE)) {
        this._errHandler.recoverInline(this);
        }
        else {
        	this._errHandler.reportMatch(this);
            this.consume();
        }
        this.state = 1459;
        this.signature();
        this.state = 1464;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while(_la===VtlParser.COMMA) {
            this.state = 1460;
            this.match(VtlParser.COMMA);
            this.state = 1461;
            this.signature();
            this.state = 1466;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


function SignatureContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = VtlParser.RULE_signature;
    return this;
}

SignatureContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
SignatureContext.prototype.constructor = SignatureContext;

SignatureContext.prototype.varID = function() {
    return this.getTypedRuleContext(VarIDContext,0);
};

SignatureContext.prototype.AS = function() {
    return this.getToken(VtlParser.AS, 0);
};

SignatureContext.prototype.alias = function() {
    return this.getTypedRuleContext(AliasContext,0);
};




VtlParser.SignatureContext = SignatureContext;

VtlParser.prototype.signature = function() {

    var localctx = new SignatureContext(this, this._ctx, this.state);
    this.enterRule(localctx, 138, VtlParser.RULE_signature);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1467;
        this.varID();
        this.state = 1470;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if(_la===VtlParser.AS) {
            this.state = 1468;
            this.match(VtlParser.AS);
            this.state = 1469;
            this.alias();
        }

    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


function RuleClauseDatapointContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = VtlParser.RULE_ruleClauseDatapoint;
    return this;
}

RuleClauseDatapointContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
RuleClauseDatapointContext.prototype.constructor = RuleClauseDatapointContext;

RuleClauseDatapointContext.prototype.ruleItemDatapoint = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(RuleItemDatapointContext);
    } else {
        return this.getTypedRuleContext(RuleItemDatapointContext,i);
    }
};

RuleClauseDatapointContext.prototype.EOL = function(i) {
	if(i===undefined) {
		i = null;
	}
    if(i===null) {
        return this.getTokens(VtlParser.EOL);
    } else {
        return this.getToken(VtlParser.EOL, i);
    }
};





VtlParser.RuleClauseDatapointContext = RuleClauseDatapointContext;

VtlParser.prototype.ruleClauseDatapoint = function() {

    var localctx = new RuleClauseDatapointContext(this, this._ctx, this.state);
    this.enterRule(localctx, 140, VtlParser.RULE_ruleClauseDatapoint);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1472;
        this.ruleItemDatapoint();
        this.state = 1477;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while(_la===VtlParser.EOL) {
            this.state = 1473;
            this.match(VtlParser.EOL);
            this.state = 1474;
            this.ruleItemDatapoint();
            this.state = 1479;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


function RuleItemDatapointContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = VtlParser.RULE_ruleItemDatapoint;
    this.ruleName = null; // Token
    this.antecedentContiditon = null; // ExprComponentContext
    this.consequentCondition = null; // ExprComponentContext
    return this;
}

RuleItemDatapointContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
RuleItemDatapointContext.prototype.constructor = RuleItemDatapointContext;

RuleItemDatapointContext.prototype.exprComponent = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(ExprComponentContext);
    } else {
        return this.getTypedRuleContext(ExprComponentContext,i);
    }
};

RuleItemDatapointContext.prototype.COLON = function() {
    return this.getToken(VtlParser.COLON, 0);
};

RuleItemDatapointContext.prototype.WHEN = function() {
    return this.getToken(VtlParser.WHEN, 0);
};

RuleItemDatapointContext.prototype.THEN = function() {
    return this.getToken(VtlParser.THEN, 0);
};

RuleItemDatapointContext.prototype.erCode = function() {
    return this.getTypedRuleContext(ErCodeContext,0);
};

RuleItemDatapointContext.prototype.erLevel = function() {
    return this.getTypedRuleContext(ErLevelContext,0);
};

RuleItemDatapointContext.prototype.IDENTIFIER = function() {
    return this.getToken(VtlParser.IDENTIFIER, 0);
};




VtlParser.RuleItemDatapointContext = RuleItemDatapointContext;

VtlParser.prototype.ruleItemDatapoint = function() {

    var localctx = new RuleItemDatapointContext(this, this._ctx, this.state);
    this.enterRule(localctx, 142, VtlParser.RULE_ruleItemDatapoint);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1482;
        this._errHandler.sync(this);
        var la_ = this._interp.adaptivePredict(this._input,161,this._ctx);
        if(la_===1) {
            this.state = 1480;
            localctx.ruleName = this.match(VtlParser.IDENTIFIER);
            this.state = 1481;
            this.match(VtlParser.COLON);

        }
        this.state = 1488;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if(_la===VtlParser.WHEN) {
            this.state = 1484;
            this.match(VtlParser.WHEN);
            this.state = 1485;
            localctx.antecedentContiditon = this.exprComponent(0);
            this.state = 1486;
            this.match(VtlParser.THEN);
        }

        this.state = 1490;
        localctx.consequentCondition = this.exprComponent(0);
        this.state = 1492;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if(_la===VtlParser.ERRORCODE) {
            this.state = 1491;
            this.erCode();
        }

        this.state = 1495;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if(_la===VtlParser.ERRORLEVEL) {
            this.state = 1494;
            this.erLevel();
        }

    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


function RuleClauseHierarchicalContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = VtlParser.RULE_ruleClauseHierarchical;
    return this;
}

RuleClauseHierarchicalContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
RuleClauseHierarchicalContext.prototype.constructor = RuleClauseHierarchicalContext;

RuleClauseHierarchicalContext.prototype.ruleItemHierarchical = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(RuleItemHierarchicalContext);
    } else {
        return this.getTypedRuleContext(RuleItemHierarchicalContext,i);
    }
};

RuleClauseHierarchicalContext.prototype.EOL = function(i) {
	if(i===undefined) {
		i = null;
	}
    if(i===null) {
        return this.getTokens(VtlParser.EOL);
    } else {
        return this.getToken(VtlParser.EOL, i);
    }
};





VtlParser.RuleClauseHierarchicalContext = RuleClauseHierarchicalContext;

VtlParser.prototype.ruleClauseHierarchical = function() {

    var localctx = new RuleClauseHierarchicalContext(this, this._ctx, this.state);
    this.enterRule(localctx, 144, VtlParser.RULE_ruleClauseHierarchical);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1497;
        this.ruleItemHierarchical();
        this.state = 1502;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while(_la===VtlParser.EOL) {
            this.state = 1498;
            this.match(VtlParser.EOL);
            this.state = 1499;
            this.ruleItemHierarchical();
            this.state = 1504;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


function RuleItemHierarchicalContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = VtlParser.RULE_ruleItemHierarchical;
    this.ruleName = null; // Token
    return this;
}

RuleItemHierarchicalContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
RuleItemHierarchicalContext.prototype.constructor = RuleItemHierarchicalContext;

RuleItemHierarchicalContext.prototype.codeItemRelation = function() {
    return this.getTypedRuleContext(CodeItemRelationContext,0);
};

RuleItemHierarchicalContext.prototype.COLON = function() {
    return this.getToken(VtlParser.COLON, 0);
};

RuleItemHierarchicalContext.prototype.erCode = function() {
    return this.getTypedRuleContext(ErCodeContext,0);
};

RuleItemHierarchicalContext.prototype.erLevel = function() {
    return this.getTypedRuleContext(ErLevelContext,0);
};

RuleItemHierarchicalContext.prototype.IDENTIFIER = function() {
    return this.getToken(VtlParser.IDENTIFIER, 0);
};




VtlParser.RuleItemHierarchicalContext = RuleItemHierarchicalContext;

VtlParser.prototype.ruleItemHierarchical = function() {

    var localctx = new RuleItemHierarchicalContext(this, this._ctx, this.state);
    this.enterRule(localctx, 146, VtlParser.RULE_ruleItemHierarchical);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1507;
        this._errHandler.sync(this);
        var la_ = this._interp.adaptivePredict(this._input,166,this._ctx);
        if(la_===1) {
            this.state = 1505;
            localctx.ruleName = this.match(VtlParser.IDENTIFIER);
            this.state = 1506;
            this.match(VtlParser.COLON);

        }
        this.state = 1509;
        this.codeItemRelation();
        this.state = 1511;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if(_la===VtlParser.ERRORCODE) {
            this.state = 1510;
            this.erCode();
        }

        this.state = 1514;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if(_la===VtlParser.ERRORLEVEL) {
            this.state = 1513;
            this.erLevel();
        }

    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


function HierRuleSignatureContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = VtlParser.RULE_hierRuleSignature;
    return this;
}

HierRuleSignatureContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
HierRuleSignatureContext.prototype.constructor = HierRuleSignatureContext;

HierRuleSignatureContext.prototype.RULE = function() {
    return this.getToken(VtlParser.RULE, 0);
};

HierRuleSignatureContext.prototype.IDENTIFIER = function() {
    return this.getToken(VtlParser.IDENTIFIER, 0);
};

HierRuleSignatureContext.prototype.VALUE_DOMAIN = function() {
    return this.getToken(VtlParser.VALUE_DOMAIN, 0);
};

HierRuleSignatureContext.prototype.VARIABLE = function() {
    return this.getToken(VtlParser.VARIABLE, 0);
};

HierRuleSignatureContext.prototype.CONDITION = function() {
    return this.getToken(VtlParser.CONDITION, 0);
};

HierRuleSignatureContext.prototype.valueDomainSignature = function() {
    return this.getTypedRuleContext(ValueDomainSignatureContext,0);
};




VtlParser.HierRuleSignatureContext = HierRuleSignatureContext;

VtlParser.prototype.hierRuleSignature = function() {

    var localctx = new HierRuleSignatureContext(this, this._ctx, this.state);
    this.enterRule(localctx, 148, VtlParser.RULE_hierRuleSignature);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1516;
        _la = this._input.LA(1);
        if(!(_la===VtlParser.VALUE_DOMAIN || _la===VtlParser.VARIABLE)) {
        this._errHandler.recoverInline(this);
        }
        else {
        	this._errHandler.reportMatch(this);
            this.consume();
        }
        this.state = 1519;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if(_la===VtlParser.CONDITION) {
            this.state = 1517;
            this.match(VtlParser.CONDITION);
            this.state = 1518;
            this.valueDomainSignature();
        }

        this.state = 1521;
        this.match(VtlParser.RULE);
        this.state = 1522;
        this.match(VtlParser.IDENTIFIER);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


function ValueDomainSignatureContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = VtlParser.RULE_valueDomainSignature;
    return this;
}

ValueDomainSignatureContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ValueDomainSignatureContext.prototype.constructor = ValueDomainSignatureContext;

ValueDomainSignatureContext.prototype.signature = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(SignatureContext);
    } else {
        return this.getTypedRuleContext(SignatureContext,i);
    }
};

ValueDomainSignatureContext.prototype.COMMA = function(i) {
	if(i===undefined) {
		i = null;
	}
    if(i===null) {
        return this.getTokens(VtlParser.COMMA);
    } else {
        return this.getToken(VtlParser.COMMA, i);
    }
};





VtlParser.ValueDomainSignatureContext = ValueDomainSignatureContext;

VtlParser.prototype.valueDomainSignature = function() {

    var localctx = new ValueDomainSignatureContext(this, this._ctx, this.state);
    this.enterRule(localctx, 150, VtlParser.RULE_valueDomainSignature);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1524;
        this.signature();
        this.state = 1529;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while(_la===VtlParser.COMMA) {
            this.state = 1525;
            this.match(VtlParser.COMMA);
            this.state = 1526;
            this.signature();
            this.state = 1531;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


function CodeItemRelationContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = VtlParser.RULE_codeItemRelation;
    this.codetemRef = null; // ValueDomainValueContext
    return this;
}

CodeItemRelationContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
CodeItemRelationContext.prototype.constructor = CodeItemRelationContext;

CodeItemRelationContext.prototype.codeItemRelationClause = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(CodeItemRelationClauseContext);
    } else {
        return this.getTypedRuleContext(CodeItemRelationClauseContext,i);
    }
};

CodeItemRelationContext.prototype.valueDomainValue = function() {
    return this.getTypedRuleContext(ValueDomainValueContext,0);
};

CodeItemRelationContext.prototype.WHEN = function() {
    return this.getToken(VtlParser.WHEN, 0);
};

CodeItemRelationContext.prototype.exprComponent = function() {
    return this.getTypedRuleContext(ExprComponentContext,0);
};

CodeItemRelationContext.prototype.THEN = function() {
    return this.getToken(VtlParser.THEN, 0);
};

CodeItemRelationContext.prototype.comparisonOperand = function() {
    return this.getTypedRuleContext(ComparisonOperandContext,0);
};




VtlParser.CodeItemRelationContext = CodeItemRelationContext;

VtlParser.prototype.codeItemRelation = function() {

    var localctx = new CodeItemRelationContext(this, this._ctx, this.state);
    this.enterRule(localctx, 152, VtlParser.RULE_codeItemRelation);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1536;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if(_la===VtlParser.WHEN) {
            this.state = 1532;
            this.match(VtlParser.WHEN);
            this.state = 1533;
            this.exprComponent(0);
            this.state = 1534;
            this.match(VtlParser.THEN);
        }

        this.state = 1538;
        localctx.codetemRef = this.valueDomainValue();
        this.state = 1540;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << VtlParser.EQ) | (1 << VtlParser.LT) | (1 << VtlParser.MT) | (1 << VtlParser.ME) | (1 << VtlParser.NEQ) | (1 << VtlParser.LE))) !== 0)) {
            this.state = 1539;
            this.comparisonOperand();
        }

        this.state = 1542;
        this.codeItemRelationClause();
        this.state = 1546;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while(_la===VtlParser.PLUS || _la===VtlParser.MINUS || ((((_la - 229)) & ~0x1f) == 0 && ((1 << (_la - 229)) & ((1 << (VtlParser.INTEGER_CONSTANT - 229)) | (1 << (VtlParser.NUMBER_CONSTANT - 229)) | (1 << (VtlParser.IDENTIFIER - 229)))) !== 0)) {
            this.state = 1543;
            this.codeItemRelationClause();
            this.state = 1548;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


function CodeItemRelationClauseContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = VtlParser.RULE_codeItemRelationClause;
    this.opAdd = null; // Token
    this.rightCodeItem = null; // ValueDomainValueContext
    this.rightCondition = null; // ExprComponentContext
    return this;
}

CodeItemRelationClauseContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
CodeItemRelationClauseContext.prototype.constructor = CodeItemRelationClauseContext;

CodeItemRelationClauseContext.prototype.valueDomainValue = function() {
    return this.getTypedRuleContext(ValueDomainValueContext,0);
};

CodeItemRelationClauseContext.prototype.QLPAREN = function() {
    return this.getToken(VtlParser.QLPAREN, 0);
};

CodeItemRelationClauseContext.prototype.QRPAREN = function() {
    return this.getToken(VtlParser.QRPAREN, 0);
};

CodeItemRelationClauseContext.prototype.exprComponent = function() {
    return this.getTypedRuleContext(ExprComponentContext,0);
};

CodeItemRelationClauseContext.prototype.PLUS = function() {
    return this.getToken(VtlParser.PLUS, 0);
};

CodeItemRelationClauseContext.prototype.MINUS = function() {
    return this.getToken(VtlParser.MINUS, 0);
};




VtlParser.CodeItemRelationClauseContext = CodeItemRelationClauseContext;

VtlParser.prototype.codeItemRelationClause = function() {

    var localctx = new CodeItemRelationClauseContext(this, this._ctx, this.state);
    this.enterRule(localctx, 154, VtlParser.RULE_codeItemRelationClause);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1550;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if(_la===VtlParser.PLUS || _la===VtlParser.MINUS) {
            this.state = 1549;
            localctx.opAdd = this._input.LT(1);
            _la = this._input.LA(1);
            if(!(_la===VtlParser.PLUS || _la===VtlParser.MINUS)) {
                localctx.opAdd = this._errHandler.recoverInline(this);
            }
            else {
            	this._errHandler.reportMatch(this);
                this.consume();
            }
        }

        this.state = 1552;
        localctx.rightCodeItem = this.valueDomainValue();
        this.state = 1557;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if(_la===VtlParser.QLPAREN) {
            this.state = 1553;
            this.match(VtlParser.QLPAREN);
            this.state = 1554;
            localctx.rightCondition = this.exprComponent(0);
            this.state = 1555;
            this.match(VtlParser.QRPAREN);
        }

    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


function ValueDomainValueContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = VtlParser.RULE_valueDomainValue;
    return this;
}

ValueDomainValueContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ValueDomainValueContext.prototype.constructor = ValueDomainValueContext;

ValueDomainValueContext.prototype.IDENTIFIER = function() {
    return this.getToken(VtlParser.IDENTIFIER, 0);
};

ValueDomainValueContext.prototype.INTEGER_CONSTANT = function() {
    return this.getToken(VtlParser.INTEGER_CONSTANT, 0);
};

ValueDomainValueContext.prototype.NUMBER_CONSTANT = function() {
    return this.getToken(VtlParser.NUMBER_CONSTANT, 0);
};




VtlParser.ValueDomainValueContext = ValueDomainValueContext;

VtlParser.prototype.valueDomainValue = function() {

    var localctx = new ValueDomainValueContext(this, this._ctx, this.state);
    this.enterRule(localctx, 156, VtlParser.RULE_valueDomainValue);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1559;
        _la = this._input.LA(1);
        if(!(((((_la - 229)) & ~0x1f) == 0 && ((1 << (_la - 229)) & ((1 << (VtlParser.INTEGER_CONSTANT - 229)) | (1 << (VtlParser.NUMBER_CONSTANT - 229)) | (1 << (VtlParser.IDENTIFIER - 229)))) !== 0))) {
        this._errHandler.recoverInline(this);
        }
        else {
        	this._errHandler.reportMatch(this);
            this.consume();
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


function ScalarTypeConstraintContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = VtlParser.RULE_scalarTypeConstraint;
    return this;
}

ScalarTypeConstraintContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ScalarTypeConstraintContext.prototype.constructor = ScalarTypeConstraintContext;


 
ScalarTypeConstraintContext.prototype.copyFrom = function(ctx) {
    antlr4.ParserRuleContext.prototype.copyFrom.call(this, ctx);
};


function RangeConstraintContext(parser, ctx) {
	ScalarTypeConstraintContext.call(this, parser);
    ScalarTypeConstraintContext.prototype.copyFrom.call(this, ctx);
    return this;
}

RangeConstraintContext.prototype = Object.create(ScalarTypeConstraintContext.prototype);
RangeConstraintContext.prototype.constructor = RangeConstraintContext;

VtlParser.RangeConstraintContext = RangeConstraintContext;

RangeConstraintContext.prototype.GLPAREN = function() {
    return this.getToken(VtlParser.GLPAREN, 0);
};

RangeConstraintContext.prototype.constant = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(ConstantContext);
    } else {
        return this.getTypedRuleContext(ConstantContext,i);
    }
};

RangeConstraintContext.prototype.GRPAREN = function() {
    return this.getToken(VtlParser.GRPAREN, 0);
};

RangeConstraintContext.prototype.COMMA = function(i) {
	if(i===undefined) {
		i = null;
	}
    if(i===null) {
        return this.getTokens(VtlParser.COMMA);
    } else {
        return this.getToken(VtlParser.COMMA, i);
    }
};


function ConditionConstraintContext(parser, ctx) {
	ScalarTypeConstraintContext.call(this, parser);
    ScalarTypeConstraintContext.prototype.copyFrom.call(this, ctx);
    return this;
}

ConditionConstraintContext.prototype = Object.create(ScalarTypeConstraintContext.prototype);
ConditionConstraintContext.prototype.constructor = ConditionConstraintContext;

VtlParser.ConditionConstraintContext = ConditionConstraintContext;

ConditionConstraintContext.prototype.QLPAREN = function() {
    return this.getToken(VtlParser.QLPAREN, 0);
};

ConditionConstraintContext.prototype.exprComponent = function() {
    return this.getTypedRuleContext(ExprComponentContext,0);
};

ConditionConstraintContext.prototype.QRPAREN = function() {
    return this.getToken(VtlParser.QRPAREN, 0);
};


VtlParser.ScalarTypeConstraintContext = ScalarTypeConstraintContext;

VtlParser.prototype.scalarTypeConstraint = function() {

    var localctx = new ScalarTypeConstraintContext(this, this._ctx, this.state);
    this.enterRule(localctx, 158, VtlParser.RULE_scalarTypeConstraint);
    var _la = 0; // Token type
    try {
        this.state = 1576;
        this._errHandler.sync(this);
        switch(this._input.LA(1)) {
        case VtlParser.QLPAREN:
            localctx = new ConditionConstraintContext(this, localctx);
            this.enterOuterAlt(localctx, 1);
            this.state = 1561;
            this.match(VtlParser.QLPAREN);
            this.state = 1562;
            this.exprComponent(0);
            this.state = 1563;
            this.match(VtlParser.QRPAREN);
            break;
        case VtlParser.GLPAREN:
            localctx = new RangeConstraintContext(this, localctx);
            this.enterOuterAlt(localctx, 2);
            this.state = 1565;
            this.match(VtlParser.GLPAREN);
            this.state = 1566;
            this.constant();
            this.state = 1571;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            while(_la===VtlParser.COMMA) {
                this.state = 1567;
                this.match(VtlParser.COMMA);
                this.state = 1568;
                this.constant();
                this.state = 1573;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
            }
            this.state = 1574;
            this.match(VtlParser.GRPAREN);
            break;
        default:
            throw new antlr4.error.NoViableAltException(this);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


function CompConstraintContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = VtlParser.RULE_compConstraint;
    return this;
}

CompConstraintContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
CompConstraintContext.prototype.constructor = CompConstraintContext;

CompConstraintContext.prototype.componentType = function() {
    return this.getTypedRuleContext(ComponentTypeContext,0);
};

CompConstraintContext.prototype.componentID = function() {
    return this.getTypedRuleContext(ComponentIDContext,0);
};

CompConstraintContext.prototype.multModifier = function() {
    return this.getTypedRuleContext(MultModifierContext,0);
};




VtlParser.CompConstraintContext = CompConstraintContext;

VtlParser.prototype.compConstraint = function() {

    var localctx = new CompConstraintContext(this, this._ctx, this.state);
    this.enterRule(localctx, 160, VtlParser.RULE_compConstraint);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1578;
        this.componentType();
        this.state = 1581;
        this._errHandler.sync(this);
        switch(this._input.LA(1)) {
        case VtlParser.IDENTIFIER:
            this.state = 1579;
            this.componentID();
            break;
        case VtlParser.OPTIONAL:
            this.state = 1580;
            this.multModifier();
            break;
        default:
            throw new antlr4.error.NoViableAltException(this);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


function MultModifierContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = VtlParser.RULE_multModifier;
    return this;
}

MultModifierContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
MultModifierContext.prototype.constructor = MultModifierContext;

MultModifierContext.prototype.OPTIONAL = function() {
    return this.getToken(VtlParser.OPTIONAL, 0);
};

MultModifierContext.prototype.PLUS = function() {
    return this.getToken(VtlParser.PLUS, 0);
};

MultModifierContext.prototype.MUL = function() {
    return this.getToken(VtlParser.MUL, 0);
};




VtlParser.MultModifierContext = MultModifierContext;

VtlParser.prototype.multModifier = function() {

    var localctx = new MultModifierContext(this, this._ctx, this.state);
    this.enterRule(localctx, 162, VtlParser.RULE_multModifier);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1583;
        this.match(VtlParser.OPTIONAL);
        this.state = 1585;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if(_la===VtlParser.PLUS || _la===VtlParser.MUL) {
            this.state = 1584;
            _la = this._input.LA(1);
            if(!(_la===VtlParser.PLUS || _la===VtlParser.MUL)) {
            this._errHandler.recoverInline(this);
            }
            else {
            	this._errHandler.reportMatch(this);
                this.consume();
            }
        }

    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


function ValidationOutputContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = VtlParser.RULE_validationOutput;
    return this;
}

ValidationOutputContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ValidationOutputContext.prototype.constructor = ValidationOutputContext;

ValidationOutputContext.prototype.INVALID = function() {
    return this.getToken(VtlParser.INVALID, 0);
};

ValidationOutputContext.prototype.ALL_MEASURES = function() {
    return this.getToken(VtlParser.ALL_MEASURES, 0);
};

ValidationOutputContext.prototype.ALL = function() {
    return this.getToken(VtlParser.ALL, 0);
};




VtlParser.ValidationOutputContext = ValidationOutputContext;

VtlParser.prototype.validationOutput = function() {

    var localctx = new ValidationOutputContext(this, this._ctx, this.state);
    this.enterRule(localctx, 164, VtlParser.RULE_validationOutput);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1587;
        _la = this._input.LA(1);
        if(!(_la===VtlParser.ALL || _la===VtlParser.INVALID || _la===VtlParser.ALL_MEASURES)) {
        this._errHandler.recoverInline(this);
        }
        else {
        	this._errHandler.reportMatch(this);
            this.consume();
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


function ValidationModeContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = VtlParser.RULE_validationMode;
    return this;
}

ValidationModeContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ValidationModeContext.prototype.constructor = ValidationModeContext;

ValidationModeContext.prototype.NON_NULL = function() {
    return this.getToken(VtlParser.NON_NULL, 0);
};

ValidationModeContext.prototype.NON_ZERO = function() {
    return this.getToken(VtlParser.NON_ZERO, 0);
};

ValidationModeContext.prototype.PARTIAL_NULL = function() {
    return this.getToken(VtlParser.PARTIAL_NULL, 0);
};

ValidationModeContext.prototype.PARTIAL_ZERO = function() {
    return this.getToken(VtlParser.PARTIAL_ZERO, 0);
};

ValidationModeContext.prototype.ALWAYS_NULL = function() {
    return this.getToken(VtlParser.ALWAYS_NULL, 0);
};

ValidationModeContext.prototype.ALWAYS_ZERO = function() {
    return this.getToken(VtlParser.ALWAYS_ZERO, 0);
};




VtlParser.ValidationModeContext = ValidationModeContext;

VtlParser.prototype.validationMode = function() {

    var localctx = new ValidationModeContext(this, this._ctx, this.state);
    this.enterRule(localctx, 166, VtlParser.RULE_validationMode);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1589;
        _la = this._input.LA(1);
        if(!(((((_la - 213)) & ~0x1f) == 0 && ((1 << (_la - 213)) & ((1 << (VtlParser.NON_NULL - 213)) | (1 << (VtlParser.NON_ZERO - 213)) | (1 << (VtlParser.PARTIAL_NULL - 213)) | (1 << (VtlParser.PARTIAL_ZERO - 213)) | (1 << (VtlParser.ALWAYS_NULL - 213)) | (1 << (VtlParser.ALWAYS_ZERO - 213)))) !== 0))) {
        this._errHandler.recoverInline(this);
        }
        else {
        	this._errHandler.reportMatch(this);
            this.consume();
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


function ConditionClauseContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = VtlParser.RULE_conditionClause;
    return this;
}

ConditionClauseContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ConditionClauseContext.prototype.constructor = ConditionClauseContext;

ConditionClauseContext.prototype.CONDITION = function() {
    return this.getToken(VtlParser.CONDITION, 0);
};

ConditionClauseContext.prototype.componentID = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(ComponentIDContext);
    } else {
        return this.getTypedRuleContext(ComponentIDContext,i);
    }
};

ConditionClauseContext.prototype.COMMA = function(i) {
	if(i===undefined) {
		i = null;
	}
    if(i===null) {
        return this.getTokens(VtlParser.COMMA);
    } else {
        return this.getToken(VtlParser.COMMA, i);
    }
};





VtlParser.ConditionClauseContext = ConditionClauseContext;

VtlParser.prototype.conditionClause = function() {

    var localctx = new ConditionClauseContext(this, this._ctx, this.state);
    this.enterRule(localctx, 168, VtlParser.RULE_conditionClause);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1591;
        this.match(VtlParser.CONDITION);
        this.state = 1592;
        this.componentID();
        this.state = 1597;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while(_la===VtlParser.COMMA) {
            this.state = 1593;
            this.match(VtlParser.COMMA);
            this.state = 1594;
            this.componentID();
            this.state = 1599;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


function InputModeContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = VtlParser.RULE_inputMode;
    return this;
}

InputModeContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
InputModeContext.prototype.constructor = InputModeContext;

InputModeContext.prototype.DATASET = function() {
    return this.getToken(VtlParser.DATASET, 0);
};

InputModeContext.prototype.DATASET_PRIORITY = function() {
    return this.getToken(VtlParser.DATASET_PRIORITY, 0);
};




VtlParser.InputModeContext = InputModeContext;

VtlParser.prototype.inputMode = function() {

    var localctx = new InputModeContext(this, this._ctx, this.state);
    this.enterRule(localctx, 170, VtlParser.RULE_inputMode);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1600;
        _la = this._input.LA(1);
        if(!(_la===VtlParser.DATASET || _la===VtlParser.DATASET_PRIORITY)) {
        this._errHandler.recoverInline(this);
        }
        else {
        	this._errHandler.reportMatch(this);
            this.consume();
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


function ImbalanceExprContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = VtlParser.RULE_imbalanceExpr;
    return this;
}

ImbalanceExprContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ImbalanceExprContext.prototype.constructor = ImbalanceExprContext;

ImbalanceExprContext.prototype.IMBALANCE = function() {
    return this.getToken(VtlParser.IMBALANCE, 0);
};

ImbalanceExprContext.prototype.expr = function() {
    return this.getTypedRuleContext(ExprContext,0);
};




VtlParser.ImbalanceExprContext = ImbalanceExprContext;

VtlParser.prototype.imbalanceExpr = function() {

    var localctx = new ImbalanceExprContext(this, this._ctx, this.state);
    this.enterRule(localctx, 172, VtlParser.RULE_imbalanceExpr);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1602;
        this.match(VtlParser.IMBALANCE);
        this.state = 1603;
        this.expr(0);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


function InputModeHierarchyContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = VtlParser.RULE_inputModeHierarchy;
    return this;
}

InputModeHierarchyContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
InputModeHierarchyContext.prototype.constructor = InputModeHierarchyContext;

InputModeHierarchyContext.prototype.RULE = function() {
    return this.getToken(VtlParser.RULE, 0);
};

InputModeHierarchyContext.prototype.DATASET = function() {
    return this.getToken(VtlParser.DATASET, 0);
};

InputModeHierarchyContext.prototype.RULE_PRIORITY = function() {
    return this.getToken(VtlParser.RULE_PRIORITY, 0);
};




VtlParser.InputModeHierarchyContext = InputModeHierarchyContext;

VtlParser.prototype.inputModeHierarchy = function() {

    var localctx = new InputModeHierarchyContext(this, this._ctx, this.state);
    this.enterRule(localctx, 174, VtlParser.RULE_inputModeHierarchy);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1605;
        _la = this._input.LA(1);
        if(!(_la===VtlParser.DATASET || _la===VtlParser.RULE || _la===VtlParser.RULE_PRIORITY)) {
        this._errHandler.recoverInline(this);
        }
        else {
        	this._errHandler.reportMatch(this);
            this.consume();
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


function OutputModeHierarchyContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = VtlParser.RULE_outputModeHierarchy;
    return this;
}

OutputModeHierarchyContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
OutputModeHierarchyContext.prototype.constructor = OutputModeHierarchyContext;

OutputModeHierarchyContext.prototype.COMPUTED = function() {
    return this.getToken(VtlParser.COMPUTED, 0);
};

OutputModeHierarchyContext.prototype.ALL = function() {
    return this.getToken(VtlParser.ALL, 0);
};




VtlParser.OutputModeHierarchyContext = OutputModeHierarchyContext;

VtlParser.prototype.outputModeHierarchy = function() {

    var localctx = new OutputModeHierarchyContext(this, this._ctx, this.state);
    this.enterRule(localctx, 176, VtlParser.RULE_outputModeHierarchy);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1607;
        _la = this._input.LA(1);
        if(!(_la===VtlParser.ALL || _la===VtlParser.COMPUTED)) {
        this._errHandler.recoverInline(this);
        }
        else {
        	this._errHandler.reportMatch(this);
            this.consume();
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


function AliasContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = VtlParser.RULE_alias;
    return this;
}

AliasContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
AliasContext.prototype.constructor = AliasContext;

AliasContext.prototype.IDENTIFIER = function() {
    return this.getToken(VtlParser.IDENTIFIER, 0);
};




VtlParser.AliasContext = AliasContext;

VtlParser.prototype.alias = function() {

    var localctx = new AliasContext(this, this._ctx, this.state);
    this.enterRule(localctx, 178, VtlParser.RULE_alias);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1609;
        this.match(VtlParser.IDENTIFIER);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


function VarIDContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = VtlParser.RULE_varID;
    return this;
}

VarIDContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
VarIDContext.prototype.constructor = VarIDContext;

VarIDContext.prototype.IDENTIFIER = function() {
    return this.getToken(VtlParser.IDENTIFIER, 0);
};




VtlParser.VarIDContext = VarIDContext;

VtlParser.prototype.varID = function() {

    var localctx = new VarIDContext(this, this._ctx, this.state);
    this.enterRule(localctx, 180, VtlParser.RULE_varID);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1611;
        this.match(VtlParser.IDENTIFIER);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


function SimpleComponentIdContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = VtlParser.RULE_simpleComponentId;
    return this;
}

SimpleComponentIdContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
SimpleComponentIdContext.prototype.constructor = SimpleComponentIdContext;

SimpleComponentIdContext.prototype.IDENTIFIER = function() {
    return this.getToken(VtlParser.IDENTIFIER, 0);
};




VtlParser.SimpleComponentIdContext = SimpleComponentIdContext;

VtlParser.prototype.simpleComponentId = function() {

    var localctx = new SimpleComponentIdContext(this, this._ctx, this.state);
    this.enterRule(localctx, 182, VtlParser.RULE_simpleComponentId);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1613;
        this.match(VtlParser.IDENTIFIER);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


function ComponentIDContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = VtlParser.RULE_componentID;
    return this;
}

ComponentIDContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ComponentIDContext.prototype.constructor = ComponentIDContext;

ComponentIDContext.prototype.IDENTIFIER = function(i) {
	if(i===undefined) {
		i = null;
	}
    if(i===null) {
        return this.getTokens(VtlParser.IDENTIFIER);
    } else {
        return this.getToken(VtlParser.IDENTIFIER, i);
    }
};


ComponentIDContext.prototype.MEMBERSHIP = function() {
    return this.getToken(VtlParser.MEMBERSHIP, 0);
};




VtlParser.ComponentIDContext = ComponentIDContext;

VtlParser.prototype.componentID = function() {

    var localctx = new ComponentIDContext(this, this._ctx, this.state);
    this.enterRule(localctx, 184, VtlParser.RULE_componentID);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1615;
        this.match(VtlParser.IDENTIFIER);
        this.state = 1618;
        this._errHandler.sync(this);
        var la_ = this._interp.adaptivePredict(this._input,181,this._ctx);
        if(la_===1) {
            this.state = 1616;
            this.match(VtlParser.MEMBERSHIP);
            this.state = 1617;
            this.match(VtlParser.IDENTIFIER);

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


function InexprContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = VtlParser.RULE_inexpr;
    return this;
}

InexprContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
InexprContext.prototype.constructor = InexprContext;


 
InexprContext.prototype.copyFrom = function(ctx) {
    antlr4.ParserRuleContext.prototype.copyFrom.call(this, ctx);
};


function SetExprContext(parser, ctx) {
	InexprContext.call(this, parser);
    InexprContext.prototype.copyFrom.call(this, ctx);
    return this;
}

SetExprContext.prototype = Object.create(InexprContext.prototype);
SetExprContext.prototype.constructor = SetExprContext;

VtlParser.SetExprContext = SetExprContext;

SetExprContext.prototype.GLPAREN = function() {
    return this.getToken(VtlParser.GLPAREN, 0);
};

SetExprContext.prototype.constant = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(ConstantContext);
    } else {
        return this.getTypedRuleContext(ConstantContext,i);
    }
};

SetExprContext.prototype.GRPAREN = function() {
    return this.getToken(VtlParser.GRPAREN, 0);
};

SetExprContext.prototype.COMMA = function(i) {
	if(i===undefined) {
		i = null;
	}
    if(i===null) {
        return this.getTokens(VtlParser.COMMA);
    } else {
        return this.getToken(VtlParser.COMMA, i);
    }
};


function ValueDomainExprContext(parser, ctx) {
	InexprContext.call(this, parser);
    InexprContext.prototype.copyFrom.call(this, ctx);
    return this;
}

ValueDomainExprContext.prototype = Object.create(InexprContext.prototype);
ValueDomainExprContext.prototype.constructor = ValueDomainExprContext;

VtlParser.ValueDomainExprContext = ValueDomainExprContext;

ValueDomainExprContext.prototype.valueDomainID = function() {
    return this.getTypedRuleContext(ValueDomainIDContext,0);
};


VtlParser.InexprContext = InexprContext;

VtlParser.prototype.inexpr = function() {

    var localctx = new InexprContext(this, this._ctx, this.state);
    this.enterRule(localctx, 186, VtlParser.RULE_inexpr);
    var _la = 0; // Token type
    try {
        this.state = 1632;
        this._errHandler.sync(this);
        switch(this._input.LA(1)) {
        case VtlParser.GLPAREN:
            localctx = new SetExprContext(this, localctx);
            this.enterOuterAlt(localctx, 1);
            this.state = 1620;
            this.match(VtlParser.GLPAREN);
            this.state = 1621;
            this.constant();
            this.state = 1626;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            while(_la===VtlParser.COMMA) {
                this.state = 1622;
                this.match(VtlParser.COMMA);
                this.state = 1623;
                this.constant();
                this.state = 1628;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
            }
            this.state = 1629;
            this.match(VtlParser.GRPAREN);
            break;
        case VtlParser.IDENTIFIER:
            localctx = new ValueDomainExprContext(this, localctx);
            this.enterOuterAlt(localctx, 2);
            this.state = 1631;
            this.valueDomainID();
            break;
        default:
            throw new antlr4.error.NoViableAltException(this);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


function ErCodeContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = VtlParser.RULE_erCode;
    return this;
}

ErCodeContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ErCodeContext.prototype.constructor = ErCodeContext;

ErCodeContext.prototype.ERRORCODE = function() {
    return this.getToken(VtlParser.ERRORCODE, 0);
};

ErCodeContext.prototype.constant = function() {
    return this.getTypedRuleContext(ConstantContext,0);
};




VtlParser.ErCodeContext = ErCodeContext;

VtlParser.prototype.erCode = function() {

    var localctx = new ErCodeContext(this, this._ctx, this.state);
    this.enterRule(localctx, 188, VtlParser.RULE_erCode);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1634;
        this.match(VtlParser.ERRORCODE);
        this.state = 1635;
        this.constant();
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


function ErLevelContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = VtlParser.RULE_erLevel;
    return this;
}

ErLevelContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ErLevelContext.prototype.constructor = ErLevelContext;

ErLevelContext.prototype.ERRORLEVEL = function() {
    return this.getToken(VtlParser.ERRORLEVEL, 0);
};

ErLevelContext.prototype.constant = function() {
    return this.getTypedRuleContext(ConstantContext,0);
};




VtlParser.ErLevelContext = ErLevelContext;

VtlParser.prototype.erLevel = function() {

    var localctx = new ErLevelContext(this, this._ctx, this.state);
    this.enterRule(localctx, 190, VtlParser.RULE_erLevel);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1637;
        this.match(VtlParser.ERRORLEVEL);
        this.state = 1638;
        this.constant();
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


function ComparisonOperandContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = VtlParser.RULE_comparisonOperand;
    return this;
}

ComparisonOperandContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ComparisonOperandContext.prototype.constructor = ComparisonOperandContext;

ComparisonOperandContext.prototype.MT = function() {
    return this.getToken(VtlParser.MT, 0);
};

ComparisonOperandContext.prototype.ME = function() {
    return this.getToken(VtlParser.ME, 0);
};

ComparisonOperandContext.prototype.LE = function() {
    return this.getToken(VtlParser.LE, 0);
};

ComparisonOperandContext.prototype.LT = function() {
    return this.getToken(VtlParser.LT, 0);
};

ComparisonOperandContext.prototype.EQ = function() {
    return this.getToken(VtlParser.EQ, 0);
};

ComparisonOperandContext.prototype.NEQ = function() {
    return this.getToken(VtlParser.NEQ, 0);
};




VtlParser.ComparisonOperandContext = ComparisonOperandContext;

VtlParser.prototype.comparisonOperand = function() {

    var localctx = new ComparisonOperandContext(this, this._ctx, this.state);
    this.enterRule(localctx, 192, VtlParser.RULE_comparisonOperand);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1640;
        _la = this._input.LA(1);
        if(!((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << VtlParser.EQ) | (1 << VtlParser.LT) | (1 << VtlParser.MT) | (1 << VtlParser.ME) | (1 << VtlParser.NEQ) | (1 << VtlParser.LE))) !== 0))) {
        this._errHandler.recoverInline(this);
        }
        else {
        	this._errHandler.reportMatch(this);
            this.consume();
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


function OptionalExprContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = VtlParser.RULE_optionalExpr;
    return this;
}

OptionalExprContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
OptionalExprContext.prototype.constructor = OptionalExprContext;

OptionalExprContext.prototype.expr = function() {
    return this.getTypedRuleContext(ExprContext,0);
};

OptionalExprContext.prototype.OPTIONAL = function() {
    return this.getToken(VtlParser.OPTIONAL, 0);
};




VtlParser.OptionalExprContext = OptionalExprContext;

VtlParser.prototype.optionalExpr = function() {

    var localctx = new OptionalExprContext(this, this._ctx, this.state);
    this.enterRule(localctx, 194, VtlParser.RULE_optionalExpr);
    try {
        this.state = 1644;
        this._errHandler.sync(this);
        switch(this._input.LA(1)) {
        case VtlParser.LPAREN:
        case VtlParser.PLUS:
        case VtlParser.MINUS:
        case VtlParser.EVAL:
        case VtlParser.IF:
        case VtlParser.CURRENT_DATE:
        case VtlParser.NOT:
        case VtlParser.BETWEEN:
        case VtlParser.NULL_CONSTANT:
        case VtlParser.ISNULL:
        case VtlParser.UNION:
        case VtlParser.SYMDIFF:
        case VtlParser.INTERSECT:
        case VtlParser.CHECK:
        case VtlParser.EXISTS_IN:
        case VtlParser.MIN:
        case VtlParser.MAX:
        case VtlParser.ABS:
        case VtlParser.LN:
        case VtlParser.LOG:
        case VtlParser.TRUNC:
        case VtlParser.ROUND:
        case VtlParser.POWER:
        case VtlParser.MOD:
        case VtlParser.LEN:
        case VtlParser.TRIM:
        case VtlParser.UCASE:
        case VtlParser.LCASE:
        case VtlParser.SUBSTR:
        case VtlParser.SUM:
        case VtlParser.AVG:
        case VtlParser.MEDIAN:
        case VtlParser.COUNT:
        case VtlParser.EXP:
        case VtlParser.CHARSET_MATCH:
        case VtlParser.NVL:
        case VtlParser.HIERARCHY:
        case VtlParser.LTRIM:
        case VtlParser.RTRIM:
        case VtlParser.INSTR:
        case VtlParser.REPLACE:
        case VtlParser.CEIL:
        case VtlParser.FLOOR:
        case VtlParser.SQRT:
        case VtlParser.SETDIFF:
        case VtlParser.STDDEV_POP:
        case VtlParser.STDDEV_SAMP:
        case VtlParser.VAR_POP:
        case VtlParser.VAR_SAMP:
        case VtlParser.FIRST_VALUE:
        case VtlParser.LAST_VALUE:
        case VtlParser.LAG:
        case VtlParser.LEAD:
        case VtlParser.RATIO_TO_REPORT:
        case VtlParser.FILL_TIME_SERIES:
        case VtlParser.FLOW_TO_STOCK:
        case VtlParser.STOCK_TO_FLOW:
        case VtlParser.TIMESHIFT:
        case VtlParser.INNER_JOIN:
        case VtlParser.LEFT_JOIN:
        case VtlParser.CROSS_JOIN:
        case VtlParser.FULL_JOIN:
        case VtlParser.PERIOD_INDICATOR:
        case VtlParser.TIME_AGG:
        case VtlParser.CAST:
        case VtlParser.CHECK_DATAPOINT:
        case VtlParser.CHECK_HIERARCHY:
        case VtlParser.INTEGER_CONSTANT:
        case VtlParser.NUMBER_CONSTANT:
        case VtlParser.BOOLEAN_CONSTANT:
        case VtlParser.STRING_CONSTANT:
        case VtlParser.IDENTIFIER:
            this.enterOuterAlt(localctx, 1);
            this.state = 1642;
            this.expr(0);
            break;
        case VtlParser.OPTIONAL:
            this.enterOuterAlt(localctx, 2);
            this.state = 1643;
            this.match(VtlParser.OPTIONAL);
            break;
        default:
            throw new antlr4.error.NoViableAltException(this);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


function OptionalExprComponentContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = VtlParser.RULE_optionalExprComponent;
    return this;
}

OptionalExprComponentContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
OptionalExprComponentContext.prototype.constructor = OptionalExprComponentContext;

OptionalExprComponentContext.prototype.exprComponent = function() {
    return this.getTypedRuleContext(ExprComponentContext,0);
};

OptionalExprComponentContext.prototype.OPTIONAL = function() {
    return this.getToken(VtlParser.OPTIONAL, 0);
};




VtlParser.OptionalExprComponentContext = OptionalExprComponentContext;

VtlParser.prototype.optionalExprComponent = function() {

    var localctx = new OptionalExprComponentContext(this, this._ctx, this.state);
    this.enterRule(localctx, 196, VtlParser.RULE_optionalExprComponent);
    try {
        this.state = 1648;
        this._errHandler.sync(this);
        switch(this._input.LA(1)) {
        case VtlParser.LPAREN:
        case VtlParser.PLUS:
        case VtlParser.MINUS:
        case VtlParser.EVAL:
        case VtlParser.IF:
        case VtlParser.CURRENT_DATE:
        case VtlParser.NOT:
        case VtlParser.BETWEEN:
        case VtlParser.NULL_CONSTANT:
        case VtlParser.ISNULL:
        case VtlParser.RANK:
        case VtlParser.MIN:
        case VtlParser.MAX:
        case VtlParser.ABS:
        case VtlParser.LN:
        case VtlParser.LOG:
        case VtlParser.TRUNC:
        case VtlParser.ROUND:
        case VtlParser.POWER:
        case VtlParser.MOD:
        case VtlParser.LEN:
        case VtlParser.TRIM:
        case VtlParser.UCASE:
        case VtlParser.LCASE:
        case VtlParser.SUBSTR:
        case VtlParser.SUM:
        case VtlParser.AVG:
        case VtlParser.MEDIAN:
        case VtlParser.COUNT:
        case VtlParser.EXP:
        case VtlParser.CHARSET_MATCH:
        case VtlParser.NVL:
        case VtlParser.LTRIM:
        case VtlParser.RTRIM:
        case VtlParser.INSTR:
        case VtlParser.REPLACE:
        case VtlParser.CEIL:
        case VtlParser.FLOOR:
        case VtlParser.SQRT:
        case VtlParser.STDDEV_POP:
        case VtlParser.STDDEV_SAMP:
        case VtlParser.VAR_POP:
        case VtlParser.VAR_SAMP:
        case VtlParser.FIRST_VALUE:
        case VtlParser.LAST_VALUE:
        case VtlParser.LAG:
        case VtlParser.LEAD:
        case VtlParser.RATIO_TO_REPORT:
        case VtlParser.FILL_TIME_SERIES:
        case VtlParser.FLOW_TO_STOCK:
        case VtlParser.STOCK_TO_FLOW:
        case VtlParser.TIMESHIFT:
        case VtlParser.PERIOD_INDICATOR:
        case VtlParser.TIME_AGG:
        case VtlParser.CAST:
        case VtlParser.INTEGER_CONSTANT:
        case VtlParser.NUMBER_CONSTANT:
        case VtlParser.BOOLEAN_CONSTANT:
        case VtlParser.STRING_CONSTANT:
        case VtlParser.IDENTIFIER:
            this.enterOuterAlt(localctx, 1);
            this.state = 1646;
            this.exprComponent(0);
            break;
        case VtlParser.OPTIONAL:
            this.enterOuterAlt(localctx, 2);
            this.state = 1647;
            this.match(VtlParser.OPTIONAL);
            break;
        default:
            throw new antlr4.error.NoViableAltException(this);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


function ComponentRoleContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = VtlParser.RULE_componentRole;
    return this;
}

ComponentRoleContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ComponentRoleContext.prototype.constructor = ComponentRoleContext;

ComponentRoleContext.prototype.MEASURE = function() {
    return this.getToken(VtlParser.MEASURE, 0);
};

ComponentRoleContext.prototype.COMPONENT = function() {
    return this.getToken(VtlParser.COMPONENT, 0);
};

ComponentRoleContext.prototype.DIMENSION = function() {
    return this.getToken(VtlParser.DIMENSION, 0);
};

ComponentRoleContext.prototype.ATTRIBUTE = function() {
    return this.getToken(VtlParser.ATTRIBUTE, 0);
};

ComponentRoleContext.prototype.viralAttribute = function() {
    return this.getTypedRuleContext(ViralAttributeContext,0);
};




VtlParser.ComponentRoleContext = ComponentRoleContext;

VtlParser.prototype.componentRole = function() {

    var localctx = new ComponentRoleContext(this, this._ctx, this.state);
    this.enterRule(localctx, 198, VtlParser.RULE_componentRole);
    try {
        this.state = 1655;
        this._errHandler.sync(this);
        switch(this._input.LA(1)) {
        case VtlParser.MEASURE:
            this.enterOuterAlt(localctx, 1);
            this.state = 1650;
            this.match(VtlParser.MEASURE);
            break;
        case VtlParser.COMPONENT:
            this.enterOuterAlt(localctx, 2);
            this.state = 1651;
            this.match(VtlParser.COMPONENT);
            break;
        case VtlParser.DIMENSION:
            this.enterOuterAlt(localctx, 3);
            this.state = 1652;
            this.match(VtlParser.DIMENSION);
            break;
        case VtlParser.ATTRIBUTE:
            this.enterOuterAlt(localctx, 4);
            this.state = 1653;
            this.match(VtlParser.ATTRIBUTE);
            break;
        case VtlParser.VIRAL:
            this.enterOuterAlt(localctx, 5);
            this.state = 1654;
            this.viralAttribute();
            break;
        default:
            throw new antlr4.error.NoViableAltException(this);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


function ViralAttributeContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = VtlParser.RULE_viralAttribute;
    return this;
}

ViralAttributeContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ViralAttributeContext.prototype.constructor = ViralAttributeContext;

ViralAttributeContext.prototype.VIRAL = function() {
    return this.getToken(VtlParser.VIRAL, 0);
};

ViralAttributeContext.prototype.ATTRIBUTE = function() {
    return this.getToken(VtlParser.ATTRIBUTE, 0);
};




VtlParser.ViralAttributeContext = ViralAttributeContext;

VtlParser.prototype.viralAttribute = function() {

    var localctx = new ViralAttributeContext(this, this._ctx, this.state);
    this.enterRule(localctx, 200, VtlParser.RULE_viralAttribute);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1657;
        this.match(VtlParser.VIRAL);
        this.state = 1658;
        this.match(VtlParser.ATTRIBUTE);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


function ValueDomainIDContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = VtlParser.RULE_valueDomainID;
    return this;
}

ValueDomainIDContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ValueDomainIDContext.prototype.constructor = ValueDomainIDContext;

ValueDomainIDContext.prototype.IDENTIFIER = function() {
    return this.getToken(VtlParser.IDENTIFIER, 0);
};




VtlParser.ValueDomainIDContext = ValueDomainIDContext;

VtlParser.prototype.valueDomainID = function() {

    var localctx = new ValueDomainIDContext(this, this._ctx, this.state);
    this.enterRule(localctx, 202, VtlParser.RULE_valueDomainID);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1660;
        this.match(VtlParser.IDENTIFIER);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


function OperatorIDContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = VtlParser.RULE_operatorID;
    return this;
}

OperatorIDContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
OperatorIDContext.prototype.constructor = OperatorIDContext;

OperatorIDContext.prototype.IDENTIFIER = function() {
    return this.getToken(VtlParser.IDENTIFIER, 0);
};




VtlParser.OperatorIDContext = OperatorIDContext;

VtlParser.prototype.operatorID = function() {

    var localctx = new OperatorIDContext(this, this._ctx, this.state);
    this.enterRule(localctx, 204, VtlParser.RULE_operatorID);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1662;
        this.match(VtlParser.IDENTIFIER);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


function RoutineNameContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = VtlParser.RULE_routineName;
    return this;
}

RoutineNameContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
RoutineNameContext.prototype.constructor = RoutineNameContext;

RoutineNameContext.prototype.IDENTIFIER = function() {
    return this.getToken(VtlParser.IDENTIFIER, 0);
};




VtlParser.RoutineNameContext = RoutineNameContext;

VtlParser.prototype.routineName = function() {

    var localctx = new RoutineNameContext(this, this._ctx, this.state);
    this.enterRule(localctx, 206, VtlParser.RULE_routineName);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1664;
        this.match(VtlParser.IDENTIFIER);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


function ConstantContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = VtlParser.RULE_constant;
    return this;
}

ConstantContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ConstantContext.prototype.constructor = ConstantContext;

ConstantContext.prototype.INTEGER_CONSTANT = function() {
    return this.getToken(VtlParser.INTEGER_CONSTANT, 0);
};

ConstantContext.prototype.NUMBER_CONSTANT = function() {
    return this.getToken(VtlParser.NUMBER_CONSTANT, 0);
};

ConstantContext.prototype.BOOLEAN_CONSTANT = function() {
    return this.getToken(VtlParser.BOOLEAN_CONSTANT, 0);
};

ConstantContext.prototype.STRING_CONSTANT = function() {
    return this.getToken(VtlParser.STRING_CONSTANT, 0);
};

ConstantContext.prototype.NULL_CONSTANT = function() {
    return this.getToken(VtlParser.NULL_CONSTANT, 0);
};




VtlParser.ConstantContext = ConstantContext;

VtlParser.prototype.constant = function() {

    var localctx = new ConstantContext(this, this._ctx, this.state);
    this.enterRule(localctx, 208, VtlParser.RULE_constant);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1666;
        _la = this._input.LA(1);
        if(!(_la===VtlParser.NULL_CONSTANT || ((((_la - 229)) & ~0x1f) == 0 && ((1 << (_la - 229)) & ((1 << (VtlParser.INTEGER_CONSTANT - 229)) | (1 << (VtlParser.NUMBER_CONSTANT - 229)) | (1 << (VtlParser.BOOLEAN_CONSTANT - 229)) | (1 << (VtlParser.STRING_CONSTANT - 229)))) !== 0))) {
        this._errHandler.recoverInline(this);
        }
        else {
        	this._errHandler.reportMatch(this);
            this.consume();
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


function BasicScalarTypeContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = VtlParser.RULE_basicScalarType;
    return this;
}

BasicScalarTypeContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
BasicScalarTypeContext.prototype.constructor = BasicScalarTypeContext;

BasicScalarTypeContext.prototype.STRING = function() {
    return this.getToken(VtlParser.STRING, 0);
};

BasicScalarTypeContext.prototype.INTEGER = function() {
    return this.getToken(VtlParser.INTEGER, 0);
};

BasicScalarTypeContext.prototype.NUMBER = function() {
    return this.getToken(VtlParser.NUMBER, 0);
};

BasicScalarTypeContext.prototype.BOOLEAN = function() {
    return this.getToken(VtlParser.BOOLEAN, 0);
};

BasicScalarTypeContext.prototype.DATE = function() {
    return this.getToken(VtlParser.DATE, 0);
};

BasicScalarTypeContext.prototype.TIME = function() {
    return this.getToken(VtlParser.TIME, 0);
};

BasicScalarTypeContext.prototype.TIME_PERIOD = function() {
    return this.getToken(VtlParser.TIME_PERIOD, 0);
};

BasicScalarTypeContext.prototype.DURATION = function() {
    return this.getToken(VtlParser.DURATION, 0);
};

BasicScalarTypeContext.prototype.SCALAR = function() {
    return this.getToken(VtlParser.SCALAR, 0);
};




VtlParser.BasicScalarTypeContext = BasicScalarTypeContext;

VtlParser.prototype.basicScalarType = function() {

    var localctx = new BasicScalarTypeContext(this, this._ctx, this.state);
    this.enterRule(localctx, 210, VtlParser.RULE_basicScalarType);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1668;
        _la = this._input.LA(1);
        if(!(((((_la - 156)) & ~0x1f) == 0 && ((1 << (_la - 156)) & ((1 << (VtlParser.BOOLEAN - 156)) | (1 << (VtlParser.DATE - 156)) | (1 << (VtlParser.TIME_PERIOD - 156)) | (1 << (VtlParser.NUMBER - 156)) | (1 << (VtlParser.STRING - 156)) | (1 << (VtlParser.TIME - 156)) | (1 << (VtlParser.INTEGER - 156)))) !== 0) || _la===VtlParser.DURATION || _la===VtlParser.SCALAR)) {
        this._errHandler.recoverInline(this);
        }
        else {
        	this._errHandler.reportMatch(this);
            this.consume();
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


function RetainTypeContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = VtlParser.RULE_retainType;
    return this;
}

RetainTypeContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
RetainTypeContext.prototype.constructor = RetainTypeContext;

RetainTypeContext.prototype.BOOLEAN_CONSTANT = function() {
    return this.getToken(VtlParser.BOOLEAN_CONSTANT, 0);
};

RetainTypeContext.prototype.ALL = function() {
    return this.getToken(VtlParser.ALL, 0);
};




VtlParser.RetainTypeContext = RetainTypeContext;

VtlParser.prototype.retainType = function() {

    var localctx = new RetainTypeContext(this, this._ctx, this.state);
    this.enterRule(localctx, 212, VtlParser.RULE_retainType);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1670;
        _la = this._input.LA(1);
        if(!(_la===VtlParser.ALL || _la===VtlParser.BOOLEAN_CONSTANT)) {
        this._errHandler.recoverInline(this);
        }
        else {
        	this._errHandler.reportMatch(this);
            this.consume();
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


VtlParser.prototype.sempred = function(localctx, ruleIndex, predIndex) {
	switch(ruleIndex) {
	case 2:
			return this.expr_sempred(localctx, predIndex);
	case 3:
			return this.exprComponent_sempred(localctx, predIndex);
    default:
        throw "No predicate with index:" + ruleIndex;
   }
};

VtlParser.prototype.expr_sempred = function(localctx, predIndex) {
	switch(predIndex) {
		case 0:
			return this.precpred(this._ctx, 9);
		case 1:
			return this.precpred(this._ctx, 8);
		case 2:
			return this.precpred(this._ctx, 7);
		case 3:
			return this.precpred(this._ctx, 5);
		case 4:
			return this.precpred(this._ctx, 4);
		case 5:
			return this.precpred(this._ctx, 12);
		case 6:
			return this.precpred(this._ctx, 11);
		case 7:
			return this.precpred(this._ctx, 6);
		default:
			throw "No predicate with index:" + predIndex;
	}
};

VtlParser.prototype.exprComponent_sempred = function(localctx, predIndex) {
	switch(predIndex) {
		case 8:
			return this.precpred(this._ctx, 9);
		case 9:
			return this.precpred(this._ctx, 8);
		case 10:
			return this.precpred(this._ctx, 7);
		case 11:
			return this.precpred(this._ctx, 5);
		case 12:
			return this.precpred(this._ctx, 4);
		case 13:
			return this.precpred(this._ctx, 6);
		default:
			throw "No predicate with index:" + predIndex;
	}
};


exports.VtlParser = VtlParser;

},{"antlr4/index":84}],321:[function(require,module,exports){

var antlrEditor = require('antlr4-editor');
var implementation = require('antlr4-editor/implementations/codemirror');
var antlrHelper = require('antlr4-helper');
var VtlLexer = require('./VtlLexer').VtlLexer;
var VtlParser = require('./VtlParser').VtlParser;

var factory = antlrHelper.createFactoryBuilder()
    .lexer(function(input) { return new VtlLexer(input); })
    .parser(function(tokenStream) { return new VtlParser(tokenStream); })
    .rootRule(function(parser) { return parser.start(); })
    .build();

var parser = antlrHelper.createParser(factory);


function createEditor() {
    return implementation.createEditor(parser);
}

exports.createEditor = createEditor;


},{"./VtlLexer":319,"./VtlParser":320,"antlr4-editor":14,"antlr4-editor/implementations/codemirror":12,"antlr4-helper":20}],322:[function(require,module,exports){
module.exports = require('./editor');

},{"./editor":321}]},{},[1])(1)
});
